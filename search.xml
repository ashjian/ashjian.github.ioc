<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>00-计算机基础知识</title>
    <url>/00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p>计算机系统由硬件(Hardware)系统和软件(Software)系统两大部分组成</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813192631.png" alt="image-20200812231148884"></p>
<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><ul>
<li><p>计算机（Computer）：俗称电脑，是一种能接收和存储信息，并按照存储在其内部的程序对海量数据进行自动、高速地处理，然后把处理结果输出的现代化智能电子设备</p>
</li>
<li><p>发展历史：</p>
<p>第一代计算机(1946-1957)     电子管时代 </p>
<p>第二代计算机(1958-1964)     晶体管时代 </p>
<p>第三代计算机(1965-1970)     集成电路时代 </p>
<p>第四代计算机(1971以后)       大规模集成电路时代</p>
</li>
</ul>
<p>1946年,世界上第一台计算机ENIAC(electronic numerical integrator and calculator)在美国宾州大学诞生，是美国奥伯丁武器试验场为了满足计算弹道需要而研制成的。使用了17468只电子管，占地170平方米,重达30吨，耗电174千瓦，耗资40多万美元。每秒可进行5000次加法或减法运算</p>
<p><strong>世界第一台计算机</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813192651.png" alt="image-20200812232833422"></p>
<h2 id="计算机硬件组成"><a href="#计算机硬件组成" class="headerlink" title="计算机硬件组成"></a>计算机硬件组成</h2><p>冯·诺依曼体系结构： 1946年数学家冯·诺依曼于提出，计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813192706.png" alt="image-20200812232941188"></p>
<p><strong>摩尔定律</strong></p>
<p>由英特尔（Intel）创始人之一戈登·摩尔于1965年提出<br>当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍 </p>
<p><strong>按规模划分</strong></p>
<ul>
<li>巨型计算机：应用于国防尖端技术和现代科学计算中。巨型机的运算速度可达每秒百万亿次以上， “天河一号”为我国首台千万亿次超级计算机</li>
<li>大型计算机：具有较高的运算速度，每秒可以执行几千万条指令，而且有较大的存储空间。往往用于科学计算、数据处理或作为网络服务器使用，如：IBM z13 mainframe</li>
<li>小型计算机：规模较小、结构简单、运行环境要求较低，一般应用于工业自动控制、测量仪器、医疗设备中的数据采集等方面</li>
<li>微型计算机：中央处理器（CPU）采用微处理器芯片，体积小巧轻便，广泛用于商业、服务业、工厂的自动控制、办公自动化以及大众化的信息处理</li>
</ul>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li>服务器Server是计算机的一种，是网络中为客户端计算机提供各种服务的高性能的计算机，服务器在网络操作系统的控制下，将与其相连的硬盘、磁带、打印机及昂贵的专用通讯设备提供给网络上的客户站点共享，也能为网络用户提供集中计算、信息发布及数据管理等服务</li>
<li>服务器按应用功能可分为：<br>Web服务器、数据库服务器、文件服务器、中间件应用服务器、日志服务器、监控服务器、程序版本控制服务器、虚拟机服务器、邮件服务器、打印服务器、域控制服务器、多媒体服务器、通讯服务器、ERP服务器等</li>
<li>服务器按外形分类：<br>塔式服务器、刀片式服务器、机架式服务器</li>
</ul>
<p><strong>塔式Tower服务器</strong></p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813192706.png" alt="image-20200812234815088"></p>
<ul>
<li><p>早期的服务器形式</p>
</li>
<li><p>外形以及结构和平时使用的立式PC差不多</p>
</li>
<li><p>机箱空间大，主板扩展性较强，插槽较多</p>
</li>
<li><p>预留了足够的内部空间，以便日后进行硬盘和电源的冗余扩展，设计一般都考虑降噪</p>
</li>
<li><p>目前较少使用</p>
</li>
</ul>
<p><strong>刀片式Blade服务器</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201016.png" alt="image-20200812235043750"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201040.png" alt="image-20200812235056197"></p>
<ul>
<li>在标准高度的机架式机箱内可插装多个卡式的服务器单元，实现高可用和高密度</li>
<li>更高的密度，集中管理，高性能，灵活扩展，按需配置</li>
<li>可以使用系统软件将这些母板集合成一个服务器集群。在集群模式下，所有的母板可以连接起来提供高速的网络环境，并同时共享资源，为相同的用户群服务</li>
</ul>
<p><strong>机架式Rack服务器</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201046.png" alt="image-20200812235318717"></p>
<ul>
<li>按照统一标准设计，配合机柜统一使用</li>
<li>便于统计管理，高密度，节省空间</li>
<li>机架服务器的宽度为19英寸（48.26cm），高度以U为单位，如42U</li>
<li>1U=1.75英寸=44.45毫米，通常有1U， 2U，3U，4U，5U，7U几种标准的服务器。机柜的尺寸也是采用通用的工业标准</li>
<li>现阶段销售数量最多的服务器</li>
<li>机箱尺寸比较小巧</li>
<li>在机柜中可以同时放置多台服务器</li>
</ul>
<p><strong>服务器硬件组成</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201110.png" alt="image-20200812235524966"></p>
<p><strong>服务器配置示例</strong></p>
<table>
<thead>
<tr>
<th>No.</th>
<th>指标项</th>
<th>指标要求</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ntel 处理器</td>
<td>标配2个Intel6核XeonE7-4809v2处理器(1.9GHz,12M缓存,6.4GT/s)</td>
</tr>
<tr>
<td>2</td>
<td>处理器的数量(配置/最多)</td>
<td>2/2</td>
</tr>
<tr>
<td>3</td>
<td>配置/内存(最多</td>
<td>2GB(4x8GB)1600MHzDDR3内存</td>
</tr>
<tr>
<td>4</td>
<td>硬盘</td>
<td>IBM 1TB 7.2K 6Gbps SAS 2.5” SFF Slim-HS  HDD</td>
</tr>
<tr>
<td>5</td>
<td>RAID卡</td>
<td>标配M5210支持RAID0、1、10可选缓存或Flash保护</td>
</tr>
<tr>
<td>6</td>
<td>网络</td>
<td>4口个千兆以太网卡</td>
</tr>
<tr>
<td>7</td>
<td>光驱</td>
<td>DVD-ROM</td>
</tr>
<tr>
<td>8</td>
<td>整机保修时间</td>
<td>原厂3年7*24(4小时之内携带备件现场服务)</td>
</tr>
<tr>
<td>9</td>
<td>电源</td>
<td>标配2个900W热插拔电源(带2根PDU电源线)</td>
</tr>
<tr>
<td>10</td>
<td>服务器的外观样式</td>
<td>4U机架式(含上机架导轨)</td>
</tr>
</tbody></table>
<h3 id="服务器硬件—CPU"><a href="#服务器硬件—CPU" class="headerlink" title="服务器硬件—CPU"></a>服务器硬件—CPU</h3><ul>
<li><p>CPU是Central Processing Unit的缩写，即中央处理器。由控制器和运算器构成，是整个计算机系统中最重要的部分</p>
</li>
<li><p>服务器CPU公司</p>
</li>
<li><p>Intel</p>
<ul>
<li>Xeon      至强  </li>
<li>Itanium   安腾</li>
</ul>
</li>
<li><p>AMD</p>
<ul>
<li>Althlon MP</li>
</ul>
</li>
<li><p>IBM</p>
<ul>
<li>power</li>
</ul>
</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201123.png" alt="image-20200813000459375"></p>
<ul>
<li>主频：主频是CPU的时钟频率(CPU Clock Speed)，是CPU运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是Hz。一般说来，主频越高，CPU的速度越快，由于内部结构不同，并非所有的时钟频率相同的CPU的性能都一样</li>
</ul>
<ul>
<li><p>外频：系统总线的工作频率， CPU与外部（主板芯片组）交换数据、指令的工作时钟频率</p>
<ul>
<li>倍频：倍频则是指CPU外频与主频相差的倍数</li>
<li>三者关系是：主频=外频x倍频</li>
<li>高速缓存（cache）：高速交换的存储器。CPU缓存分为一级，二级，三级缓存，即L1，L2，L3</li>
<li>内存总线速度(Memory-Bus Speed)：一般等同于CPU的外频，指CPU与二级<br>(L2)高速缓存和内存之间的通信速度</li>
<li>地址总线宽度：决定了CPU可以访问的物理地址空间</li>
</ul>
<p><strong>CPU类型</strong></p>
<ul>
<li>x86</li>
</ul>
</li>
<li><p>X64（CISC）</p>
<ul>
<li>ARM（Acorn RISC Machine）</li>
<li>m68000, m68k（moto）</li>
<li>Power（IBM）</li>
<li>Powerpc（apple,ibm,moto）</li>
<li>Ultrasparc （Sun）</li>
<li>Alpha（HP）</li>
<li>安腾（compaq）</li>
</ul>
</li>
</ul>
<h3 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h3><ul>
<li>按照CPU体系架构来区分，服务器主要分为两类：</li>
<li>非x86服务器：使用RISC（精简指令集）或EPIC（并行指令代码） 处理器，并且主要采用UNIX和其它专用操作系统的服务器，指令系统相对简单，它只要求硬件执行很有限且最常用的那部分执令，CPU主要有Compaq的Alpha、HP的PA-RISC、IBM的Power PC、MIPS的MIPS和SUN的Sparc、Intel研发的EPIC安腾处理器等。这种服务器价格昂贵，体系封闭，但是稳定性好，性能强，主要用在金融、电信等大型企业的核心系统</li>
<li>x86服务器：又称CISC（复杂指令集）架构服务器，即通常所讲的PC服务器，它是基于PC机体系结构，使用Intel或其它兼容x86指令集的处理器芯片的服务器。目前主要为intel的Xeon E3，E5，E7系列，价格相对便宜、兼容性好、稳定性较差、安全性不算太高</li>
</ul>
<h3 id="服务器硬件—主板"><a href="#服务器硬件—主板" class="headerlink" title="服务器硬件—主板"></a>服务器硬件—主板</h3><ul>
<li>主板mainboard、系统板systemboard或母板motherboard，安装在机箱内，是计算机最基本的也是最重要的部件之一</li>
<li>主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有BIOS芯片、I/O控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201134.png" alt="image-20200813001010354"></p>
<h3 id="服务器硬件—内存"><a href="#服务器硬件—内存" class="headerlink" title="服务器硬件—内存"></a>服务器硬件—内存</h3><ul>
<li><p>内存是介于CPU 和外部存储之间，是CPU 对外部存储中程序与数据进行高速运算时存放程序指令、数据和中间结果的临时场所，它的物理实质就是一组具备数据输入输出和数据存储功能的高速集成电路</p>
</li>
<li><p>内存是CPU能直接寻址的存储空间，由半导体器件制成。内存的特点是存取速度快</p>
</li>
<li><p>计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大</p>
</li>
<li><p>外存：硬盘，U盘，软盘，光盘</p>
</li>
<li><p>内存和外存的区别：</p>
<p>​    内存断电后数据丢失<br>​    外存断电后数据可以保存</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201420.png" alt="image-20200813001222691"></p>
</li>
<li><p>容量：即该内存的存储容量，单位一般为“MB”或“GB”</p>
</li>
<li><p>内存带宽：<br>•    内存带宽是指内存与北桥芯片之间的数据传输率<br>•    单通道内存节制器一般都是64-bit的，8个二进制位相当于1个字节，换算成字节是64/8=8，再乘以内存的运行频率，如果是DDR内存就要再乘以2<br>•    计算公式：<br>内存带宽=内存总线频率×数据总线位数/8</p>
</li>
<li><p>示例：单通道DDR内存带宽计算</p>
<p>​            DDR4-4000：4000MHz * 64bit/8=32000MB/S<br>​            DDR4-3600：3600MHz * 64bit/8=28800MB/S </p>
<pre><code>双通道： 
DDR4-4000：4000MHz * 64bit * 2/8=64000MB/S</code></pre></li>
<li><p>在线备用内存技术</p>
<ul>
<li>当主内存或者是扩展内存中的内存出现多位错误时或者出现物理内存故障时，服务器仍继续运行 </li>
<li>由备用内存接替出现故障内存的工作</li>
<li>备用的内存区域必须比其它区域的内存容量要大或相同</li>
</ul>
</li>
<li><p>内存镜像</p>
<ul>
<li>镜像为系统在出现多位错或内存物理故障时提供数据保护功能，以保证系统仍能正常的运行 </li>
<li>数据同时写入两个镜像的内存区域</li>
<li>从一个区域进行数据的读取</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201428.png" alt="image-20200813012646321"></p>
<h3 id="服务器硬件—硬盘"><a href="#服务器硬件—硬盘" class="headerlink" title="服务器硬件—硬盘"></a>服务器硬件—硬盘</h3><ul>
<li>机械硬盘结构：</li>
<li>存储介质（Media）——盘片<br>盘片的基板是金属或玻璃材质制成，为达到高密度高稳定的质量，基板要求表面光滑平整，不可有任何暇疵</li>
<li>读写头（Read Write Head）——磁头<br>磁头是硬盘读取数据的关键部件，它的主要作用就是将存储在硬盘盘片上的磁信息转化为电信号向</li>
<li>传输马达（ Spindle Motor &amp; Voice Coil Motor ）<br>马达上装有一至多片盘片，以7200，10000，15000 RPM等定速旋转，为保持其平衡不可抖动，所以其质量要求严谨，不产生高温躁音</li>
</ul>
<img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201435.png" alt="image-20200813084604566" style="zoom:50%;" />

<ul>
<li><p>硬盘基本参数：</p>
<ul>
<li><p>容量</p>
<p>容量是硬盘最主要的参数。单位有MB、GB、TB</p>
</li>
<li><p>转速</p>
<p>转速是指硬盘盘片每分钟转动的圈数，单位为rpm。现在硬盘的转速已经达到10000rpm，15000rpm </p>
</li>
<li><p>传输速率</p>
<p>传输速率(Data Transfer Rate) 。硬盘的数据传输率是指硬盘读写数据的速度，单位为兆字节每秒（MB/s） </p>
</li>
<li><p>缓存</p>
<p>硬盘缓存的目的是为了解决系统前后级读写速度不匹配的问题，以提高硬盘的读写速度 </p>
</li>
</ul>
</li>
</ul>
<p>​    硬盘接口类型：</p>
<ul>
<li>IDE接口：硬盘接口规范，采用ATA技术规范</li>
<li>SCSI接口：应用于小型机上的高速数据传输技术</li>
<li>SATA接口： Serial ATA，提高传输速率，支持热插拔</li>
<li>SAS接口： Serial Attached SCSI，兼容SAT</li>
</ul>
<p>​    目前主流的硬盘接口为SATA和SAS接口</p>
<ul>
<li><p>SSD硬盘：<br>SSD(Solid State Disk)泛指使用NAND Flash组成的固态硬盘。其特别之处在于</p>
<p>没有机械结构，</p>
<p>以区块写入和抹除的方式作读写的功能，因此在读写的效率上，非常依赖读写技术上的设计SSD读写存取速度快，性能稳定，防震性高，发热低，耐低温，电耗低，无噪音。因为没有机械部分，所以长时间使用也出现故障几率也较小。缺点:价格高，容量小，在普通硬盘前毫无性价比优势 </p>
</li>
</ul>
<p><strong>服务器的性能短板</strong>：<br>如果CPU有每秒处理1000个服务请求的能力，各种总线的负载能力能达到500个，但网卡只能接受200个请求，而硬盘只能负担150个的话，那这台服务器得处理能力只能是150个请求/秒，有85%的处理器计算能力浪费了<br>在计算机系统当中，硬盘的读写速率已经成为影响系统性能进一步提高的瓶颈</p>
<p><strong>各种硬件处理速度</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201441.png" alt="image-20200813085148766"></p>
<h3 id="服务器硬件—阵列卡"><a href="#服务器硬件—阵列卡" class="headerlink" title="服务器硬件—阵列卡"></a>服务器硬件—阵列卡</h3><ul>
<li><p>Raid卡：<br>用来实现RAID的建立和重建，检测和修复多位错误，错误磁盘自动检测等功能。RAID芯片使CPU的资源得以释放<br>阵列卡（RAID卡）的作用:</p>
<p>阵列卡把若干硬盘驱动器按照一定要求组成一个整体、由阵列控制器管理的系统。<br>阵列卡用来提高磁盘子系统的性能及可靠性</p>
<p>阵列卡参数:</p>
<p>​    支持的RAID级别<br>​    阵列卡缓存<br>​    电池保护</p>
</li>
</ul>
<p><strong>服务器硬件—电源</strong></p>
<p>电源和风扇</p>
<ul>
<li>支持服务器的电力负载</li>
<li>支持冗余，防止电源故障<br>–    故障预警和防止<br>–    故障之前的预防性维护<br>–    保证服务器持续运行</li>
<li>电源子系统包括<br>–    智能电源和风扇</li>
<li>冗余电源和风扇</li>
</ul>
<h3 id="服务器硬件—显卡"><a href="#服务器硬件—显卡" class="headerlink" title="服务器硬件—显卡"></a>服务器硬件—显卡</h3><p>服务器都在主板上集成了显卡，但是显存容量不高，一般为16M或32M GPU： Graphic Processing Unit，即“图形处理器” </p>
<h3 id="服务器硬件—网卡"><a href="#服务器硬件—网卡" class="headerlink" title="服务器硬件—网卡"></a>服务器硬件—网卡</h3><p>服务器都在主板上集成了网卡，传输速率为1Gbps，即千兆网卡<br>特殊应用需要高端网卡，如光纤网卡，Infiniband网卡等，传输速率能达到10Gbps、 20Gbps，即万兆网卡</p>
<h3 id="服务器硬件—热插拔技术"><a href="#服务器硬件—热插拔技术" class="headerlink" title="服务器硬件—热插拔技术"></a>服务器硬件—热插拔技术</h3><ul>
<li>称为热交换技术（Hot  Swap），允许在不关机的状态下更换故障热插拔设备</li>
<li>常见的热插拔设备：硬盘，电源，PCI设备，风扇等</li>
<li>热插拔硬盘技术与RAID技术配合起来，可以使服务器在不关机的状态下恢复故障硬盘上的数据，同时并不影响网络用户对数据的使用</li>
</ul>
<h3 id="服务器硬件—机柜"><a href="#服务器硬件—机柜" class="headerlink" title="服务器硬件—机柜"></a>服务器硬件—机柜</h3><p>机架式服务器-服务器放置在机柜中<br>通常使用的机柜是42U（约2米高）机柜（ 1U=44.45mm） 外观尺寸一般为：宽600<em>深1000</em>高2000（mm） </p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201511.png" alt="image-20200813115249821"></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>OS: Operating System，通用目的的软件程序</p>
<p>​    硬件驱动</p>
<p>​    进程管理    </p>
<p>​    内存管理    </p>
<p>​    网络管理    </p>
<p>​    安全管理    </p>
<p>​    文件管理</p>
<p>OS分类：</p>
<p>​    服务器OS：RHEL，CentOS，Windows Server，AIX     </p>
<p>​    桌面OS：Windows 10，Mac OS，Fedora<br>​    移动设备OS：Andriod，IOS，AliOS </p>
<img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201511.png" alt="image-20200813115654804" style="zoom:50%;" />

<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><ul>
<li><p>接口：interface，来源于电气工程学科，指的是插座与插头的连接口，起到将电与电器连接起为的功能。后来延伸到软件工程里指软件包向外提供的功能模块的函数接口。所以接口是用来连接两个东西、信号转换和屏蔽细节</p>
</li>
<li><p>​    操作系统通过接口的方式，建立了用户与计算机硬件的沟通方式。用户通过调用操作系统的接口来使用计算机的各种计算服务。</p>
</li>
<li><p>为操作系统一般会提供两个重要的接口来满足用户的一些一般性的使用需求：</p>
<p>命令行：实际是一个叫shell的终端程序提供的功能，该程序底层的实质还是调用一些操作系统提供的函数</p>
<p>窗口界面：窗口界面通过编写的窗口程序接收来自操作系统消息队列的一些鼠标、键盘动作，进而做出一些响应</p>
</li>
</ul>
<h3 id="开发接口标准"><a href="#开发接口标准" class="headerlink" title="开发接口标准"></a>开发接口标准</h3><ul>
<li>ABI: Application Binary Interface<br>ABI描述了应用程序与OS之间的底层接口,允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行</li>
<li>运行程序格式：<br>Windows: EXE, .dll(dynamic link library)，.lib<br>Linux: ELF,  .so(shared object),  .a</li>
<li>API：Application Programming Interface<br>API定义了源代码和库之间的接口，因此同样的源代码可以在支持这个API的任何系统中编译</li>
<li>POSIX: Portable Operating System Interface 可移植的操作系统接口IEEE在操作系统上定义的一系列API标准<br>POSIX兼容的程序可在其它POSIX操作系统编译执行</li>
</ul>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><ul>
<li><p>计算机硬件资源都是操作系统内核进行管理的，目前操作系统都是基于多任务、多用户的。如果每个用户进程都可以随便访问操作系统内核的模块，改变状态，那整个操作系统的稳定性、安全性都大大降低</p>
</li>
<li><p>为了将内核程序与用户程序隔离开，在硬件层面上提供了一次机制，将程序执行的状态分为了不同的级别，从0到3，数字越小，访问级别越高。0代表内核态，在该特权级别下，所有内存上的数据都是可见的，可访问的。3代表用户态，在这个特权级下，程序只能访问一部分的内存区域，只能执行一些限定的指令</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813192206.png" alt="image-20200813120234652"></p>
<h3 id="系统调用system-call"><a href="#系统调用system-call" class="headerlink" title="系统调用system call"></a>系统调用system call</h3><p>对于非一般性使用需求，操作系统提供了一系列的函数调用给软件开发者，由软件开发者来实现一些用户需要的功能。这些函数调用由于是操作系统内核提供的，为了有别于一般的函数调用，被称为系统调用。比如使用C语言进行软件开发时，经常用的printf函数，它的内部实际就是通过write这个系统调用，让操作系统内核把字符打印在屏幕上的</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201641.png" alt="image-20200813120327044"></p>
<h3 id="Library-function和system-call"><a href="#Library-function和system-call" class="headerlink" title="Library function和system call"></a>Library function和system call</h3><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201641.png" alt="image-20200813120410005"></p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><ul>
<li><p>低级语言</p>
<p>机器语言：0和1<br>汇编语言：和机器语言一一对应，与硬件相关的特有代码、驱动程序开发</p>
</li>
<li><p>中级语言：C</p>
<p>系统级应用、驱动程序</p>
</li>
<li><p>高级语言： java，python，go，php，Objective-C，C#</p>
<p>应用级程序开发</p>
<h2 id="服务器三大操作系统"><a href="#服务器三大操作系统" class="headerlink" title="服务器三大操作系统"></a>服务器三大操作系统</h2><ul>
<li><p>Windows：</p>
</li>
<li><p>Linux：GNU/Linux</p>
</li>
<li><p>Unix：1969年Ken Thompson</p>
<p>System: Bell Lab</p>
<p>​        AIX （IBM） </p>
<p>​        Solaris (SUN) </p>
<p>​        HP-UX (HP) </p>
<p>BSD: （BSRG）Berkeley System Distribution</p>
<p>​        NetBSD OpenBSD FreeBSD </p>
</li>
</ul>
<h2 id="Linux起源"><a href="#Linux起源" class="headerlink" title="Linux起源"></a>Linux起源</h2><ul>
<li><p>1991年的10月5日，Torvalds在comp.os.minix新闻组上发布消息，正式向外宣布他自行编写的完全自由免费的内核诞生（Freeminix-like kernel sources for 386-AT）—FREAX，含义是怪诞的、怪物、异想天开</p>
</li>
<li><p>类Unix的内核，在GPL下发布</p>
</li>
<li><p>官网：<a href="http://www.kernel.org" target="_blank" rel="noopener">www.kernel.org</a></p>
</li>
<li><p>Linux操作系统</p>
<p>​        完整的类UNIX操作系统 </p>
<p>​        Linux内核+ GNU工具<br>​        如：CentOS,Ubuntu,Android</p>
</li>
</ul>
<h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2><p>slackware：SUSE Linux Enterprise Server (SLES)</p>
<p>​                                                    OpenSuse桌面 </p>
<ul>
<li><p>debian:        ubuntu，deepin（深度），mint</p>
</li>
<li><p>redhat：    </p>
<p>​              RHEL: RedHat Enterprise Linux  每18个月发行一个   新版本</p>
<p>​                CentOS：兼容RHEL的格式<br>​               中标麒麟：中标软件 </p>
</li>
</ul>
<p>​                     Fedora：每6个月发行一个新版本</p>
<ul>
<li>ArchLinux：轻量简洁，遵循K.I.S.S.原则（ keep it simple and stupid ）</li>
<li>Gentoo：极致性能，不提供传统意义的安装程序，下载源代码在本机上编译安装软件</li>
<li>LFS：Linux From scratch 自制Linux</li>
<li>Android：kernel+busybox（工具集）+java虚拟机</li>
<li>Linux分支参考网站：</li>
</ul>
<p>​    <a href="http://futurist.se/gldt/" target="_blank" rel="noopener">http://futurist.se/gldt/</a><br>​    <a href="http://www.mindpin.com/d3js-demo/linux/" target="_blank" rel="noopener">http://www.mindpin.com/d3js-demo/linux/</a></p>
<p>开源 Open Source</p>
<ul>
<li>开源： Open Source ，软件和源代码提供给所有人</li>
</ul>
<p>​        自由分发软件和源代码 能够修改和创建衍生作品</p>
<ul>
<li>软件分类：</li>
</ul>
<p>​        商业<br>​        共享<br>​        自由 free</p>
<h3 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h3><ul>
<li>世界上的开源许可证，大概有上百种</li>
<li>GPLv2, GPLv3, LGPL(lesser) ：通用公共许可 copyleft</li>
<li>Apache: apache</li>
<li>BSD: bsd</li>
<li>Mozilla</li>
<li>MIT</li>
<li><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201711.png" alt="image-20200813191107707"></li>
</ul>
<h2 id="Linux哲学思想"><a href="#Linux哲学思想" class="headerlink" title="Linux哲学思想"></a>Linux哲学思想</h2><ul>
<li>一切都是一个文件（包括硬件） </li>
<li>小型，单一用途的程序<br>链接程序，共同完成复杂的任务 </li>
<li>避免令人困惑的用户界面</li>
<li>配置数据存储在文本中</li>
</ul>
<h3 id="获取发行版"><a href="#获取发行版" class="headerlink" title="获取发行版"></a>获取发行版</h3><ul>
<li>CentOS<br><a href="https://wiki.centos.org/Download" target="_blank" rel="noopener">https://wiki.centos.org/Download</a><br><a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a><br><a href="http://mirrors.sohu.com" target="_blank" rel="noopener">http://mirrors.sohu.com</a><br><a href="http://mirrors.163.com" target="_blank" rel="noopener">http://mirrors.163.com</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/centos/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/centos/</a></li>
<li>Ubuntu<br><a href="http://cdimage.ubuntu.com/releases/18.04.1/release/?_ga=2.56783850.1" target="_blank" rel="noopener">http://cdimage.ubuntu.com/releases/18.04.1/release/?_ga=2.56783850.1</a> 533668672.1544323446-1412352718.1543052421</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机：用软件（如：vmware,virtualbox等）模拟硬件</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200813201739.png" alt="image-20200813191718186"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01-HAProxy简介</title>
    <url>/01-HAProxy%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们<code>yum info haproxy</code>可以看到HAProxy的描述，翻译一下：</p>
<blockquote>
<p>摘要：HAProxy是在高可用环境下提供TCP/HTTP proxy和Load Balance的工具。<br>描述：HAProxy 是一个适用于HA环境的 TCP/HTTP reverse proxy（译者注：本身没有HA功能，但是有proxy和LB功能，可以这样理解，HA的proxy…… ），HAProxy可以：</p>
<ul>
<li>路由依赖静态分配cookies的HTTP请求。</li>
<li>在多个服务器之间扩展负载，同时确保通过使用HTTP cookie来保持服务器的持久性。</li>
<li>在主服务器fail时候，可以切换到备用服务器。</li>
<li>接受连接到特定端口的专用服务监控</li>
<li>在不断开已有的链接的情况下，停止接受新的链接请求。</li>
<li>双向添加，修改，删除HTTP headers。</li>
<li>锁定匹配特定模式的请求。</li>
<li>从一个被应用解析的URI来报告详细状态给认证过的用户（译者注：相当方便和强大）</li>
</ul>
</blockquote>
<p><a href="http://www.yulongjun.com/images/15073045670396.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135201.jpg" alt="img"></a></p>
<p>HAProxy是一个纯粹的reverse proxy，能够实现基于TCP的4层和基于HTTP的7层负载均衡功能，但是和Nginx不一样，是没有Web Server功能的，所以HAProxy后端通常会接Nginx或Apache httpd等Web Server。</p>
<p>通常HAproxy会和Keepalived配合使用，实现高可用的负载均衡(Keepalived后面会讲到）：</p>
<p><a href="http://www.yulongjun.com/images/HAProxy-Structure.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135202.svg" alt="HAProxy-"></a></p>
<p>更多详细的介绍可以看官方文档：<a href="http://cbonte.github.io/haproxy-dconv/1.7/intro.html#3" target="_blank" rel="noopener">Introduction to HAProxy</a></p>
]]></content>
  </entry>
  <entry>
    <title>01-Keepalived介绍</title>
    <url>/01-Keepalived%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HA（高可用，High-availability）里的几个概念"><a href="#HA（高可用，High-availability）里的几个概念" class="headerlink" title="HA（高可用，High availability）里的几个概念"></a>HA（高可用，High availability）里的几个概念</h2><p><strong>SPOF</strong>(single point of failure)单点故障</p>
<p><strong>MTBF</strong>(Mean Time Between Failures)：平均故障间隔<br><strong>MTTR</strong>(Mean Time To Repair)：平均修复时间<br><strong>A</strong>(Availability)：可用性<br><code>A=MTBF/(MTBF+MTTR)</code>：99%、99.9%、99.99%、99.999%、99.9999%</p>
<p>用高可用的方案可以减少无故障时间。</p>
<p><strong>Failover</strong>(故障转移)：即当活动的服务或应用意外终止时，快速启用冗余或备用的服务器、系统、硬件或者网络接替它们工作。<br><strong>Failback</strong>(故障恢复)：是将系统，组件，服务恢复到故障之前的组态。</p>
<h2 id="解决高可用中网络分区的方法"><a href="#解决高可用中网络分区的方法" class="headerlink" title="解决高可用中网络分区的方法"></a>解决高可用中网络分区的方法</h2><p>两节点集群容易出现网络分区（Network Partition）。网络分区是一种在系统的任何两个组之间的所有网络连接同时发生故障后所出现的情况。发生这种情况时，分裂的系统双方都会从对方一侧重新启动应用程序，进而导致重复服务或脑裂（Brain Split）。如果一个群集中配置的两个独立系统具有对指定资源（通常是文件系统或卷）的独占访问权限，则会发生裂脑情况。由网络分裂造成的最为严重的问题是它会影响共享磁盘上的数据。</p>
<p>在两节点集群中（偶数节点也有这种情况，也要考虑），由于网络分区导致集群的节点之间无法正常通信，无法判断对方是否故障，各持有一票无法裁决。这时候就需要引入<strong>观察者</strong>，一个<strong>拥有投票权</strong>，但<strong>不拥有被投票权</strong>的设备。</p>
<ol>
<li>我们可以引入<strong>前端路由</strong>作为观察者，能跟前端路由通信的就获得一票，那么能通讯的集群节点就对外服务，前端的路由也叫做一个ping node(ping节点，只用来做探测和投票的，没有被投票权）。</li>
<li>我们可以引入一个<strong>仲裁盘（quorum disk）</strong>，活动节点周期性的写入磁盘，备用节点接受心跳，并能周期性的读到磁盘上的写入的数据。如果不能接受到心跳，也无法读到周期性的数据，那么就可以认为活动节点挂了，这时候就可以让备用节点变为活动节点对外服务。</li>
</ol>
<p>多节点集群，只有一个对外服务，会导致资源大量的浪费（尤其节点很多的情况下），为了避免资源浪费，那么我们就可以让多个主机同时工作起来。但是需要故障时候，ip地址可以漂移到另外一个节点。这种方式叫做<strong>双主模型</strong>。</p>
<p><strong>STONITH</strong>（shoot the other node in the head）：</p>
<p>Heartbeat软件包里提供了这样的一个STONITH组件，它允许使用一个远程或“智能的”连接到健康服务器的电源设备自动重启失效服务器的电源，stonith设备可以关闭电源并响应软件命令，运行Heartbeat的服务器可以通过串口线或网线向stonith设备发送命令，它控制高可用服务器对中其他服务器的电力供应，换句话说，主服务器可以复位备用服务器的电源，备用服务器也可以复位主服务器的电源。</p>
<p>HA Cluster实现方案：<br>VRRP协议的实现：Keepalived<br>AIS（完备HA集群）：RHCS(corosync + pacemaker)、heartbeat</p>
<h2 id="VRRP协议"><a href="#VRRP协议" class="headerlink" title="VRRP协议"></a>VRRP协议</h2><p>VRRP：Virtual Router redundancy Protocol(虚拟路由器冗余协议)</p>
<p>相关术语：</p>
<ul>
<li><strong>虚拟路由器(Virtual Router)</strong>：由一个 Master 路由器和多个 Backup 路由器组成。主机将虚拟路由器当作默认网关。</li>
<li><strong>VRID</strong>：虚拟路由器的标识。 有相同 VRID 的一组路由器构成一个虚拟路由器。</li>
<li><strong>Master</strong> 路由器：虚拟路由器中承担报文转发任务的路由器。</li>
<li><strong>Backup</strong> 路由器：Master 路由器出现故障时，能够代替 Master 路由器工作的路由器。</li>
<li><strong>虚拟 IP 地址(VIP: Virtual IP)</strong>：虚拟路由器的 IP 地址。一个虚拟路由器可以拥有一个或多个IP 地址。</li>
<li><strong>IP 地址拥有者</strong>：接口 IP 地址与虚拟 IP 地址相同的路由器被称为 IP 地址拥有者。</li>
<li><strong>虚拟 MAC 地址(VMAC: Virutal MAC)</strong>：一个虚拟路由器拥有一个虚拟 MAC 地址。虚拟 MAC 地址的格式为 00-00-5E-00-01-{VRID}。通常情况下，虚拟路由器回应 ARP 请求使用的是虚拟 MAC 地址，只有虚拟路由器做特殊配置的时候，才回应接口的真实 MAC 地址。</li>
<li><strong>优先级(Priority)</strong>：VRRP 根据优先级来确定虚拟路由器中每台路由器的地位。</li>
</ul>
<blockquote>
<p>VRRP详细内容可见：<a href="http://www0.h3c.com.cn/Products___Technology/Technology/ComwareV5/Dependability/Other_technology/Technology_book/200802/335873_30003_0.htm" target="_blank" rel="noopener">VRRP技术白皮书</a><br>需要细读一下。了解VRRP工作原理。</p>
</blockquote>
<h2 id="VRRP工作模式"><a href="#VRRP工作模式" class="headerlink" title="VRRP工作模式"></a>VRRP工作模式</h2><p>VRRP全称 Virtual Router Redundancy Protocol，即 虚拟路由冗余协议。可以认为它是实现路由器高可用的容错协议，即将N台提供相同功能的路由器组成一个路由器组(Router Group)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。</p>
<p>在VRRP协议实现里，虚拟路由器使用 00-00-5E-00-01-XX 作为虚拟MAC地址，XX就是唯一的 VRID （Virtual Router IDentifier），这个地址同一时间只有一个物理路由器占用。在虚拟路由器里面的物理路由器组里面通过多播IP地址 224.0.0.18 来定时发送通告消息。每个Router都有一个 1-255 之间的优先级别，级别最高的（highest priority）将成为主控（master）路由器。通过降低master的优先权可以让处于backup状态的路由器抢占（pro-empt）主路由器的状态，两个backup优先级相同的IP地址较大者为master，接管虚拟IP。</p>
<p><strong>单主模式（主备模式）</strong>：</p>
<p>单主模式仅仅一个虚拟IP，仅实现高可用。</p>
<p><a href="http://www.yulongjun.com/images/15045792396310.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135430.jpg" alt="img"></a></p>
<p><strong>多活模式</strong>（或叫多主模式、负载均衡的高可用模式）：</p>
<p>对外表现为多个虚拟IP，这样就可以同时实现负载均衡和高可用。</p>
<p><a href="http://www.yulongjun.com/images/15045792979854.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135431.jpg" alt="img"></a></p>
<blockquote>
<p>上面两图是针对正向代理的，不过和反向代理的原理一样，大家只要理解VRRP原理就可以了，不比纠结于图示。</p>
</blockquote>
<h2 id="Heartbeat、Corosync、Keepalived对比"><a href="#Heartbeat、Corosync、Keepalived对比" class="headerlink" title="Heartbeat、Corosync、Keepalived对比"></a>Heartbeat、Corosync、Keepalived对比</h2><p>Heartbeat、Corosync、Keepalived这三个集群组件我们到底选哪个好，首先我想说明的是，Heartbeat、Corosync是属于同一类型，Keepalived与Heartbeat、Corosync，根本不是同一类型的。Keepalived使用的vrrp协议方式，虚拟路由冗余协议 (Virtual Router Redundancy Protocol，简称VRRP)；Heartbeat或Corosync是基于主机或网络服务的高可用方式；简单的说就是，Keepalived的目的是模拟路由器的高可用，Heartbeat或Corosync的目的是实现Service的高可用。</p>
<p>所以一般Keepalived是实现前端高可用，常用的前端高可用的组合有，就是我们常见的LVS+Keepalived、Nginx+Keepalived、HAproxy+Keepalived。而Heartbeat或Corosync是实现服务的高可用，常见的组合有Heartbeat v3(Corosync)+Pacemaker+NFS+Httpd 实现Web服务器的高可用、Heartbeat v3(Corosync)+Pacemaker+NFS+MySQL 实现MySQL服务器的高可用。总结一下，Keepalived中实现轻量级的高可用，一般用于前端高可用，且不需要共享存储，一般常用于两个节点的高可用。而Heartbeat(或Corosync)一般用于服务的高可用，且需要共享存储，一般用于多节点的高可用。这个问题我们说明白了。</p>
<p>又有博友会问了，那heartbaet与corosync我们又应该选择哪个好啊，我想说我们一般用corosync，因为corosync的运行机制更优于heartbeat，就连从heartbeat分离出来的pacemaker都说在以后的开发当中更倾向于corosync，所以现在corosync+pacemaker是最佳组合。</p>
<h2 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h2><p>Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障。</p>
<p>一个WEB服务至少会有2台服务器运行Keepalived，一台为主服务器（Master），一台为备份服务器（Backup），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性(主备模式）。当然，也可以对外表现为多个虚拟IP，这样就可以同时实现负载均衡和高可用。（两台的话叫主主模式，或者叫双活模式）</p>
<p>但是它一般不会单独出现，而是与其它负载均衡技术（如LVS、HAProxy、Nginx）一起工作来达到集群的高可用。</p>
<p><strong>Keepalive是vrrp协议的软件实现，原生设计的目的为了高可用ipvs（LVS、Nginx、HAProxy）服务：</strong></p>
<ul>
<li>基于vrrp协议完成地址流动(IP Floating)。</li>
<li>为集群内的所有的节点生成ipvs规则（在配置文件中预先定义）。</li>
<li>为ipvs集群的各RS做健康状态检测。</li>
<li>基于脚本调用接口通过执行脚本完成脚本中定义的功能，进而影响集群事务。</li>
</ul>
<p><strong>组件：</strong></p>
<ul>
<li>核心组件：<ul>
<li><code>vrrp stack</code>：VRRP协议的实现</li>
<li><code>ipvs wrapper</code>：为集群内的所有的节点生成ipvs规则</li>
<li><code>checkers</code>：为ipvs集群的各RS做健康状态检测。</li>
</ul>
</li>
<li>控制组件：配置文件分析器</li>
<li>IO复用器</li>
<li>内存管理组件</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>01-Linux系统层级结构标准</title>
    <url>/01-Linux%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux Foundation有一套标准规范:</p>
<ul>
<li><p>文件和目录被组织成一个单根倒置树结构</p>
</li>
<li><p>文件系统从根目录下开始，用“/”表示</p>
</li>
<li><p>根文件系统(rootfs)：root filesystem</p>
</li>
<li><p>文件名称区分大小写</p>
</li>
<li><p>以.开头的文件为隐藏文件</p>
</li>
<li><p>路径分隔的 /</p>
</li>
<li><p>文件有两类数据：</p>
<p>元数据：metadata </p>
<p>数据：data</p>
</li>
</ul>
<p>LSB  Linux Standard Base</p>
<p>FHS: Filesystem Hierarchy Standard（文件系统层级标准）</p>
<p>目前最新的标准是3.0版本：<a href="http://refspecs.linuxfoundation.org/FHS_3.0/" target="_blank" rel="noopener">http://refspecs.linuxfoundation.org/FHS_3.0/</a></p>
<ul>
<li><code>/bin</code> ：所有用户可用的基本命令程序文件</li>
<li><code>/sbin</code> ：系统用户管理命令</li>
<li><code>/boot</code>： boot loader的静态文件（kernel，initramfs（initrd），grub等）</li>
<li><code>/dev</code> ：存储特殊文件（tty虚拟终端之类）和设备文件（字符设备（键盘、显示器）、块设备（硬盘、光盘））</li>
</ul>
<blockquote>
<p>tips：<code>主设备名，次设备名</code>如/<code>dev/null</code>就是<code>1,3</code>，<code>/dev/zero</code>就是<code>1,5</code></p>
</blockquote>
<p><a href="http://www.yulongjun.com/images/1495420231591.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200818210339.png" alt="img"></a></p>
<ul>
<li><p><code>/etc</code>：配置文件</p>
</li>
<li><p><code>/home</code>：非root用户的家目录</p>
</li>
<li><p><code>/root</code>：root用户的家目录</p>
</li>
<li><p><code>/lib</code>：为系统启动或者根文件系统上的应用程序（/bin,/sbin）等提供共享库，以及为内核提供内核模块</p>
<ul>
<li><code>libc.so.*</code>：动态链接的c库</li>
<li><code>ld*</code>：运行时链接器/加载器</li>
<li><code>modules</code>：用于存储内核模块的目录</li>
</ul>
</li>
<li><p><code>/lib64</code>：64位系统特有的存放64位共享库的路径</p>
</li>
<li><p><code>/media</code>：便携式设备的挂载点（如光盘cdrom、u盘floppy）。</p>
</li>
<li><p><code>/mnt</code>：临时文件系统挂载点。</p>
</li>
<li><p><code>/opt</code>：附加程序的安装位置</p>
</li>
<li><p><code>/srv</code>：当前主机为服务提供的数据</p>
</li>
<li><p><code>/tmp</code>：临时文件（temporary files）（可供所有用户执行写入操作）</p>
</li>
<li><p><code>/usr</code>：全局共享只读文件（Universial Shareable Read-only）（第二主要的层级目录）</p>
<ul>
<li><p><code>bin</code>：非系统启动时用到的程序</p>
</li>
<li><p><code>sbin</code>：非系统启动时用到的系统程序</p>
</li>
<li><p><code>include</code>：c程序的头文件（header files）</p>
</li>
<li><p><code>lib</code>：程序依赖的库</p>
</li>
<li><p><code>lib64</code>：程序依赖的库（64位）</p>
</li>
<li><p><code>local</code>：（<code>/usr</code>后又一个层级目录）用来安装本地应用程序，第三方程序<br>（比如在MacOS下，<code>brew</code>安装的程序都会安装在<code>usr/local/bin</code>下）</p>
</li>
<li><p><code>share</code>：命令man手册页，命令自带文档</p>
<ul>
<li><code>/usr/share/dict/words</code> 暴力破解的密码表(弱口令)</li>
</ul>
</li>
<li><p><code>src</code>：某些程序的源代码</p>
</li>
<li><blockquote>
<p>tips ：CentOS 7 都是把根目录的一些目录软连接到/usr下的目录</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><a href="http://www.yulongjun.com/images/1495455385293.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200818210339.png" alt="img"></a></p>
<ul>
<li><p><code>/var</code>：可变数据文件（系统日志、缓存文件）</p>
<ul>
<li><code>cache</code>: 应用程序缓存数据目录 </li>
<li><code>lib</code>: 应用程序状态信息数据 </li>
<li><code>local</code>：专用于为/usr/local下的应用程序存储可变数据 lock: 锁文件 </li>
<li><code>log</code>: 日志目录及文件 </li>
<li><code>opt</code>: 专用于为/opt下的应用程序存储可变数据 </li>
<li><code>run</code>: 运行中的进程相关数据,通常用于存储进程pid文件 spool: 应用程序数据池 </li>
<li><code>tmp</code>: 保存系统两次重启之间产生的临时数据 </li>
</ul>
</li>
<li><p><code>/proc</code>：基于内存的虚拟文件系统（一切皆文件，把实时的内核参数和进程的信息进行可视化）（系统调优经常用到）</p>
<p>于输出内核与进程信息相关的虚拟文件系统</p>
<ul>
<li><code>/proc/cpuinfo</code>：</li>
<li><code>/proc/partitions</code>：</li>
</ul>
</li>
<li><p><code>/sys</code>：sysfs虚拟文件系统，提供了一种比proc更为理想的访问内存数据的途径，为管理Linux设备提供了一种统一模型的接口（see also:<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/）（**系统调优经常用到**）" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/）（**系统调优经常用到**）</a></p>
<p>用于输出当前系统上硬件设备相关信息虚拟文件系统</p>
</li>
</ul>
<ul>
<li>文件名最长255个字节</li>
<li>包括路径在内文件名称最长4095个字节</li>
<li>蓝色–&gt;目录   绿色–&gt;可执行文件    红色–&gt;压缩文件   浅蓝色–&gt;链接文<br>件  灰色–&gt;其他文件</li>
<li>除了斜杠和NUL,所有字符都有效.但使用特殊字符的目录名和文件不推荐使用，有些字符需要用引号来引用它们</li>
<li>标准Linux文件系统（如ext4），文件名称大小写敏感</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Nginx简介</title>
    <url>/01-Nginx%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Nginx</strong> （是engine x的缩写） 是一个<strong>HTTP server</strong>（HTTP服务器）和<strong>HTTP reverse proxy server</strong>（HTTP反向代理服务器），一个<strong>mail proxy server</strong>（邮件代理服务器）, 一个 通用 <strong>TCP/UDP proxy server</strong>（TCP/UDP反向代理服务器）。</p>
<p>Nginx工作在OSI模型的<strong>七层</strong>，也可以提供<strong>伪四层</strong>负载均衡。</p>
<p>Nginx是一个<code>scalable event-driven（asynchronous）architecture</code>，即<strong>可伸缩的事件驱动型（异步）架构</strong>。</p>
<p>国内的基于Nginx的二次开发版本：</p>
<ul>
<li><a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a></li>
</ul>
<p><a href="http://www.yulongjun.com/images/15033346509889.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130210416.jpg" alt="img"></a></p>
<ul>
<li><a href="https://openresty.org/cn/" target="_blank" rel="noopener">OpenResty</a></li>
</ul>
<p><a href="http://www.yulongjun.com/images/15033346303394.jpg" target="_blank" rel="noopener"><img src="01-Nginx%E7%AE%80%E4%BB%8B.assets/15033346303394.jpg" alt="img"></a></p>
<p>Nginx三大核心功能：</p>
<ul>
<li><code>http</code><ul>
<li>Web服务器（类似于httpd的功能）</li>
<li>HTTP reverse proxy Server（httpd也有类似的功能）</li>
</ul>
</li>
<li><code>mail</code><ul>
<li>Mail proxy server，支持icmp/pop3/smtp</li>
</ul>
</li>
<li><code>stream</code><ul>
<li>TCP/UDP proxy server（类似于lvs，不过是伪四层代理，效率没有lvs高）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="HTTP的几个概念术语"><a href="#HTTP的几个概念术语" class="headerlink" title="HTTP的几个概念术语"></a>HTTP的几个概念术语</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>统一资源定位符（Uniform Resource Identifier）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">scheme:[&#x2F;&#x2F;[user[:password]@]host[:port]][&#x2F;path][?query][#fragment]<br></code></pre></td></tr></table></figure>

<p>例子：<br><a href="http://www.yulongjun.com/images/15033355483183.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130210427.jpg" alt="img"></a></p>
<p><strong>fragment</strong>,可以通过访问下面网站来实验：<br><a href="http://www.yulongjun.com/images/15033359966742.jpg" target="_blank" rel="noopener"><img src="01-Nginx%E7%AE%80%E4%BB%8B.assets/15033359966742.jpg" alt="img"></a></p>
<h3 id="PV、UV"><a href="#PV、UV" class="headerlink" title="PV、UV"></a>PV、UV</h3><p><strong>PV</strong>: Page View<br><strong>UV</strong>: User View</p>
<h3 id="http事务："><a href="#http事务：" class="headerlink" title="http事务："></a><strong>http事务</strong>：</h3><p>request&lt;–&gt;response</p>
<p><strong><code>Headers</code></strong>:</p>
<ul>
<li>通用头部（General Headers）</li>
<li>请求头部（Response Headers）</li>
<li>回应头部（Request Headers）</li>
<li><a href="http://www.yulongjun.com/images/15033367804680.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130210434.jpg" alt="img"></a></li>
</ul>
<h3 id="Method："><a href="#Method：" class="headerlink" title="Method："></a><strong><code>Method</code></strong>：</h3><p><strong>GET/HEAD/POST</strong>(常用）, PUT/DELETE, TRACE, OPTIONS</p>
<h3 id="常用Status-Code-状态码）："><a href="#常用Status-Code-状态码）：" class="headerlink" title="常用Status Code(状态码）："></a>常用<strong><code>Status Code</code></strong>(状态码）：</h3><ul>
<li><strong><code>2xx</code></strong>：成功类响应码，<strong>200</strong>（OK）等</li>
<li><strong><code>3xx</code></strong>：重定向类的响应码，<strong>301</strong>（永久重定向,permenent）、<strong>302</strong>（临时重定向,termina）、<strong>304</strong>（Not Modified，从上次访问后未发生改变）</li>
<li><strong><code>4xx</code></strong>：客户端错误：403(Forbidden)，<strong>404</strong>(Not Found)</li>
<li><strong><code>5xx</code></strong>：服务器端错误，<strong>502</strong>(Bad Gateway)、<strong>503</strong> （Service Unavailable）</li>
</ul>
<h3 id="认证（Auth）："><a href="#认证（Auth）：" class="headerlink" title="认证（Auth）："></a><strong>认证</strong>（Auth）：</h3><ul>
<li>基于IP认证</li>
<li>基于用户认证：basic（基于htpasswd生成的用户文件认证）/digest（摘要认证）</li>
</ul>
<h3 id="httpd-MPM："><a href="#httpd-MPM：" class="headerlink" title="httpd MPM："></a><strong>httpd MPM</strong>：</h3><ul>
<li>prefork：进程模型，两级结构，主进程master负责生成prefork子进程，每个子进程相应一个请求。</li>
<li>worker：线程模型，三级结构，主进程master负责生成子进程worker，每个worker子进程负责生成多个worker线程，每个worker线程相应一个请求。</li>
<li>event：主进程master负责生成子进程event，每个event子进程基于事件驱动机制相应多个请求。</li>
</ul>
<h3 id="文件描述符（file-descriptor，简写fd）"><a href="#文件描述符（file-descriptor，简写fd）" class="headerlink" title="文件描述符（file descriptor，简写fd）"></a>文件描述符（file descriptor，简写fd）</h3><p>内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p>
<p>在设备读写（IO）、网络通信、进程通信，fd可谓是关键中的关键。</p>
<hr>
<h2 id="IO类型"><a href="#IO类型" class="headerlink" title="IO类型"></a>IO类型</h2><p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。</p>
<h3 id="1-同步-Synchronous-与异步-Asynchronous"><a href="#1-同步-Synchronous-与异步-Asynchronous" class="headerlink" title="1.同步(Synchronous)与异步(Asynchronous)"></a>1.同步(Synchronous)与异步(Asynchronous)</h3><p><strong>同步和异步关注的是<code>消息通信机制</code></strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。</p>
<p>换句话说，就是由<strong>调用者<code>主动等待</code>这个调用的结果</strong>。</p>
<p>而异步则是相反，调用在发出之后，这个调用就直接返回了，但是没有返回最终结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，<strong>被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用</strong>。</p>
<p>典型的异步编程模型比如<code>Node.js</code>，Python的<code>asyncio</code>。</p>
<blockquote>
<p><strong>举个通俗的例子：</strong><br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<h3 id="2-阻塞-Blocking）与非阻塞IO-Non-Blocking"><a href="#2-阻塞-Blocking）与非阻塞IO-Non-Blocking" class="headerlink" title="2. 阻塞(Blocking）与非阻塞IO(Non-Blocking)"></a>2. 阻塞(Blocking）与非阻塞IO(Non-Blocking)</h3><p>阻塞和非阻塞关注的是<strong><code>程序</code>在<code>等待调用结果</code>（消息，返回值）时的<code>状态</code></strong>。</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p>
<p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<blockquote>
<p><strong>还是上面的例子:</strong><br>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>
<h3 id="3-同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"><a href="#3-同步阻塞、同步非阻塞、异步阻塞、异步非阻塞" class="headerlink" title="3. 同步阻塞、同步非阻塞、异步阻塞、异步非阻塞"></a>3. 同步阻塞、同步非阻塞、异步阻塞、异步非阻塞</h3><blockquote>
<p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
<p>（1）老张把水壶放到火上，立等水开。（<strong>同步阻塞</strong>）老张觉得自己有点傻。</p>
<p>（2）老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（<strong>同步非阻塞</strong>）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀<del>~</del>的噪音。</p>
<p>（3）老张把响水壶放到火上，立等水开。（<strong>异步阻塞</strong>）老张觉得这样傻等意义不大。</p>
<p>（4）老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（<strong>异步非阻塞</strong>）老张觉得自己聪明了。</p>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。</p>
<p>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<p>– 来自知乎：<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
<p>下一节我们来了解一下IO模型，IO模型不光Nginx有设计，其他服务也会涉及。</p>
]]></content>
  </entry>
  <entry>
    <title>01-Zabbix-Server安装指南</title>
    <url>/01-Zabbix-Server%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装-Zabbix-的-yum-仓库"><a href="#安装-Zabbix-的-yum-仓库" class="headerlink" title="安装 Zabbix 的 yum 仓库"></a>安装 Zabbix 的 yum 仓库</h2><p>在所有机器上安装zabbix的yum仓库文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rpm -ivh http:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;3.4&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-release-3.4-3.el7.centos.noarch.rpm<br></code></pre></td></tr></table></figure>

<h2 id="安装配置MariaDB数据库并启动"><a href="#安装配置MariaDB数据库并启动" class="headerlink" title="安装配置MariaDB数据库并启动"></a>安装配置MariaDB数据库并启动</h2><p>数据库可以装在和 Zabbix Server 同一台机器上（zabbix.yulongjun.com)，也可以装在不同的机器上，这里直接装在同一台机器上了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y mariadb-server<br>systemctl start mariadb<br>systemctl enable mariadb<br></code></pre></td></tr></table></figure>

<p>在 Zabbix Server 上创建数据库zabbix、用户zabbix、运行建库脚本<code>schema.sql</code>、<code>schema.sql</code>、<code>images.sql</code>、<code>data.sql</code>（如果是Zabbix Proxy，就不用运行后两个）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># shell下运行：<br>shell&gt; mysql -uroot<br># mysql命令行里运行：<br>mysql&gt; create database zabbix character set utf8 collate utf8_bin;<br>mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &#39;zabbix&#39;;<br>mysql&gt; quit;<br># shell下运行：<br>shell&gt; cd &#x2F;usr&#x2F;share&#x2F;doc&#x2F;zabbix-server-mysql-3.4.2<br>shell&gt; zcat create.sql.gz | mysql -uroot zabbix # zcat出来的脚本写入zabbix库<br></code></pre></td></tr></table></figure>

<h2 id="安装配置Zabbix-Server并启动Server后端"><a href="#安装配置Zabbix-Server并启动Server后端" class="headerlink" title="安装配置Zabbix Server并启动Server后端"></a>安装配置Zabbix Server并启动Server后端</h2><p>在<code>zabbix.yulongjun.com</code>节点上,安装Zabbix Server相关：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install zabbix-server-mysql zabbix-web-mysql zabbix-get<br></code></pre></td></tr></table></figure>

<p>Zabbix 的配置主要分为下面几段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep &quot;^#####&quot; &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf<br>############ GENERAL PARAMETERS #################<br>############ ADVANCED PARAMETERS ################<br>####### LOADABLE MODULES #######<br>####### TLS-RELATED PARAMETERS #######<br></code></pre></td></tr></table></figure>

<p>通用参数、高级参数、加载的模块、TLS加密通信相关配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf&#123;,.bak&#125;<br>vim &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf<br></code></pre></td></tr></table></figure>

<p><strong>主要更改通用参数（GENERAL PARAMETERS）：</strong></p>
<p>下面是通用参数的说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">############ GENERAL PARAMETERS #################<br>ListenPort&#x3D;10051 # trapper监听端口，一般不变<br>SourceIP&#x3D;192.168.0.222 # 对外服务ip，这里要设置一下，要不会开放给所有ip<br>LogType&#x3D;file # 日志格式，默认为file，可设置为system（syslog）、file（需要定义LogFile参数）、console（标准输出）<br>LogFile&#x3D;&#x2F;var&#x2F;log&#x2F;zabbix&#x2F;zabbix_server.log # 上面定义为LogFile，这里就要定义路径了。<br>LogFileSize&#x3D;50 # 日志到多大滚动，0表示不滚动，一般需要设置下，最大为1024（MB)<br>PidFile&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix&#x2F;zabbix_server.pid  # pid对应的文件位置和名字<br>DBHost&#x3D;localhost  # 数据库地址<br>DBName&#x3D;zabbix  # 数据库名字<br>DBUser&#x3D;zabbix  # 数据库用户<br>DBPassword&#x3D;zabbix # 数据库密码<br>SocketDir&#x3D;&#x2F;var&#x2F;run&#x2F;zabbix  # Zabbix的IPC socket目录<br>DebugLevel&#x3D;3 # debug 级别，默认为3，一般不动，需要详细日志是可设置为5<br>DBHost&#x3D;localhost # 不变，因为zabbix用户就是授权到地址localhost了<br>DBName&#x3D;zabbix # 不变，当时创建的数据库名就是zabbix<br>DBUser&#x3D;zabbix # 不变，当时创建的用户就是zabbix<br>DBPassword&#x3D;zabbix # 这条原来没设置，设置为上面定义的密码<br>DBSocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock # DBSocket文件路径默认为&#96;&#x2F;tmp&#x2F;mysql.sock&#96;，所以这条需要设置数据库的sock文件所在位置；或者 &#96;ln -sv &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock &#x2F;tmp&#x2F;&#96;，这样不用改配置也能用<br>DBPort&#x3D;3306 # 数据库端口<br></code></pre></td></tr></table></figure>

<p>其实主要改的就这几项，其余的如果不一样再修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SourceIP&#x3D;192.168.0.222<br>DBPassword&#x3D;zabbix<br>DBSocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock<br></code></pre></td></tr></table></figure>

<p>启动zabbix-server并设置下次开机自动开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start zabbix-server<br></code></pre></td></tr></table></figure>

<h2 id="编辑Zabbix前端PHP配置，并启动Zabbix的Web服务"><a href="#编辑Zabbix前端PHP配置，并启动Zabbix的Web服务" class="headerlink" title="编辑Zabbix前端PHP配置，并启动Zabbix的Web服务"></a>编辑Zabbix前端PHP配置，并启动Zabbix的Web服务</h2><p>只要把httpd配置文件<code>/etc/httpd/conf.d/zabbix.conf</code>中的<code>php_value date.timezone</code>启用并设置为当前时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">php_value date.timezone Asia&#x2F;Shanghai<br></code></pre></td></tr></table></figure>

<p>或者是，把<code>/etc/php.ini</code>里的<code>date.timezone =</code>启用，并设置为当前时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">date.timezone &#x3D; Asia&#x2F;Shanghai<br></code></pre></td></tr></table></figure>

<p>上述两种方法均可。</p>
<p>启动Apache Web服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start httpd<br>systemctl enable httpd<br></code></pre></td></tr></table></figure>

<h2 id="设置Zabbix-Server"><a href="#设置Zabbix-Server" class="headerlink" title="设置Zabbix Server"></a>设置Zabbix Server</h2><p>在浏览器输入<code>zabbix.yulongjun.com/zabbix</code>即可登录Web页面，然后开始进一步的设置：</p>
<p><a href="http://www.yulongjun.com/images/15065619067746.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153554.jpg" alt="img"></a></p>
<p>点击Next step 配置，进入检查阶段，全部OK可以进入下一步配置：<br><a href="http://www.yulongjun.com/images/15065624714773.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153555.jpg" alt="img"></a></p>
<p>输入密码，其他的如果有自己更改过的可以自行更改：</p>
<p><a href="http://www.yulongjun.com/images/15065625613249.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153556.jpg" alt="img"></a></p>
<p>输入主机名或者ip地址、端口、还有名字<br><a href="http://www.yulongjun.com/images/15065627402045.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153557.jpg" alt="img"></a></p>
<p>安装摘要，点下一步开始安装：<br><a href="http://www.yulongjun.com/images/15065628136127.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153558.jpg" alt="img"></a></p>
<p>安装成功：</p>
<p><a href="http://www.yulongjun.com/images/15065628636288.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153559.jpg" alt="img"></a></p>
<p>可以登录了，默认用户名<code>admin</code>, 密码<code>zabbix</code>：</p>
<p><a href="http://www.yulongjun.com/images/15065629160607.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153600.jpg" alt="img"></a></p>
<p>进入页面：</p>
<p><a href="http://www.yulongjun.com/images/15065632054371.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153601.jpg" alt="img"></a></p>
<p>可以更换页面风格和语言：</p>
<p>Administration –&gt; General –&gt; 选择Dark主题–&gt;Update<br><a href="http://www.yulongjun.com/images/15065634445487.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153602.jpg" alt="img"></a></p>
<p>可以更改密码，语言（支持中文哦）：</p>
<p><a href="http://www.yulongjun.com/images/15065647113415.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153603.jpg" alt="img"></a></p>
<p>看一下中文界面：<br><a href="http://www.yulongjun.com/images/15065647698932.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153604.jpg" alt="img"></a></p>
<h2 id="设置media类型（报警媒介类型）"><a href="#设置media类型（报警媒介类型）" class="headerlink" title="设置media类型（报警媒介类型）"></a>设置media类型（报警媒介类型）</h2><p>由于某些原因，无法使用自带的一些媒介，所以使用自定义的邮箱设置</p>
<p>自带的Media，国内无法使用：<br><a href="http://www.yulongjun.com/images/15065667855013.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153605.jpg" alt="img"></a></p>
<p>点击右上角<code>创建媒体类型</code>创建自定义的媒介，这里的媒介指的是出现报警后，用什么媒介来报警，这里设置的一个<code>zabbix@yulongjun.com</code>来负责发送报警邮件。</p>
<p><a href="http://www.yulongjun.com/images/15065687896603.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153606.jpg" alt="img"></a></p>
<p>在Admin用户的设置里设置报警媒介，即出现报警后发送给谁，这里设置的<a href="mailto:ops@yulongjun.com">ops@yulongjun.com</a>。如果出现报警，则可以设置通过MyEmail(<a href="mailto:zabbix@yulongjun.com">zabbix@yulongjun.com</a>),向用户Admin设置的邮箱<code>ops@yulongjun.com</code>发送报警。</p>
<p><a href="http://www.yulongjun.com/images/15066088036948.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153607.jpg" alt="img"></a></p>
<p>这里设置里仅设置了警告以上级别：<br><a href="http://www.yulongjun.com/images/15066084049326.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153608.jpg" alt="img"></a></p>
<p>如果触发了triggers（触发器）的阈值，如果设定了相应的发送报警信息的Actions（行动），则会通过定义的规则来发送信息。</p>
<p>还可以设置页面的报警音（右上角人头–&gt;正在发送消息）</p>
<p><a href="http://www.yulongjun.com/images/15066089095200.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153609.jpg" alt="img"></a></p>
<h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>dashboard页面可以定义每个仪表盘的刷新时间：</p>
<p><a href="http://www.yulongjun.com/images/15065691116529.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153610.jpg" alt="img"></a></p>
<h1 id="监控模板网站"><a href="#监控模板网站" class="headerlink" title="监控模板网站"></a>监控模板网站</h1><p>在<a href="https://share.zabbix.com/，提供了各种各样的监控模板，可以自行搜索，套用。" target="_blank" rel="noopener">https://share.zabbix.com/，提供了各种各样的监控模板，可以自行搜索，套用。</a></p>
<p><a href="http://www.yulongjun.com/images/15065651011121.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153611.jpg" alt="img"></a></p>
<p>下一节根据具体Agent来设置监控</p>
]]></content>
  </entry>
  <entry>
    <title>01-iptables防火墙工具</title>
    <url>/01-iptables%E9%98%B2%E7%81%AB%E5%A2%99%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="iptables：-包过滤型的防火墙"><a href="#iptables：-包过滤型的防火墙" class="headerlink" title="iptables： 包过滤型的防火墙"></a>iptables： 包过滤型的防火墙</h2><p>Firewall：防火墙，隔离工具；工作于主机或网络边缘，对于进出本主机或本网络的报文根据事先定义的检查规则作匹配检测，对于能够被规则匹配到的报文作出相应处理的组件；</p>
<ul>
<li><p>主机防火墙 ：针对本机</p>
</li>
<li><p>网络防火墙 ：针对局域网</p>
</li>
<li><p>软件防火墙（软件逻辑）</p>
</li>
<li><p>硬件防火墙（硬件和软件逻辑）：特殊设计的CPU，更加效率的指令集，在硬件层完成报文的拆封和封装</p>
<p>ipfw (firewall framework)<br>ipchains (firewall framework)</p>
</li>
</ul>
<p>iptables(netfilter)<br>    netfilter：kernel 内核空间中真正对规则进行设置和管理的工具<br>    iptables：rules until 用户空间中，提供给用户系统调用netfilter的工具<br>nftables</p>
<p>hook function：在内核中，对报文进行检查过滤操作的五个位置<br>    prerouting        刚到防火墙服务器的报文，还没被路由时<br>    input             请求报文传送到本机<br>    output            本机进程发送响应报文到主机出门防火墙<br>    forward         请求报文传送到路由网关<br>    postrouting      经过output或者forward的报文再次经过路由出去本机后</p>
<p>链（内置）：每一个钩子hook都能放一堆规则，每个钩子的所有规则称为链<br>    PREROUTING<br>    INPUT<br>    FORWARD<br>    OUTPUT<br>    POSTROUTING</p>
<p>功能：<br>    filter：过滤，防火墙；<br>    nat：network address translation；用于修改源IP或目标IP，也可以改端口；主要目的用来内部主机<br>    mangle：拆解报文，做出修改，并重新封装起来；<br>    raw：关闭nat表上启用的连接追踪机制；<br>    每种功能在同一个链中，有执行顺序，相同功能连在一起执行，顺序为：<code>filter-nat-mangle-raw</code></p>
<p>功能&lt;–链：<br>    raw：PREROUTING， OUTPUT<br>    mangle：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING<br>    nat：PREROUTING，[INPUT，]OUTPUT，POSTROUTING<br>    filter：INPUT，FORWARD，OUTPUT（只在第一个路由和主机响应报文OUTPUT上做过滤）</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150751.png" alt="image-20200922153404635"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150758.png" alt="功能在链上额工作顺序"></p>
<p>报文流向：<br>    流入本机：PREROUTING –&gt; INPUT<br>    由本机流出：OUTPUT –&gt; POSTROUTING<br>    转发：PREROUTING –&gt; FORWARD –&gt; POSTROUTING</p>
<p>路由功能发生的时刻：<br>    报文进入本机后：<br>        判断目标主机是？<br>    报文离开本机之前：<br>        判断经由哪个接口送往下一站？</p>
<p>iptables/netfilter</p>
<p>规则：<br>    组成部分：根据规则匹配条件来尝试匹配报文，一旦匹配成功，就由规则定义的处理动作作出处理；<br>        匹配条件：<br>            基本匹配条件：内建<br>            扩展匹配条件：由扩展模块定义；<br>        处理动作：<br>            基本处理动作：内建<br>            扩展处理动作：由扩展模块定义；<br>            自定义处理机制：自定义链</p>
<p>iptables的链：内置链和自定义链<br>    内置链：对应于hook function<br>    自定义链接：用于内置链的扩展和补充，可实现更灵活的规则管理机制；</p>
<p>添加规则时的考量点：<br>    (1) 要实现哪种功能：判断添加到哪个表上；<br>    (2) 报文流经的路径：判断添加到哪个链上；</p>
<p>链：链上的规则次序，即为检查的次序；因此，隐含一定的应用法则：<br>    (1) 同类规则（访问同一应用），匹配范围小的放上面；<br>    (2) 不同类的规则（访问不同应用），匹配到报文频率较大的放在上面；<br>    (3) 将那些可由一条规则描述的多个规则合并起来；<br>    (4) 设置默认策略；</p>
<h2 id="iptables命令："><a href="#iptables命令：" class="headerlink" title="iptables命令："></a>iptables命令：</h2><p>​    高度模块化，由诸多扩展模块实现其检查条件或处理动作的定义；<br>​        /usr/lib64/xtables/<br>​            IPv6：libip6t_<br>​            IPv4：libipt_  libxt_<br>​    </p>
<p>​       iptables [-t table] {-A|-C|-D} chain rule-specification</p>
<p>​        iptables [-t table] -I chain [rulenum] rule-specification</p>
<p>​        iptables [-t table] -R chain rulenum rule-specification</p>
<p>​        iptables [-t table] -D chain rulenum</p>
<p>​        iptables [-t table] -S [chain [rulenum]]</p>
<p>​        iptables [-t table] {-F|-L|-Z} [chain [rulenum]] [options…]</p>
<p>​        iptables [-t table] -N chain</p>
<p>​        iptables [-t table] -X  [chain]</p>
<p>​        iptables [-t table] -P chain target</p>
<p>​        iptables [-t table] -E old-chain-name new-chain-name<br>​<br>​        rule-specification = [matches…]  [target]</p>
<p>​        match = -m matchname [per-match-options]</p>
<p>​        target = -j targetname [per-target-options]<br>​<br>​        规则格式：iptables   [-t table]   COMMAND   chain   [-m matchname [per-match-options]]   -j targetname [per-target-options]<br>​<br>​            -t table：可省略，则默认filter功能表<br>​                raw, mangle, nat, [filter]<br>​                </p>
<h3 id="COMMAND："><a href="#COMMAND：" class="headerlink" title="COMMAND："></a>COMMAND：</h3><h3 id="链管理："><a href="#链管理：" class="headerlink" title="链管理："></a>链管理：</h3><p>​                    -N：new, 自定义一条新的规则链；<br>​                    -X： delete，删除自定义的规则链；<br>​                        注意：仅能删除 用户自定义的 引用计数为0的 空的 链；<br>​                    -P：Policy，设置默认策略；对filter表中的链而言，其默认策略有：<br>​                        ACCEPT：接受<br>​                        DROP：丢弃<br>​                        REJECT：拒绝<br>​                    -E：重命名自定义链；引用计数不为0的自定义链不能够被重命名，也不能被删除；</p>
<h3 id="规则管理："><a href="#规则管理：" class="headerlink" title="规则管理："></a>规则管理：</h3><p>​                    -A：append，追加；<br>​                    -I：insert, 插入，要指明位置，省略时表示第一条；<br>​                    -D：delete，删除；<br>​                        (1) 指明规则序号；<br>​                        (2) 指明规则本身；<br>​                    -R：replace，替换指定链上的指定规则；<br>​<br>​                    -F：flush，清空指定的规则链；<br>​                    -Z：zero，置零；<br>​                        iptables的每条规则都有两个计数器：<br>​                            (1) 匹配到的报文的个数；<br>​                            (2) 匹配到的所有报文的大小之和；<br>​                查看：<br>​                    -L：list, 列出指定鏈上的所有规则；<br>​                        -n：numberic，以数字格式显示地址和端口号；<code>因为iptables会将ip地址反解为主机名，性能会消耗，不利的，所以取消反解ip</code><br>​                        -v：verbose，<code>详细信息</code>；<br>​                            -vv, -vvv<br>​                        -x：exactly，显示计数器结果的精确值；<br>​                        –line-numbers：显示规则的序号；<br>​<br>​            chain：<br>​                PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING<br>​                </p>
<h3 id="匹配条件："><a href="#匹配条件：" class="headerlink" title="匹配条件："></a>匹配条件：</h3><p>​       基本匹配条件：PARAMETERS<br>​        扩展匹配条件：<br>​            隐式扩展：在使用-p选项指明了特定的协议时，无需再同时使用-m选项指明扩展模块的扩展机制；<br>​            显式扩展：必须使用-m选项指明要调用的扩展模块的扩展机制；</p>
<p>​                <code>基本匹配条件</code>：无需加载任何模块，由iptables/netfilter自行提供；</p>
<p>​                    [!] -s, –source  address[/mask][,…]：检查报文中的源IP地址是否符合此处指定的地址或范围；<br>​                    [!] -d, –destination address[/mask][,…]：检查报文中的目标IP地址是否符合此处指定的地址或范围；<br>​                        所有地址：0.0.0.0/0<br>​                    [!] -p, –protocol protocol<br>​                        protocol: tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh or  “all”<br>​                            {tcp|udp|icmp}<br>​                    [!] -i, –in-interface name：数据报文流入的接口；只能应用于数据报文流入的环节，只能应用于PREROUTING，INPUT和FORWARD链；<br>​                    [!] -o, –out-interface name：数据报文流出的接口；只能应用于数据报文流出的环节，只能应用于FORWARD、OUTPUT和POSTROUTING链；                                            </p>
<p>​                处理动作：<br>​                    -j targetname [per-target-options]<br>​                        ACCEPT<br>​                        DROP<br>​                        REJECT<br>​                        </p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>​               本机地址172.16.0.67<br>​            1、开放本机的所有tcp服务给所有主机；<br>​                # iptables -I INPUT  -d 172.16.0.67 -p tcp -j ACCEPT<br>​                # iptables -I OUTPUT  -s 172.16.0.67 -p tcp -j ACCEPT<br>​            2、开放本机的所有udp服务给172.16.0.0/16网络中的主机，但不包含172.16.0.200；<br>​                # iptables -I INPUT 2 -d 172.16.0.67 -s 172.16.0.200 -p udp -j REJECT<br>​                # iptables -I INPUT 3 -d 172.16.0.67 -s 172.16.0.0/16 -p udp -j ACCEPT<br>​                # iptables -I OUTPUT 2 -s 172.16.0.67 -d 172.16.0.0/16 -p udp -j ACCEPT<br>​            3、默认策略为REJECT；<br>​            扩展：<br>​            1、仅开放本机的ssh服务给172.16.0.0/16中的主机，而且不包含172.16.0.200; </p>
<p>​                    <code>隐式扩展</code>：不需要手动加载扩展模块；因为它们是对协议的扩展，所以，但凡使用-p指明了协议，就表示已经指明了要扩展的模块；<br>​                        tcp：<br>​                            [!] –source-port, –sport port[:port]：匹配报文的源端口；可以是端口范围；<br>​                            [!] –destination-port,–dport port[:port]：匹配报文的目标端口；可以是端口范围；<br>​                            [!] –tcp-flags  mask  comp<br>​                                    mask is the flags which we should examine,  written as a comma-separated list，例如 SYN,ACK,FIN,RST<br>​                                    comp is a comma-separated list  of  flags  which must be set，例如SYN<br>​                                    例如：“–tcp-flags  SYN,ACK,FIN,RST  SYN”表示，要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0；<br>​                            [!] –syn：用于匹配第一次握手，相当于”–tcp-flags  SYN,ACK,FIN,RST  SYN“；<br>​                        udp<br>​                            [!] –source-port, –sport port[:port]：匹配报文的源端口；可以是端口范围；<br>​                            [!] –destination-port,–dport port[:port]：匹配报文的目标端口；可以是端口范围；<br>​<br>​                        icmp<br>​                            [!] –icmp-type {type[/code]|typename}<br>​                                    echo-request：8 发送icmp报文，ping请求<br>​                                    echo-reply：0   接受icmp报文，ping响应<br>​<br>​                    显式扩展：必须要手动加载扩展模块， [-m matchname [per-match-options]]；                     </p>
<p>​            <code>显式扩展</code>：必须使用-m选项指明要调用的扩展模块的扩展机制；<br>​                1、<code>multiport</code> 匹配散列端口<br>​                    This  module  matches  a  set  of  source  or  destination  ports. Up  to 15 ports can be specified.  A port range (port:port) counts as two ports.  It can only be used in conjunction with one of the following protocols: tcp,  udp, udplite, dccp and sctp.<br>​<br>​                    以离散或连续的 方式定义多端口匹配条件，最多15个；<br>​<br>​                    [!] –source-ports,–sports port[,port|,port:port]…：指定多个源端口；<br>​                    [!] –destination-ports,–dports port[,port|,port:port]…：指定多个目标端口；<br>​                    </p>
<p>iptables -I INPUT  -d 172.16.0.7 -p tcp -m multiport –dports 22,80,139,445,3306 -j ACCEPT</p>
<p>​            2、<code>iprange</code> 匹配连续地址<br>​                以连续地址块的方式来指明多IP地址匹配条件；<br>​                [!] –src-range from[-to]<br>​                [!] –dst-range from[-to]<br>​                </p>
<p>iptables -I INPUT -d 172.16.0.7 -p tcp -m multiport –dports 22,80,139,445,3306 -m iprange –src-range 172.16.0.61-172.16.0.70 -j REJECT</p>
<p>​            3、<code>time</code> 限制（匹配）时间<br>​                This  matches  if the packet arrival time/date is within a given range.<br>​<br>​                 –timestart hh:mm[:ss]<br>​                 –timestop hh:mm[:ss]<br>​<br>​                 [!] –weekdays day[,day…]<br>​<br>​                 [!] –monthdays day[,day…]<br>​<br>​                –datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]]<br>​                –datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]]<br>​<br>​                 –kerneltz：使用内核配置的时区而非默认的UTC；<br>​<br>​            4、<code>string</code> 匹配报文字符串<br>​                This modules matches a given string by using some pattern matching strategy.<br>​<br>​                –algo {bm|kmp}<br>​                [!] –string pattern<br>​                [!] –hex-string pattern<br>​<br>​                –from offset<br>​                –to offset<br>​<br>​                ~]# iptables -I OUTPUT -m string –algo bm –string “gay” -j REJECT<br>​<br>​            5、<code>connlimit</code>  限制（匹配）同一个ip的并发连接数<br>​                Allows  you  to  restrict  the  number  of parallel connections to a server per client IP address (or client address block).<br>​<br>​                –connlimit-upto n  小于某个连接数量 ，一般搭配ACCEPT动作和黑名单默认策略<br>​                –connlimit-above n  大于某个连接数量 ，一般搭配REJIECTT动作和白名单默认策略<br>​<br>​                ~]# iptables -I INPUT -d 172.16.0.7 -p tcp –syn –dport 22 -m connlimit –connlimit-above 2 -j REJECT<br>​<br>​            6、<code>limit</code>  ：限制（匹配）发送报文的速度（而不是带宽的速度）。发送报文方要拿到令牌才有资格发送报文，而主动限制方是固定时间发令牌。这限制发送报文速率用的是令牌算法。限制方和被限制方协商好限制方一秒产生多少个令牌发送给被限制方，限制方有一个<code>令牌孔</code>，用来存放暂时不用的令牌（因为限制方一直发送令牌，被限制方不一定经常发送报文，既是某些令牌会多余出来，为了不扔了浪费，就用令牌孔来存放），制方可定义令牌孔的存放数量大小。因此被限制方积累了部分令牌，可能有一段时间超速。<br>​                This  module  matches  at  a limited rate using a token bucket filter.<br>​<br>​                –limit rate[/second|/minute|/hour|/day]<br>​                –limit-burst number 令牌孔最多收集多少个令牌<br>​<br>​                ~]# iptables -I OUTPUT -s 172.16.0.7 -p icmp –icmp-type 0 -j ACCEPT<br>​<br>​                限制本机某tcp服务接收新请求的速率：–syn, -m limit  既是接受够请求数量后，多余的放到阻塞队列中去<br>​<br>​            7、state<br>​                The “state” extension is a subset of the “conntrack” module.  “state” allows access to the connection tracking state for this packet.<br>​<br>​                [!] –state state<br>​                    INVALID, ESTABLISHED, NEW, RELATED or UNTRACKED.<br>​<br>​                    NEW: 新连接请求；<br>​                    ESTABLISHED：已建立的连接；<br>​                    INVALID：无法识别的连接；<br>​                    RELATED：相关联的连接，当前连接是一个新请求，但附属于某个已存在的连接；<br>​                    UNTRACKED：未追踪的连接；<br>​<br>​                    state扩展：<br>​                        内核模块装载：<br>​                            nf_conntrack<br>​                            nf_conntrack_ipv4<br>​<br>​                            手动装载：<br>​                                nf_conntrack_ftp<br>​<br>​                追踪到的连接：<br>​                    /proc/net/nf_conntrack<br>​<br>​                调整可记录的连接数量最大值：<br>​                    /proc/sys/net/nf_conntrack_max<br>​<br>​                超时时长：<br>​                    /proc/sys/net/netfilter/<em>timeout</em><br>​<br>处理动作（跳转目标）：<br>​    -j targetname [per-target-options]<br>​        简单target：<br>​            ACCEPT， DROP<br>​<br>​        扩展target：<br>​            REJECT<br>​                This is used to send back an error packet in response to the matched packet: otherwise it is equivalent to  DROP  so it  is  a  terminating  TARGET,  ending  rule traversal.<br>​<br>​                –reject-with type<br>​                    The type given can be icmp-net-unreachable, icmp-host-unreachable, icmp-port-unreachable, icmp-proto-unreach‐ able, icmp-net-prohibited, icmp-host-prohibited, or icmp-admin-prohibited (*), which return  the  appropriate ICMP  error  message (icmp-port-unreachable is the default).<br>​<br>​            LOG<br>​                Turn  on  kernel  logging of matching packets.<br>​<br>​                –log-level<br>​                –log-prefix<br>​<br>​                默认日志保存于/var/log/messages<br>​<br>​            RETURN：<br>​                返回调用者；<br>​<br>​        自定义链做为target：</p>
<p>​<br>​    保存和载入规则：<br>​        保存：iptables-save &gt; /PATH/TO/SOME_RULE_FILE<br>​        重载：iptabls-restore &lt; /PATH/FROM/SOME_RULE_FILE<br>​            -n, –noflush：不清除原有规则<br>​            -t, –test：仅分析生成规则集，但不提交<br>​<br>​        CentOS 6：<br>​            保存规则：<br>​                service iptables save<br>​                保存规则于/etc/sysconfig/iptables文件，覆盖保存；<br>​            重载规则：<br>​                service iptables restart<br>​                默认重载/etc/sysconfig/iptables文件中的规则<br>​<br>​            配置文件：/etc/sysconfig/iptables-config<br>​<br>​        CentOS 7：<br>​            (1) 自定义Unit File，进行iptables-restore；<br>​            (2) firewalld服务；<br>​            (3) 自定义脚本；<br>​<br>​    规则优化的思路：<br>​        使用自定义链管理特定应用的相关规则，模块化管理规则；<br>​<br>​        (1) 优先放行双方向状态为ESTABLISHED的报文；<br>​        (2) 服务于不同类别的功能的规则，匹配到报文可能性更大的放前面；<br>​        (3) 服务于同一类别的功能的规则，匹配条件较严格的放在前面；<br>​        (4) 设置默认策略：白名单机制<br>​            (a) iptables -P，不建议；<br>​            (b) 建议在规则的最后定义规则做为默认策略；</p>
<p>回顾：<br>    iptables/netfilter：<br>        netfilter：raw，mangle, nat, filter<br>            PREROUTING –&gt; INPUT<br>            PREROUTING –&gt; FORWARD –&gt; POSTROUTING<br>            OUTPUT –&gt; POSTROUTING<br>        filter：INPUT，FORWARD，OUTPUT<br>        nat：PREROUTING，INPUT，OUTPUT，POSTROUTING</p>
<pre><code>iptables：
    [-t table] COMMAND [chain] rule-specification
        -m matchname [per-match-options]
        -t targetname [per-target-options]
        [options]

    匹配 条件：
        基本匹配条件：-s, -d, -p, -m, -i, -o
        扩展匹配条件：
            隐式扩展：
                -p tcp: --dport, --sport, --tcp-flags, --syn 
                -p udp：--dport, --sport
                -p imcp: --icmp-type
            显式扩展：
                multiport：--sports, --dports
                iprange：--src-range, --dst-range
                time：--timestart, --timestop, --weekdays, --monthdays, --datestart, --datestop
                string：--algo {bm|kmp}, --string
                connlimit：--connlimit-upto, --connlimit-above
                limit：--limit, --limit-burst
                state：--state
                    NEW, ESTABLISHED, RELATED, INVALID, UNTRACKED

    target：
        -j：
            ACCEPT/DROP
            REJECT：--reject-with
            LOG：--log-level, --log-prefix
            自定义链
                RETURN

iptables-save/iptables-restore</code></pre><p>​<br>iptables（3）<br>​    iptables/netfilter网络防火墙：<br>​        (1) 网关；<br>​        (2) filter表的FORWARD链；<br>​<br>​        要注意的问题：<br>​            (1) 请求-响应报文均会经由FORWARD链，要注意规则的方向性；<br>​            (2) 如果要启用conntrack机制，建议将双方向的状态为ESTABLISHED的报文直接放行；<br>​<br>​        NAT: Network Address Translation<br>​            请求报文：由管理员定义；<br>​            响应报文：由NAT的conntrack机制自动实现；<br>​<br>​            请求报文：<br>​                改源地址：SNAT，MASQUERADE<br>​                改目标地址：DNAT<br>​<br>​        iptables/netfilter：<br>​            NAT定义在nat表；<br>​                PREROUTING，INPUT，OUTPUT，POSTROUTING<br>​<br>​                SNAT：POSTROUTING<br>​                DNAT：PREROUTING<br>​                PAT：<br>​<br>​        target：<br>​            SNAT：<br>​                This  target  is only valid in the nat table, in the POSTROUTING and INPUT chains, and user-defined chains which are only called from those chains.<br>​<br>                –to-source [ipaddr[-ipaddr]]</p>
<pre><code>    DNAT：
        This target is only valid in the nat table, in the PREROUTING and OUTPUT chains, and user-defined chains  which  are only  called from those chains.

        --to-destination [ipaddr[-ipaddr]][:port[-port]]

     MASQUERADE
        This target is only valid in the nat table, in the POSTROUTING chain.  It  should  only  be  used  with  dynamically assigned  IP (dialup) connections: if you have a static IP address, you should use the SNAT target.

        SNAT场景中应用于POSTROUTING链上的规则实现源地址转换，但外网地址不固定时，使用此target；

    REDIRECT
        This  target  is only valid in the nat table, in the PREROUTING and OUTPUT chains, and user-defined chains which are only called from those chains.

        --to-ports port[-port]

layer7</code></pre><p>​<br>​<br>​    博客作业：iptables/netfilter入门到进阶</p>
<p>tcp_wrapper：</p>
<pre><code>库文件：libwrap.so，tcp包装器；

判断一个服务程序是否能够由tcp_wrapper进行访问控制的方法：
    (1) 动态链接至libwrap.so库；
        ldd  /PATH/TO/PROGRAM
            libwrap.so
    (2) 静态编译libwrap.so库文件至程序中：
        strings /PATH/TO/PGRGRAM 
            hosts_access

配置文件：/etc/hosts.allow, /etc/hosts.deny

     See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; for information on rule syntax.    

    配置文件语法：
        daemon_list : client_list[ : option : option ...]

        daemon_list：程序文件名称列表
            (1) 单个应用程序文件名；
            (2) 程序文件名列表，以逗号分隔；
            (3) ALL：所有受tcp_wrapper控制的应用程序文件；

        client_list：
            (1) 单个IP地址或主机名；
            (2) 网络地址：n.n.n.n/m.m.m.m，n.n.n.；
            (3) 内建的ACL:
                ALL：所有客户端主机；
                LOCAL：Matches any host whose name does not contain a dot character.
                UNKNOWN
                KNOWN
                PARANOID

            OPERATORS：
                EXCEPT
                    list1 EXCEPT list2 EXCEPT list3

                    sshd: 172.16. EXCEPT 172.16.100. EXCEPT 172.16.100.68

        [ : option : option ...]

            deny：拒绝，主要用于hosts.allow文件中定义“拒绝”规则；
            allow：允许，主要用于hosts.deny文件中定义”允许“规则；

            spawn：生成，发起，触发执行用户指定的任意命令，此处通常用于记录日志；

                vsftpd: 172.16. : spawn /bin/echo $(date) login attempt from %c to %s &gt;&gt; /var/log/tcp_wrapper.log 

练习：仅开放本机的sshd服务给172.16.0.0/16网络中除了172.16.0.0/24网络中的主机之外的所有主机，但允许172.16.0.200访问； 每次的用户访问都要记录于日志文件中；</code></pre><p>​<br>​<br>​<br>​<br>​<br>​     </p>
]]></content>
  </entry>
  <entry>
    <title>01-shell进阶--流程</title>
    <url>/01-shell%E8%BF%9B%E9%98%B6-%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于条件判断和循环跟其他语言都大同小异，学过编程的话很好理解，这里只贴出格式，不具体写用法了。（select菜单会详细讲一下）</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><p>普通if条件判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if 判断条件1; then<br>    条件为真的分支代码<br>elif 判断条件2; then<br>    条件为真的分支代码<br>elif 判断条件3; then<br>    条件为真的分支代码<br>else<br>    以上条件都为假的分支代码<br>fi<br></code></pre></td></tr></table></figure>

<p>嵌套if条件判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if 判断条件1; then<br>    条件为真的分支代码<br>else<br>    if 判断条件2; then<br>        条件为真的分支代码<br>    else<br>        条件为真的分支代码<br>    fi<br>fi<br>​&#96;&#96;&#96;    <br><br>### case条件判断<br><br>​&#96;&#96;&#96;bash<br>case 变量引用 in<br>PAT1)<br>    分支1<br>    ;;<br>PAT2)<br>    分支2<br>    ;;<br>#...省略<br>*)<br>    默认分支<br>esac<br></code></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>普通for循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for 变量名 in 列表;do<br>    循环体<br>done<br></code></pre></td></tr></table></figure>

<p>嵌套for循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for 变量名1 in 列表1;do<br>    循环体1<br>    for 变量名2 in 列表2;do<br>        循环体2<br>    done<br>done<br></code></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">while CONDITION; do<br>    循环体<br>done<br></code></pre></td></tr></table></figure>

<h3 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">until CONDITION; do<br>    循环体<br>done<br></code></pre></td></tr></table></figure>

<h3 id="循环中使用continue和break"><a href="#循环中使用continue和break" class="headerlink" title="循环中使用continue和break"></a>循环中使用continue和break</h3><p>continue 结束本次循环，还会进入下一轮循环<br>break 结束全部循环，不会进入下一轮循环</p>
<h3 id="循环工中使用shift跳过参数列表中的某项"><a href="#循环工中使用shift跳过参数列表中的某项" class="headerlink" title="循环工中使用shift跳过参数列表中的某项"></a>循环工中使用shift跳过参数列表中的某项</h3><p>用于处理参数不确定的情况，shift比较好用</p>
<h3 id="while循环的特殊用法（遍历文件的每一行）"><a href="#while循环的特殊用法（遍历文件的每一行）" class="headerlink" title="while循环的特殊用法（遍历文件的每一行）"></a>while循环的特殊用法（遍历文件的每一行）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">while read line; do<br>循环体<br>done &lt; &#x2F;PATH&#x2F;FROM&#x2F;SOMEFILE<br></code></pre></td></tr></table></figure>

<h3 id="select-菜单"><a href="#select-菜单" class="headerlink" title="select 菜单"></a>select 菜单</h3><ul>
<li>select 循环主要用于创建菜单，按数字顺序排列的菜单项将显示在标准错误上，并显示 PS3 提示符，等待用户输入。</li>
<li>用户输入菜单列表中的某个数字，执行相应的命令</li>
<li>用户输入被保存在内置变量 REPLY 中。</li>
<li>可以和case结合使用。</li>
</ul>
<p>下面举个和select和case结合使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">PS3&#x3D;&quot;Please choose your food(Input No.): &quot;<br>select food in &quot;exit&quot; &quot;huimian&quot; &quot;juejiangmian&quot; &quot;laomo&quot; &quot;yangroutang&quot;<br>do<br>    case $food in<br>        &quot;exit&quot;)<br>            echo Your choice is $REPLY<br>            echo &quot;Thanks!&quot;<br>            exit<br>            ;;<br>        &quot;huimian&quot;|&quot;juejiangmian&quot;)<br>            echo Your choice is $REPLY<br>            echo &quot;12 yuan&quot;<br>            ;;<br>        &quot;laomo&quot;)<br>            echo Your choice is $REPLY<br>            echo &quot;15 yuan&quot;<br>            ;;<br>        &quot;yangroutang&quot;)<br>            echo Your choice is $REPLY<br>            echo &quot;20 yuan&quot;<br>            ;;<br>        *)<br>            echo &quot;Dont&#39;s have this food&quot;<br>            ;;<br>    esac<br>done<br></code></pre></td></tr></table></figure>



<h3 id="trap-信号捕捉"><a href="#trap-信号捕捉" class="headerlink" title="trap 信号捕捉"></a>trap 信号捕捉</h3><ul>
<li><code>trap &#39;触发指令&#39; 信号</code> ：自定义进程收到系统发出的指定信号后，将执行触发指令 ，而不会执行原操作</li>
<li><code>trap &#39;&#39; 信号</code> ：信号忽略信号的操作</li>
<li><code>trap &#39;-&#39; 信号</code> ：恢复原信号的操作</li>
<li><code>trap -p</code>：列出自定义信号操作</li>
</ul>
<p><a href="http://www.yulongjun.com/images/14992632250484.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002903.jpg" alt="img"></a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>01-socket概念</title>
    <url>/01-socket%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="跨网络的主机间通讯"><a href="#跨网络的主机间通讯" class="headerlink" title="跨网络的主机间通讯"></a>跨网络的主机间通讯</h2><p>在建立通信连接的每一端，进程间的传输要有两个标志：<br>IP地址和端口号，合称为套接字地址 socket address<br>客户机套接字地址定义了一个唯一的客户进程<br>服务器套接字地址定义了一个唯一的服务器进程</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828084107.png" alt="image-20200823110346149"></p>
<h2 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h2><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828084053.png" alt="image-20200823110428138"></p>
<ul>
<li>Socket:套接字，进程间通信IPC的一种实现，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换</li>
<li>Socket API：封装了内核中所提供的socket通信相关的系统调用</li>
<li>Socket Domain：根据其所使用的地址</li>
</ul>
<p>​            AF_INET：Address Family，IPv4 </p>
<p>​            AF_INET6：IPv6<br>​            AF_UNIX：同一主机上不同进程之间通信时使用。本机之间的socket通信时，通过内存中的socket文件进行读写通信</p>
<ul>
<li><p>Socket Type：根据使用的传输层协议</p>
<p>SOCK_STREAM：流，tcp套接字，可靠地传递、面向连接 SOCK_DGRAM：数据报，udp套接字，不可靠地传递、无连接 SOCK_RAW: 裸套接字,无须tcp或udp,APP直接通过IP包通信 </p>
</li>
</ul>
<h3 id="客户-服务器程序的套接字函数"><a href="#客户-服务器程序的套接字函数" class="headerlink" title="客户/服务器程序的套接字函数"></a>客户/服务器程序的套接字函数</h3><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828084040.png" alt="image-20200823111337993"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828084030.png" alt="image-20200823111351832"></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>套接字相关的系统调用：</p>
<p>socket():  创建一个套接字  </p>
<p>bind()： 绑定IP和端口</p>
<p>listen()： 监听 </p>
<p>accept()： 接收请求 </p>
<p>connect()： 请求连接建立 </p>
<p>write()： 发送 </p>
<p>read()： 接收 </p>
<p>close(): 关闭连接 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#Socket通信示例：服务器端tcpserver.py <br>import socket <br>HOST&#x3D;&#39;127.0.0.1&#39; <br>PORT&#x3D;9527 <br>BUFFER&#x3D;4096 <br>sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.bind((HOST,PORT)) <br>sock.listen(3) <br>print(&#39;tcpServer listen at: %s:%s\n\r&#39; %(HOST,PORT)) while True: <br>	   client_sock,client_addr&#x3D;sock.accept()    <br>	   print(&#39;%s:%s connect&#39; %client_addr)    <br>	   while True: <br>	   	recv&#x3D;client_sock.recv(BUFFER)   <br>	    if not recv: <br>	      client_sock.close()     <br>	      break <br>	    print(&#39;[Client %s:%s said]:%s&#39; %(client_addr[0],client_addr[1],recv))<br>	    client_sock.send(‘I am tcpServer and has received your message&#39;)<br>sock.close() <br>#Socket通信示例：服务器端tcpclient.py <br>import socket <br>HOST&#x3D;&#39;127.0.0.1&#39; <br>PORT&#x3D;9527 <br>BUFFER&#x3D;4096 <br>sock&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.connect((HOST,PORT)) <br>sock.send(‘hello, tcpServer!，I am TcpClient&#39;) <br>recv&#x3D;sock.recv(BUFFER) <br>print(&#39;[tcpServer said]: %s&#39; % recv) <br>sock.close()<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>01-vim文本编辑工具</title>
    <url>/01-vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="文本编辑工具"><a href="#文本编辑工具" class="headerlink" title="文本编辑工具"></a>文本编辑工具</h2><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819105030.png" alt=""></p>
<h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><p>+# 打开文件后，让光标处于第#行的行首，+默认行尾 </p>
<p>+/PATTERN 让光标处于第一个被PATTERN匹配到的行的行首</p>
<p>–    b file 二进制方式打开文件<br>–    d file1 file2…  比较多个文件件</p>
<p>-m file  只读打开文件</p>
<ul>
<li>vim -e file 或 ex  file 直接进入ex模式</li>
<li>如果该文件存在，文件被打开并显示内容如果该文件不存在，当编辑后第一次存盘时创建它</li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>三种主要模式：<br>    命令(Normal)模式：默认模式，移动光标，剪切/粘贴文本<br>    插入(Insert)或编辑模式：修改文本<br>    扩展命令(extended command )模式：保存，退出等<br>Esc键 退出当前模式，返回到命令模式</p>
<p><img src="01-vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7.assets/image-20200819093109089.png" alt="image-20200819093109089"></p>
<h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><p>命令模式 –&gt; 插入模式</p>
<p>i    insert, 在光标所在处输入<br>I    在当前光标所在行的行首输入 </p>
<p>a    append, 在光标所在处后面输入 </p>
<p>A    在当前光标所在行的行尾输入</p>
<p>o    在当前光标所在行的下方打开一个新行</p>
<p>O     在当前光标所在行的上方打开一个新行</p>
<p>插入模式 ——–&gt; 命令模式</p>
<p>​    <strong>ESC</strong></p>
<p>命令模式 ——–&gt; 扩展命令模式</p>
<p>​    <strong>:</strong></p>
<p>扩展命令模式 ——–&gt; 命令模式</p>
<p>​    <strong>ESC,enter</strong></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>扩展命令模式：</p>
<p>:q    退出</p>
<p>:q!    强制退出，放弃修改</p>
<p>:wq    保存退出</p>
<p>:x    保存退出 （不推荐）</p>
<p>命令模式：</p>
<p>ZZ    保存退出</p>
<p>ZQ    不保存退出</p>
<h3 id="命令模式翻屏操作"><a href="#命令模式翻屏操作" class="headerlink" title="命令模式翻屏操作"></a>命令模式翻屏操作</h3><p>Ctrl+f     向文件尾部翻一屏<br>Ctrl+b     向文件首部翻一屏<br>Ctrl+d     向文件尾部翻半屏<br>Ctrl+u     向文件首部翻半屏</p>
<h3 id="命令模式操作"><a href="#命令模式操作" class="headerlink" title="命令模式操作"></a>命令模式操作</h3><h4 id="字符编辑："><a href="#字符编辑：" class="headerlink" title="字符编辑："></a>字符编辑：</h4><p>x    删除光标处的字符<br>#x    删除光标处起始的#个字符<br>xp    交换光标所在处的字符及其后面字符的位置 </p>
<p>~    转换大小写<br>J    删除当前行后的换行符 </p>
<p>替换命令(r, replace)</p>
<p>r    替换光标所在处的字符 </p>
<p>R    切换成REPLACE模式 </p>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><p>d    删除命令：删除命令，可结合光标跳转字符，实现范围删除 </p>
<p>d$    删除到行尾<br>删除到非空行首<br>删除到行首 </p>
<p>dw<br>d3e<br>d4l</p>
<p>#COMMAND</p>
<p>dd    删除光标所在的行</p>
<p>#dd    多行删除</p>
<p>D：从当前光标位置一直删除到行尾，等同于d$</p>
<h4 id="复制命令-y-yank"><a href="#复制命令-y-yank" class="headerlink" title="复制命令(y, yank)"></a>复制命令(y, yank)</h4><p>y    复制，行为相似于d命令</p>
<p>y$<br>y0<br>y^<br>ye<br>yw<br>yb<br>#COMMAND</p>
<p>yy：复制行</p>
<p>#yy 复制多行</p>
<p>Y：复制整行</p>
<h4 id="粘贴命令-p-paste"><a href="#粘贴命令-p-paste" class="headerlink" title="粘贴命令(p, paste)"></a>粘贴命令(p, paste)</h4><p>p    缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面</p>
<p>P    缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面</p>
<h4 id="改变命令-c-change"><a href="#改变命令-c-change" class="headerlink" title="改变命令(c, change)"></a>改变命令(c, change)</h4><p>c: 修改后切换成插入模式，类似进入插入模式的d命令</p>
<p>c$ </p>
<p>c^</p>
<p>c0 </p>
<p>cb </p>
<p>ce</p>
<p>cc：删除当前行并输入新内容，相当于S</p>
<p>#cc</p>
<p>C：删除当前光标到行尾，并切换成插入模式</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>100iwang [ESC] 粘贴“wang”100次<br><start position><command><end position><br>常见Command：</p>
<p>y 复制、d 删除、gU 变大写、gu 变小写 </p>
<p>例如： 0y$ 命令 </p>
<p>0 → 先到行头<br>y → 从这里开始拷贝<br>$ → 拷贝到本行最后一个字符</p>
<p>di”   光标在”“之间，则删除”“之间的内容<br>yi(   光标在()之间，则复制()之间的内容<br>vi[   光标在[]之间，则选中[]之间的内容<br>dtx  删除字符直到遇见光标之后的第一个 x 字符</p>
<p>ytx  复制字符直到遇见光标之后的第一个x字符</p>
<h3 id="扩展命令模式：地址定界"><a href="#扩展命令模式：地址定界" class="headerlink" title="扩展命令模式：地址定界"></a>扩展命令模式：地址定界</h3><p>地址定界</p>
<p>:start_pos,end_pos<br>/# 具体第#行，例如2表示第2行<br>#,# 从左侧#表示起始行，到右侧#表示结尾行  #,+#  从左侧#表示的起始行，加上右侧#表示的行数<br>示例：2,+3  表示2到5行<br>.   当前行<br>$  最后一行<br>.,$-1 当前行到倒数第二行<br>%  全文, 相当于1,$ </p>
<p>/pattern/   匹配pattern的行<br>/pat1/,/pat2/</p>
<p>​    从第一次被pat1模式匹配到的行开始，一直到第一次被pat2匹配到的行结束 </p>
<p>​    #,/pat/<br>​    /pat/,$ </p>
<p>使用方式：后跟一个编辑命令:</p>
<p>d<br>y<br>w file: 将范围内的行另存至指定文件中<br>r  file：在指定位置插入指定文件中的所有内容</p>
<h3 id="命令模式：查找"><a href="#命令模式：查找" class="headerlink" title="命令模式：查找"></a>命令模式：查找</h3><p>/PATTERN：从当前光标所在处向文件尾部查找 </p>
<p>?PATTERN：从当前光标所在处向文件首部查找 </p>
<p>n：与命令同方向<br>N：与命令反方向 </p>
<h3 id="命令模式：撤消更改"><a href="#命令模式：撤消更改" class="headerlink" title="命令模式：撤消更改"></a>命令模式：撤消更改</h3><p>    u 撤销最近的更改<br>    #u 撤销之前多次更改<br>    U  撤消光标落在这行后所有此行的更改</p>
<p>Ctrl - r    重做最后的“撤消”更改</p>
<p>. 重复前一个操作</p>
<p>#. 重复前一个操作#次</p>
<h3 id="vim的寄存器"><a href="#vim的寄存器" class="headerlink" title="vim的寄存器"></a>vim的寄存器</h3><ul>
<li><p>有26个命名寄存器和1个无命名寄存器，常存放不同的剪贴版内容，可以不同会话间共享</p>
</li>
<li><p>寄存器名称a，b,…,z,格式：“寄存器   放在数字和命令之间</p>
<p>如：3”tyy 表示复制3行到t寄存器中</p>
<p> “tp  表示将t寄存器内容粘贴 </p>
</li>
<li><p>未指定，将使用无命名寄存器</p>
</li>
<li><p>有10个数字寄存器，用0，1，…，9表示，0存放最近复制内容，1存放最近删除内容。当新的文本变更和删除时，1转存到2，2转存到3，以此类推。数字寄存器不能在不同会话间共享</p>
</li>
</ul>
<h3 id="标记和宏-macro"><a href="#标记和宏-macro" class="headerlink" title="标记和宏(macro)"></a>标记和宏(macro)</h3><p>ma   将当前位置标记为a，26个字母均可做标记， mb 、 mc 等等</p>
<p>‘a    跳转到a标记的位置，实用的文档内标记方法，文档中跳跃编辑时很有用</p>
<p>qa    录制宏 a，a为宏的名称</p>
<p>q    停止录制宏</p>
<p>@a    执行宏 a<br>@@   重新执行上次执行的宏</p>
<h3 id="扩展命令模式：查找并替换"><a href="#扩展命令模式：查找并替换" class="headerlink" title="扩展命令模式：查找并替换"></a>扩展命令模式：查找并替换</h3><p>在扩展命令模式下完成查找替换操作</p>
<p>格式：s/要查找的内容/替换为的内容/修饰符<br>要查找的内容：可使用模式<br>替换为的内容：不能使用模式，但可以使用\1, \2, …等后向引用符号；还可</p>
<p>以使用“&amp;”引用前面查找时查找到的整个内容</p>
<p>​    修饰符：</p>
<p>​    i    忽略大小写 </p>
<p>​    g    全局替换，默认情况下，每一行只替换第一次出现<br>​    gc    全局替换，每次替换前询问 </p>
<p>查找替换中的分隔符/可替换为其它字符</p>
<p>s@/etc@/var@g </p>
<p>s#/boot#/#i </p>
<h3 id="编辑二进制文件"><a href="#编辑二进制文件" class="headerlink" title="编辑二进制文件"></a>编辑二进制文件</h3><ul>
<li>以二进制方式打开文件</li>
</ul>
<p>vim –b binaryfile</p>
<ul>
<li><p>扩展命令模式下，利用xxd命令转换为可读的十六进制</p>
<p>:%!xxd</p>
</li>
<li><p>插入模式下，编辑二进制文件</p>
</li>
<li><p>扩展命令模式下，利用xxd命令转换回二进制</p>
<p>%!xxd  -r</p>
</li>
</ul>
<h3 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h3><ul>
<li><p>允许选择的文本块</p>
<p>v 面向字符 </p>
<p>V 面向行 </p>
<p>ctrl-v 面向块 </p>
</li>
<li><p>可视化键可用于与移动键结合使用<br>w  )   }   箭头等 </p>
</li>
<li><p>突出显示的文字可被删除，复制，变更，过滤，搜索，替换等</p>
</li>
</ul>
<h3 id="使用多个“窗口”"><a href="#使用多个“窗口”" class="headerlink" title="使用多个“窗口”"></a>使用多个“窗口”</h3><ul>
<li><p>多文件分割</p>
<p>vim -o|-O FILE1 FILE2 …</p>
<p>-o: 水平分割</p>
<p>-O: 垂直分割<br>在窗口间切换：Ctrl+w, Arrow</p>
</li>
<li><p>单文件窗口分割</p>
<p>Ctrl+w,s：split, 水平分割</p>
<p> Ctrl+w,v：vertical, 垂直分割 </p>
<p>ctrl+w,q：取消相邻窗口 </p>
<p>ctrl+w,o：取消全部窗口<br>：wqall 退出 </p>
</li>
</ul>
<h3 id="定制vim的工作特性"><a href="#定制vim的工作特性" class="headerlink" title="定制vim的工作特性"></a>定制vim的工作特性</h3><p>配置文件：永久有效</p>
<p>全局：/etc/vimrc </p>
<p>个人：~/.vimrc </p>
<p>扩展命令模式：当前vim进程有效<br>(1) 行号</p>
<p>显示：set number，简写 set nu<br>取消显示：set nonumber, 简写 set nonu</p>
<p>2) 忽略字符的大小写</p>
<p>启用：set ignorecase，简写 set ic 不</p>
<p>忽略：set noic </p>
<p>3) 自动缩进</p>
<p>启用：set autoindent，简写 set ai </p>
<p>禁用：set noai </p>
<p>4) 复制保留格式</p>
<p>启用：set paste</p>
<p>禁用：set nopaste</p>
<p>(5) 显示Tab和换行符 ^I 和$显示</p>
<p>启用：set list 禁用：set nolist</p>
<p>6) 高亮搜索</p>
<p>启用：set hlsearch 禁用：set nohlsearch</p>
<p>(7) 语法高亮</p>
<p>启用：syntax on </p>
<p>禁用：syntax off</p>
<p>(8) 文件格式</p>
<p>启用windows格式：set  fileformat=dos </p>
<p>启用unix格式：set fileformat=unix<br>简写 set ff=dos|unix </p>
<p>(9) 设置文本宽度</p>
<p>set textwidth=65 (vim only) </p>
<p>set wrapmargin=15 </p>
<p>(10) 设置光标所在行的标识线</p>
<p>启用：set cursorline，简写 set cul</p>
<p>禁用：set nocursorline</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>01-什么是DNS</title>
    <url>/01-%E4%BB%80%E4%B9%88%E6%98%AFDNS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/15010776282799.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827234957.jpg" alt="img"></a></p>
<p>DNS，或者说域名系统，通常是学习如何配置网站和服务器的一个非常困难的部分。了解 DNS 的工作原理将有助于诊断网络访问的问题，也有助于理解 DNS 系统背后的工作原理。</p>
<p>这篇文章中，我们会讨论一些基本的 DNS 概念，这些概念将有助于你配置并使用 DNS。</p>
<p>在我们开始配置你自己的服务器域名解析之前，让我们先来看一些关于这些是如何实现的的基本概念。</p>
<p>我们应该先从<strong>术语</strong>定义开始。虽然有一些术语在谈论计算领域中其它内容时经常出现，但是有许多术语不常使用。</p>
<p>先从简单的开始：</p>
<h3 id="域名系统（Domain-Name-System）"><a href="#域名系统（Domain-Name-System）" class="headerlink" title="域名系统（Domain Name System）"></a>域名系统（Domain Name System）</h3><p>域名系统（通常被称为“<strong>DNS</strong>”）是一个网络系统，允许我们把对人类友好的名称解析为唯一的地址。</p>
<h3 id="域名（Domain-Name）"><a href="#域名（Domain-Name）" class="headerlink" title="域名（Domain Name）"></a>域名（Domain Name）</h3><p>域名是我们习惯于与互联网资源关联的人性化名称。例如，”google.com” 是一个域名。有些人会说 “google” 部分是域名部分，但我们通常可以将组合形式称为域名。</p>
<p>网址 “google.com” 与 Google Inc. 拥有的服务器相关联。当我们在浏览器中键入 “google.com” 时，域名系统允许我们访问其相关联的 Google 服务器。</p>
<h3 id="IP-地址（IP-Address）"><a href="#IP-地址（IP-Address）" class="headerlink" title="IP 地址（IP Address）"></a>IP 地址（IP Address）</h3><p><strong>IP</strong> 地址是我们所说的网络可寻址位置。每个 IP 地址在其网络中必须是唯一的。我们这里谈论的网络就是指整个互联网。</p>
<p>IPv4，目前最常见的地址形式，由四组数字组成，每组最多有三位数字，每一组用一个点分隔。例如，111.222.111.222 是有效的 IPv4 IP 地址。使用 DNS，我们可以将名称映射到该地址，这样，你就不必记住一组复杂的数字，来访问你需要的网站。</p>
<h3 id="顶级域名（Top-Level-Domain）"><a href="#顶级域名（Top-Level-Domain）" class="headerlink" title="顶级域名（Top Level Domain）"></a>顶级域名（Top Level Domain）</h3><p>顶级域名，或者说 <strong>TLD</strong>，是域名的最基本部分。顶级域名是右侧的最远部分（由点分隔）。常见的顶级域名是 com、net、org、gov、edu 和 io。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">域名</th>
<th align="left">代表含义</th>
<th align="left">域名</th>
<th align="left">代表含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">.com</td>
<td align="left">表示商业机构</td>
<td align="left">.cn</td>
<td align="left">中国</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">.net</td>
<td align="left">表示网络服务机构</td>
<td align="left">.hk</td>
<td align="left">中国香港</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">.org</td>
<td align="left">表示非营利性组织</td>
<td align="left">.tw</td>
<td align="left">中国台湾</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">.gov</td>
<td align="left">表示政府机构</td>
<td align="left">.us</td>
<td align="left">美国</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">.edu</td>
<td align="left">表示教育机构</td>
<td align="left">.jp</td>
<td align="left">日本</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">.mil</td>
<td align="left">表示军事机构</td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<p>顶级域名在域名术语层次结构的最上层。由 ICANN（互联网名称和号码分配公司）对顶级域名进行管理控制。然后，通过域名注册商来分发 TLD 下面的域名。</p>
<h3 id="主机（Host）"><a href="#主机（Host）" class="headerlink" title="主机（Host）"></a>主机（Host）</h3><p>域名所有者可以定义多个单独的主机，指向可以通过该域名访问的不同的计算机或者服务。例如，大多数域名所有者会让他们的 web 服务器可以通过裸域（example.com）以及 www 主机（<a href="http://www.example.com）访问。" target="_blank" rel="noopener">www.example.com）访问。</a></p>
<p>你可以在一个域名下面定义其它主机。比如说，通过 api 主机(api.example.com) 允许 API 访问，通过 ftp 主机或者 files 主机(ftp.example.com 或者 files.example.com）允许 ftp 访问。主机名可以任意指定，只要它们在该域名下是唯一的。</p>
<h3 id="子域名（Sub-Domain-Name）"><a href="#子域名（Sub-Domain-Name）" class="headerlink" title="子域名（Sub Domain Name）"></a>子域名（Sub Domain Name）</h3><p>一个和主机相关的主题就是子域名。</p>
<p>DNS 有层次结构，TLD 下面可以有多个域名。例如，com 下面有 google.com 和 ubuntu.com。”子域名” 是指作为较高层级域名的一部分。所以说，ubuntu.com 可以说是 com 的子域名，但是通常这被称为域名，或者 “ubuntu” 部分是 <strong>SLD</strong>(Second Level Domain)，所以这是一个二级域名。</p>
<p>同样，每个域名可以控制它下面的子域名。这通常就是我们所指的子域名。例如，你可以把 “<a href="http://www.history.school.edu”" target="_blank" rel="noopener">www.history.school.edu”</a> 作为你学校的历史部门的域名。 “history” 部分是一个子域名。</p>
<p>主机名和子域名之间的区别是主机定义计算机或资源，而子域名扩展父域。它是一种把域名本身细分的方法。</p>
<p>无论谈论子域名还是主机，你都可以开始看到域名的最左边部分是最具体的。这也是 DNS 的工作原理：从左到右阅读时，从最具体到最不具体。</p>
<h3 id="完全限定域名（Fully-Qualified-Domain-Name）"><a href="#完全限定域名（Fully-Qualified-Domain-Name）" class="headerlink" title="完全限定域名（Fully Qualified Domain Name）"></a>完全限定域名（Fully Qualified Domain Name）</h3><p>完全限定的域名，通常称为 <strong>FQDN</strong>，也就是我们所说的绝对域名。DNS 系统中的域名可以是相对的，所以可能是模糊的。FQDN 是一个绝对名称，表示了它相对于域名系统中绝对根目录的位置。</p>
<p>这表明它表示的每个域名都包括 TLD 部分。正确的 FQDN 以点结束，表示 DNS 层次结构的根。“mail.google.com.” 就是一个标准的 FQDN 的例子。有时候，一些软件使用的 FQDN 不需要末尾的点，但是要符合 ICANN 标准的话一定要加上末尾的点。</p>
<h3 id="名称服务器（Name-Server）"><a href="#名称服务器（Name-Server）" class="headerlink" title="名称服务器（Name Server）"></a>名称服务器（Name Server）</h3><p>名称服务器(<strong>NS</strong>)是一种将域名翻译成 IP 地址的计算机。这些服务器完成了 DNS 系统中的大部分工作。由于域名翻译的数量对于任何一台服务器来说都太多了，因此每台服务器可以将请求转发给其他名称服务器或把它们负责的子域名的子集委派给其他名称服务器。</p>
<p>名称服务器可以是 “权威的”，表示它们自己可以提供所负责的域名的查询结果。否则，它们可能会转发到其他服务器，或者提供其他名称服务器数据的缓存副本。</p>
<h3 id="区域文件（Zone-Files）"><a href="#区域文件（Zone-Files）" class="headerlink" title="区域文件（Zone Files）"></a>区域文件（Zone Files）</h3><p>区域文件是一个简单的文本文件，包含域名和 IP 地址之间的映射。这是当用户请求某个域名时，DNS 系统最终找出 IP 关联记录的地方。</p>
<p>区域文件放置在名称服务器中，通常定义了特定域名下可用的资源，或者可以去获取该信息的位置。</p>
<h3 id="记录（Record）"><a href="#记录（Record）" class="headerlink" title="记录（Record）"></a>记录（Record）</h3><p>在区域文件中，保存着记录。其中最简单的记录形式是，是资源和名称之间的单独映射。它们可以将域名映射到 IP 地址，定义域名的名称服务器，定义域名的邮件服务器等。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>01-全局变量和局部变量</title>
    <url>/01-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>全局变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的 shell可见。</p>
</blockquote>
<hr>
<h2 id="全局变量（global-variables）"><a href="#全局变量（global-variables）" class="headerlink" title="全局变量（global variables）"></a>全局变量（global variables）</h2><p>用<strong><code>printenv</code></strong>就可以打印全局变量，里面会包括系统生成的全局环境变量和用户自定义的环境变量。</p>
<p>下面列出部分CentOS的全局环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">XDG_SESSION_ID&#x3D;226<br>HOSTNAME&#x3D;centos7.ashjian.com #主机名<br>TERM&#x3D;xterm-256color  #颜色方案<br>SHELL&#x3D;&#x2F;bin&#x2F;bash    #当前使用的shell<br>HISTSIZE&#x3D;1000      #历史命令最大条目<br>SSH_CLIENT&#x3D;172.17.251.64 50610 22 # ssh client信息，也就是我登录的地址信息<br>SSH_TTY&#x3D;&#x2F;dev&#x2F;pts&#x2F;2 # 我的终端号<br>USER&#x3D;root # 当前用户名<br>LS_COLORS&#x3D;xxxxxxxxxxxxxxxx #ls时文件的配色，太长了省略<br>MAIL&#x3D;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;root # 当前用户的系统邮件存放的位置<br>PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin # 命令的查找路径<br>PWD&#x3D;&#x2F;app&#x2F;scripts # 当前目录<br>LANG&#x3D;en_US.UTF-8 # 当前使用的语言<br>HISTCONTROL&#x3D;ignoredups # 历史命令控制选项，当前只有一个：去除连续重复的命令<br>SHLVL&#x3D;1 #shell 层级，当前只有一层shell<br>HOME&#x3D;&#x2F;root # 当前用户家目录<br>LOGNAME&#x3D;root # 登录用户名<br>SSH_CONNECTION&#x3D;172.17.251.64 50610 172.17.37.200 22 # ssh连接信息，两端的信息都有<br>OLDPWD&#x3D;&#x2F;app # 前一个工作目录<br></code></pre></td></tr></table></figure>

<p>可以只打印某一个全局环境变量，有两种方法，记得要用echo调用变量的话，要在变量名前面加一个<code>$</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# printenv HOME<br>&#x2F;root<br><br>[root@centos7 ~]# echo $HOME<br>&#x2F;root<br></code></pre></td></tr></table></figure>

<p>全局变量可用于子shell中(也可以用于当前shell下运行的脚本中，其实运行脚本就是在子shell中运行的）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# bash<br>[root@centos7 ~]# bash<br>[root@centos7 ~]# ps -f --forest<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root     25202 25198  0 14:22 pts&#x2F;2    00:00:00 -bash<br>root     26148 25202  0 15:44 pts&#x2F;2    00:00:00  \_ bash<br>root     26180 26148  0 15:45 pts&#x2F;2    00:00:00      \_ bash<br>root     26207 26180  0 15:45 pts&#x2F;2    00:00:00          \_ ps -f --forest<br>[root@centos7 ~]# echo $HOME<br>&#x2F;root<br>[root@centos7 ~]# exit<br>exit<br>[root@centos7 ~]# exit<br>exit<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="局部变量（local-variables）"><a href="#局部变量（local-variables）" class="headerlink" title="局部变量（local variables）"></a>局部变量（local variables）</h2><p>没有专门的命令查看局部变量，只有一个<strong><code>set</code></strong>命令，会显示当前bash进程设置的所有变量，包括全局和局部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# set<br>ABRT_DEBUG_LOG&#x3D;&#x2F;dev&#x2F;null<br>BASH&#x3D;&#x2F;bin&#x2F;bash<br>BASHOPTS&#x3D;checkwinsize:cmdhist:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath<br>BASH_ALIASES&#x3D;()<br>BASH_ARGC&#x3D;()<br>BASH_ARGV&#x3D;()<br>BASH_CMDS&#x3D;()<br>BASH_COMPLETION_COMPAT_DIR&#x3D;&#x2F;etc&#x2F;bash_completion.d<br>...<br>HISTSIZE&#x3D;1000<br>HOME&#x3D;&#x2F;root<br>HOSTNAME&#x3D;centos7.ashjian.com<br>HOSTTYPE&#x3D;x86_64<br>ID&#x3D;0<br>IFS&#x3D;$&#39; \t\n&#39;<br>...<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="创建局部变量和全局变量"><a href="#创建局部变量和全局变量" class="headerlink" title="创建局部变量和全局变量"></a>创建局部变量和全局变量</h2><p>创建局部变量的方法很简单，就是<code>变量名=值</code>，例如<code>var=10</code>。</p>
<p>把局部变量<code>export</code>之后就是全局变量了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# var&#x3D;10<br>[root@centos7 ~]# echo $var<br>10<br>[root@centos7 ~]# bash<br>[root@centos7 ~]# echo $var<br><br>[root@centos7 ~]# exit<br>exit<br>[root@centos7 ~]# echo $var<br>10<br>[root@centos7 ~]# export var<br>[root@centos7 ~]# echo $var<br>10<br>[root@centos7 ~]# bash<br>[root@centos7 ~]# echo $var<br>10<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="调用变量"><a href="#调用变量" class="headerlink" title="调用变量"></a>调用变量</h2><p><code>$变量名</code>即可调用变量，既返回(return)变量的值。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# var&#x3D;10<br>[root@centos7 ~]# echo $var<br>10<br><br>[root@centos7 ~]# echo $USER<br>root<br><br>[root@centos7 ~]# echo &quot;My hostname is $HOSTNAME&quot;<br>My hostname is centos7.yulongjun.com<br><br>[root@centos7 ~]# echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin<br>[root@centos7 ~]# export PATH&#x3D;$PATH:&#x2F;root&#x2F;bin<br>[root@centos7 ~]# echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;root&#x2F;bin<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：<code>PATH=$PATH:/root/bin</code>看起来可能有点绕，其实就是<code>$PATH</code>取出原有的<code>PATH</code>的值，然后和后面的<code>:/root/bin</code>字符串连接起来，然后把连接后的字符串赋值给<code>PATH</code>。</p>
</blockquote>
<hr>
<h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">unset 变量名<br></code></pre></td></tr></table></figure>

<p>unset之后，调用变量就是空的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# unset var<br>[root@centos7 ~]# echo $var<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL编程</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>01-命令基本格式</title>
    <url>/01-%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="命令的基本格式"><a href="#命令的基本格式" class="headerlink" title="命令的基本格式"></a>命令的基本格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">COMMAND [OPTIONS...] [ARGUMENTS...]<br></code></pre></td></tr></table></figure>

<ul>
<li>命令（COMMAND)</li>
<li>选项（OPTIONS）：<ul>
<li>短格式， 如<code>-a</code>、<code>-h</code>、<code>-l</code>、<code>-r</code>、<code>-f</code>等</li>
<li>长格式， 如<code>--forest</code>,<code>--exclude=PATTERN</code>等</li>
</ul>
</li>
<li>参数（ARGUMENTS)：通常为文件</li>
</ul>
<h2 id="可以执行多个命令，用逗号分隔开"><a href="#可以执行多个命令，用逗号分隔开" class="headerlink" title="可以执行多个命令，用逗号分隔开"></a>可以执行多个命令，用逗号分隔开</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls;pwd;hostname;who<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这个不是特别好，如果中间有报错的命令，下面的命令也会继续执行。后面会学一个命令<code>&amp;</code>，可以在前面命令执行成功后再执行后面命令<code>ls&amp;pwd&amp;hostn&amp;who</code>，执行到<code>hostn</code>就会报错，后面的命令不予执行。当然也有好的</p>
</blockquote>
<h2 id="回车后可以再接着写"><a href="#回车后可以再接着写" class="headerlink" title="\回车后可以再接着写"></a><code>\回车</code>后可以再接着写</h2><p>这种方式常用在长格式的命令下面用，段落更清晰。</p>
<p>下面举个例子。tar命令暂时没讲，知道<code>\</code>的作用就行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# tar -czvf \<br>&gt; 20200516.tar.gz \<br>&gt; * \<br>&gt; --exclude&#x3D;&quot;test&quot;<br><br>anaconda-ks.cfg<br>initial-setup-ks.cfg<br></code></pre></td></tr></table></figure>

<h3 id="执行中的命令退出"><a href="#执行中的命令退出" class="headerlink" title="执行中的命令退出"></a>执行中的命令退出</h3><ul>
<li><code>ctrl + d</code>：正常退出</li>
<li><code>ctrl +c</code>：强制退出`</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>01-存储基础知识</title>
    <url>/01-%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="存储基础知识"><a href="#存储基础知识" class="headerlink" title="存储基础知识"></a>存储基础知识</h2><p>直接存储(Direct Attached Storage)。存储设备与主机的紧密相连</p>
<p>•    管理成本较低，实施简单<br>•    储时直接依附在服务器上，因此存储共享受到限制<br>•    CPU必须同时完成磁盘存取和应用运行的双重任务，所以不利于CPU的指令周期的优化，增加系统负担</p>
<p>网络连接存储(Network Attached Storage)：<br>通过局域网在多个文件服务器之间实现了互联，基于文件的协议（ FTP、NFS、 SMB/CIFS等 ），实现文件共享 </p>
<p>•    集中管理数据，从而释放带宽、提高性能<br>•    可提供跨平台文件共享功能<br>•    可靠性较差，适用于局域网或较小的网络</p>
<p>存储区域网络(Storage Area Networks，SAN)<br>利用高速的光纤网络链接服务器与存储设备，基于SCSI，IP，ATM等多种高级协议，实现存储共享 </p>
<p>•    服务器跟储存装置两者各司其职<br>•    利用光纤信道来传输数据﹐以达到一个服务器与储存装置之间多对多的高效能、高稳定度的存储环境<br>•    实施复杂，管理成本高</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>01-数据库和SQL简介</title>
    <url>/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在比较流行的数据库分为以下几种：</p>
<blockquote>
<p><code>Relational DBMS</code>：如Oracle，MySQL/MariaDB，SQL Server，DB2。<br><code>Document Store</code>：如MongoDB，Amazon DynamoDB。<br><code>Key-Value Store</code>：如Redis。<br><code>Search Engine</code>：如Elasticsearch。</p>
</blockquote>
<h2 id="行（记录）、列（字段）"><a href="#行（记录）、列（字段）" class="headerlink" title="行（记录）、列（字段）"></a>行（记录）、列（字段）</h2><p><a href="http://www.yulongjun.com/images/15011602257661.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203145255.jpg" alt="img"></a></p>
<p>表的列（column）（垂直方向）称为字段(field)，它代表了保存在表中的数据项目。<br>表的行（row）（水平方向）称为记录(record)，它相当于一条数据。<br>关系数据库必须以行为单位进行数据读写。</p>
<h2 id="SQL语句种类："><a href="#SQL语句种类：" class="headerlink" title="SQL语句种类："></a>SQL语句种类：</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p><code>DDL（Data Definition Language，数据定义语言）</code> 用来创建或者删除存储数据用的数据库以及数据库中的表等对象。DDL 包含以下几种指令。</p>
<blockquote>
<p><code>CREATE</code> ：创建数据库和表等对象<br><code>DROP</code> ： 删除数据库和表等对象<br><code>ALTER</code> ： 修改数据库和表等对象的结构</p>
</blockquote>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><code>DML（Data Manipulation Language，数据操纵语言）</code> 用来查询或者变更</p>
<p>表中的记录。DML 包含以下几种指令。</p>
<blockquote>
<p><code>SELECT</code> ：查询表中的数据（Oracle算在DML里面，MySQL算在DQL（Data Query Language）里面）<br><code>INSERT</code> ：向表中插入新数据<br><code>UPDATE</code> ：更新表中的数据<br><code>DELETE</code> ：删除表中的数据</p>
</blockquote>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p><code>DCL（Data Control Language，数据控制语言）</code> 用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限 操作数据库中的对象（数据库表等）进行设定。DCL 包含以下几种指令。</p>
<blockquote>
<p><code>COMMIT</code> ： 确认对数据库中的数据进行的变更<br><code>ROLLBACK</code> ：取消对数据库中的数据进行的变更<br><code>GRANT</code> ： 赋予用户操作权限</p>
<p><code>REVOKE</code> ： 取消用户的操作权限</p>
</blockquote>
<p><strong>DDL</strong>和<strong>DCL</strong>是自带commit的，一旦使用，无法rollback。</p>
<p><strong>实际使用的 SQL 语句当中有 90% 属于 DML。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>01-文件和目录权限</title>
    <url>/01-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="权限位"><a href="#权限位" class="headerlink" title="权限位"></a>权限位</h3><p><img src="01-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90.assets/image-20200819195324060.png" alt="image-20200819195324060"></p>
<p><code>rwxrwrwx</code>：<br>左三位：定义user（owner）的权限，属主权限<br>中三位：定义group的权限，属组权限<br>有三位：定义other的权限，其他的权限</p>
<p>进程对文件的访问权限应用模型：<br>进程的属主与文件的属主是否相同。如果相同，则应用属主权限；否则去检查是否属于文件的属组；如果是，则应用属组权限，否则，就只能引用other权限。</p>
<p>权限：<br><code>r</code>：readable，可读<br><code>w</code>：writable，可写<br><code>x</code>：executble，可执行</p>
<ul>
<li>文件<ul>
<li><code>r</code>：可获取文件的数据</li>
<li><code>w</code>：可修改文件的数据</li>
<li><code>x</code>：可将此文件运行为进程</li>
</ul>
</li>
<li>目录<ul>
<li><code>r</code>：可使用ls命令获取旗下的所有文件列表</li>
<li><code>w</code>：可修改次目录下的文件列表，即创建或删除文件</li>
<li><code>x</code>：可cd值此目录中，且可使用<code>ll</code>来获取到所有文件详细属性信息</li>
</ul>
</li>
</ul>
<p>权限组合机制：</p>
<ul>
<li><code>---</code>：二进制<code>000</code>，十进制<code>0</code></li>
<li><code>--x</code>：二进制<code>001</code>，十进制<code>1</code></li>
<li><code>-w-</code>：二进制<code>010</code>，十进制<code>2</code></li>
<li><code>-wx</code>：二进制<code>011</code>，十进制<code>3</code></li>
<li><code>r--</code>：二进制<code>100</code>，十进制<code>4</code></li>
<li><code>r-x</code>：二进制<code>101</code>，十进制<code>5</code></li>
<li><code>rw-</code>：二进制<code>110</code>，十进制<code>6</code></li>
<li><code>rwx</code>：二进制<code>111</code>，十进制<code>7</code></li>
</ul>
<hr>
<h3 id="文件权限管理命令"><a href="#文件权限管理命令" class="headerlink" title="文件权限管理命令"></a>文件权限管理命令</h3><p>chmod的三种用法：</p>
<blockquote>
<p>chmod [OPTION]… MODE[,MODE]… FILE…<br>chmod [OPTION]… OCTAL-MODE FILE…<br>chmod [OPTION]… –reference=RFILE FILE…</p>
</blockquote>
<p>三类用户：</p>
<ul>
<li><code>u</code>：属主</li>
<li><code>g</code>：属组</li>
<li><code>o</code>；其他</li>
<li><code>a</code>：所有</li>
</ul>
<p><strong>(1)MODE表示法：<code>chmod [OPTION]... MODE[,MODE]... FILE...</code></strong></p>
<ul>
<li>赋值表示法：直接操作一类用户的所有权限位：<ul>
<li><code>u=</code></li>
<li><code>g=</code></li>
<li><code>o=</code></li>
<li><code>a=</code></li>
</ul>
</li>
<li>授权表示法：直接操作一类用户的一个或多个权限位：<ul>
<li><code>u+</code>、<code>u-</code></li>
<li><code>g+</code>、<code>g-</code></li>
<li><code>o+</code>、<code>o-</code></li>
<li><code>a+</code>、<code>a-</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">touch test<br>chmod g&#x3D;rw test<br>ll<br>chmod ug&#x3D;r test<br>ll<br>chmod u&#x3D;rwx,g&#x3D;rw,o&#x3D; test<br>ll<br>chmod u-x test<br>ll<br>chmod o+r test<br>ll<br>chmod ug+x test<br>ll<br>chmod g-wx test<br>ll<br>chmod u-r test<br>ll<br>chmod +x test # +x对所有都有效<br>ll<br>chmod +w test # +w只对属主有效<br>ll<br>chmod u+x,g+w test<br>ll<br></code></pre></td></tr></table></figure>

<p><strong>(2)八进制表示法：chmod [OPTION]… OCTAL-MODE FILE…</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">chmod 660 test<br>ll<br>chmod 777 test<br>ll<br></code></pre></td></tr></table></figure>

<p><strong>(3)参考某个文件的权限：chmod [OPTION]… –reference=RFILE FILE…</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">chmod --reference&#x3D;&#x2F;etc&#x2F;fstab test<br></code></pre></td></tr></table></figure>

<p><strong>(4)chmod选项</strong></p>
<ul>
<li><code>-R</code> ：recursive ，递归修改</li>
</ul>
<hr>
<h3 id="从属关系管理命令"><a href="#从属关系管理命令" class="headerlink" title="从属关系管理命令"></a>从属关系管理命令</h3><p>主要有两个命令<code>chown</code>，<code>chgrp</code></p>
<h4 id="chown更改文件的的属主-属组也能更改"><a href="#chown更改文件的的属主-属组也能更改" class="headerlink" title="chown更改文件的的属主(属组也能更改)"></a><code>chown</code>更改文件的的属主(属组也能更改)</h4><ul>
<li><code>-R</code>：递归修改</li>
</ul>
<p>用法：<br><code>chown -R USERNAME[:FILENAME] FILENAME</code></p>
<p>例如：<br><code>chown -R oracle:oinstall /u01</code></p>
<h4 id="chgrp更改文件的属组"><a href="#chgrp更改文件的属组" class="headerlink" title="chgrp更改文件的属组"></a><code>chgrp</code>更改文件的属组</h4><ul>
<li><code>-R</code>：递归修改</li>
</ul>
<p>用法：<br><code>chgrp -R GROUPNAME FILENAME</code><br>用到很少，chown可以修改属组，这个命令就被打入冷宫了，很少用。</p>
<hr>
<h3 id="新建文件和目录的默认权限（umask）"><a href="#新建文件和目录的默认权限（umask）" class="headerlink" title="新建文件和目录的默认权限（umask）"></a>新建文件和目录的默认权限（umask）</h3><p>新建的文件和文件夹都有一个默认权限，那么是如何实现的呢？就是用umask实现的。</p>
<p>umask原理：</p>
<ul>
<li>针对新建文件：<code>666-umas</code>k后的权限就是新建文件的权限</li>
<li>针对新建目录：<code>777-umask</code>后的权限就是新建目录的权限。</li>
</ul>
<p>我们可以看<code>/etc/bashrc</code>里面的umask规则：</p>
<p>![]/images/1496043520606.png)</p>
<p>看代码，即<strong>UID</strong> 大于<code>199</code>，umask为<code>002</code>，否则umask为<code>022</code></p>
<p>普通用户UID在CentOS 6下大于500，CentOS7下大于1000，所以umask值为<code>002</code>，默认创建的<strong>文件</strong>和<strong>文件夹</strong>权限分别为<code>666-002=664</code>、<code>777-002=775</code>。</p>
<p>而root用户，UID为0，umask值为022，默认创建的<strong>文件</strong>和<strong>文件夹</strong>权限分别为<code>666-022=644</code>、<code>777-022=755</code>。</p>
<hr>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>1、当用户<code>docker</code>对<code>/testdir</code> 目录无执行权限时，意味着无法做哪些操作？</p>
<blockquote>
<p>无法cd到这个目录，无法ll查看目录下的文件元数据（能看到文件名）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[ash@ashjian ~]<span class="hljs-variable">$ll</span> -d dir1/<br>dr--r--r--. 2 ash ash 4096 Aug 19 20:24 dir1/<br>[ash@ashjian ~]<span class="hljs-variable">$cd</span> dir1/<br>-bash: <span class="hljs-built_in">cd</span>: dir1/: Permission denied<br>[ash@ashjian ~]<span class="hljs-variable">$ll</span> dir1/<br>ls: cannot access dir1/f1: Permission denied<br>ls: cannot access dir1/f2: Permission denied<br>total 0<br>-????????? ? ? ? ?            ? f1<br>-????????? ? ? ? ?            ? f2<br><span class="hljs-comment">#好奇，能找到名字应该能找到节点号码，通过节点号码能在inode table中找到节点信息才对?</span><br></code></pre></td></tr></table></figure>

<p>2、当用户<code>xiaoqiang</code>对<code>/testdir</code> 目录无读权限时，意味着无 法做哪些操作？</p>
<blockquote>
<p>无法ls查看这个目录列表。</p>
</blockquote>
<p>3、当用户<code>wangcai</code> 对<code>/testdir</code> 目录无写权限时，该目录下的只读文件<code>file1</code>是否可修改和删除？</p>
<blockquote>
<p>不可以修改和删除。</p>
</blockquote>
<p>4、当用户<code>wangcai</code> 对<code>/testdir</code> 目录有写和执行权限时，该目 录下的只读文件file1是否可修改和删除？</p>
<blockquote>
<p>可以修改和删除，但是没有读权限的话，只能盲找。</p>
</blockquote>
<p>5、复制<code>/etc/fstab</code>文件到/<code>var/tmp</code>下，设置文件所有者为 <code>wangcai</code>读写权限，所属组为<code>sysadmins</code>组有读写权限，其他人无权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;etc&#x2F;fstab &#x2F;var&#x2F;tmp&#x2F;<br>chown wangcai:sysadmins &#x2F;var&#x2F;tmp&#x2F;fstab<br>chmod 660 &#x2F;var&#x2F;tmp&#x2F;fstab<br></code></pre></td></tr></table></figure>

<p>6、误删除了用户<code>wangcai</code>的家目录，请重建并恢复该用户家目录及相应的权限属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rm -rf &#x2F;home&#x2F;wangcai<br>cp -r &#x2F;etc&#x2F;skel&#x2F; &#x2F;home&#x2F;wangcai<br>chmod 700 &#x2F;home&#x2F;wangcia<br>chown -R wangcai:wangcai &#x2F;home&#x2F;wangcai<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>[object Object]</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>01-文件查找</title>
    <url>/01-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>cate, find</p>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><ul>
<li>查询系统上预建的文件索引数据库</li>
</ul>
<p>/var/lib/mlocate/mlocate.db</p>
<p>依赖于事先构建的索引<br>索引的构建是在系统较为空闲时自动进行(周期性任务)，管理员手动更新数据库(updatedb)</p>
<p>索引构建过程需要遍历整个根文件系统，极消耗资源<br>工作特点:<br>•    查找速度快<br>•    模糊查找<br>•    非实时查找<br>•    搜索的是文件的全路径，不仅仅是文件名<br>•    可能只搜索用户具备读取和执行权限的目录</p>
<p>locate KEYWORD<br>有用的选项<br>-i 不区分大小写的搜索<br>-n  N 只列举前N个匹配项目<br>-r  使用基本正则表达式<br>示例<br>搜索名称或路径中带有“conf”的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">locate  conf<br></code></pre></td></tr></table></figure>

<p>使用Regex来搜索以“.conf”结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">locate  -r  &#39;\.conf$&#39;<br></code></pre></td></tr></table></figure>



<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>实时查找工具，通过遍历指定路径完成文件查找<br>工作特点：<br>•    查找速度略慢<br>•    精确查找<br>•    实时查找<br>•    可能只搜索用户具备读取和执行权限的目录</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p>find [OPTION]… [查找路径] [查找条件] [处理动作]</p>
<ul>
<li>查找路径：指定具体目标路径；默认为当前目录 </li>
<li>查找条件：指定的查找标准，可以文件名、大小、类型、权限等标准进行；默认为找出指定路径下的所有文件 </li>
<li>处理动作：对符合条件的文件做操作，默认输出至屏幕</li>
</ul>
<ul>
<li><p>指搜索层级<br>-maxdepth  level 最大搜索目录深度,指定目录下的文件为第1级</p>
<p>-mindepth level 最小搜索目录深度</p>
</li>
<li><p>先处理目录内的文件，再处理指定目录</p>
<p>-depth</p>
</li>
<li><p>根据文件名和inode查找：</p>
<p>-name “文件名称”：支持使用glob</p>
<p>-iname “文件名称”：不区分字母大小写</p>
<p>-inum n  按inode号查找</p>
<p>-samefile name  相同inode号的文件</p>
<p>-links n   链接数为n的文件</p>
<p>-regex “PATTERN”：以PATTERN匹配整个文件路径，而非文件名称</p>
</li>
<li><p>根据属主、属组查找：<br>-user USERNAME：查找属主为指定用户名的文件</p>
<p>-group GRPNAME: 查找属组为指定组名的文件</p>
<p>-uid UserID：查找属主为指定的UID号的文件</p>
<p>-gid GroupID：查找属组为指定的GID号的文件</p>
<p>-nouser：查找没有属主的文件</p>
<p>-nogroup：查找没有属组的文件</p>
<ul>
<li><p>根据文件类型查找<br>-type TYPE<br>•    f: 普通文件<br>•    d: 目录文件<br>•    l: 符号链接文件<br>•    s：套接字文件<br>•    b: 块设备文件<br>•    c: 字符设备文件<br>•    p: 管道文件<br>-empty  空文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;app -type d  -empty<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组合条件：</p>
<pre><code>与：-a 
或：-o 
非：-not   !</code></pre></li>
<li><p>德·摩根定律：</p>
<pre><code>(非 A) 或 (非 B) = 非(A 且 B) </code></pre><p>​    (非 A) 且 (非 B) = 非(A 或 B)<br>​      !    A -a !B = !(A -o B)<br>​      !    A -o !B = !(A -a B)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">  find -name snow.png<br>  find -iname snow.png<br>  find / -name  “*.txt”<br>  find /var –name “*<span class="hljs-built_in">log</span>*”<br>  find  -user joe  -group joe<br>  find -user joe -not -group joe<br>  find -user joe -o -user jane<br>  find -not  \(  -user joe -o -user jane  \)<br>  find / -user joe -o -uid 500<br>  <br><span class="hljs-comment">#找出/tmp目录下，属主不是root，且文件名不以f开头的文件</span><br>find /tmp \( -not -user root -a -not -name <span class="hljs-string">'f*'</span> \) -ls <br>find /tmp -not \( -user root -o -name <span class="hljs-string">'f*'</span> \)  –ls<br><br><span class="hljs-comment">#查找/etc/下，除/etc/sane.d目录的其它所有.conf后缀的文件 </span><br>find /etc -path ‘/etc/sane.d’ -a –prune -o -name “*.conf”  <br><br><span class="hljs-comment">#查找/etc/下，除/etc/sane.d和/etc/fonts两个目录的所有.conf后缀的文件 </span><br>find /etc \( -path <span class="hljs-string">"/etc/sane.d"</span> -o -path <span class="hljs-string">"/etc/fonts"</span> \) -a -prune -o - name <span class="hljs-string">"*.conf"</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>根据文件大小来查找：</p>
<p>-size [+|-]#UNIT<br>常用单位：k, M, G，c（byte） #UNIT: (#-1, #]<br>  如：6k 表示(5k,6k]<br>  -#UNIT：[0,#-1]<br>如：-6k 表示[0,5k]<br>  +#UNIT：(#,∞)<br> 如：+6k 表示(6k,∞)</p>
</li>
<li><p>根据时间戳：</p>
<p>以“天”为单位</p>
<p>-atime [+|-]#,</p>
<p>​    #: [#,#+1)<br>​    +#: [#+1,∞] </p>
<p>​    -#: [0,#) </p>
<p>  -mtime<br>  -ctime<br>  以“分钟”为单位</p>
<pre><code>-amin
-mmin
-cmin</code></pre></li>
</ul>
</li>
<li><p>根据权限查找：</p>
<p>-perm [/|-]MODE</p>
<p>MODE: 精确权限匹配<br>/MODE：任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，+ 从centos7开始淘汰 </p>
<p>-MODE：每一类对象都必须同时拥有指定权限，与关系</p>
<p>  0 表示不关注</p>
<p>  •    find -perm 755 会匹配权限模式恰好是755的文件<br>•    只要当任意人有写权限时，find -perm +222就会匹配<br>  •    只有当每个人都有写权限时，find -perm -222才会匹配<br>•    只有当其它人（other）有写权限时，find -perm -002才会匹配</p>
<h3 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h3><p>  -print：默认的处理动作，显示至屏幕<br>  -ls：类似于对查找到的文件执行“ls -l”命令<br>  -delete：删除查找到的文件<br>  -fls file：查找到的所有文件的长格式信息保存至指定文件中<br>  -ok COMMAND {} ; 对查找到的每个文件执行由COMMAND指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认<br>-exec COMMAND {} ; 对查找到的每个文件执行由COMMAND指定的命令<br>  {}: 用于引用查找到的文件名称自身<br>find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的命令</p>
<h3 id="参数替换xargs"><a href="#参数替换xargs" class="headerlink" title="参数替换xargs"></a>参数替换xargs</h3><p>  由于很多命令不支持管道|来传递参数，xargs用于产生某个命令的参数，xargs可以读入 stdin 的数据，并且以空格符或回车符将 stdin 的数据分隔成为参数<br>  许多命令不能接受过多参数，命令执行可能会失败，xargs可以解决<br>注意：文件名或者是其他意义的名词内含有空格符的情况<br>  find和xargs的组合：find | xargs COMMAND<br>  示例：</p>
<p>  ls  | xargs   rm     </p>
<p>删除当前目录下的大量文件 </p>
<p>find /sbin/ -perm +700 | ls -l       这个命令是错误的<br>  find /bin/ -perm /7000 | xargs ls -Sl  </p>
<p>查找有特殊权限的文件 </p>
<p>find /bin/ -perm -7000 | xargs ls -Sl  此命令和上面有何区别？  </p>
<p>find -type f -name “*.txt” -print0 | xargs -0 rm 以字符nul分隔 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  备份配置文件，添加.orig这个扩展名<br>  find  -name  “*.conf”  -exec  cp &#123;&#125;  &#123;&#125;.orig  \;<br>  提示删除存在时间超过３天以上的joe的临时文件<br>  find &#x2F;tmp -ctime +3 -user joe -ok rm &#123;&#125; \;<br>  在主目录中寻找可被其它用户写入的文件<br>  find ~ -perm -002  -exec chmod o-w &#123;&#125; \;<br>  查找&#x2F;data下的权限为644，后缀为sh的普通文件，增加执行权限<br>  find &#x2F;data –type  f -perm 644  -name “*.sh” –exec chmod 755 &#123;&#125; \;<br>查看&#x2F;home的目录<br>  find  &#x2F;home –type d -ls<br></code></pre></td></tr></table></figure>



</li>
</ul>
<p>  以下转载：<a href="https://blog.csdn.net/l_liangkk/article/details/81297826" target="_blank" rel="noopener">https://blog.csdn.net/l_liangkk/article/details/81297826</a> </p>
<h3 id="Linux中find命令-path-prune用法详解"><a href="#Linux中find命令-path-prune用法详解" class="headerlink" title="Linux中find命令-path -prune用法详解"></a>Linux中find命令-path -prune用法详解</h3><p>  在Windows中可以在某些路径中查找文件，也可以设定不在某些路径中查找文件，下面用Linux中的find的命令结合其-path -prune参数来看看在Linux中怎么实现此功能。</p>
<p>  假如在当前目录下查找文件，且当前目录下有很多文件及目录（多层目录），包括dir0、dir1和dir2 …等目录及dir00、dir01…dir10、dir11…等子目录。</p>
<p>  \1. 在当前目录下查找所有txt后缀文件</p>
<pre><code>find ./ -name &apos;*.txt&apos;</code></pre><p>  2.在当前目录下的dir0目录及子目录下查找txt后缀文件</p>
<pre><code>find ./ -path &apos;./dir0*&apos; -name &apos;*.txt&apos;</code></pre><p>  3.在当前目录下的dir0目录下的子目录dir00及其子目录下查找txt后缀文件</p>
<pre><code>find ./ -path &apos;*dir00*&apos; -name &apos;*.txt&apos;</code></pre><p>  4.在除dir0及子目录以外的目录下查找txt后缀文件</p>
<pre><code>find ./ -path &apos;./dir0*&apos; -a -prune -o -name &apos;*.txt&apos; -print</code></pre><p>  <strong>说明：-a 应该是and的缩写，意思是逻辑运算符‘与’(&amp;&amp;); -o应该是or的缩写,意思是逻辑运算符‘或’(||), -not 表示非.</strong></p>
<p>  <strong>命令行的意思是：如果目录dir0存在（即-a左边为真），则求-prune的值，-prune 返回真，‘与’逻辑表达式为真（即-path ‘./dir0*‘ -a -prune 为真），find命令将在除这个目录以外的目录下查找txt后缀文件并打印出来；如果目录dir0不存在（即-a左边为假），则不求值-prune ，‘与’逻辑表达式为假，则在当前目录下查找所有txt后缀文件。</strong></p>
<p>  5.在除dir0、dir1及子目录以外的目录下查找txt后缀文件</p>
<pre><code>find ./ −*p**a**t**h* ′ ./*d**i**r*0∗ ′ −*o*−*p**a**t**h* ′ ./*d**i**r*1∗ ′ −path′./dir0∗′−o−path′./dir1∗′ -path &apos;./dir0*&apos; -o -path &apos;./dir1*&apos;  -a -prune -o -name &apos;*.txt&apos; -print</code></pre><p>  注意：圆括号()表示表达式的结合。即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。由于命令行不能直接使用圆括号，所以需要用反斜杠’&#39;进行转意(即’&#39;转意字符使命令行认识圆括号)。同时注意’ ′ ， ′ ′，′ ‘，’ ‘两边都需空格。</p>
<p>  6.在dir0、dir1及子目录下查找txt后缀文件</p>
<pre><code>find ./ −*p**a**t**h* ′ ./*d**i**r*0∗ ′ −*o*−*p**a**t**h* ′ ./*d**i**r*1∗ ′ −path′./dir0∗′−o−path′./dir1∗′ -path &apos;./dir0*&apos; -o -path &apos;./dir1*&apos;  -a -name &apos;*.txt&apos; -print</code></pre><p>  +1. 在所有以名为dir_general的目录下查找txt后缀文件</p>
<p>  find ./ -path ‘<em>/dir_general/</em>‘ -name ‘*.txt’ -print</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件查找</tag>
      </tags>
  </entry>
  <entry>
    <title>01-文本处理三剑客之SED</title>
    <url>/01-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BSED/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。<br>主要用来自动编辑一个或多个文件,简化对文件的反复操作,编写转换程序等</p>
<p>sed [option]… ‘script’ inputfile…</p>
<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><p><code>-n</code>    不输出模式空间内容到屏幕，即不自动打印<br><code>-e</code>    多点编辑<br><code>-f  /PATH/SCRIPT_FILE</code>    从指定文件中读取编辑脚本<br><code>-r</code>    支持使用扩展正则表达式<br><code>-i.bak</code>    备份文件并原处编辑 </p>
<h2 id="SCRIPT"><a href="#SCRIPT" class="headerlink" title="SCRIPT"></a>SCRIPT</h2><p>SCRIPT内多个命令用<code>;</code>连接，依次执行</p>
<h3 id="地址命令"><a href="#地址命令" class="headerlink" title="地址命令"></a>地址命令</h3><p>地址定界：<br>(1)    不给地址：对全文进行处理<br>(2)    单地址：</p>
<p><code>#</code>：指定的行</p>
<p><code>$</code>：最后一行<br><code>/pattern/</code>：被此处模式所能够匹配到的每一行</p>
<p>(3) 地址范围：</p>
<p><code>#,#</code>     第#到第#行<br><code>#,+#</code>     第#向下#行<br><code>/pat1/,/pat2/</code> </p>
<p><code>#,/pat1/</code> </p>
<p>(4) ~：步进</p>
<p><code>1~2</code> 奇数行 （从第一行开始，步进行为2）</p>
<p><code>2~2</code> 偶数行  （从第二行开始，步进行为2）</p>
<h3 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h3><p><code>d</code>         删除模式空间匹配的行，并立即启用下一轮循环<br><code>p</code>                 打印当前模式空间内容，追加到默认输出之后<br><code>a text</code>         在指定行后面追加文本，支持使用\n实现多行追加 </p>
<p><code>i text</code>         在行前面插入文本 </p>
<p><code>c text</code>    替换行为单行或多行文本 </p>
<p><code>w /path/file</code> 保存模式匹配的行至指定文件</p>
<p><code>r /path/file</code>     读取指定文件的文本至模式空间中匹配到的行后</p>
<p><code>=</code>             为模式空间中的行打印行号 </p>
<p><code>!</code>            模式空间中匹配行取反处理</p>
<p><code>s///</code>        查找替换,支持使用其它分隔符，s@@@，s###<br>替换标记：</p>
<p><code>g</code>    行内全局替换<br><code>p</code>    显示替换成功的行</p>
<p><code>w /PATH/FILE</code>    将替换成功的行保存至文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sed ‘2p’  /etc/passwd<br>sed  -n ‘2p’ /etc/passwd<br>sed  -n ‘1,4p’ /etc/passwd<br>sed  -n ‘/root/p’  /etc/passwd<br>sed  -n ‘2,/root/p’  /etc/passwd 从2行开始<br>sed  -n ‘/^$/=’  file 显示空行行号<br>sed  -n  -e ‘/^$/p’ -e ‘/^$/=’  file<br>sed‘/root/a\superman’  /etc/passwd行后<br>sed ‘/root/i\superman’ /etc/passwd 行前<br>sed ‘/root/c\superman’ /etc/passwd 代替行<br>sed ‘/^$/d’ file<br>sed ‘1,10d’   file<br>nl   /etc/passwd | sed ‘2,5d’<br>nl   /etc/passwd | sed ‘2a tea’<br>sed <span class="hljs-string">'s/test/mytest/g'</span> example<br>sed –n ‘s/root/&amp;superman/p’ /etc/passwd 单词后<br>sed –n ‘s/root/superman&amp;/p’ /etc/passwd 单词前<br>sed -e ‘s/dog/cat/’ -e ‘s/hi/lo/’ pets<br>sed –i.bak  ‘s/dog/cat/g’ pets<br></code></pre></td></tr></table></figure>

<h3 id="高级编辑命令"><a href="#高级编辑命令" class="headerlink" title="高级编辑命令"></a>高级编辑命令</h3><p><code>P</code>： 打印模式空间开端至\n内容，并追加到默认输出之前<br><code>h</code>:  把模式空间中的内容覆盖至保持空间中<br><code>H</code>：把模式空间中的内容追加至保持空间中<br><code>g</code>:  从保持空间取出数据覆盖至模式空间<br><code>G</code>：从保持空间取出内容追加至模式空间<br><code>x</code>:  把模式空间中的内容与保持空间中的内容进行互换<br><code>n</code>:  读取匹配到的行的下一行覆盖至模式空间<br><code>N</code>：读取匹配到的行的下一行追加至模式空间<br><code>d</code>:  删除模式空间中的行<br><code>D</code>：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sed -n <span class="hljs-string">'n;p'</span> FILE<br>sed <span class="hljs-string">'1!G;h;$!d'</span> FILE<br>sed‘N;D’FILE<br>sed <span class="hljs-string">'$!N;$!D'</span> FILE<br>sed <span class="hljs-string">'$!d'</span> FILE<br>sed ‘G’ FILE<br>sed ‘g’ FILE<br>sed ‘/^$/d;G’ FILE<br>sed <span class="hljs-string">'n;d'</span> FILE<br>sed -n <span class="hljs-string">'1!G;h;$p'</span> FILE<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>01-文本处理工具</title>
    <url>/01-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看文件，从第一行到最后一行全部显示。</p>
<p>参数：</p>
<blockquote>
<ul>
<li><code>-E</code>: 显示行结束符$</li>
<li><code>-A</code>：显示不可打印字符，通常查看脚本是否有多加空格tab回车之类的。</li>
<li><code>-n</code>：对显示出的每一行进行编号</li>
<li><code>-s</code>：显示行号，压缩连续的空行，只显示一行空行</li>
<li><code>-b</code> ：空行不加行号，等同于<code>nl</code>命令</li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ cat catfile<br>AAA	BBB<br>CCC DDD<br>EEE<br><br>GGG<br><br><br>HHH<br>[root❄centos7 app]☭ cat -A catfile <br>AAA^IBBB$<br>CCC DDD$<br>EEE$<br>$<br>GGG$<br>$<br>$<br>HHH$<br>[root❄centos7 app]☭ cat -n catfile <br>     1	AAA	BBB<br>     2	CCC DDD<br>     3	EEE<br>     4	<br>     5	GGG<br>     6	<br>     7	<br>     8	HHH<br>[root❄centos7 app]☭ cat -b catfile<br>     1	AAA	BBB<br>     2	CCC DDD<br>     3	EEE<br><br>     4	GGG<br><br><br>     5	HHH<br>[root❄centos7 app]☭ cat -s catfile<br>AAA	BBB<br>CCC DDD<br>EEE<br><br>GGG<br><br>HHH<br></code></pre></td></tr></table></figure>

<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>从后往前显示文件，和<code>cat</code>相反。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ tac catfile<br>HHH<br><br><br>GGG<br><br>EEE<br>CCC DDD<br>AAA	BBB<br></code></pre></td></tr></table></figure>

<h3 id="rev"><a href="#rev" class="headerlink" title="rev"></a>rev</h3><p><code>reverse lines</code>水平反转每一行里的字母。</p>
<p>示例1，水平翻转文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ rev catfile <br>BBB	AAA<br>DDD CCC<br>EEE<br><br>GGG<br><br><br>HHH<br></code></pre></td></tr></table></figure>

<p>示例2，倒序+水平翻转文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ tac catfile | rev<br>HHH<br><br><br>GGG<br><br>EEE<br>DDD CCC<br>BBB	AAA<br></code></pre></td></tr></table></figure>

<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>分页显示，显示到最后会退出。</p>
<blockquote>
<ul>
<li><code>空格</code>或者<code>f</code>下一页</li>
<li><code>b</code>上一页（管道后跟<code>more</code>无法上一页）</li>
</ul>
</blockquote>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分页显示，显示到最后也不会退出，要按<code>q</code>退出。</p>
<p><strong>翻屏操作：</strong></p>
<table>
<thead>
<tr>
<th align="left">键盘按键</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>空格键</code></td>
<td align="left">向下滚动一屏</td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">向上滚动一屏</td>
</tr>
<tr>
<td align="left"><code>j</code></td>
<td align="left">向下移动一行</td>
</tr>
<tr>
<td align="left"><code>k</code>或<code>回车</code></td>
<td align="left">向上移动一行</td>
</tr>
<tr>
<td align="left"><code>gg</code></td>
<td align="left">跳转至第一行</td>
</tr>
<tr>
<td align="left"><code>5g</code></td>
<td align="left">跳转到第5行</td>
</tr>
<tr>
<td align="left"><code>G</code></td>
<td align="left">跳转到最后一行</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left">退出</td>
</tr>
</tbody></table>
<p><strong>文本搜索:</strong></p>
<table>
<thead>
<tr>
<th align="left">键盘按键</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/keyword</code></td>
<td align="left">向下查找，不区分大小写</td>
</tr>
<tr>
<td align="left"><code>?keyword</code></td>
<td align="left">向上查找，不区分大小写</td>
</tr>
<tr>
<td align="left"><code>n</code></td>
<td align="left">查找下一个，与查找方向相同</td>
</tr>
<tr>
<td align="left"><code>N</code></td>
<td align="left">查找上一个，与查找方向相反</td>
</tr>
</tbody></table>
<hr>
<h2 id="按行截取"><a href="#按行截取" class="headerlink" title="按行截取"></a>按行截取</h2><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取文件头部的行，默认头10行。</p>
<p>参数：</p>
<blockquote>
<ul>
<li><code>-c NUM</code>：显示几个字符</li>
<li><code>-n NUM</code>：显示几行</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 取随机数里，数字或字母的字符，取前20个字符，可以用来做随机密码。<br>cat &#x2F;dev&#x2F;urandom | tr -dc &quot;0-9a-zA-Z&quot; | head -c 20<br></code></pre></td></tr></table></figure>

<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件尾部的行，默认最后10行。</p>
<p>参数：</p>
<blockquote>
<ul>
<li><code>-c NUM</code>：只显示倒数几个字符。</li>
<li><code>-n NUM</code>：示倒数几行。</li>
<li><code>-f</code>：follow，跟踪这个文件的变动，用来看日志比较多</li>
</ul>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tail -n0 -f &#x2F;var&#x2F;log&#x2F;messages &amp;&#96;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><code>-n0</code>只显示新增加的内容，命令最后加一个<code>&amp;</code>，表示放在后台运行，可以去运行其他命令不受影响。当日志变动的时候，会在前台打印出一条，按回车可以继续运行其他命令。</p>
</blockquote>
<hr>
<h2 id="转化内容"><a href="#转化内容" class="headerlink" title="转化内容"></a>转化内容</h2><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p><code>tr [OPTION]... SET1 [SET2]</code><br>把输入的数据当中的字符，凡是在<code>SET1</code>定义范围内出现的，通通对位转换为<code>SET2</code>出现的字符</p>
<p>参数：</p>
<blockquote>
<ul>
<li><code>tr SET1 SET2 &lt; /path/from/somefile</code>对位转化SET1中的字符为SET2中的字符</li>
<li><code>tr -d SET1 &lt; /path/from/somefile</code>删除指定集合里出现的字符</li>
<li><code>tr -s &quot;\n&quot; /path/from/somefile</code>把指定的连续的字符以一个字符表示，压缩。</li>
<li><code>tr -c</code>Complement ,取字符集的补集，通常与其他参数结合使用，例如<code>-dc</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian~]# tr &#39;a-z&#39; &#39;A-Z&#39;<br>aabbcc33<br>AABBCC33<br>^C<br>[root@ashjian~]# tr &#39;a-z&#39; &#39;A-Z&#39; &lt;&#x2F;etc&#x2F;issue<br>\S<br>KERNEL \R ON AN \M<br><br>[root@ashjian~]# tr &#39;a-z&#39; &#39;A-Z&#39; &lt; &#x2F;etc&#x2F;issue &gt; &#x2F;app&#x2F;issue2<br>[root@ashjian~]# cat &#x2F;app&#x2F;issue2<br>\S<br>KERNEL \R ON AN \M<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：如果是输入后再输出到同一个文件，就会清空这个文件，所以最好不要这么用，下面是一个错误示范：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 ~]☭ cd &#x2F;app&#x2F;<br>[root❄centos7 app]☭ cp issue2 issue3<br>[root❄centos7 app]☭ tr &#39;a-z&#39; &#39;A-Z&#39; &lt; issue3 &gt;issue3<br>[root❄centos7 app]☭ cat issue3<br>[root❄centos7 app]☭<br></code></pre></td></tr></table></figure>

<p>追加是可以的，在原有文件基础上再追加一段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ cat issue2<br>\S<br>KERNEL \R ON AN \M<br><br>[root❄centos7 app]☭ tr &#39;A-Z&#39; &#39;a-z&#39; &lt; issue2 &gt;&gt; issue2<br>[root❄centos7 app]☭ cat issue2<br>\S<br>KERNEL \R ON AN \M<br><br>\s<br>kernel \r on an \m<br></code></pre></td></tr></table></figure>

<p>dc结合使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjianapp]# echo &#123;a..z&#125; &gt;f1<br>[root@ashjianapp]# cat f1<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>[root@ashjianapp]# tr -d &#39;f-n&#39; &lt;f1<br>a b c d e          o p q r s t u v w x y z<br>[root@ashjianapp]# cat f1<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>[root@ashjianapp]# tr -dc &#39;f-n&#39; &lt; f1<br>fghijklmn[root@ashjianapp]#<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="按列操作"><a href="#按列操作" class="headerlink" title="按列操作"></a>按列操作</h2><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>cut可以实现分割每一行，并且指定输出列的字段。</p>
<blockquote>
<ul>
<li><code>-d DELIMITER</code>：指定分隔符（delimiter）</li>
<li><code>-f FIELDS</code>：取指定字段（fileds）</li>
</ul>
</blockquote>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 以冒号作为分隔符，取1到3、7的字段<br>cut -d: -f1-3,7 &#x2F;etc&#x2F;passwd<br># 结果<br>root:x:0:&#x2F;bin&#x2F;bash<br>...<br>LongDream:x:1000:&#x2F;bin&#x2F;bash<br>yu:x:1001:&#x2F;bin&#x2F;bash<br>alice:x:1002:&#x2F;bin&#x2F;bash<br>tom:x:1003:&#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 取磁盘利用率,先tr压缩空格为一个空格，然后以空格作为分隔符，取第五个字段<br>df |tr -s &quot; &quot;| cut -d&quot; &quot; -f5<br># 结果<br>Use%<br>5%<br>0%<br>0%<br>1%<br>0%<br>1%<br>22%<br>0%<br></code></pre></td></tr></table></figure>

<h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><p>把多个文件的多行进行合并，逐行进行合并。</p>
<p>参数：</p>
<blockquote>
<ul>
<li><code>-d</code>指定分隔符,默认是tab</li>
<li><code>-s</code>把每个文件里的多行合成一行，每个文件一行。</li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]# cat file1<br>name<br>aaa<br>bbb<br>ccc<br>[root❄centos7 app]# cat file2<br>age<br>18<br>20<br>22<br>[root❄centos7 app]# paste file1 file2<br>name	age<br>aaa		18<br>bbb		20<br>ccc		22<br>[root❄centos7 app]# paste -d: file1 file2<br>name:age<br>aaa:18<br>bbb:20<br>ccc:22<br>[root❄centos7 app]# paste -s file1 file2<br>name	aaa	bbb	ccc<br>age	18	20	22<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="分析文本"><a href="#分析文本" class="headerlink" title="分析文本"></a>分析文本</h2><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>直接运行原<code>wc</code>命令：输出文件中的行数、单词数、字节数</p>
<p>参数：</p>
<blockquote>
<ul>
<li><code>-c</code>：输出字节数</li>
<li><code>-m</code>：输出字符数</li>
<li><code>-l</code>：输出行数</li>
<li><code>-L</code>：输出最长的行的长度。</li>
<li><code>-w</code>： 输出单词统计数。</li>
</ul>
</blockquote>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>排序，默认是按照字符的大小来排列</p>
<blockquote>
<ul>
<li><code>-t</code> ：指定分隔符</li>
<li><code>-k</code>：以哪一个为分割</li>
<li><code>-n</code>：按数字大小排列，从小到大</li>
<li><code>-r</code>：反向，从大到小</li>
<li><code>-u</code>：删除重复的行</li>
</ul>
</blockquote>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 以冒号分割，取第三列UID，nr表示按照数值大小倒序（由大到小）排列。<br>sort -t: -k3 -nr &#x2F;etc&#x2F;passwd<br># 先cut只留第一列用户名和第三列UID<br>cut -d: -f1,3 &#x2F;etc&#x2F;passwd | sort -t: -k2 -nr<br></code></pre></td></tr></table></figure>



<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 取分区使用率最大值<br>df |tr -s &quot; &quot; &quot;%&quot;|cut -d% -f5|sort -nr|head -n1<br></code></pre></td></tr></table></figure>

<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>唯一，从输入中删除前后相接的重复的行</p>
<p><code>-c</code>: 显示每行重复出现的次数</p>
<p><code>-d</code>: 仅显示重复过的行</p>
<p><code>-u</code>: 仅显示不曾重复的行</p>
<p>常和sort 命令一起配合使用，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 把用户名列表进行排序（重复的会在相邻的行），然后统计重复用户出现的次数：<br>sort userlist.txt | uniq -c<br># 登录用户的登录次数：<br>&#96;last | cut -d &#39; &#39; -f1|sort| uniq -c |sort -nr&#96;<br></code></pre></td></tr></table></figure>

<h3 id="diff、patch"><a href="#diff、patch" class="headerlink" title="diff、patch"></a>diff、patch</h3><p>diff比较两个文件的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 比较两个文件的区别，发现第5行有区别<br>diff foo.conf-broken foo.conf-works<br><br>5c5<br>&lt; use_widgets &#x3D; no<br>---<br>&gt; use_widgets &#x3D; yes<br></code></pre></td></tr></table></figure>

<p>patch可以用diff生成的patch来修复另一个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">diff -u foo.conf-broken foo.conf-works &gt; foo.patch #把差异写到foo.patch补丁里<br>cp foo.conf-broken foo.conf-broken.bak #备份一下<br>patch -b foo.conf-broken foo.patch # 从差异的补丁进行恢复<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="按关键字过滤"><a href="#按关键字过滤" class="headerlink" title="按关键字过滤"></a>按关键字过滤</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>文本过滤工具</p>
<p>不带参数普通用法：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep root &#x2F;etc&#x2F;passwd<br></code></pre></td></tr></table></figure>
</blockquote>
<p>带参数：</p>
<blockquote>
<ul>
<li><code>-v</code>：显示不被pattern匹配到的行</li>
<li><code>-i</code>：忽略字符大小写</li>
<li><code>-n</code>：显示匹配的行号</li>
<li><code>-c</code>：统计匹配的行数</li>
<li><code>-o</code>：仅显示匹配到的字符串</li>
<li><code>-q</code>：静默模式，不输出任何信息(quiet，可以结合<code>echo $?</code>状态码使用)</li>
<li><code>-A NUM</code> after, 包含匹配行的后NUM行</li>
<li><code>-B NUM</code>:before, 包含匹配行的前NUM行</li>
<li><code>-C NUM</code> context, 包含匹配行的前后各NUM行</li>
<li><code>-e</code>: 实现多个选项间的逻辑or关系</li>
<li><code>-w</code>匹配整个单词(字母、下划线、数字汉字，这几个连在一起算一个单词)</li>
<li><code>-E</code>使用ERE</li>
<li><code>-F</code>相当于fgrep，不支持正则表达式</li>
</ul>
<p>参考书籍：关于grep的各个参数的具体用法，可以看《Linux Shell 脚本攻略（第2版）》4.3章节，有详细说明，这里不做赘述。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 扫描172.16.252。0段的机器，如果主机是up状态（Host is up）的，显示之前一行（-B1）,前一行有ip地址，然后grep for是因为只有有ip的那行有for，然后以空格为分隔符，取第五个，就是ip地址。<br>nmap -v -sP 172.17.252.0&#x2F;24 |grep -B1 &quot;Host is up.&quot;|grep for|cut -d&quot; &quot; -f5<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>01-标准IO重定向</title>
    <url>/01-%E6%A0%87%E5%87%86IO%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14975176407733.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819142222.jpg" alt="img"></a></p>
<h3 id="标准IO（Standard-Input-Output）"><a href="#标准IO（Standard-Input-Output）" class="headerlink" title="标准IO（Standard Input/Output）"></a>标准IO（Standard Input/Output）</h3><p>可用于做输入的设备：</p>
<blockquote>
<p>键盘设备、文件系统上的常规文件、网卡等。</p>
</blockquote>
<p>可用于做输出的设备：</p>
<blockquote>
<p>显示器、文件系统上的常规文件、网卡等。</p>
</blockquote>
<p>程序的数据流有三种：</p>
<ul>
<li>输入的数据流：&lt;– 标准输入（<code>stdin</code>(standard input)）,默认接受来自键盘的输入。</li>
<li>输出的数据流：–&gt; 标准输出（<code>stdout</code>(standard output)），默认输出到终端窗口。</li>
<li>错误输出流：–&gt; 标准错误（<code>stderr</code>(standard error)），默认输出到终端窗口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fd&#96;:file descriptor，文件描述符<br>标准输入：&#96;0&#96;<br>标准输出：&#96;1&#96;<br>标准错误：&#96;2<br></code></pre></td></tr></table></figure>

<p><code>echo $?</code>（bash脚本编程中，很多判断基于<code>$?</code>这个来决定）</p>
<p><a href="http://www.yulongjun.com/images/1495628807365.png" target="_blank" rel="noopener"><img src="01-%E6%A0%87%E5%87%86IO%E9%87%8D%E5%AE%9A%E5%90%91.assets/1495628807365.png" alt="img"></a></p>
<hr>
<h3 id="IO重定向-Input-Output-Redirection"><a href="#IO重定向-Input-Output-Redirection" class="headerlink" title="IO重定向(Input/Output Redirection)"></a>IO重定向(Input/Output Redirection)</h3><blockquote>
<p><strong>输入本来默认是键盘，我们改成其他输入，就是输入重定向</strong> ：例如从文本文件里输入。<br><strong>本来输出的位置是显示器，我们改成其他输出，就是输出重定向</strong>：例如输出到文件。</p>
</blockquote>
<p><code>set -C</code>：</p>
<blockquote>
<p>禁止覆盖输出重定向到已存在的文件(在这种模式下，如果你非要覆盖，可以使用<code>&gt;|</code>）</p>
</blockquote>
<p><code>set +C</code>：</p>
<blockquote>
<p>关闭上述特性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;dev&#x2F;null<br></code></pre></td></tr></table></figure>

<blockquote>
<p>特殊设备，空设备，也叫黑洞，数据进去都没了。</p>
</blockquote>
<hr>
<h3 id="输出重定向（Output-Redirection）的几种方法"><a href="#输出重定向（Output-Redirection）的几种方法" class="headerlink" title="输出重定向（Output Redirection）的几种方法"></a>输出重定向（Output Redirection）的几种方法</h3><h4 id="1-正常输出重定向：-gt-（覆盖输出）、-gt-gt-（追加输出）"><a href="#1-正常输出重定向：-gt-（覆盖输出）、-gt-gt-（追加输出）" class="headerlink" title="1. 正常输出重定向：&gt;（覆盖输出）、&gt;&gt;（追加输出）"></a><strong>1. 正常输出重定向</strong>：<code>&gt;</code>（覆盖输出）、<code>&gt;&gt;</code>（追加输出）</h4><p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; cat &#x2F;etc&#x2F;issue &gt; &#x2F;tmp&#x2F;issue.out<br>#开两个ssh连接,我们先看第二个的终端所在的虚拟设备文件，然后在第一个输入<br><br>#第二个ssh：<br>&gt;&gt;&gt; tty<br>&#x2F;dev&#x2F;pts&#x2F;1<br><br>#第一个ssh输入：<br>&gt;&gt;&gt; cat &#x2F;etc&#x2F;issue &gt; &#x2F;dev&#x2F;pts&#x2F;1<br># 我们看到第二个ssh输出了信息<br><br>#追加输出<br>ls &#x2F;var &gt; &#x2F;tmp&#x2F;test.out<br>cat &#x2F;etc&#x2F;fstab &gt;&gt; &#x2F;tmp&#x2F;test.out<br></code></pre></td></tr></table></figure>



<h4 id="2-错误输出重定向：2-gt-（覆盖输出）、2-gt-gt-（追加输出）"><a href="#2-错误输出重定向：2-gt-（覆盖输出）、2-gt-gt-（追加输出）" class="headerlink" title="2. 错误输出重定向：2&gt;（覆盖输出）、2&gt;&gt;（追加输出）"></a><strong>2. 错误输出重定向</strong>：<code>2&gt;</code>（覆盖输出）、<code>2&gt;&gt;</code>（追加输出）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls &#x2F;etc&#x2F;issue1111 2&gt;&gt; &#x2F;tmp&#x2F;error.out<br>catt &#x2F;etc&#x2F;issue 2&gt;&gt; &#x2F;dev&#x2F;null<br></code></pre></td></tr></table></figure>

<h4 id="3-正确和错误的都进行输出重定向："><a href="#3-正确和错误的都进行输出重定向：" class="headerlink" title="3. 正确和错误的都进行输出重定向："></a><strong>3. 正确和错误的都进行输出重定向</strong>：</h4><ul>
<li>新写法：<code>COMMAND &amp;&gt; /path/to/somefile</code>、<code>COMMAND &amp;&gt;&gt; /path/to/somefile</code></li>
<li>老写法：<code>COMMAND &gt; /path/to/somefile 2&gt;&amp;1</code>、<code>COMMAND &gt;&gt; /path/to/somefile 2&gt;&amp;1</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls &#x2F;boot &#x2F;err &amp;&gt; &#x2F;tmp&#x2F;all1.log # 新写法<br>ls &#x2F;boot &#x2F;err &amp;&gt;&gt; &#x2F;tmp&#x2F;all2.log # 新写法<br>ls &#x2F;boot &#x2F;err &gt; &#x2F;tmp&#x2F;all3.log 2&gt;&amp;1 # 老写法<br>ls &#x2F;boot &#x2F;err &gt;&gt; &#x2F;tmp&#x2F;all4.log 2&gt;&amp;1 # 老写法<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="输入重定向（Input-Redirection）的方法"><a href="#输入重定向（Input-Redirection）的方法" class="headerlink" title="输入重定向（Input Redirection）的方法"></a><strong>输入重定向（Input Redirection）的方法</strong></h3><h4 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a><code>tr</code>命令</h4><p><code>tr [OPTION]... SET1 [SET2]</code><br>把输入的数据当中的字符，凡是在<code>SET1</code>定义范围内出现的，通通对位转换为<code>SET2</code>出现的字符</p>
<ul>
<li><code>tr SET1 SET2 &lt; /path/from/somefile</code>对位转化SET1中的字符为SET2中的字符</li>
<li><code>tr -d SET1 &lt; /path/from/somefile</code>删除指定集合里出现的字符</li>
<li><code>tr -s &quot;\n&quot; /path/from/somefile</code>把指定的连续的字符以一个字符表示，压缩。</li>
<li><code>tr -c</code>Complement ,取字符集的补集，通常与其他参数结合使用，例如<code>-dc</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 ~]☭ tr &#39;a-z&#39; &#39;A-Z&#39;<br>aabbcc33<br>AABBCC33<br>^C<br>[root❄centos7 ~]☭ tr &#39;a-z&#39; &#39;A-Z&#39; &lt;&#x2F;etc&#x2F;issue<br>\S<br>KERNEL \R ON AN \M<br><br>[root❄centos7 ~]☭ tr &#39;a-z&#39; &#39;A-Z&#39; &lt; &#x2F;etc&#x2F;issue &gt; &#x2F;app&#x2F;issue2<br>[root❄centos7 ~]☭ cat &#x2F;app&#x2F;issue2<br>\S<br>KERNEL \R ON AN \M<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：如果是输入后再输出到同一个文件，就会清空这个文件，所以最好不要这么用，下面是一个错误示范：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 ~]☭ cd &#x2F;app&#x2F;<br>[root❄centos7 app]☭ cp issue2 issue3<br>[root❄centos7 app]☭ tr &#39;a-z&#39; &#39;A-Z&#39; &lt; issue3 &gt;issue3<br>[root❄centos7 app]☭ cat issue3<br>[root❄centos7 app]☭<br></code></pre></td></tr></table></figure>

<p>追加是可以的，在原有文件基础上再追加一段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ cat issue2<br>\S<br>KERNEL \R ON AN \M<br><br>[root❄centos7 app]☭ tr &#39;A-Z&#39; &#39;a-z&#39; &lt; issue2 &gt;&gt; issue2<br>[root❄centos7 app]☭ cat issue2<br>\S<br>KERNEL \R ON AN \M<br><br>\s<br>kernel \r on an \m<br></code></pre></td></tr></table></figure>

<p>dc结合使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ echo &#123;a..z&#125; &gt;f1<br>[root❄centos7 app]☭ cat f1<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>[root❄centos7 app]☭ tr -d &#39;f-n&#39; &lt;f1<br>a b c d e          o p q r s t u v w x y z<br>[root❄centos7 app]☭ cat f1<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>[root❄centos7 app]☭ tr -dc &#39;f-n&#39; &lt; f1<br>fghijklmn[root❄centos7 app]☭<br></code></pre></td></tr></table></figure>

<h4 id="Here-documents"><a href="#Here-documents" class="headerlink" title="Here documents"></a>Here documents</h4><p>输出到屏幕，或创建多行文档)：<code>&lt;&lt;终止词</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ cat &lt;&lt;EOF<br>&gt; yulongjun<br>&gt; zhaoweiqiang<br>&gt; EOF<br><br>yulongjun<br>zhaoweiqiang<br><br>[root❄centos7 app]☭ cat &gt;cat.out &lt;&lt;END<br>&gt; yulongjun<br>&gt; zhaoweiqiang<br>&gt; hanjinze<br>&gt; songda<br>&gt; END<br><br>[root❄centos7 app]☭ cat &#x2F;tmp&#x2F;cat.out <br>yulongjun<br>zhaoweiqiang<br>hanjinze<br>songda<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="代表输出流"><a href="#代表输出流" class="headerlink" title="-代表输出流"></a><code>-</code>代表输出流</h3><blockquote>
<p>此段来源于：<a href="https://www.cnblogs.com/dachenzi/p/6790596.html" target="_blank" rel="noopener">https://www.cnblogs.com/dachenzi/p/6790596.html</a></p>
</blockquote>
<p><strong>搭配<code>cat</code></strong></p>
<p><code>cat -</code>：如果指定cat的文件为-，表示从标准输入读取（和直接使用cat，好像没什么区别）</p>
<p><strong>搭配<code>|</code></strong></p>
<p><code>echo 123 | cat -</code>：表示把管道符前面的输出流，在交给cat执行一遍（这就很牛逼了）</p>
<p><strong>例子：</strong></p>
<p>如果操作系统没有scp命令，只有ssh，那么是不是就不能远程拷贝了（前提：没有openssh-clients软件包）</p>
<p>利用<code>-</code>，就可以实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat jdk.tar.gz | ssh 192.168.56.101  &#39;cat - &gt; &#x2F;tmp&#x2F;jdk.tar.gz&#39;<br>cat jdk.tar.gz&#96; 产生输出流， 在管道后面的 &#96;-&#96; ,则可以接受输出流，并重定向到&#96;&#x2F;tmp&#x2F;jdk.tar.gz<br></code></pre></td></tr></table></figure>



<h3 id="：合并多个程序的STDOUT"><a href="#：合并多个程序的STDOUT" class="headerlink" title="()：合并多个程序的STDOUT"></a>()：合并多个程序的STDOUT</h3><p>( cal 2007 ; cal 2008 ) &gt; all.txt</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>IO重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>01-用户和组</title>
    <url>/01-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>3A</p>
<ul>
<li><code>Authentication</code>：认证（用户的识别（密码、指纹、虹膜））</li>
<li><code>Authorization</code>：授权（用户的访问权限控制）</li>
<li><code>Accounting</code>：审计（用户的动作记录，监督权限的使用）</li>
</ul>
<p>用户：<code>user</code><br>组：<code>group</code>（组在有些系统里组被称为角色）</p>
<hr>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p><strong>用户类别</strong>:</p>
<ul>
<li>管理员</li>
<li>普通用户<ul>
<li>系统用户</li>
<li>登录用户</li>
</ul>
</li>
</ul>
<p><strong>用户标识</strong>：</p>
<p><code>UID</code>(User ID)，范围为16bits（0-65535）</p>
<ul>
<li><p>管理员：<code>0</code></p>
</li>
<li><p>普通用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1-65535<br></code></pre></td></tr></table></figure>

<ul>
<li>系统用户：<code>1-499</code>（CentOS6）<code>1-999</code>（CentOS7）</li>
<li>登录用户：<code>500-60000</code>（CentOS6），<code>1000-60000</code>（CentOS7）、</li>
</ul>
</li>
</ul>
<p><strong>名称解析</strong>：<br>UserName &lt;–&gt; UID<br>根据名称解析库进行：<strong><code>/etc/passwd</code></strong></p>
<hr>
<h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><h3 id="组类别1"><a href="#组类别1" class="headerlink" title="组类别1"></a><strong>组类别1</strong></h3><ul>
<li>管理员组</li>
<li>普通用户组<ul>
<li>系统组</li>
<li>登录组</li>
</ul>
</li>
</ul>
<p><strong>组标识</strong>：</p>
<p><code>GID</code>(Group ID)，范围为16bits（0-65535）</p>
<ul>
<li><p>管理员：<code>0</code></p>
</li>
<li><p>普通用户组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1-65535<br></code></pre></td></tr></table></figure>

<ul>
<li>系统组：<code>1-499</code>（CentOS6）<code>1-999</code>（CentOS7）</li>
<li>登录组：<code>500-60000</code>（CentOS6），<code>1000-60000</code>（CentOS7）、</li>
</ul>
</li>
</ul>
<p><strong>名称解析</strong>：<br>GroupName &lt;–&gt; GID<br>根据名称解析库进行：<strong><code>/etc/group</code></strong></p>
<h3 id="组类别2"><a href="#组类别2" class="headerlink" title="组类别2"></a><strong>组类别2</strong></h3><p>一个用户属于多个组，可以划分为：</p>
<ul>
<li><strong>用户主组</strong>(基本组)(g)：primary group</li>
<li><strong>附加组</strong>(G)：supplymentary group</li>
</ul>
<p>用户必须属于主组，有且只有一个主组，附加组可有可无，可以有多个。</p>
<h3 id="组类别3"><a href="#组类别3" class="headerlink" title="组类别3"></a><strong>组类别3</strong></h3><p><strong>私有组</strong>：组名同用户名，且只包含一个用户<br><strong>公共组</strong>：组内包含了多个用户</p>
<hr>
<h2 id="认证信息"><a href="#认证信息" class="headerlink" title="认证信息"></a>认证信息</h2><p>通过比对事先存储的信息，与登录时候提供的信息否一致。<br>密码：passwd</p>
<p><strong><code>/etc/shadow</code></strong>(用户密码)<br><strong><code>/etc/gshadow</code></strong>(组密码)</p>
<p>加密算法：</p>
<ul>
<li><p><strong>对称加密</strong>：加密和解密使用同一个密码</p>
</li>
<li><p>非对称加密</p>
<p>：加密和解密使用一对儿秘钥。</p>
<ul>
<li>公钥：public key</li>
<li>私钥：private key</li>
</ul>
</li>
<li><p><strong>单向加密</strong>：只能加密，不能解密：提取数据特征码</p>
<ul>
<li>定长输出（跟原来的数据量多大没关系）</li>
<li>雪崩效应（数据的一点点差别，加密后差别很大 ）<br><code>echo &quot;How are you?&quot; | md5sum</code><br><code>echo &quot;How are you&quot; | md5sum</code></li>
</ul>
</li>
<li><p><strong>算法</strong>：</p>
<ul>
<li><p><code>md5</code>：message digest（消息摘要）version5， 128位</p>
</li>
<li><pre><code>sha</code></pre><p>：secure hash algorithm（安全的哈希算法）</p>
<ul>
<li><code>sha1sum</code></li>
<li><code>sha224sum</code></li>
<li><code>sha256sum</code></li>
<li><code>sha384sum</code></li>
<li><code>sha512sum</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>账户输入密码后，加点salt（添加随机数），这样保证不同用户用同样的密码，加密后结果不一样。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>用户和组</tag>
      </tags>
  </entry>
  <entry>
    <title>01-磁盘分区</title>
    <url>/01-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ector）。</p>
<p><strong>MBR机制</strong>：Master Boot Record（主引导记录）<br>占用空间为<code>512bytes</code>：</p>
<ul>
<li><code>bootloader</code>（一段程序，引导加载器的程序）加载指定操作系统的内核：<code>446bytes</code></li>
<li><code>fat</code>：<code>64bytes</code>，每16个bytes存放一个分区信息，最多只有4个分区。</li>
<li><code>55 AA</code>：MBR有效性标记，<code>2bytes</code></li>
</ul>
<p><strong>GPT机制</strong>：大于2T的磁盘机制<br>GPT全称是<code>GUID Partition Table</code>，<strong>GUID</strong>指的是<strong>全球统一标识符</strong>（<strong>Globals Unique Identifiers</strong>）。</p>
<p>GPT分区需要硬件有UEFI接口。</p>
<hr>
<h3 id="硬盘接口类型"><a href="#硬盘接口类型" class="headerlink" title="硬盘接口类型"></a>硬盘接口类型</h3><ul>
<li><p><del><strong>IDE（ATA）</strong></del>：并口，每个控制器可接两块硬盘，早期PC机用的比较多，现在已经淘汰。<code>133MB/s</code></p>
</li>
<li><p><strong>SCSI（Small computer System Interface）</strong>：并口，可以接 N多块硬盘。转速高，寿命长，早期的服务器用的很多。<code>320MB/s</code>，目前面临淘汰。</p>
</li>
<li><p><strong>SAS （Serial Attached SCS）</strong>：串行SCSI，可以与SATA兼容。<code>600MB/s</code></p>
<blockquote>
<p>现在的x86服务器上，主流就是SAS口，可以支持SATA口的硬盘，也可支持SAS口的硬盘。</p>
</blockquote>
</li>
<li><p><strong>SATA（Serial ATA）</strong>：串行ATA口。目前很多台式机的机械硬盘是此类接口。</p>
<ul>
<li>SATA1：<code>150MB/s</code></li>
<li>SATA2：<code>300MB/s</code></li>
<li>SATA3：<code>600MB/s</code></li>
</ul>
</li>
<li><p><strong>mSATA（mini-SATA）</strong>：mini SATA口。好多笔记本的SSD用mini-SATA口，目前最新版是<strong>M.2</strong></p>
<ul>
<li>mSATA</li>
<li>M.2(mini-SATA 2)：socket3类型最高支持<code>4GB/s</code>。</li>
</ul>
</li>
<li><p><strong>PCI-e（PCI-express）</strong>：台式机的SSD，还有部分笔记本（比如苹果Macbook），用的是PCI-e，此接口比mSATA要快，最高支持<code>8GB/s</code></p>
</li>
<li><p><strong>USB（Universal Serial Bus）</strong>：u盘、移动硬盘。</p>
<ul>
<li>USB2.0：<code>60MB/s</code></li>
<li>USB3.0：<code>500MB/s</code></li>
<li>USB3.1（也叫type-c）：<code>1.2GB/s</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="查看分区（查）"><a href="#查看分区（查）" class="headerlink" title="查看分区（查）"></a>查看分区（查）</h2><h3 id="df查看磁盘状态"><a href="#df查看磁盘状态" class="headerlink" title="df查看磁盘状态"></a><code>df</code>查看磁盘状态</h3><p>df：disk free</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">* &#96;-h&#96;：human readable，人类可读<br>* &#96;-T&#96;：print type，输出格式。<br>[root@yulongjun ~]# df -hT<br>Filesystem     Type   Size  Used Avail Use% Mounted on<br>&#x2F;dev&#x2F;sda2      ext4    50G  5.2G   42G  11% &#x2F;<br>tmpfs          tmpfs  3.9G     0  3.9G   0% &#x2F;dev&#x2F;shm<br>&#x2F;dev&#x2F;sda1      ext4   190M   39M  142M  22% &#x2F;boot<br></code></pre></td></tr></table></figure>

<h3 id="fdisk-l-列出所有磁盘信息。"><a href="#fdisk-l-列出所有磁盘信息。" class="headerlink" title="fdisk -l 列出所有磁盘信息。"></a><code>fdisk -l</code> 列出所有磁盘信息。</h3><p>Id：</p>
<ul>
<li>83：Linux可以使用的文件系统。</li>
<li>8e：指的是逻辑卷（logical volume）</li>
</ul>
<p>常见的几种文件格式：<br>基本：<code>ext3</code>（CentOS 5默认）， <code>ext4</code>（CentOS 6默认），<code>xfs</code>（CentOS 7 默认）<br>光盘：<code>iso9660</code><br>可移动U盘：<code>fat32</code>（文件最大不能超过4G）， <code>exfat</code><br>windows：<code>ntfs</code>（linux可编译安装ntfs-3g来识别）</p>
<h2 id="创建分区（增）"><a href="#创建分区（增）" class="headerlink" title="创建分区（增）"></a>创建分区（增）</h2><p><code>fdisk /dev/sda</code>进入管理sda磁盘</p>
<p>常用的几个：</p>
<blockquote>
<p><code>m</code>：menu，列出帮助菜单<br><code>d</code>：delete，删除<br><code>n</code>：new，新建<br><code>p</code>：print，列出<br><code>t</code>：调整分区ID<br><code>l</code>：list，列出内核支持的分区ID<br>83 Linux（linux基础分区）<br>5 extend（扩展分区）<br>8e LVM（逻辑卷管理）<br>ee GPT（2T以上硬盘）<br>w：write，保存退出<br>q：quit，不保存退出</p>
</blockquote>
<p>new新分区的时候，如果是加主分区，只能加到第四个。如果想要更多的分区，可以把第四个加为扩展分区。然后再在扩展分区上创建分区。</p>
<hr>
<h2 id="删除分区（删）"><a href="#删除分区（删）" class="headerlink" title="删除分区（删）"></a>删除分区（删）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fdisk &#x2F;dev&#x2F;sda<br><br>d #进入删除模式<br><br># 输入要删除的分区号<br><br>w #保存退出<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="修改分区格式（改）"><a href="#修改分区格式（改）" class="headerlink" title="修改分区格式（改）"></a>修改分区格式（改）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">fdisk &#x2F;dev&#x2F;sda<br><br>t # 进入修改模式<br><br># 输入要修改的分区<br><br>L # 列出可以修改的格式<br><br># 输入要修改的格式的代码<br><br>w # 保存退出<br><br># 然后用到上面让内核识别的两个命令：<br>kpartx -af &#x2F;dev&#x2F;sda  # 强制添加分区到内核中<br>partx -a &#x2F;dev&#x2F;sda    # 再添加一次<br><br># 上述命令多次都不成功，只能重启了<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="通知内核识别新分区"><a href="#通知内核识别新分区" class="headerlink" title="通知内核识别新分区"></a>通知内核识别新分区</h2><p>CentOS 5，7：<code>partprobe</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">parprobe &#x2F;dev&#x2F;sda<br></code></pre></td></tr></table></figure>

<p>CentOS 6 ：<code>partx</code>，<code>kpartx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">kpartx -l &#x2F;dev&#x2F;sda   # 列出sda中可重新加载到内核的分区<br>kpartx -af &#x2F;dev&#x2F;sda  # 强制添加分区到内核中<br>partx -a &#x2F;dev&#x2F;sda    # 再添加一次<br></code></pre></td></tr></table></figure>

<p>CentOS 6 有时候不管用，只能重启系统(目前版本6.9，这个bug还没有修复。)，不过对于新硬盘，进行创建操作的时候，CentOS6不会有这个问题。</p>
<p>CentOS 5 和 7 使用<code>partprobe</code>即可，无bug。</p>
<hr>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><ol>
<li><p><code>mkfs -t FSTYPE /dev/DEVICE</code></p>
</li>
<li><p><code>mkfs.FSTYPE /dev/DEVICE</code></p>
</li>
<li><p><code>mkswap /dev/DEVICE</code> 创建交换分区。</p>
</li>
<li><pre><code>mke2fs
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>更加精细的操作<br><br>- &#96;-t&#96;：ext2, ext3, ext4, xfs<br>- &#96;-L&#96;：label，指定卷标名<br>- &#96;-b&#96;：block size ，（1024、2048、4096）默认是4k（4096）<br>- &#96;-i #&#96;: 为数据空间中每多少个字节创建一个inode；此大 小不应该小于block的大小<br>- &#96;-N #&#96;：指定分区中创建多少个inode<br>- &#96;-I #&#96; 一个inode记录占用的磁盘空间大小，128—4096<br>- &#96;-m #&#96;: 默认5%,为管理人员预留空间占总空间的百分比<br>- &#96;-O FEATURE[,...]&#96;：启用指定特性<br>- &#96;-O ^FEATURE&#96;：关闭指定特性<br>- &#96;-o&#96;: 调整文件系统的默认挂载选项，&#96;–o acl&#96;<br></code></pre></td></tr></table></figure>
mkfs.ext2 -O has_journal /dev/sda5
# 上面虽然指定的格式是ext2，但是启动journal特性，所以就变成了ext3了。
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; acl权限：&#96;xfs&#96;创建的默认就带&#96;acl&#96;权限，&#96;ext&#96;系列的格式的需要手工指定。<br><br>卷标的操作：<br>&#96;e2label &#x2F;dev&#x2F;DEVICE&#96;：查看卷标。<br>&#96;e2label &#x2F;dev&#x2F;DEVICE LABEL_NAME&#96;：修改卷标。<br><br>示例：<br></code></pre></td></tr></table></figure>
mkfs -t ext4 /dev/sda5
mkfs.ext4 /dev/sda5
mke2fs.ext4 -t ext4 -L DB /dev/sda5
mkswap /dev/sda6
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>## 查看磁盘分区的类型和uuid<br><br>在Linux里，设备名是有可能变动的，比如我们添加一块IDE的磁盘，会变成sda，系统原来的sda会变成sdb，这样，我们就不能用设备名来唯一表示设备，这时候我们就用到UUID。<br></code></pre></td></tr></table></figure>
blkid /dev/DEVICE
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- UUID 设备唯一标识<br>- TYPE 文件系统类型<br></code></pre></td></tr></table></figure>
blkid /dev/sda5
</code></pre></li>
</ol>
<p>/dev/sda5 UUID=”XXXXXXXX” TYPE=”ext4”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>## 检测和修复文件系统<br><br>检测修复**ext**类型的文件系统<br>&#96;fsck DEVICE&#96; ：file system check ,文件系统检测<br>&#96;fsck -t ext4 &#x2F;dev&#x2F;sda5&#96;检测文件系统错误<br>&#96;fsck -r DEVICE&#96;:交互式检测文件系统<br>&#96;fsck -y DEVICE&#96;：不用交互，一路确认检测文件系统。<br><br>检测修复**xfs**类型的文件系统，要用另外一个命令：<br>&#96;xfs_check -y DEVICE&#96;<br><br>&gt; tips：&#96;xfs_check&#96;命令需要安装&#96;xfsprogs&#96;包<br><br>## 挂载<br><br>挂载的本质就是调用&#96;blkid&#96;查看设备UUID，然后查找到设备，进行挂载。<br><br>### (1)手动挂载<br><br>**挂载交换分区**：<br>&#96;swapon &#x2F;dev&#x2F;sda6&#96;启用指定的交换分区<br>&#96;swapon -a&#96;启用所有的交换分区<br>&#96;swapon -s&#96; 显示交换分区的挂载情况<br>**卸载交换分区**：<br>&#96;swapoff &#x2F;dev&#x2F;sda6&#96;关闭指定的交换分区<br>&#96;swapoff -a&#96; 关闭所有的临时交换分区<br><br>**挂载普通分区**：<br>&#96;mount [-t FILETYPE] [-o option] &#x2F;dev&#x2F;DEVICE DIRECTORY&#96;<br>参数详解：<br><br>**卸载普通分区**：<br>&#96;umount &#x2F;dev&#x2F;DEVICE&#96; 或者&#96;umount &#x2F;DIRECTORY&#96;，具体参数情况，见文章最后一节：**附2：mount命令详解**<br><br>**查看挂载信息**：<br>&#96;mount&#96;<br><br>示例：<br></code></pre></td></tr></table></figure>
<p>mount -t ext4  /dev/sda5  /u01</p>
<p>mount -t iso9660  -o loop xxx.iso /media</p>
<p>mount</p>
<p>umount /dev/sda5</p>
<p>unmount /media</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br><br>### (2)永久挂载<br><br>修改&#96;&#x2F;etc&#x2F;fstab&#96;配置文件。<br>&#96;fstab&#96;：file system table<br></code></pre></td></tr></table></figure>
<p>[root❄CentOS6 ~]☭ cat /etc/fstab </p>
<p>#</p>
<h1 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Wed-May-17-01-52-09-2017"><a href="#Created-by-anaconda-on-Wed-May-17-01-52-09-2017" class="headerlink" title="Created by anaconda on Wed May 17 01:52:09 2017"></a>Created by anaconda on Wed May 17 01:52:09 2017</h1><p>#</p>
<h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><p>#<br>UUID=964e8f82-ef35-4b1e-ae3f-9a95e36b5ee2 /                       ext4    defaults        1 1<br>UUID=899d5f64-7a0c-4aba-b77f-a94f9c6df085 /app                    ext4    defaults        1 2<br>UUID=ce69275d-68f5-46c7-975b-785e653d3d79 /boot                   ext4    defaults        1 2<br>UUID=3aa122ef-cf5f-4198-81a7-48b799c9d914 swap                    swap    defaults        0 0<br>tmpfs                   /dev/shm                tmpfs   defaults        0 0<br>devpts                  /dev/pts                devpts  gid=5,mode=620  0 0<br>sysfs                   /sys                    sysfs   defaults        0 0<br>proc                    /proc                   proc    defaults        0 0<br>/dev/sr0        /media            iso9660 defaults    0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>字段从左到右含义：<br><br>- 要挂载的设备<br><br>  ：<br><br>  - 设备文件&#96;&#x2F;dev&#x2F;sda&#96;、&#96;&#x2F;dev&#x2F;sr0&#96;<br>  - 卷名&#96;LABEL&#x3D;&quot;ladel&quot;&#96;<br>  - UUID&#96;UUID&#x3D;xxx&#96;<br><br>- **挂载点**：挂载在那个目录下面。有的文件系统没有挂载点 ，例如&#96;swap&#96;，挂载点为&#96;swap&#96;。<br><br>- **文件系统类型**：&#96;ext2,3,4&#96;、&#96;xfs&#96;、&#96;iso9660&#96;<br><br>- 挂载选项<br><br>  ：多个选项间使用逗号分隔<br><br>  - &#96;loop&#96;：loop设备<br>  - &#96;ro&#96;：只读（默认rw）<br>  - &#96;pri&#x3D;xxx&#96;：priority，优先级，默认都是&#96;-1&#96;，你可以写&#96;0~65535&#96;，数值越大，优先级越高。<br><br>- **转储频率**：<br>  &#96;0&#96;：从不备份（CentOS7 采用xfs，默认从不备份）<br>  &#96;1&#96;：每日备份（6 采用ext4，默认是1）<br>  &#96;2&#96;：每隔一天备份（很少使用）<br><br>- **自检次序**：<br>  &#96;1&#96;：首先自检，通常只能被&#x2F;使用<br>  &#96;2-9&#96;：顺序<br>  &#96;0&#96;：从不自检（默认从不自检）<br><br>&#x2F;etc&#x2F;fstab里写挂载的几个特殊例子：<br></code></pre></td></tr></table></figure>
<p>#目录挂目录<br>/boot /mnt/boot none bind 0 0</p>
<h1 id="loop文件挂目录"><a href="#loop文件挂目录" class="headerlink" title="loop文件挂目录"></a>loop文件挂目录</h1><p>/app/partfile /mnt/part loop 0 0<br>#windows共享挂目录<br>//winsvr_url/share_file /mnt/win cifs 0 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 实验：将swap分区迁移到高速磁盘上，优化性能，原swap不删除，作为次swap。(提示：利用pritory优先级）<br></code></pre></td></tr></table></figure>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>------<br><br>## 卸载<br><br>- 查看挂载情况:<br>  &#96;findmnt MOUNT_POINT&#96;<br>- 查看正在访问指定文件系统的进程：<br>  &#96;lsof MOUNT_POINT&#96;或&#96;fuser -v MOUNT_POINT&#96;<br>- 终止所有在正访问指定的文件系统的进程：<br>  &#96;fuser -km MOUNT_POINT&#96;<br>- 卸载：<br>  &#96;umount DEVICE&#96;<br>  &#96;umount MOUNT_POINT&#96;<br><br>------<br><br>## 附1：其他常用命令<br><br>### findmnt<br><br>&#96;findmnt &#x2F;DEVICE&#96;或者&#96;findmnt PATH&#96;<br>查找某个设备是否挂载，或者某个路径是否为挂载点。<br></code></pre></td></tr></table></figure>
<p>[root❄centos7 ~]☭ findmnt /dev/sdb5<br>[root❄centos7 ~]☭ echo $?<br>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>查看&#x2F;mnt&#x2F;sdb5是否是挂载点，如果不是，就把&#x2F;dev&#x2F;sdb5挂载在&#x2F;mnt&#x2F;sdb5上。<br></code></pre></td></tr></table></figure>
<p>findmnt /mnt/sdb5 &gt;&gt; /dev/null || mount /dev/sdb5 /mnt/sdb5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>### findfs<br></code></pre></td></tr></table></figure>
<p>findfs LABEL=xxxxx<code></code>findfs UUID=xxxxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>查找&#96;dir&#96;对应的&#96;uuid&#96;的挂载磁盘<br></code></pre></td></tr></table></figure>
<p>[root❄centos7 ~]☭ dir=/;findfs <code>egrep &quot;$dir[[:space:]]+&quot; /etc/fstab | cut -d&quot; &quot; -f1</code><br>/dev/sda2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br><br>&gt; tips: 一个设备可以挂载到不同的挂载点。<br>&gt; 不同的设备，可以挂载到同一个挂载点，最后一个挂载的设备生效。<br><br>------<br><br>\##附2：mount命令详解<br><br>**参数解析：**<br><br>&gt; **device**：指明要挂载的设备；<br><br>- 设备文件：例如&#96;&#x2F;dev&#x2F;sda5&#96;<br>- 卷标：&#96;-L &#39;LABEL&#39;&#96;, 例如 &#96;-L &#39;MYDATA&#39;&#96;<br>- &#96;UUID, -U &#39;UUID&#39;&#96;：例如 &#96;-U &#39;0c50523c-43f1-45e7-85c0-a126711d406e&#39;&#96;<br>- 伪文件系统名称：proc, sysfs, devtmpfs, configfs<br><br>&gt; **dir**：挂载点<br><br>事先存在；建议使用空目录<br><br>进程正在使用中的设备无法被卸载<br><br>&gt; **-t vsftype**<br><br>指定要挂载的设备上的文件系统类型<br><br>&gt; **-fnrsvw**：<br><br>- &#96;-r&#96;: readonly，只读挂载<br>- &#96;-w&#96;: read and write, 读写挂载<br>- &#96;-n&#96;: 不更新&#x2F;etc&#x2F;mtab，mount不可见(可以用&#96;cat &#x2F;proc&#x2F;mounts&#96;看到挂载）<br>- &#96;-a&#96;：自动挂载所有支持自动挂载的设备(定义在了&#x2F;etc&#x2F;fstab 文件中，且挂载选项中有auto功能)<br>- &#96;-L &#39;LABEL&#39;&#96;: 以卷标指定挂载设备<br>- &#96;-U &#39;UUID&#39;&#96;: 以UUID指定要挂载的设备<br>- &#96;-B, --bind&#96;: **绑定目录到另一个目录上**<br></code></pre></td></tr></table></figure>
<p>mount -B /var/ftp/pub /var/www/html/</p>
<h1 id="这样可以实现同一份数据，在两个地方。"><a href="#这样可以实现同一份数据，在两个地方。" class="headerlink" title="这样可以实现同一份数据，在两个地方。"></a>这样可以实现同一份数据，在两个地方。</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 查看内核追踪到的已挂载的所有设备：&#96;cat &#x2F;proc&#x2F;mounts&#96;<br><br>&gt; **-o options**：(挂载文件系统的选项)，多个选项使用逗号分隔<br><br>- &#96;async&#96;：异步模式<br>- &#96;sync&#96;：同步模式,内存更改时，同时写磁盘<br>- &#96;atime&#x2F;noatime&#96;：包含目录和文件的访问时间戳<br>- &#96;diratime&#x2F;nodiratime&#96;：目录的访问时间戳<br>- &#96;auto&#x2F;noauto&#96;：是否支持自动挂载,是否支持-a选项<br>- &#96;exec&#x2F;noexec&#96;：是否支持将文件系统上运行应用程序<br>- &#96;dev&#x2F;nodev&#96;：是否支持在此文件系统上使用设备文件<br>- &#96;suid&#x2F;nosuid&#96;：是否支持suid和sgid权限<br>- **&#96;remount&#96;：重新挂载**<br>- **&#96;ro&#96;：只读**<br>- **&#96;rw&#96;：读写**<br>- &#96;user&#x2F;nouser&#96;：是否允许普通用户挂载此设备，默认管理员才能挂载<br>- &#96;acl&#96;：启用此文件系统上的acl功能<br>- &#96;Defaults&#96;：相当于&#96;rw, nosuid, dev, exec, auto, nouser, async&#96;<br><br>### 附3：loop特殊设备<br><br>CentOS 6 默认只支持8个loop设备，7没有限制(每增加一个，control会去生成一个）:<br></code></pre></td></tr></table></figure>
<p>[root❄CentOS6 ~]☭ ls /dev/loop*<br>/dev/loop0  /dev/loop2  /dev/loop4  /dev/loop6<br>/dev/loop1  /dev/loop3  /dev/loop5  /dev/loop7<br>[root❄centos7 ~]☭ ll /dev/loop*<br>crw-rw—- 1 root disk 10, 237 Jun 14 10:17 /dev/loop-control</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>要想让6支持更多，要更改内核参数,kernel那一行，最后面加上&#96;max_loop&#x3D;数量&#96;参数<br></code></pre></td></tr></table></figure>
<p>…<br>kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=UUID=964e8f82-ef35-4b1e-ae3f-9a95e36b5ee2 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet max_loop=100<br>…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>**&#96;losetup&#96;命令**<br><br>指定loop号挂载，可以不用按顺序挂载<br><br>&#96;losetup -a&#96; ：显示系统挂载的loop设备(CentOS 7 不用加&#96;-a&#96;)<br>&#96;losetup LOOP-DEVICE LOOP-FILE&#96;：关联loop文件到指定的loop设备上<br></code></pre></td></tr></table></figure>
<p>losetup  /dev/loop9 /app/partfile9 #关联loop文件到指定的/dev/loop设备上<br>mount /dev/loop9 /mnt/part9 # 把关联的设备挂载到目录上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>挂载Windows共享文件：<br></code></pre></td></tr></table></figure>
<p>mkdir /mnt/win</p>
<p>mount -o username=test,password=magedu //192.168.8.1/winshare /mnt/win</p>
<pre><code>
</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>磁盘存储</tag>
      </tags>
  </entry>
  <entry>
    <title>01-程序包管理工具rpm</title>
    <url>/01-%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7rpm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rpm就是一个程序的打包工具。在安装软件的时候，可以把不同的目录拷贝到相应的目录下（如二进制文件，配置文件等等。）</p>
<p>RedHat里全名叫<code>Redhat Package Management</code></p>
<p>SuSe为了避免冲突，就叫<code>RPM Package Management</code>（类似于GNU，<code>GNU is not a unix</code>）</p>
<p><strong>rpm包格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">程序报名-版本号-打包号.操作系统号.架构.rpm&#96;如：&#96;vsftpd-3.0.2-21.el7.x86_64.rpm<br></code></pre></td></tr></table></figure>

<p>插入小练习，查看rpm包架构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 第一种方法<br>ls *.rpm |rev|cut -d. -f2|rev|sort | uniq -c<br>   1337 noarch<br>   2494 x86_64<br>   <br># 第二种方法<br>ls *rpm |egrep -o &quot;[^.]+\.rpm&quot; | cut -d. -f1 |sort |uniq -c<br>   1337 noarch<br>   2494 x86_64<br></code></pre></td></tr></table></figure>

<p><strong>包里面内容：</strong></p>
<ul>
<li><code>path/files</code> 要安装的文件和相对路径</li>
<li><code>metadata</code> 元数据</li>
<li><code>scripts</code> 脚本(安装前脚本、安装后脚本、卸载前脚本、卸载后脚本）</li>
</ul>
<p><strong>包安装信息数据库：</strong><code>/var/lib/rpm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">* 程序包名称及版本<br>* 依赖关系<br>* 功能说明<br>* 包安装后生成的各文件路径及校验码信息<br></code></pre></td></tr></table></figure>

<h2 id="程序包的来源"><a href="#程序包的来源" class="headerlink" title="程序包的来源"></a>程序包的来源</h2><h3 id="1-系统发版的光盘或官方的服务器；"><a href="#1-系统发版的光盘或官方的服务器；" class="headerlink" title="1. 系统发版的光盘或官方的服务器；"></a>1. 系统发版的光盘或官方的服务器；</h3><p>CentOS官网：<a href="https://www.centos.org/download/" target="_blank" rel="noopener">https://www.centos.org/download/</a><br>阿里云：<a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com</a><br>网易：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com</a><br>清华：<a href="https://mirror.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/</a><br>中科大：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a><br>浙大：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></p>
<h3 id="2-项目官方站点"><a href="#2-项目官方站点" class="headerlink" title="2. 项目官方站点"></a>2. 项目官方站点</h3><p>举几个例子：</p>
<p><a href="https://grafana.com/grafana/download" target="_blank" rel="noopener">https://grafana.com/grafana/download</a></p>
<p><a href="https://portal.influxdata.com/downloads#influxdb" target="_blank" rel="noopener">https://portal.influxdata.com/downloads#influxdb</a></p>
<h3 id="3-第三方组织"><a href="#3-第三方组织" class="headerlink" title="3. 第三方组织"></a>3. 第三方组织</h3><p><code>Fedora-EPEL</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Extra Packages for Enterprise Linux<br></code></pre></td></tr></table></figure>

<p>基本上镜像站都提供epel源。</p>
<h3 id="4-搜索引擎："><a href="#4-搜索引擎：" class="headerlink" title="4. 搜索引擎："></a>4. 搜索引擎：</h3><p><a href="http://pkgs.org/" target="_blank" rel="noopener">http://pkgs.org</a></p>
<p><a href="http://rpmfind.net/" target="_blank" rel="noopener">http://rpmfind.net</a></p>
<p><a href="http://rpm.pbone.net/" target="_blank" rel="noopener">http://rpm.pbone.net</a></p>
<p><a href="https://sourceforge.net/" target="_blank" rel="noopener">https://sourceforge.net/</a></p>
<h3 id="5-自己制作"><a href="#5-自己制作" class="headerlink" title="5. 自己制作"></a>5. 自己制作</h3><p>注意：第三方包建议要检查其合法性</p>
<ul>
<li>来源合法性</li>
<li>程序包的完整性</li>
</ul>
<hr>
<h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><h3 id="安装卸载"><a href="#安装卸载" class="headerlink" title="安装卸载"></a>安装卸载</h3><p><code>-i</code>：install ,安装<br><code>-v</code>：verbose,显示详情<br><code>-h</code>：显示进度条<br><code>-e</code>：erase，删除（卸载）<br><code>-U</code> upgrade，升级<br><code>--force</code>强制安装（不能用于强制卸载）<br><code>--test</code>： 测试安装，不真正执行安装。<br><code>--nodeps</code>：忽略依赖性（一般不忽略）<br><code>--oldpackage</code> 降级安装（一般不降级）</p>
<p>内核安装默认是不覆盖安装的，装了多个kernel，可以修改<code>grub.conf</code>修改默认启动内核顺序。可以<code>rpm -e</code>卸载旧的kernel</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><code>rpm -q PackageName</code>查询某个包<br><code>rpm -qa</code> 查询已安装的所有包<br><code>rpm -qa |grep xxx</code> 模糊过滤<br><code>rpm -qf FILE</code> 硬盘上的文件(file)是来自于哪个rpm包（可以是二进制程序，也可以是配置文件等）<br><code>rpm -qi xxx.rpm</code> 查询安装包详细信息（information）<br><code>rpm -ql xxx.rpm</code> 查看某个包安装后在系统里的所有文件<br><code>rpm -qc xxx</code> 查询安装包后的配置（config）文件位置<br><code>rpm -q --scripts</code>查询程序自带的脚本</p>
<h3 id="rpm校验"><a href="#rpm校验" class="headerlink" title="rpm校验"></a>rpm校验</h3><p><code>rpm --import xxx/yyy/RPM-GPG-KEY-CentOS-7</code>：导入包完整性校验文件<br><code>rpm -K xxxxx.rpm</code>校验某个包</p>
<p>查找安装gpg-pubkey<br><code>rpm -qa &quot;gpg-*&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjianPackages]# rpm --import &#x2F;media&#x2F;RPM-GPG-KEY-CentOS-7 <br>[root@ashjianPackages]# rpm -K tree-1.6.0-10.el7.x86_64.rpm <br>[root@ashjianPackages]# rpm -qa &quot;gpg-*&quot;<br>gpg-pubkey-f4a80eb5-53a7ff4b<br>[root@ashjianPackages]# rpm -e gpg-pubkey <br>[root@ashjianPackages]# rpm -K tree-1.6.0-10.el7.x86_64.rpm <br>tree-1.6.0-10.el7.x86_64.rpm: RSA sha1 ((MD5) PGP) md5 NOT OK (MISSING KEYS: (MD5) PGP#f4a80eb5)<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>软件包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>01-进程</title>
    <url>/01-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14986992717977.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826225210.jpg" alt="img"></a></p>
<h2 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h2><p><a href="http://www.yulongjun.com/images/14986313663372.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826225702.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/14986313948908.jpg" target="_blank" rel="noopener"><img src="01-%E8%BF%9B%E7%A8%8B.assets/14986313948908.jpg" alt="img"></a></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a><code>pstree</code></h3><p><code>-p</code> 把各个子线程都详细显示出来<br><a href="http://www.yulongjun.com/images/14986972774775.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235006.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/14986972925727.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235616.jpg" alt="img"></a></p>
<h3 id="ps-进程状态（process-state）"><a href="#ps-进程状态（process-state）" class="headerlink" title="ps 进程状态（process state）"></a><code>ps</code> 进程状态（process state）</h3><p>UNIX风格：<code>ps -ef</code><br>BSD风格：<code>ps aux</code></p>
<p>还有用到o参数，选项显示定制的信息：<br><code>pid、comm、%cpu、%mem、state、tty、euser、ruser、psr</code></p>
<p>psr:用的哪颗cpu</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ps axo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,comm<br>ps -eo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ni</code>: nice值</li>
<li><code>pri</code>: priority 优先级(数越大优先级越高，跟前面图里的system优先级反过来）</li>
<li><code>psr</code>: processor CPU编号</li>
<li><code>rtprio</code>: 实时优先级</li>
</ul>
<p>示例：</p>
<p><a href="http://www.yulongjun.com/images/14986973769753.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235638.jpg" alt="img"></a></p>
<p><code>ps -C PROCESSNAME</code><br>单独显示某个进程，可以加o参数扩展。<br><a href="http://www.yulongjun.com/images/14986974585582.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235638.jpg" alt="img"></a></p>
<p><strong>STAT</strong>：进程状态<br><a href="http://www.yulongjun.com/images/14986975425807.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235653.jpg" alt="img"></a></p>
<p><code>R</code>：running</p>
<p><code>S</code>: interruptable sleeping</p>
<p><code>D</code>: uninterruptable sleeping</p>
<p><code>T</code>: stopped</p>
<p><code>Z</code>: zombie</p>
<p><code>+</code>: 前台进程</p>
<p><code>l</code>: 多线程进程</p>
<p><code>L</code>：内存分页并带锁</p>
<p><code>N</code>：低优先级进程</p>
<p><code>&lt;</code>: 高优先级进程</p>
<p><code>s</code>: session leader，会话（子进程）发起者</p>
<h3 id="nice-调整优先级"><a href="#nice-调整优先级" class="headerlink" title="nice 调整优先级"></a><code>nice</code> 调整优先级</h3><p>运行某个命令，指定优先级：<br><code>nice -n -XX COMMAND</code> :xx范围是<code>-20~19</code></p>
<p>在运行中的程序，修改优先级：<br><code>renice -n -XX PID</code>:xx范围是<code>-20~19</code></p>
<h3 id="pgrep-搜索进程信息"><a href="#pgrep-搜索进程信息" class="headerlink" title="pgrep 搜索进程信息"></a><code>pgrep</code> 搜索进程信息</h3><p><code>-u uid</code>: effective user，生效者</p>
<p><code>-U uid</code>: real user，真正发起运行命令者</p>
<p><code>-t terminal</code>: 与指定终端相关的进程</p>
<p><code>-l</code>: 显示进程名</p>
<p><code>-a</code>: 显示完整格式的进程名</p>
<p><code>-P pid</code>: 显示指定进程的子进程</p>
<h3 id="pidof按确切的程序名称显示pid"><a href="#pidof按确切的程序名称显示pid" class="headerlink" title="pidof按确切的程序名称显示pid"></a><code>pidof</code>按确切的程序名称显示pid</h3><p>命令绝对路径：<code>/sbin/pidof</code><br>用法：<code>pidof COMMAND</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pidof httpd<br>echo $? # 将来在脚本里可以判断进程是否存在<br></code></pre></td></tr></table></figure>

<h3 id="uptime显示启动状态"><a href="#uptime显示启动状态" class="headerlink" title="uptime显示启动状态"></a><code>uptime</code>显示启动状态</h3><p>显示当前时间，系统已启动的时间、当前上线人数，系统平 均负载（1、5、10分钟的平均负载，一般不会超过1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root@centos6 ~]# uptime<br> 17:18:44 up 11:40,  2 users,  load average: 0.00, 0.00, 0.00<br></code></pre></td></tr></table></figure>

<ul>
<li>系统平均负载: 指在特定时间间隔内运行队列中的平均进程数。</li>
<li>通常每个CPU内核的当前活动进程数不大于3，那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题。</li>
<li>如果linux主机是1个双核CPU，当Load Average为6的时候说明机器已经被充分使用。</li>
</ul>
<h3 id="top显示进程使用系统资源情况"><a href="#top显示进程使用系统资源情况" class="headerlink" title="top显示进程使用系统资源情况"></a><code>top</code>显示进程使用系统资源情况</h3><p><a href="http://www.yulongjun.com/images/14986421994505.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235653.jpg" alt="img"></a></p>
<p><strong>第一行：相当于uptime命令</strong><br><strong>第二行：进程信息</strong><br><strong>第三行：CPU使用情况</strong><br><strong>第四行：内存使用情况</strong><br><strong>第五行：交换分区swap使用情况</strong></p>
<p>cpu那行：</p>
<ul>
<li><code>us</code>：user, 用户空间占用</li>
<li><code>sy</code>：system, 内核空间占用</li>
<li><code>ni</code>：调整nice时间</li>
<li><code>id</code>：idle, 空闲</li>
<li><code>wa</code>：wait, 等待IO时间</li>
<li><code>hi</code>：hard interupt, 硬中断</li>
<li><code>si</code>：soft interupt, 软中断（模式切换）</li>
<li><code>st</code>：stole, 虚拟机偷走的时间</li>
</ul>
<p><strong>排序</strong><br>在打开top后，可以按快捷键进行自定义排序：</p>
<ul>
<li><code>P</code>：以占据的CPU百分比,%CPU</li>
<li><code>M</code>：占据内存百分比,%MEM</li>
<li><code>T</code>：累积占据CPU时长,TIME+</li>
</ul>
<p>首部信息是否显示：</p>
<ul>
<li>uptime信息：<code>l</code>（字母l）</li>
<li>tasks及cpu信息：<code>t</code></li>
<li>cpu分别显示：<code>1</code>（数字1）</li>
<li>memory信息：<code>m</code></li>
<li>退出命令：<code>q</code></li>
<li>修改刷新时间间隔：<code>s</code></li>
<li>终止指定进程：<code>k</code></li>
<li>保存文件：<code>W</code></li>
</ul>
<h3 id="vmstat虚拟内存信息"><a href="#vmstat虚拟内存信息" class="headerlink" title="vmstat虚拟内存信息"></a><code>vmstat</code>虚拟内存信息</h3><p>用法示例：<br><code>vmstat 2 5</code>: 每2秒刷一次，刷5次<br>选项：<code>-s</code>: 显示内存的统计数据</p>
<p><a href="http://www.yulongjun.com/images/14986436971472.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826235736.jpg" alt="img"></a></p>
<p>显示中的各项含义：</p>
<ul>
<li><p>procs</p>
<p>:</p>
<ul>
<li><code>r</code>：可运行（正运行或等待运行）进程的个数，和核心数有关</li>
<li><code>b</code>：处于不可中断睡眠态的进程个数(被阻塞的队列的长度)</li>
</ul>
</li>
<li><p>memory</p>
<p>：</p>
<ul>
<li><code>swpd</code>: 交换内存的使用总量</li>
<li><code>free</code>：空闲物理内存总量</li>
<li><code>buffer</code>：用于buffer的内存总量</li>
<li><code>cache</code>：用于cache的内存总量</li>
</ul>
</li>
<li><p>swap</p>
<p>:</p>
<ul>
<li><code>si</code>：从磁盘交换进内存的数据速率(kb/s)</li>
<li><code>so</code>：从内存交换至磁盘的数据速率(kb/s)</li>
</ul>
</li>
<li><p>io</p>
<p>：</p>
<ul>
<li><code>bi</code>：从块设备读入数据到系统的速率(kb/s)</li>
<li><code>bo</code>: 保存数据至块设备的速率</li>
</ul>
</li>
<li><p>system</p>
<p>：</p>
<ul>
<li><code>in</code>: interrupts 中断速率，包括时钟</li>
<li><code>cs</code>: context switch 进程切换速率</li>
</ul>
</li>
<li><p>cpu</p>
<p>：</p>
<ul>
<li><code>us</code>:Time spent running non-kernel code</li>
<li><code>sy</code>: Time spent running kernel code</li>
<li><code>id</code>: Time spent idle. Linux 2.5.41前,包括IO-wait time.</li>
<li><code>wa</code>: Time spent waiting for IO.2.5.41前，包括in idle.</li>
<li><code>st</code>: Time stolen from a virtual machine.2.6.11前, unknown.</li>
</ul>
</li>
</ul>
<h3 id="iostat-CPU和磁盘IO"><a href="#iostat-CPU和磁盘IO" class="headerlink" title="iostat CPU和磁盘IO"></a><code>iostat</code> CPU和磁盘IO</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#96;iostat 1 10&#96; 每1秒刷新一次，刷新10次<br></code></pre></td></tr></table></figure>

<h3 id="pmap-进程对应的内存映射"><a href="#pmap-进程对应的内存映射" class="headerlink" title="pmap 进程对应的内存映射"></a><code>pmap</code> 进程对应的内存映射</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pmap [options] pid [...]<br></code></pre></td></tr></table></figure>

<ul>
<li>-x: 显示详细格式的信息</li>
</ul>
<h3 id="glances-监控其他机器"><a href="#glances-监控其他机器" class="headerlink" title="glances 监控其他机器"></a><code>glances</code> 监控其他机器</h3><p>C/S模式下运行glances命令</p>
<ul>
<li>服务器模式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">glances -s -B IPADDR<br></code></pre></td></tr></table></figure>

<p>IPADDR: 指明监听的本机哪个地址</p>
<ul>
<li>客户端模式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">glances -c IPADDR<br></code></pre></td></tr></table></figure>

<p>IPADDR：要连入的服务器端地址</p>
<h2 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h2><p>默认采用<code>-cdngy</code>参数<br><a href="http://www.yulongjun.com/images/14986987874666.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827001800.jpg" alt="img"></a></p>
<ul>
<li>-c: 显示cpu相关信息<ul>
<li>-C #,#,…,total</li>
<li><a href="http://www.yulongjun.com/images/14986990175335.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827001814.jpg" alt="img"></a></li>
</ul>
</li>
<li>-d: 显示disk相关信息<ul>
<li>-D total,sda,sdb,…</li>
</ul>
</li>
</ul>
<p><a href="http://www.yulongjun.com/images/14986990762878.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827001848.jpg" alt="img"></a></p>
<p>-g：显示page相关统计数据(交换分区）</p>
<p>-m: 显示memory相关统计数据</p>
<p>-n: 显示network相关统计数据</p>
<p>-p: 显示process相关统计数据</p>
<p>-r: 显示io请求相关的统计数据</p>
<p>-s: 显示swapped相关的统计数据</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>02-DNS如何工作</title>
    <url>/02-DNS%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="根服务器"><a href="#根服务器" class="headerlink" title="根服务器"></a>根服务器</h2><p>如前所述，DNS 的核心是一个分层系统。在这个系统的顶部是所谓的 “根服务器”。这些服务器由各种组织控制，并由 ICANN（互联网名称和数字地址分配公司）授权。</p>
<p>目前正在使用的根服务器有 13 个。但是，由于每分钟都要解析的名称数量多得令人难以置信，所以实际上每个根服务器都有镜像服务器。有关这个一个有趣的事情是，每个根服务器与它的镜像服务器共享同一个 IP 地址。当你对某个根服务器发出请求时，请求会被路由到该根服务器离你最近的镜像服务器。</p>
<p>这些根服务器做什么的？根服务器处理有关顶级域名信息的请求。因此，如果某个请求低级别名称服务器无法解析，则会向该域的根服务器进行查询。</p>
<p>根服务器不知道实际托管域名的位置。然而，他们会将请求引导到处理特定请求的顶级域名的名称服务器。</p>
<p>因此，如果向根服务器发出对 “<a href="http://www.wikipedia.org”" target="_blank" rel="noopener">www.wikipedia.org”</a> 的请求，则根服务器不能在它的记录文件中找到与 “<a href="http://www.wikipedia.org”" target="_blank" rel="noopener">www.wikipedia.org”</a> 匹配的记录。</p>
<p>但是它会找到 “org” TLD 的记录，并把负责 “org” 地址的名称服务器的地址发回给请求者。</p>
<p>定义根服务器的文件地址：<code>/var/named/named.ca</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">;; ANSWER SECTION:<br>.			518400	IN	NS	a.root-servers.net.<br>.			518400	IN	NS	b.root-servers.net.<br>.			518400	IN	NS	c.root-servers.net.<br>.			518400	IN	NS	d.root-servers.net.<br>.			518400	IN	NS	e.root-servers.net.<br>.			518400	IN	NS	f.root-servers.net.<br>.			518400	IN	NS	g.root-servers.net.<br>.			518400	IN	NS	h.root-servers.net.<br>.			518400	IN	NS	i.root-servers.net.<br>.			518400	IN	NS	j.root-servers.net.<br>.			518400	IN	NS	k.root-servers.net.<br>.			518400	IN	NS	l.root-servers.net.<br>.			518400	IN	NS	m.root-servers.net.<br><br>;; ADDITIONAL SECTION:<br>a.root-servers.net.	3600000	IN	A	198.41.0.4<br>a.root-servers.net.	3600000	IN	AAAA	2001:503:ba3e::2:30<br>b.root-servers.net.	3600000	IN	A	192.228.79.201<br>b.root-servers.net.	3600000	IN	AAAA	2001:500:84::b<br>c.root-servers.net.	3600000	IN	A	192.33.4.12<br>c.root-servers.net.	3600000	IN	AAAA	2001:500:2::c<br>d.root-servers.net.	3600000	IN	A	199.7.91.13<br>d.root-servers.net.	3600000	IN	AAAA	2001:500:2d::d<br>e.root-servers.net.	3600000	IN	A	192.203.230.10<br>e.root-servers.net.	3600000	IN	AAAA	2001:500:a8::e<br>f.root-servers.net.	3600000	IN	A	192.5.5.241<br>f.root-servers.net.	3600000	IN	AAAA	2001:500:2f::f<br>g.root-servers.net.	3600000	IN	A	192.112.36.4<br>g.root-servers.net.	3600000	IN	AAAA	2001:500:12::d0d<br>h.root-servers.net.	3600000	IN	A	198.97.190.53<br>h.root-servers.net.	3600000	IN	AAAA	2001:500:1::53<br>i.root-servers.net.	3600000	IN	A	192.36.148.17<br>i.root-servers.net.	3600000	IN	AAAA	2001:7fe::53<br>j.root-servers.net.	3600000	IN	A	192.58.128.30<br>j.root-servers.net.	3600000	IN	AAAA	2001:503:c27::2:30<br>k.root-servers.net.	3600000	IN	A	193.0.14.129<br>k.root-servers.net.	3600000	IN	AAAA	2001:7fd::1<br>l.root-servers.net.	3600000	IN	A	199.7.83.42<br>l.root-servers.net.	3600000	IN	AAAA	2001:500:9f::42<br>m.root-servers.net.	3600000	IN	A	202.12.27.33<br>m.root-servers.net.	3600000	IN	AAAA	2001:dc3::35<br></code></pre></td></tr></table></figure>

<h2 id="TLD-服务器"><a href="#TLD-服务器" class="headerlink" title="TLD 服务器"></a>TLD 服务器</h2><p>请求者然后向负责该请求的顶级域名的 IP 地址（由根服务器给予）发送新请求。</p>
<p>对于我们的例子，它会发送想负责 “org” 域名的名称服务器发送一个请求，看看它是否知道 “<a href="http://www.wikipedia.org”" target="_blank" rel="noopener">www.wikipedia.org”</a> 在哪里。</p>
<p>同样，该名称服务器也不会在记录文件中找到 “<a href="http://www.wikipdia.org”" target="_blank" rel="noopener">www.wikipdia.org”</a> 记录。</p>
<p>但是，它会找到负责 “wikipedia.org” 的名称服务器的 IP 地址。这样就越来越接近我们想要的答案了。</p>
<h2 id="域名级别名称服务器"><a href="#域名级别名称服务器" class="headerlink" title="域名级别名称服务器"></a>域名级别名称服务器</h2><p>此时，请求者知道了具体负责该资源的实际 IP 地址的名称服务器的 IP 地址。它向该名称服务器发送一个新的请求，再次询问它是否可以解析 “<a href="http://www.wikipedia.org”。" target="_blank" rel="noopener">www.wikipedia.org”。</a></p>
<p>名称服务器检查其区域文件，并发现它有与 “wikipedia.org” 相关联的区域文件。在此文件的内部，有一个 “www” 主机的记录。此记录说明此主机所在的 IP 地址，并向请求者返回最终答案。</p>
<h2 id="请求者是什么？"><a href="#请求者是什么？" class="headerlink" title="请求者是什么？"></a>请求者是什么？</h2><p>在上面的场景中，我们引用了 “请求者”。在这种情况下请求者指的是什么？</p>
<p>在几乎所有情况下，请求者都是我们所谓的 “解析名称服务器”。解析名称服务器是配置着为询问其他服务器的问题的。它基本上是用户的中介，它缓存着先前的查询结果来提高速度，并且知道根服务器的地址，以便能够 “解析” 它还不知道的域名。</p>
<p>基本上，用户通常会在其计算机系统上配置多个解析名称服务器。解析名称服务器通常由 ISP 或其他组织提供。例如，Google 提供了你可以使用的 DNS 解析服务器。这些可以在计算机中自动或手动配置。</p>
<p>当你在浏览器的地址栏中键入网址时，你的计算机将首先查看是否可以在本地找到资源所在的位置。它检查计算机上的 “hosts” 文件和其他几个位置。然后它将请求发送到解析名称服务器，并等待接收资源的 IP 地址。</p>
<p>解析名称服务器首先检查其缓存。如果没有，它将通过上述步骤找到答案。</p>
<p>解析名称服务器基本上压缩了最终用户的请求过程。客户端只需要知道请求资源所在的解析名称服务器，并且确信他们会查询并返回最终答案。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>02-HAProxy简单配置和基本用法</title>
    <url>/02-HAProxy%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>一台HAProxy，两个Nginx Web Server。</p>
<p>Vagrantfile配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- mode: ruby -*-<br># vi: set ft&#x3D;ruby :<br><br>Vagrant.configure(&quot;2&quot;) do |config|<br>  config.vm.box &#x3D; &quot;longdream&#x2F;centos7&quot;<br>  config.vm.box_check_update &#x3D; false<br>  config.hostmanager.enabled &#x3D; true<br>  config.hostmanager.manage_guest &#x3D; true<br>  config.hostmanager.manage_host &#x3D; true<br><br><br>  # Create VM haproxy<br>  config.vm.define &quot;haproxy&quot; do |node|<br>    node.vm.network &quot;private_network&quot;, ip: &quot;192.168.20.222&quot;<br>    node.vm.hostname &#x3D; &quot;haproxy.yulongjun.com&quot;<br>  end<br>  # Create VM nginx-web1<br>  config.vm.define &quot;nginx-web1&quot; do |node|<br>    node.vm.network &quot;private_network&quot;, ip: &quot;192.168.20.10&quot;<br>    node.vm.hostname &#x3D; &quot;nginx-web1.yulongjun.com&quot;<br>  end<br>  # Create VM nginx-web2<br>  config.vm.define &quot;nginx-web2&quot; do |node|<br>    node.vm.network &quot;private_network&quot;, ip: &quot;192.168.20.20&quot;<br>    node.vm.hostname &#x3D; &quot;nginx-web2.yulongjun.com&quot;<br>  end<br>end<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="配置web服务器端"><a href="#配置web服务器端" class="headerlink" title="配置web服务器端"></a>配置web服务器端</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install nginx<br></code></pre></td></tr></table></figure>

<p>更改两个服务器的<code>/usr/share/nginx/html/index.html</code>文件：</p>
<p>nginx-web1更改内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Backend Server 1<br></code></pre></td></tr></table></figure>

<p>nginx-web2更改内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Backend Server 2<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这样做事为了区分开两个服务器显示页面，生产环境下一般是两台都是一样的内容。</p>
</blockquote>
<p>在浏览器上访问下<code>http://nginx-web1.yulongjun.com/</code>和<code>http://nginx-web2.yulongjun.com</code>,如果能访问成功，证明没问题。</p>
<hr>
<h2 id="配置HAProxy"><a href="#配置HAProxy" class="headerlink" title="配置HAProxy"></a>配置HAProxy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y haproxy<br></code></pre></td></tr></table></figure>

<p>程序环境：</p>
<ul>
<li>主程序：<code>/usr/sbin/haproxy</code></li>
<li>主配置文件：<code>/etc/haproxy/haproxy.cfg</code></li>
<li>Unit file：<code>/usr/lib/systemd/system/haproxy.service</code></li>
</ul>
<p>配置文件<code>/etc/haproxy/haproxy.cfg</code>的结构主要分为全局配置段和代理配置端：</p>
<ul>
<li><pre><code>global
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>  ：全局配置段<br><br>  - 进程及安全配置相关的参数<br>  - 性能调整相关参数<br>  - Debug参数<br>  - 用户列表<br>  - peers<br><br>-<br></code></pre></td></tr></table></figure>
proxies
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>  ：代理配置段<br><br>  - &#96;defaults&#96;：为frontend, listen, backend提供默认配置<br>  - &#96;fronted&#96;：前端，相当于nginx, server &#123;&#125;<br>  - &#96;backend&#96;：后端，相当于nginx, upstream &#123;&#125;<br>  - &#96;listen&#96;：同时拥前端和后端<br><br>### 1. 配置日志<br><br>在&#96;&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg&#96;里，日志定义为：<br></code></pre></td></tr></table></figure>
log         127.0.0.1 local2
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>所以我们要开启rsyslog，并且添加local2的定义项：<br><br>&#96;vim &#x2F;etc&#x2F;rsyslog.conf&#96;：<br></code></pre></td></tr></table></figure>
# Provides UDP syslog reception
$ModLoad imudp
$UDPServerRun 514
</code></pre></li>
</ul>
<h1 id="Save-boot-messages-also-to-boot-log"><a href="#Save-boot-messages-also-to-boot-log" class="headerlink" title="Save boot messages also to boot.log"></a>Save boot messages also to boot.log</h1><p>local7.*                                                /var/log/boot.log<br>local2.*                                                /var/log/haproxy.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>重启rsyslog服务，并且确保udp的514端口打开：<br></code></pre></td></tr></table></figure>
<p>systemctl restart rsyslog<br>ss -unlp |grep rsyslogd # 确保514端口处于监听状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201203135218.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15073483950327.jpg)<br><br>## HAProxy的基本用法（简单配置）<br><br>默认的全部注释掉：<br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201203135219.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15073486558127.jpg)<br><br>然后开始手动添加：<br></code></pre></td></tr></table></figure>
<p>frontend myweb<br>    bind *:80<br>    default_backend websrvs</p>
<p>backend websrvs<br>    balance roundrobin<br>    server nginx-web1 192.168.20.10:80 check<br>    server nginx-web2 192.168.20.20:80 check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>测试一下：<br></code></pre></td></tr></table></figure>
<p>[root@haproxy ~]# for i in <code>seq 10</code>;do curl 192.168.20.222;done</p>
<h1>Backend Server 1</h1>
<h1>Backend Server 2</h1>
<h1>Backend Server 1</h1>
<h1>Backend Server 2</h1>
<h1>Backend Server 1</h1>
<h1>Backend Server 2</h1>
<h1>Backend Server 1</h1>
<h1>Backend Server 2</h1>
<h1>Backend Server 1</h1>
<h1>Backend Server 2</h1>
```]]></content>
  </entry>
  <entry>
    <title>02-IO模型</title>
    <url>/02-IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自：<a href="http://www.cnblogs.com/whyandinside/archive/2012/03/04/2379234.html" target="_blank" rel="noopener">我本善良</a></p>
<p>几大模型：</p>
<ul>
<li><strong>Blocking IO</strong>（阻塞型IO）</li>
<li><strong>Non-Blocking IO</strong>（非阻塞型IO）</li>
<li><strong>IO multiplexing</strong>（IO复用型）：<code>select</code>，<code>poll</code></li>
<li><strong>signal driven I/O</strong>（事件驱动型IO）：<code>epoll</code>（Linux）、<code>Kqueue</code>（BSD）、<code>/dev/poll</code>（Solaris）</li>
<li><strong>Asynchronous I/O</strong>（异步IO）</li>
</ul>
<p>概括来说，一个IO操作可以分为两个部分：发出请求、结果完成。如果从发出请求到结果返回，一直Block，那就是Blocking IO；如果发出请求就可以返回（结果完成不考虑），就是non-blocking IO；如果发出请求就返回，结果返回是Block在select或者poll上的，则其只能称为IO multiplexing；如果发出请求就返回，结果返回通过Call Back的方式被处理，就是AIO。</p>
<h2 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h2><p>这个最好理解了，在Blocking IO模式下，函数调用只有在操作完成后才会返回。下图是它调用过程的图示：</p>
<p><a href="http://www.yulongjun.com/images/15033654539337.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130210459.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15033725611953.jpg" target="_blank" rel="noopener"><img src="02-IO%E6%A8%A1%E5%9E%8B.assets/15033725611953.jpg" alt="img"></a></p>
<p>重点解释下上图，下面例子都会讲到。首先application调用 recvfrom()转入kernel，注意kernel有2个过程，wait for data和copy data from kernel to user。直到最后copy complete后，recvfrom()才返回。此过程一直是阻塞的。</p>
<h2 id="Non-Blocking-IO"><a href="#Non-Blocking-IO" class="headerlink" title="Non-Blocking IO"></a>Non-Blocking IO</h2><p>Non-Blocking 是Blocking的反，也就是说，即使操作没有完成，函数也可以返回。调用过程如下：</p>
<p><a href="http://www.yulongjun.com/images/15033654840212.jpg" target="_blank" rel="noopener"><img src="02-IO%E6%A8%A1%E5%9E%8B.assets/15033654840212.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15033725830210.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130210506.jpg" alt="img"></a></p>
<p>可以看见，如果直接操作它，那就是个<strong>轮询</strong>。。直到内核缓冲区有数据</p>
<p>AIO也是这样啊？对！这是Non-Blocking IO 和AIO的共同点。其实从概念层面来说Non-Blocking IO 就是AIO，他们没有什么区别。但是Non-Blocking IO是对文件描述符（*nix）或者Handle（Windows）的设置，在执行操作时不需要特殊的数据结构。Non-Blocking IO提交请求后只能通过提交的操作函数来查询操作是否完成，这是一个很大的限制。而AIO往往会提供多种通知或者查询机制，也就是说用Non-Blocking IO时只能轮询，而AIO有更多选择。所以是否支持轮询外的其他机制是AIO和Non-Blocking IO的区别。</p>
<p>Non-Blocking IO和Blocking IO的区别仅仅在操作是否能够立刻完成，如果能够立刻完成，IO函数的行为是一样的；如果不能立刻完成，Non-Blocking IO会返回EAGAIN或者EWOULDBLOCK，而Blocking IO会一直阻塞。</p>
<h2 id="IO-multiplexing-select-and-poll"><a href="#IO-multiplexing-select-and-poll" class="headerlink" title="IO multiplexing (select and poll)"></a>IO multiplexing (select and poll)</h2><p>最常见的I/O复用模型，select。</p>
<p><a href="http://www.yulongjun.com/images/15033654946682.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130211234.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15033725985022.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130211256.jpg" alt="img"></a></p>
<p>select先阻塞，有活动套接字才返回。与<strong>blocking I/O</strong>相比，select会有两次系统调用，但是select能处理多个套接字。</p>
<h2 id="signal-driven-IO-SIGIO"><a href="#signal-driven-IO-SIGIO" class="headerlink" title="signal driven IO (SIGIO)"></a>signal driven IO (SIGIO)</h2><p><a href="http://www.yulongjun.com/images/15033655057576.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130213235.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15033726289532.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130213248.jpg" alt="img"></a></p>
<p>与<strong>I/O multiplexing (select and poll)</strong>相比，它的优势是，免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。</p>
<h2 id="Asynchronous-IO"><a href="#Asynchronous-IO" class="headerlink" title="Asynchronous IO"></a>Asynchronous IO</h2><p>AIO让应用发起一个操作请求，让这个请求被异步地执行。应用可以选择在操作完成时被通知到或者不被通知。所以通知机制并不是AIO的核心，但是需要提供几种方案的选择。</p>
<p><a href="http://www.yulongjun.com/images/15033655478651.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130213259.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15033726716267.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130213305.jpg" alt="img"></a></p>
<p>完全异步的I/O复用机制，因为纵观上面其它四种模型，至少都会在由kernel copy data to application时阻塞。而该模型是当copy完成后才通知application，可见是纯异步的。</p>
<blockquote>
<p>Nginx官方并没有实现AIO模块，Linux官方提供了AIO库函数来实现AIO，但是用的很少。目前有很多开源的AIO库，如<code>libevent</code>、<code>libev</code>、<code>libuv</code>都很不错。</p>
</blockquote>
<h2 id="下面是以上五种模型的比较"><a href="#下面是以上五种模型的比较" class="headerlink" title="下面是以上五种模型的比较"></a>下面是以上五种模型的比较</h2><p><a href="http://www.yulongjun.com/images/io.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130214401.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15033726836279.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130221624.jpg" alt="img"></a></p>
<p>可以看出，越往后，阻塞越少，理论上效率也是最优。</p>
<p>下面可以把select,epoll,iocp,kqueue按号入座。</p>
<p>select和iocp分别对应第3种与第5种模型，那么epoll与kqueue呢？其实也于select属于同一种模型，只是更高级一些，可以看作有了第4种模型的某些特性，如callback机制。</p>
<p><strong>那么，为什么epoll,kqueue比select高级？</strong></p>
<p>答案是，他们无<strong>轮询</strong>。因为他们用callback取代了。想想看，当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<p><strong>提供一致的接口，IO Design Patterns</strong></p>
<p>实际上，不管是哪种模型，都可以抽象一层出来，提供一致的接口，广为人知的有ACE,Libevent这些，他们都是跨平台的，而且他们自动选择最优的I/O复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，<strong>Reactor</strong> and <strong>Proactor。</strong>有一篇经典文章<a href="http://www.artima.com/articles/io_design_patterns.html值得阅读，Libevent是**Reactor**模型，ACE提供**Proactor**模型。实际都是对各种I/O复用机制的封装。" target="_blank" rel="noopener">http://www.artima.com/articles/io_design_patterns.html值得阅读，Libevent是**Reactor**模型，ACE提供**Proactor**模型。实际都是对各种I/O复用机制的封装。</a></p>
<p><strong>总结一些重点：</strong></p>
<p>只有IOCP是asynchronous I/O，其他机制或多或少都会有一点阻塞。 select低效是因为每次它都需要轮询，但低效也是相对的，视情况而定，也可通过良好的设计改善。 epoll, kqueue是Reacor模式，IOCP是Proactor模式。</p>
]]></content>
  </entry>
  <entry>
    <title>02-Keepalived配置</title>
    <url>/02-Keepalived%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Keepalived-HA-cluster的配置前提"><a href="#Keepalived-HA-cluster的配置前提" class="headerlink" title="Keepalived HA cluster的配置前提"></a>Keepalived HA cluster的配置前提</h2><p>(1) 各节点时间必须同步：可以使用<code>ntp</code>(CentOS6&amp;7)或者<code>chrony</code>(CentOS 7)。<br>(2) 确保iptables及selinux不会成为阻碍。<br>(3) 各节点之间可通过主机名互相通信（对KA并非必须）：建议使用<code>/etc/hosts</code>文件实现(DNS服务如果有问题，还不如hosts文件好用）<br>(4) 确保各节点的用于集群服务的接口支持MULTICAST通信：多播或叫组播，使用D类地址(224-239)。（多播地址最好不要使用默认的，手动修改一下。因为如果好多个集群服务都是用默认的，虽然有认证机制，但是也会互相发送信息，虽然因为认证机制丢弃掉了，但也影响性能，也会产生无用的日志。）</p>
<p><strong>（1）所有服务器都要做时间服务器同步。</strong></p>
<p>第一种方法： <strong>ntp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ntpdate TIME_SERVER_IP<br></code></pre></td></tr></table></figure>

<p>TIME_SERVER_IP换成时间服务器IP。</p>
<p>第二种方法：<strong>chrony</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;chrony.conf<br>#server 0.centos.pool.ntp.org iburst<br>#server 1.centos.pool.ntp.org iburst<br>#server 2.centos.pool.ntp.org iburst<br>#server 3.centos.pool.ntp.org iburst<br>server TIME_SERVER_IP iburst<br></code></pre></td></tr></table></figure>

<p>TIME_SERVER_IP换成时间服务器IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl restart chronyd.service<br></code></pre></td></tr></table></figure>

<p><code>chrony sources</code>可以查看同步时间情况。<br>TIME_SERVER_IP换成时间服务器IP。</p>
<p><strong>（2）iptables、SELinux、/etc/hosts自行设定。</strong></p>
<p><strong>（3）Keepalived集群的组播地址不采用系统默认的</strong>。</p>
<p>组播地址定为<code>224.111.111.111</code>。</p>
<hr>
<h2 id="Keepalived配置详解"><a href="#Keepalived配置详解" class="headerlink" title="Keepalived配置详解"></a>Keepalived配置详解</h2><p>Keepalived的配置文件：<code>/etc/keepalived/keepalived.conf</code></p>
<p><code>man keepalived.conf</code>可以查看配置详情解析。</p>
<p>配置分为三大项配置块：</p>
<ul>
<li><p>Global configuration</p>
<p>，全局配置，包含两个子配置块：</p>
<ul>
<li><strong>全局定义</strong>：<code>global_defs</code>。</li>
<li><strong>静态地址和路由</strong>：<code>static_ipaddress</code>、<code>static_routes</code></li>
</ul>
</li>
<li><p>VRRP configuration</p>
<p>，VRRP配置，包含两个子配置块：</p>
<ul>
<li><strong>VRRP同步组</strong>：<code>vrrp_sync_group</code>。</li>
<li><strong>VRRP实例</strong>：<code>vrrp_instance</code>。</li>
</ul>
</li>
<li><p>LVS configuration</p>
<p>，LVS配置。如果要用Keepalived+LVS的话，需要使用这段配置，如果是用其他的如Keepalived+Nginx的话，是不需要配置的。LVS的话，包含两个子配置块：</p>
<ul>
<li><strong>虚拟服务器组</strong>： <code>virtual_server_group</code>。可选项,大型LVS集群才会用。</li>
<li><strong>虚拟服务器</strong>：<code>virtual_server</code>。每个虚拟服务器里面又包含多个真实服务器<code>real_server</code>。</li>
</ul>
</li>
</ul>
<h3 id="Global-Configuration"><a href="#Global-Configuration" class="headerlink" title="Global Configuration"></a>Global Configuration</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30  # 前面这几段随意配置，一般不会用邮件通知，一般会有监控软件来监控<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111  # 多播地址段，最好自定义，不要用系统默认的<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="VRRP-Configuration"><a href="#VRRP-Configuration" class="headerlink" title="VRRP Configuration"></a>VRRP Configuration</h3><h4 id="VRRP同步组配置块：vrrp-sync-group"><a href="#VRRP同步组配置块：vrrp-sync-group" class="headerlink" title="VRRP同步组配置块：vrrp_sync_group"></a>VRRP同步组配置块：<code>vrrp_sync_group</code></h4><p>定义一个vrrp同步组，当同步组内的instance挂了一个，组内的所有instance都Failover（故障转移）到另外一个节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vrrp_sync_group GROUP_NAME &#123;<br>    group &#123;<br>        INSTANCE_NAME<br>        INSTANCE_NAME<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>常见的一个案例是，在有连接外网的地址和内网的地址都有，并且两个VIP做了ip_forward，需要两个VIP同时漂移。如下面例子，External_1为外网的VRRP实例，Internal_2为内网的VRRP实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vrrp_sync_group VG_1 &#123;<br>    group &#123;<br>        External_1<br>        Internal_2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="VRRP实例配置块：vrrp-instance"><a href="#VRRP实例配置块：vrrp-instance" class="headerlink" title="VRRP实例配置块：vrrp_instance"></a>VRRP实例配置块：<code>vrrp_instance</code></h4><p>定义vrrp实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vrrp_instance INSTANCE_NAME &#123;<br>    state MASTER|BACKUP  # 当前节点在此虚拟路由器上的初始状态；只能有一个是MASTER，余下的都应该为BACKUP；<br>    interface IFACE_NAME  # 绑定为当前虚拟路由器使用的物理接口；IFACE_NAME是网卡名，如&#96;eth0&#96;<br>    virtual_router_id VRID  # 当前虚拟路由器的惟一标识，VRID代表一个数字，范围是0-255；<br>    priority PRI  # 当前主机在此虚拟路径器中的优先级；PRI范围是1-254；<br>    advert_int INT  # vrrp通告的时间间隔；INT单位为秒，比如&#96;1&#96;，代表通告间隔为1秒<br>   <br>    # 认证模块，同一个实例的主和备，要用同一个认证方式和密码<br>    authentication &#123;<br>        auth_type AH|PASS   # 认证方式：PASS为简单字符串密码，推荐使用；AH为IPSEC方式，不推荐使用<br>        auth_pass &lt;PASSWORD&gt; # 密码，只有8个字符被使用，写多了会截取前8位<br>    &#125;<br>    <br>    # 虚拟地址，即Floating IP<br>    virtual_ipaddress &#123;<br>        # 格式为：&lt;IPADDR&gt;&#x2F;&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt; label &lt;LABEL&gt;<br>        # 可以简写为单个地址，系统会默认计算掩码和设备，也可以写label别名。<br>        192.168.200.15<br>        # 192.168.200.16&#x2F;24<br>        # 192.168.200.17&#x2F;24 dev eth1<br>        # 192.168.200.18&#x2F;24 dev eth2 label eth2:1<br>						&#125;<br>						<br>    # 配置要监控的网络接口，一旦配置中的一个接口出现故障，这个实例就转为FAULT状态<br>    track_interface &#123;  <br>        eth0<br>        eth1<br>        ...<br>    &#125;<br>    <br>    # 抢占模式相关配置<br>    nopreempt  # 定义工作模式为非抢占模式<br>    preempt_delay 300  # 抢占式模式下，节点上线后触发新选举操作的延迟时长（在没有nopreempt的时候才能使用）<br>						<br>    # 定义通知脚本<br>    notify_master &lt;STRING&gt;|&lt;QUOTED-STRING&gt;  # 当前节点成为主节点时触发的脚本<br>    notify_backup &lt;STRING&gt;|&lt;QUOTED-STRING&gt;  # 当前节点转为备节点时触发的脚本<br>    notify_fault &lt;STRING&gt;|&lt;QUOTED-STRING&gt;   # 当前节点转为“失败”状态时触发的脚本<br>    notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt;         # 通用格式的通知触发机制，一个脚本可完成以上三种状态的转换时的通知<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面为一段通用格式的通知脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>#<br>contact&#x3D;&#39;root@localhost&#39;<br>                <br>notify() &#123;<br>    local mailsubject&#x3D;&quot;$(hostname) to be $1, vip floating&quot;<br>    local mailbody&#x3D;&quot;$(date +&#39;%F %T&#39;): vrrp transition, $(hostname) changed to be $1&quot;<br>    echo &quot;$mailbody&quot; | mail -s &quot;$mailsubject&quot; $contact<br>&#125;<br>                <br>case $1 in<br>master)<br>    notify master   <br>    ;;<br>backup)<br>    notify backup   <br>    ;;<br>fault)<br>    notify fault    <br>    ;;<br>*)<br>    echo &quot;Usage: $(basename $0) &#123;master|backup|fault&#125;&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<p>在vrrp_instance配置块里定义通知脚本的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br></code></pre></td></tr></table></figure>

<h4 id="检测机制"><a href="#检测机制" class="headerlink" title="检测机制"></a>检测机制</h4><p>程序自带的检测示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat &#x2F;usr&#x2F;share&#x2F;doc&#x2F;keepalived-1.2.13&#x2F;samples&#x2F;keepalived.conf.vrrp.localcheck<br>vrrp_script chk_sshd &#123;<br>       script &quot;killall -0 sshd&quot;        # cheaper than pidof<br>       interval 2                      # check every 2 seconds<br>       weight -4                       # default prio: -4 if KO<br>       fall 2                          # require 2 failures for KO<br>       rise 2                          # require 2 successes for OK<br>&#125;<br><br>vrrp_script chk_http_port &#123;<br>       script &quot;&lt;&#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;80&quot; # connects and exits<br>       interval 1                      # check every second<br>       weight -2                       # default prio: -2 if connect fails<br>&#125;<br><br># .............<br><br>vrrp_instance VI_1 &#123;<br>    interface eth0<br>    state MASTER<br>    virtual_router_id 51<br>    priority 100<br>    virtual_ipaddress &#123;<br>        192.168.200.18&#x2F;25<br>    &#125;<br>    track_interface &#123;<br>       eth1 weight 2   # prio &#x3D; +2 if UP<br>       eth2 weight -2  # prio &#x3D; -2 if DOWN<br>       eth3            # no weight, fault if down<br>    &#125;<br>    track_script &#123;<br>       chk_sshd                # use default weight from the script<br>       chk_haproxy weight 2    # +2 if process is present<br>       chk_http_port<br>       chk_https_port<br>       chk_smtp_port<br>    &#125;<br>&#125;<br><br>track_script &#123;<br>       chk_sshd                # use default weight from the script<br>       chk_haproxy weight 2    # +2 if process is present<br>       # .........<br>    &#125;<br># ...............<br></code></pre></td></tr></table></figure>

<p>检测分为两个地方：<code>vrrp_script</code>(示例里通过<code>track_script</code>调用定义的<code>vrrp_script</code>)和<code>track_interface</code>：</p>
<p><strong><code>vrrp_script</code></strong>，<strong>跟踪脚本返回值</strong>：</p>
<ul>
<li><pre><code>script &quot;SCRIPT&quot;</code></pre><p>，这里写检测脚本。返回值是0，不执行后续操作，返回值是1，执行后续操作。</p>
<ul>
<li>例子1：<code>script &quot;killall -0 sshd&quot;</code>。是检测服务是否存在，如果服务存在，返回值是0，无操作；服务不存在，返回值是1，执行后续操作。</li>
<li>例子2：<code>script &quot;&lt;/dev/tcp/127.0.0.1/80&quot;</code> 检测端口80是否打开，如果端口打开，返回值是0，无操作；端口未打开，返回值是1，执行后续操作。</li>
</ul>
</li>
<li><p><code>interval 2</code>， 检测间隔为2秒。</p>
</li>
<li><p><code>weight -4</code>，如果检测返回值为1（失败），则权重-4</p>
</li>
<li><p><code>weight 2</code>，如果检测返回值为0，则权重+2</p>
</li>
<li><p><code>fall 2</code>，需要2次失败才认为是失败</p>
</li>
<li><p><code>rise 2</code>，需要2次成功能认为是成功</p>
</li>
</ul>
<p><strong><code>track_script</code></strong>，定义调用哪个<code>vrrp_script</code>：</p>
<ul>
<li><code>chk_sshd</code>,直接使用脚本里的默认权重。 # use default weight from the script</li>
<li><code>chk_haproxy weight 2</code>，自定义权重，如果进程存在，则权重+2 # +2 if process is present</li>
</ul>
<blockquote>
<p>有了vrrp_script，我们就可以基于服务层面来做Floating IP了，也就能实现其他服务，如Nginx或HAProxy的高可用。</p>
</blockquote>
<p><strong><code>track_interface</code></strong>，<strong>跟踪网卡状态</strong>：</p>
<ul>
<li><code>eth1 weight 2</code>，如果是up状态，则权重+2(prio = +2 if UP)。</li>
<li><code>eth2 weight -2</code>，如果是down状态，则权重-2(prio = -2 if DOWN)。</li>
<li><code>eth3</code>，没有写权重的话，如果是down状态，则失败(no weight, fault if down)。</li>
</ul>
<hr>
<blockquote>
<p>下一节我们来具体配置Keepalived的各种模式，包含：</p>
<ul>
<li>单网络的<code>Master-Backup</code>主备模式（单主模式）</li>
<li>单网络的<code>Active-Active</code>双活模式（双主模式）</li>
<li>双网络（内外网）的<code>Master-Backup</code>主备模式（单主模式）</li>
<li>双网络（内外网）的<code>Active-Active</code>双活模式（双主模式）</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>02-MariaDB安装</title>
    <url>/02-MariaDB%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CentOS7中，iso镜像里就带有MariaDB，因此通过yum安装mariaDB就可以了，但是版本不是最新的。</p>
<p>如果想要在6或7上安装最新的MariaDB，可以设置yum generator来找到yum repo地址，来安装：</p>
<p>yum generator：<a href="https://downloads.mariadb.org/mariadb/repositories/" target="_blank" rel="noopener">https://downloads.mariadb.org/mariadb/repositories/</a></p>
<p><a href="http://www.yulongjun.com/images/15012289239906.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203150157.jpg" alt="img"></a></p>
<p>选择要安装的版本，这里我选的是目前最新的稳定版本10.2。</p>
<p>在<code>/etc/yum.repos.d/</code>下创建<code>MariaDB.repo</code>文件。</p>
<p>CentOS 7写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># MariaDB 10.2 CentOS repository list - created 2017-07-28 08:01 UTC<br># http:&#x2F;&#x2F;downloads.mariadb.org&#x2F;mariadb&#x2F;repositories&#x2F;<br>[mariadb]<br>name &#x3D; MariaDB<br>baseurl &#x3D; http:&#x2F;&#x2F;yum.mariadb.org&#x2F;10.2&#x2F;centos7-amd64<br>gpgcheck&#x3D;0<br></code></pre></td></tr></table></figure>

<p>CentOS 6写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># MariaDB 10.2 CentOS repository list - created 2017-07-28 08:04 UTC<br># http:&#x2F;&#x2F;downloads.mariadb.org&#x2F;mariadb&#x2F;repositories&#x2F;<br>[mariadb]<br>name &#x3D; MariaDB<br>baseurl &#x3D; http:&#x2F;&#x2F;yum.mariadb.org&#x2F;10.2&#x2F;centos6-amd64<br>gpgcheck&#x3D;0<br></code></pre></td></tr></table></figure>

<p>然后（6和7通用）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sudo yum install MariaDB-server MariaDB-client<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>02-Zabbix-Agent 安装指南和Zabbix-Server设置自动发现</title>
    <url>/02-Zabbix-Agent-%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%E5%92%8CZabbix-Server%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Zabbix Agent分为两种模式，被动模式（Passive)和主动模式（</p>
<p>我们实验在node1.yulongjun.com 和node2.yulongjun.com上分别配置Zabbix Agent。</p>
<h2 id="yum-安装-Zabbix-Agent"><a href="#yum-安装-Zabbix-Agent" class="headerlink" title="yum 安装 Zabbix Agent"></a>yum 安装 Zabbix Agent</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rpm -ivh http:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;3.4&#x2F;rhel&#x2F;7&#x2F;x86_64&#x2F;zabbix-release-3.4-1.el7.centos.noarch.rpm<br><br>yum install -y zabbix-agent<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果不能联网，可以去官网下载rpm包安装。<br>repo地址：<code>http://repo.zabbix.com/zabbix/</code><br>可以找到当前你所用的版本的agent。<br>写这篇文章的时候，Zabbix的最新版本是3.4.2：<br>CentOS7的相关包下载地址：<a href="http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-agent-3.4.2-1.el7.x86_64.rpm" target="_blank" rel="noopener">http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-agent-3.4.2-1.el7.x86_64.rpm</a><br>如果后续有更新，可以自行查找。</p>
</blockquote>
<p>Agent可以设置被动检查模式或者主动检查模式：</p>
<p>node1上，<code>vim /etc/zabbix/zabbix_agentd.conf</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">##### Passive checks related 被动模式检查相关<br><br># Zabbix Server地址,如果想被Zabbix Proxy发现，可以添加zabbix-proxy的地址。<br>Server&#x3D;zabbix.yulongjun.com<br>#Server&#x3D;zabbix.yulongnjun.com, zabbix-proxy.yulongjun.com<br><br># 监听端口，默认10050<br>ListenPort&#x3D;10050<br><br># 限定Server可以监控的IP地址，可以用逗号隔开多个。默认0.0.0.0，即监控所有ip地址。<br># ListenIP&#x3D;0.0.0.0<br><br># 代理进程并发数，如果监控的选项比较多，可以改大<br>StartAgents&#x3D;3<br><br>##### Active checks related 主动模式检查相关<br>## Zabbix Server地址<br>ServerActive&#x3D;zabbix.yulongjun.com<br>#ServerActive&#x3D;zabbix.yulongjun.com,zabbix-proxy.yulongjun.com<br>## 本机主机名，也是在Zabbix Server上显示的名字<br>Hostname&#x3D;node1.yulongjun.com<br></code></pre></td></tr></table></figure>

<blockquote>
<p>node2的配置，更改相应的设置为node2.yulongjun.com和192.168.0.20</p>
</blockquote>
<p>启动服务，下次开启自启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start zabbix-agent.service<br>systemctl enable zabbix-agent.service<br></code></pre></td></tr></table></figure>

<h2 id="配置服务器的自动发现功能"><a href="#配置服务器的自动发现功能" class="headerlink" title="配置服务器的自动发现功能"></a>配置服务器的自动发现功能</h2><p>配置–&gt;自动发现，我们看到默认有一个默认本地网段（Local Network)的规则，我们直接用就可以了，，点状态那里打开为<strong>启用</strong>：<br><a href="http://www.yulongjun.com/images/15065825102184.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153750.jpg" alt="img"></a></p>
<p>在dashboard上就可以看到有发现两台主机：</p>
<p><a href="http://www.yulongjun.com/images/15065826813058.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153751.jpg" alt="img"></a></p>
<p>点开上图<code>Local network</code>可以看到主机：</p>
<p><a href="http://www.yulongjun.com/images/15065827839461.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153752.jpg" alt="img"></a></p>
<p>发现的主机，我们要添加到主机信息里，需要设置每一台主机的监控项。</p>
<h2 id="设置主机组，添加主机"><a href="#设置主机组，添加主机" class="headerlink" title="设置主机组，添加主机"></a>设置主机组，添加主机</h2><p>node1和node2分别安装Nginx，我们就对Nginx进行监控：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install nginx<br>systemctl start nginx<br>systemctl enable nginx<br></code></pre></td></tr></table></figure>

<p>在<code>配置</code>–&gt;<code>主机</code>选项卡，点右上角<code>创建主机</code>：</p>
<p><a href="http://www.yulongjun.com/images/15065867995573.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153753.jpg" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>02-bash的简单快捷键</title>
    <url>/02-bash%E7%9A%84%E7%AE%80%E5%8D%95%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>bash中命令运行中相关快捷键和相关命令</strong></p>
<p><code>&lt;Ctrl + l&gt;</code>：清屏，相当于<code>clear</code>命令。</p>
<p><code>&lt;Ctrl + c&gt;</code>：取消（终止）前台运行命令，可以用来中断当前运行的命令。<br><code>&lt;Ctrl + z&gt;</code>：挂起命令到后台，并暂停。命令状态为<strong>Stopped</strong>。<br><code>jobs</code>：查看后台的命令，每个命令都有一个序号，从1开始。<br><code>bg %NUM</code>：将挂起在后台的命令，让其在后台继续运行，NUM为命令的序号。如果不写序号，默认继续运行最后一个挂起的命令。<code>jobs</code>查看命令状态变成<strong>Running</strong>状态。<br><code>fg %NUM</code>：后台命令送到前台运行。<br><code>kill %n</code>：中断(Terminted)后台某个命令。（Stopped状态的和Running状态都可以中断）</p>
<p><code>COMMAND &amp;</code>：把命令送到后台。</p>
<p><code>nohup COMMAND &amp; [&gt;XXX]</code>：将程序放在后台运行，退出会话也不退出。（如果没有退出会话，jobs可以看到程序，按照序号杀死，如果关了会话的话，jobs是看不到的，杀死程序进程需要找到程序的进程号，用kill杀掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nohup ping github.com &amp;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>关于<code>&gt;xxx</code>后面重定向时候会学到。默认nohup 明星会重定向到运行程序的当前目录下的<code>nohup.out</code>。</p>
</blockquote>
<p><strong>bash控制和移动快捷键：</strong><br><code>&lt;Ctrl-a&gt;</code>：光标跳转至行首 （用的最多）<br><code>&lt;Ctrl-e&gt;</code>：光标跳转至行位 （用的最多）<br><code>&lt;Ctrl-u&gt;</code>：从光标所在位置删除到行首<br><code>&lt;Ctrl-k&gt;</code>：从光标所在位置删除到行尾<br><code>&lt;Alt-f&gt;</code>：光标向右移动到一个单词的末尾<br><code>&lt;Alt-b&gt;</code>：光标向左移动到一个单词的首部</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>02-http通讯</title>
    <url>/02-http%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP，Hypertext Transfer Protocol，超⽂本传输协议，和 HTML (Hypertext Markup Language 超⽂本标 记语⾔) ⼀起诞⽣，⽤于在⽹络上请求和传输 HTML 内容。 </p>
<p>超⽂本，即「扩展型⽂本」，指的是 HTML 中可以有链向别的⽂本的链接（hyperlink）。</p>
<p>http: Hyper Text Transfer Protocol, 80/tcp<br>html: Hyper Text Markup Language  超文本标记语言，编程语言</p>
<p>CSS: Cascading Style Sheet 层叠样式表。将早期的html的各种标签属性抽离处理独自定义在css中<br>js:  javascript</p>
<p>MIME： Multipurpose Internet Mail Extensions 多用途互联网邮件扩展。能使得非文本格式的文件转为为文本格式，经由文本传输协议传送到对端，能够还原为原本格式。</p>
<p>一次http事务：请求&lt;–&gt;响应</p>
<p>http请求：http request </p>
<p>http响应：http response </p>
<h2 id="HTTP服务通信过程"><a href="#HTTP服务通信过程" class="headerlink" title="HTTP服务通信过程"></a>HTTP服务通信过程</h2><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828085116.png" alt="image-20200823112149917"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828202119.png" alt="image-20200823112219828"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828184453.png" alt="image-20200823112242460"></p>
<h2 id="提高HTTP连接性能"><a href="#提高HTTP连接性能" class="headerlink" title="提高HTTP连接性能"></a>提高HTTP连接性能</h2><p>并行连接：通过多条TCP连接发起并发的HTTP请求<br>持久连接：keep-alive,长连接，重用TCP连接，以消除连接和关闭的时延,以事务个数和时间来决定是否关闭连接<br>管道化连接：通过共享TCP连接发起并发的HTTP请求<br>复用的连接：交替传送请求和响应报文（实验阶段）</p>
<h3 id="Web资源：web-resource"><a href="#Web资源：web-resource" class="headerlink" title="Web资源：web resource"></a>Web资源：web resource</h3><p>一个网页由多个资源构成，打开一个页面，会有多个资源展示出来，但是每个资源都要单独请求。因此，一个“Web 页面”通常并不是单个资源，而是一组资源的集合 </p>
<p>静态文件：无需服务端做出额外处理，文件后缀：.html, .txt, .jpg,  .js, .css, .mp3, .avi </p>
<p>动态文件：服务端执行程序，返回执行的结果，文件后缀：.php, .jsp ,.asp </p>
<h3 id="URI-统一资源标识"><a href="#URI-统一资源标识" class="headerlink" title="URI 统一资源标识"></a>URI 统一资源标识</h3><p>URI: Uniform Resource Identifier 统一资源标识，分为URL和URN<br>URN: Uniform Resource Naming，统一资源命名</p>
<p>URL: Uniform Resorce Locator，统一资源定位符，用于描述某服务器某特定资源位置<br>两者区别：URN如同一个人的名称，而URL代表一个人的住址。换言之， URN定义某事物的身份，而URL提供查找该事物的方法。URN仅用于命名，而不指定地址</p>
<h3 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h3><p><scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag></p>
<ul>
<li>scheme:方案，访问服务器以获取资源时要使用哪种协议</li>
<li>user:用户，某些方案访问资源时需要的用户名</li>
<li>password:密码，用户对应的密码，中间用：分隔</li>
<li>Host:主机，资源宿主服务器的主机名或IP地址</li>
<li>port:端口,资源宿主服务器正在监听的端口号，很多方案有默认端口号</li>
<li>path:路径,服务器资源的本地名，由一个/将其与前面的URL组件分隔</li>
<li>params:参数，指定输入的参数，参数为名/值对，多个参数，用;分隔</li>
<li>query:查询，传递参数给程序，如数据库，用？分隔,多个查询用&amp;分隔</li>
<li>frag:片段,一小片或一部分资源的名字，此组件在客户端使用，用#分隔</li>
</ul>
<h3 id="一次完整的http请求处理过程"><a href="#一次完整的http请求处理过程" class="headerlink" title="一次完整的http请求处理过程"></a>一次完整的http请求处理过程</h3><p>1、建立连接：接收或拒绝连接请求<br>2、接收请求：接收客户端请求报文中对某资源的一次请求的过程,请求的资源，方法等信息在客户端发送的http报文首部中（参考Web访问响应模型）</p>
<p>3、处理请求：服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，等信息对请求进行处理</p>
<p>4、访问资源：服务器通过磁盘I/O获取请求报文中请求的web资源，可能是静态资源，也可能前端开发的程序产生的结果数据流。</p>
<p>5、构建响应报文：一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中 包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体 </p>
<p>6、发送响应报文。Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了  </p>
<p>7、记录日志。最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务 </p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828184417.png" alt="image-20200828184408155"></p>
<h3 id="Web访问响应模型"><a href="#Web访问响应模型" class="headerlink" title="Web访问响应模型"></a>Web访问响应模型</h3><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828184430.png" alt="image-20200823121940116"></p>
<p>Web访问响应模型（Web I/O）<br><code>单进程I/O模型</code>：启动一个进程处理用户请求，而且一次只处理一个，多个请求被串行响应<br><code>多进程I/O模型</code>：并行启动多个进程,每个进程响应一个连接请求<br><code>复用I/O结构</code>：启动一个进程，同时响应N个连接请求</p>
<p>​                    <code>多线程模式</code>：一个进程生成N个线程，一个线程处理一个请求；<br>​                    <code>事件驱动(event-driven)</code>：一个进程直接N个请求；</p>
<p><code>复用的多进程I/O模型</code>：启动M个进程，每个进程响应N个连接请求，同时接收M*N个请求</p>
<p>Tip:Linux中进程和线程差别不大</p>
<h2 id="http协议版本"><a href="#http协议版本" class="headerlink" title="http协议版本"></a>http协议版本</h2><p>http/0.9：原型版本，功能简陋<br>http/1.0: cache, MIME, method,<br>            MIME：Multipurpose Internet Mail Extesion<br>            method：GET， POST， HEAD，PUT， DELETE，TRACE， OPTIONS<br>http/1.1：增强了缓存功能；<br>            spdy<br>http/2.0：<br>            rfc </p>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>HTTP<strong>最初是一个匿名、无状态的请求/响应协议</strong>。服务器处理来自客户端的请求， 然后向客户端回送一条响应。Web 服务器几乎没有什么信息可以用来判定是哪个用 户发送的请求，也无法记录来访用户的请求序列</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>02-iptables操作记录</title>
    <url>/02-iptables%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#iptables -vnL #查看iptables设置filter表的规则</span><br>Chain INPUT (policy ACCEPT 129 packets, 9715 bytes)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination         <br><br>Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination         <br><br>Chain OUTPUT (policy ACCEPT 128 packets, 21589 bytes)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination         <br><br>Chain L (0 references)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination         <br><br>Chain l (0 references)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination   <span class="hljs-comment">#ACCEPT是允许意思，既是意味是做黑名单。但是黑名单做法不好，建议做白名单</span><br> [root@ashjian ~]<span class="hljs-comment">#systemctl start iptables.services</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -t raw -vnxL --line-numbers #推荐使用查看指定功能表的链规则</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -vnL INPUT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -P FORWARD DROP #修改FORWAR链D的默认策略</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -vnL FORWARD</span><br>Chain FORWARD (policy DROP 0 packets, 0 bytes)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination<br> [root@ashjian ~]<span class="hljs-comment">#iptables -N in_web #添加自定义链</span><br> [root@ashjian ~]<span class="hljs-comment">#iptables -vnL    in_web    </span><br>Chain in_web (0 references)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination <br> [root@ashjian ~]<span class="hljs-comment">#iptables -E in_web in_web_root #自定义链改名</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -Z INPUT_ZONES 1 #清空INPUT_ZONES链的第一条规则的计数器</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -vnL INPUT_ZONES</span><br>Chain INPUT_ZONES (1 references)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination         <br>    1    28 IN_public  all  --  +      *       0.0.0.0/0            0.0.0.0/0           [goto] <br>[root@ashjian ~]<span class="hljs-comment">#iptables -F #清空所有规则，外网又能访问我的服务器了，不保存，重启firewalld.service则规则又变回</span><br>[root@ashjian ~]<span class="hljs-comment">#systemctl restart firewalld.service #不保存重启，规则恢复了了。因为规则是在内核中生效的，默认规则保存在文件中，重启则读取该文件到内存中。因此改了内存中的规则会立即生效</span><br><br>[root@ashjian ~]<span class="hljs-comment">#iptables -D FORWARD 7 #删除规则</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -t filter -A FORWARD -s 172.16.0.0/20 -d 172.16.0.3 -p tcp -j ACCEPT</span><br><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A INPUT -d 172.16.0.3 -p tcp --dport 22 -j ACCEPT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A OUTPUT -s 172.16.0.3 -p tcp --sport 22 -j ACCEPT</span><br><br><span class="hljs-comment">#设置规则带队默认策略</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A INPUT -d 172.16.0.3 -j REJECT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A OUTPUT -s 172.16.0.3 -j REJECT</span><br><span class="hljs-comment">#用以上两条规则可以替代默认策略REJECT，从而将默认策略REJECT改为ACCEPT。这样有个好处，因为默认策略REJECT会妨碍ping 回环地址，过于苛刻了。但记得先配置好SSH的规则先，否则XSHELL等SSH工具立刻连不上腾讯云等远端服务器。我学习用的主机中招了，可以重启主机恢复iptables的默认配置，，从而重新连上远程服务器</span><br><span class="hljs-comment">#[root@ashjian ~]#iptables -A INPUT -i ens0 -j REJECT</span><br><span class="hljs-comment">#[root@ashjian ~]#iptables -A OUTPUT -o ens0 -j REJECT</span><br><span class="hljs-comment">#如果地址过多，可以通过网卡入口出口来设置</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -P INPUT ACCEPT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -P OUTPUT ACCEPT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -I OUTPUT 2 -s 172.16.0.3 -p icmp --icmp-type 8 -j ACCEPT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -I INPUT 2 -d 172.16.0.3 -p icmp --icmp-type 0/0 -j ACCEPT</span><br><br>[root@ashjian ~]<span class="hljs-comment">#iptables -R INPUT 2 -d 172.16.0.3 -p -m multiport -dport 22.80,139,445 -j ACCEPT #mulitport匹配散列端口匹配</span><br> [root@ashjian videos]<span class="hljs-comment">#iptables -I INPUT -d 172.16.0.3 -p tcp --dport 23 -m iprange --src-range 172.16.0.60-172.16.0.70 -jACCEPT #iprange连续地址匹配</span><br><br>[root@ashjian videos]<span class="hljs-comment">#iptables -R INPUT 3 -d 172.16.0.3 -p tcp --dport 23 -m iprange --src-range 172.16.0.60-172.16.0.70 -m time --timestart 10:00:00 --timestop 16:00:00 --weekdays 1,2,3,4,5 --kerneltz -j ACCEPT #time设置时间限制的访问</span><br><br>[root@ashjian videos]<span class="hljs-comment">#iptables -I INPUT 2 -s 172.16.0.3 -m string --algo kmp --string "ashjain" -j REJECT #匹配报文内容字符串</span><br><br>[root@ashjian videos]<span class="hljs-comment">#iptables -R INPUT 3 -d 172.16.0.3 -p tcp --dport 3306 --connlimit --connlimit-upto 2 -j ACCEPT #connlimit限制ip的并发连接数</span><br><br>[root@ashjian videos]<span class="hljs-comment">#iptables -I INPUT 4 -d 172.16.0.3 -p icmp --icmp-type 8 -m limit --limit-burst 5 -limit 20/minute -j ACCEPT #limit限制发送报文速率</span><br><br><br>[root@ashjian ~]<span class="hljs-comment">#cat /proc/sys/net/netfilter/nf_conntrack_max</span><br>65536 <span class="hljs-comment">#最大的连接追踪数量，可调整，前提是有足够的内核空间</span><br>[root@ashjian ~]<span class="hljs-comment">#cat /proc/net/nf_conntrack #连接追踪的记录文件</span><br><br>[root@ashjian ~]<span class="hljs-comment">#iptables -I INPUT 4 -d 172.16.0.3 -p tcp -m multiport --dports 22:23,80,3306,139,445 -m state --state NEW -j ACCEPT #state限制连接转态</span><br><br>[root@ashjian ~]<span class="hljs-comment">#lsmod | grep nf</span><br>nf_reject_ipv4         13373  1 ipt_REJECT<br>nf_reject_ipv6         13717  1 ip6t_REJECT<br>nf_conntrack_ipv6      18935  7  <span class="hljs-comment">#nf_conntrack模块用于连接追踪，启动了连接追踪就会lsmod查看到</span><br>nf_defrag_ipv6         35104  1 nf_conntrack_ipv6<br>nf_nat_ipv6            14131  1 ip6table_nat<br>nf_conntrack_ipv4      15053  6  <span class="hljs-comment">#连接追踪</span><br>nf_defrag_ipv4         12729  1 nf_conntrack_ipv4<br>nf_nat_ipv4            14115  1 iptable_nat<br>nf_nat                 26787  2 nf_nat_ipv4,nf_nat_ipv6<br>nf_conntrack          133053  6 <span class="hljs-comment">#连接追踪 nf_nat,nf_nat_ipv4,nf_nat_ipv6,xt_conntrack,nf_conntrack_ipv4,nf_conntrack_ipv6</span><br>libcrc32c              12644  2 nf_nat,nf_conntrack<br>nfnetlink              14490  1 ip_set<br><br><span class="hljs-comment">#这三个模块对FTP连接的RELATED状态无效，有专门的模块来处FTP连接的RELATED状态</span><br>[root@ashjian ~]<span class="hljs-comment">#modinfo nf_conntrack_ftp</span><br>filename:       /lib/modules/3.10.0-862.el7.x86_64/kernel/net/netfilter/nf_conntrack_ftp.ko.xz<br><span class="hljs-built_in">alias</span>:          nfct-helper-ftp<br><span class="hljs-built_in">alias</span>:          ip_conntrack_ftp<br>description:    ftp connection tracking helper<br>author:         Rusty Russell &lt;rusty@rustcorp.com.au&gt;<br>license:        GPL<br>retpoline:      Y<br>rhelversion:    7.5<br>srcversion:     83D9304C9B64D8FBC064040<br>depends:        nf_conntrack<br>intree:         Y<br>vermagic:       3.10.0-862.el7.x86_64 SMP mod_unload modversions <br>signer:         CentOS Linux kernel signing key<br>sig_key:        3A:F3:CE:8A:74:69:6E:F1:BD:0F:37:E5:52:62:7B:71:09:E3:2B:96<br>sig_hashalgo:   sha256<br>parm:           ports:array of ushort<br>parm:           loose:bool<br><span class="hljs-comment">#这模块默认没有装载，它也不会自动装载</span><br>[root@ashjian ~]<span class="hljs-comment">#modprobe nf_conntrack_ftp</span><br>[root@ashjian ~]<span class="hljs-comment">#lsmod | grep nf_conntrack_ftp</span><br>nf_conntrack_ftp       18638  0 <br>nf_conntrack          133053  7 nf_nat,nf_nat_ipv4,nf_nat_ipv6,xt_conntrack,nf_conntrack_ftp,nf_conntrack_ipv4,nf_conntrack_ipv6<br>[root@ashjian ~]<span class="hljs-comment">#iptables -R INPUT 1 -d 172.16.0.3 -p tcp m state --state ESTABLISHED,RELATED -j ACCEPT #添加RELATED的放行</span><br><br><span class="hljs-comment">#target使用自定义链</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A in_ping_rules</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A in_ping_rules -d 172.16.0.3 -p icmp --icmp-type 8 -j ACCEPT</span><br>root@ashjian ~]<span class="hljs-comment">#iptables -I INPUT 5 -d 172.16.0.3 -p icmp -j in_ping_rules</span><br><span class="hljs-comment">#0reference是无法单独使用的。要被5个内置链引用，引用过后的自定义链是无法删除的。五大链调用自定义链无匹配后，会返回到原本链继续匹配规则。自定义链可以多级调用</span><br><br><span class="hljs-comment">#删除自定义链</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -F in_ping_rules #1、先清空引用计数器</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -X in_ping_rules #2、再删自定义链</span><br><br><br><span class="hljs-comment">#构建SNAT</span><br>[root@ashjian ~]<span class="hljs-comment">#man iptables-extensions</span><br><span class="hljs-comment">#SNAT选项有以下三个</span><br>--to-source [ipaddr[-ipaddr]][:port[-port]]<br><span class="hljs-comment">#指定转换成的外网地址范围，建议不转换源端口</span><br> --random <span class="hljs-comment">#转换的外网地址范围中，随机挑选一个来转换，一般不使用，默认是轮序地址</span><br> --persistent <span class="hljs-comment">#同一个客户端转换的外网地址保持同一个，一般不使用</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -t nat -A POSTROUTING -s 172.16.0.0/24 -j SNAT --source 172.16.0.1 #放行内网客户端访问外网所有</span><br>[root@ashjian ~]<span class="hljs-comment">#tcpdump -i eth0 -nn tcp port 80</span><br><span class="hljs-comment">#SNAT适用于源地址是静态地址，如果是源地址是动态地址则用 MASQUERADE</span><br><br><span class="hljs-comment">#DNAT</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -t nat -A PERROUTING -d 172.16.0.3 -p tcp --dport 80 -j DNAT --to-destination 192.168.0.2</span><br><span class="hljs-comment">#DNAT也可做目标端口转换</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -t nat -R PERROUTING -d 172.16.0.3 -p tcp --dport 80 -j DNAT --to-destination 192.168.0.2:8080</span><br><span class="hljs-comment">#结合DNAT和filter禁止某台主机访问网页，注意访问时PERROUTING时DNAT了，DNAT的外网地址已经转换成内网的服务器地址了，目标地址应该是内网的服务器地址</span><br>[root@ashjian ~]<span class="hljs-comment">#iptables -A FORWARD -s 172.16.0.200 -d 192.168.0.2 -p tcp --port 8080 -j REJECT</span><br><br><span class="hljs-comment">#端口映射REDIRECT（重定向）</span><br>root@ashjian ~]<span class="hljs-comment">#iptables -t nat -I PERROUTING -d 192.168.0.200 -p tcp --port 80 -j REDIRECT --dports 8080</span><br></code></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>02-kill命令</title>
    <url>/02-kill%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用法：，<code>kill -SIGNAL pid</code></p>
<p>SIGNAL是信号，<code>kill -l</code>可以查看支持的信号。</p>
<p>下面是系统支持的信号，用<code>man 7 signal</code>可以查询到：</p>
<p><a href="http://www.yulongjun.com/images/14987871036352.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002652.jpg" alt="img"></a></p>
<p>常用信号：</p>
<p>1) SIGHUP: 无须关闭进程而让其重读配置文件<br>2) SIGINT: 中止正在运行的进程；相当于Ctrl+c<br>3) SIGQUIT:相当于ctrl+<br>9) SIGKILL: 强制杀死正在运行的进程<br>15) SIGTERM：终止正在运行的进程<br>18) SIGCONT：继续运行<br>19) SIGSTOP：后台休眠</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">kill -9 4365<br>kill -19 4444 # 让4444休眠<br>kil -18 4444 # 让4444继续运行<br></code></pre></td></tr></table></figure>

<h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p><code>-SIGNAL</code>：指定信号</p>
<p><code>-u uid</code>: effective user，生效者</p>
<p><code>-U uid</code>: real user，真正发起运行命令者</p>
<p><code>-t terminal</code>: 与指定终端相关的进程</p>
<p>-l: 显示进程名（pgrep可用）</p>
<p>-a: 显示完整格式的进程名（pgrep可用）</p>
<p>-P pid: 显示指定进程的子进程</p>
<p>例子：<br><code>pkill -t dev/tty3</code></p>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>前台运行<br>后台运行<br>后台休眠</p>
<p>kill -19 xxx 后台休眠<br>kill -18 xxx 后台继续运行<br>bg 1 后台运行（在同一个终端窗口执行）<br>fg 1 前台运行（在同一个终端窗口执行）</p>
<p>可以让程序不依赖终端运行的两种方法：</p>
<ul>
<li><code>nohup COMMAND &amp;&gt;/dev/null &amp;</code></li>
<li><code>screen;COMMAND</code></li>
</ul>
<h2 id="同时运行多个进程，提高效率"><a href="#同时运行多个进程，提高效率" class="headerlink" title="同时运行多个进程，提高效率"></a>同时运行多个进程，提高效率</h2><ul>
<li>方法1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim all.sh<br>f1.sh&amp;<br>f2.sh&amp;<br>f3.sh&amp;<br></code></pre></td></tr></table></figure>

<ul>
<li>方法2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(f1.sh&amp;);(f2.sh&amp;);(f3.sh&amp;)<br></code></pre></td></tr></table></figure>

<ul>
<li>方法3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123; f1.sh&amp; f2.sh&amp; f3.sh&amp; &#125;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>02-shell进阶--函数</title>
    <url>/02-shell%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="系统里的函数"><a href="#系统里的函数" class="headerlink" title="系统里的函数"></a>系统里的函数</h2><p><code>declare -f</code> 查看系统里的函数</p>
<p><code>declare -f |grep &quot;.* ()&quot;|tr -d &quot; ()&quot;</code>：用grep可以过滤出函数名</p>
<p><a href="http://www.yulongjun.com/images/14992636902645.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002642.jpg" alt="img"></a></p>
<p><code>declare -f 函数名</code> ：查看特定的函数<br><a href="http://www.yulongjun.com/images/14992637450262.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002950.jpg" alt="img"></a></p>
<p><code>unset 函数名</code> ：和变量一样的取消一样，可以unset取消函数</p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>语法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">function f_name &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>

<p>语法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">function f_name () &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>

<p>语法三(最常见，记住这个用法就行）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">f_name () &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>函数的调用：</p>
<ul>
<li>可在交互式环境下定义函数，即直接在bash命令行里写函数和调用函数。</li>
<li>可将函数放在脚本文件中作为它的一部分，即在同一个脚本文件里调用函数。</li>
<li>可放在<strong>只包含函数</strong>的单独文件中，即其他shell脚本可以调用这个文件，用<code>. path/to/functions_file</code>或者<code>source path/to/functions_file</code></li>
</ul>
<p>函数调用很简单：<br>无参数：<code>function_name</code><br>有参数：<code>functions_name arg1 arg2 ... argN</code></p>
<blockquote>
<p><code>functions_name</code>为函数名，<code>arg</code>为argument（参数）的意思。在函数体中当中，可使用<code>$1</code>, <code>$2</code>调用这些参数；还 可以使用<code>$@</code>, <code>$*</code>, $#等特殊变量</p>
</blockquote>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数有两种返回值：</p>
<ul>
<li>函数的执行结果返回值：</li>
</ul>
<p>(1) 使用<code>echo</code>等命令进行输出</p>
<p>(2) 函数体中调用命令的输出结果</p>
<ul>
<li>函数的退出状态码：</li>
</ul>
<p>(1) 默认取决于函数中执行的最后一条命令的退出状态码</p>
<p>(2) 自定义退出状态码，其格式为：</p>
<p><code>return</code> 从函数中返回，用最后状态命令决定返回值。</p>
<p><code>return 0</code> 无错误返回。</p>
<p><code>return 1-255</code> 有错误返回。</p>
<h2 id="函数中的局部变量"><a href="#函数中的局部变量" class="headerlink" title="函数中的局部变量"></a>函数中的局部变量</h2><p>当函数中有变量的时候，和函数体外的变量容易冲突，这时候可以用局部变量</p>
<p>在函数中定义局部变量的方法：<br><code>local NAME=VALUE</code></p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>函数直接或间接调用函数自身。</p>
<p><strong>阶乘：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>fact() &#123;<br>    if [ $1 -eq 0 -o $1 -eq 1 ]; then<br>        echo 1<br>    else<br>        echo $[$1*$(fact $[$1-1])]<br>    fi<br>&#125;<br>fact $1<br></code></pre></td></tr></table></figure>

<p><strong>fork炸弹：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">:()&#123; :|:&amp; &#125;;:<br># 冒号在这里其实就是函数名，换成另外的单词你就理解了：<br>bomb() &#123; bomb | bomb &amp; &#125;; bomb<br></code></pre></td></tr></table></figure>

<p><strong>菲波那切数列：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">read -p &quot;请输入数列个数：&quot; n<br><br>fib()&#123;<br>    if [ $1 -eq 0 ] ; then<br>        ret&#x3D;0<br>        echo $ret<br>    elif [ $1 -eq 1 ]; then<br>        ret&#x3D;1<br>        echo $ret<br>    elif [ $1 -gt 1 ]; then<br>        let ret&#x3D;$(fib $[$1-1])+$(fib $[$1-2])<br>        echo $ret<br>    fi<br>&#125;<br><br>for i in &#96;seq $n&#96;; do<br>    fib $i<br>done<br></code></pre></td></tr></table></figure>

<h2 id="环境函数-全局函数）"><a href="#环境函数-全局函数）" class="headerlink" title="环境函数(全局函数）"></a>环境函数(全局函数）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">export -f func&#96;或者&#96;declare -fx func<br></code></pre></td></tr></table></figure>

<blockquote>
<p>declare中，<code>-f</code>的意思是function，<code>-x</code>的意思是<code>export</code></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>02-位置变量和退出码</title>
    <url>/02-%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F%E5%92%8C%E9%80%80%E5%87%BA%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h2><p>位置变量：在脚本代码中调用通过命令行传递给脚本的参数</p>
<ul>
<li><code>$1, $2, ...$9, ${10}</code>：对应脚本后参数的位置，超过两位数后要加花括号。</li>
<li><code>$0</code>: 脚本本身（绝对路径）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br><br>echo The script name is &#96;basename $0&#96;<br>echo &quot;1st arg is $1&quot;<br>echo &quot;2st arg is $2&quot;<br>echo &quot;9st arg is $9&quot;<br>echo &quot;10st arg is $&#123;10&#125;&quot;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[LongDream❄MBP:Scripts]☭ .&#x2F;testarg.sh &#123;1..10&#125;<br>The script name is testarg.sh<br>1st arg is 1<br>2st arg is 2<br>9st arg is 9<br>10st arg is 10<br></code></pre></td></tr></table></figure>

<ul>
<li><code>$*</code>: 传递给脚本的所有参数，<strong>全部参数合为一个字符串</strong></li>
<li><code>$@</code>: 传递给脚本的所有参数，<strong>每个参数为独立字符串</strong></li>
<li><code>$#</code>: 传递给脚本的参数的<strong>个数</strong></li>
</ul>
<blockquote>
<p>tips: <code>$@</code> <code>$*</code> 只在被双引号包起来的时候才会有差异</p>
</blockquote>
<ul>
<li><code>shift NUM</code>可以用来想做移动位置参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># shift.sh <br>echo 1st arg is $1<br>echo 2st arg is $2<br>echo 9st arg is $9<br>echo the args counts is $#<br>echo all args are &quot;$*&quot;<br><br>shift<br><br>echo 1st arg is $1<br>echo 2st arg is $2<br>echo 9st arg is $9<br>echo the args counts is $#<br>echo all args are &quot;$*&quot;<br><br>shift<br><br><br>echo 1st arg is $1<br>echo 2st arg is $2<br>echo 9st arg is $9<br>echo the args counts is $#<br>echo all args are &quot;$*&quot;<br><br>shift 2<br></code></pre></td></tr></table></figure>

<p>可以看到执行效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 bin]☭ .&#x2F;shift.sh &#123;a..z&#125;<br>1st arg is a<br>2st arg is b<br>9st arg is i<br>the args counts is 26<br>all args are a b c d e f g h i j k l m n o p q r s t u v w x y z<br>1st arg is b<br>2st arg is c<br>9st arg is j<br>the args counts is 25<br>all args are b c d e f g h i j k l m n o p q r s t u v w x y z<br>1st arg is c<br>2st arg is d<br>9st arg is k<br>the args counts is 24<br>all args are c d e f g h i j k l m n o p q r s t u v w x y z<br></code></pre></td></tr></table></figure>



<h2 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h2><p><code>0</code>代表命令运行成功<br><code>1-255</code>代表命令运行失败</p>
<p><a href="http://www.yulongjun.com/images/14967409749144.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200821141031.jpg" alt="img"></a></p>
<p>脚本中可以自定义退出码，比如<code>exit 100</code><br><code>$?</code>上一个命令运行时候的退出状态码。</p>
<h2 id="amp-amp-与"><a href="#amp-amp-与" class="headerlink" title="&amp;&amp; 与 ||"></a><code>&amp;&amp;</code> 与 <code>||</code></h2><p><code>&amp;&amp;</code>：前面命令成功，则运行后面命令。<br><code>||</code>：前面命令失败，则运行后面命令。</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>实现自动生成sh脚本的模板。</p>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;env bash<br><br>echo &quot;#!&#x2F;bin&#x2F;bash&quot; &gt;&gt; $1<br>echo &quot;# Script Name: &#96;basename $1&#96;&quot; &gt;&gt;$1<br>echo &quot;# Author: ashjian&quot; &gt;&gt;$1<br>echo &quot;# Version: 0.1&quot; &gt;&gt;$1<br>echo &quot;# Date: &#96;date +%F&#96;&quot; &gt;&gt;$1<br>echo &quot;# Description: &quot; &gt;&gt;$1<br></code></pre></td></tr></table></figure>

<h3 id="我的-vimrc"><a href="#我的-vimrc" class="headerlink" title="我的.vimrc"></a>我的.vimrc</h3><p>.vimrc可用于定义sh后缀的文件，用vim打开时自动添加#! /bin/bash射邦语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">set ignorecase <br>set cursorline<br>set autoindent<br>autocmd BufNewFile *.sh exec &quot;:call SetTitle()&quot;<br>func SetTitle()<br>        if expand(&quot;%:e&quot;) &#x3D;&#x3D; &#39;sh&#39;<br>        call setline(1,&quot;#!&#x2F;bin&#x2F;bash&quot;) <br>        call setline(2,&quot;#&quot;) <br>        call setline(3,&quot;#********************************************************************&quot;) <br>        call setline(4,&quot;#Author:                ashjian&quot;) <br>        call setline(5,&quot;#QQ:                    2672259469&quot;) <br>        call setline(6,&quot;#Date:                  &quot;.strftime(&quot;%Y-%m-%d&quot;))<br>        call setline(7,&quot;#FileName：             &quot;.expand(&quot;%&quot;))<br>        call setline(8,&quot;#URL:                   http:&#x2F;&#x2F;www.ashjian.xyz&quot;)<br>        call setline(9,&quot;#Description：          The test script&quot;) <br>        call setline(10,&quot;#Copyright (C):        &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;)<br>        call setline(11,&quot;#********************************************************************&quot;) <br>        call setline(12,&quot;&quot;) <br>        endif<br>endfunc<br>autocmd BufNewFile * normal G<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL编程</tag>
      </tags>
  </entry>
  <entry>
    <title>02-命令提示符</title>
    <url>/02-%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="命令提示符（prompt）"><a href="#命令提示符（prompt）" class="headerlink" title="命令提示符（prompt）"></a>命令提示符（prompt）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]$	这个为命令提示符<br></code></pre></td></tr></table></figure>

<p><strong>#</strong>代表管理员</p>
<p><strong>$</strong>代表普通用户</p>
<p>显示提示符格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian /]<span class="hljs-variable">$echo</span> <span class="hljs-variable">$PS1</span><br>\[\e[1;32m\][\u@\h \W]\\$\[\e[0m\]<br></code></pre></td></tr></table></figure>

<p>变量PS1定义了提示符的<strong><em>格式</em></strong></p>
<p>通过man命令查看bash的帮助说明，再用<strong>/</strong>搜索<strong>PS1</strong>或者<strong>prompt</strong>，可以查看得到提示符格式的相关说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian /]<span class="hljs-variable">$man</span> bash<br></code></pre></td></tr></table></figure>

<h3 id="修改命令提示符"><a href="#修改命令提示符" class="headerlink" title="修改命令提示符"></a>修改命令提示符</h3><table>
<thead>
<tr>
<th align="left">转义字符</th>
<th>意思</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\e</td>
<td>控制符\033</td>
</tr>
<tr>
<td align="left">\h</td>
<td>主机名简称</td>
</tr>
<tr>
<td align="left">\w</td>
<td>当前工作目录</td>
</tr>
<tr>
<td align="left">\t</td>
<td>24小时时间格式</td>
</tr>
<tr>
<td align="left">!</td>
<td>命令历史数</td>
</tr>
<tr>
<td align="left">\u</td>
<td>当前用户</td>
</tr>
<tr>
<td align="left">\H</td>
<td>主机名</td>
</tr>
<tr>
<td align="left">\W</td>
<td>当前工作目录基名</td>
</tr>
<tr>
<td align="left">\T</td>
<td>12小时时间格式</td>
</tr>
<tr>
<td align="left">#</td>
<td>开机后命令历史数</td>
</tr>
</tbody></table>
<p>Linux的变量要永久生效，得写在一个配置文件中，文件名往往<strong>.sh</strong>为后缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;profile.d&#x2F;env.sh <br>PS1&#x3D;&quot;\[\e[1;32m\][\u@\h \W]\\$\[\e[0m\]&quot;<br></code></pre></td></tr></table></figure>



<h3 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#  PS1设置字符颜色的格式为：<br><br>      \[\e[F;Bm\].....\[\e[0m\]  <br>      或者 \[\033[F;Bm\].....\[\033[0m\] <br>      其中“F”为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47，B和F不区分先后，系统会识别		数字范围<br>      \[\e[0m\] 结束颜色设定。“B”还可以设置其他格式，<br>      例如为1时，将显示加亮加粗的文字<br><br>** PS1&#x3D;&quot;\[\e[01;32m\]\u@\h: \W\$\[\e[00m\] &quot;export PS1 **<br>#  ** PS1&#x3D;&quot;\[\033[01;32m\]\u@\h: \W\$\[\033[00m\] &quot;#export PS1 **<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02-打包压缩</title>
    <url>/02-%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-tar"><a href="#1-tar" class="headerlink" title="1. tar"></a>1. tar</h2><p>tar的意思是<code>Together ARchive</code>（打包归档）。我们可以用来打包，也可以用来解压包，而且还支持打包后用各种格式压缩（gz、bz2、xz等）。</p>
<p>单个参数意义：<br><code>f</code>: 归档file<br><code>v</code>: verbose（注：详细），显示压缩过程的详细信息<br><code>t</code>: list,显示归档的内容<br><code>x</code>: extract,解压<br><code>c</code>: compress,压缩<br><code>z</code>: gzip格式压缩，后缀为<code>.gz</code><br><code>j</code>: bzip2格式压缩，后缀为<code>.bz2</code><br><code>J</code>: xz格式压缩，后缀为<code>.xz</code></p>
<p><code>-exclude</code>排除文件</p>
<p><code>-T</code> 指定输入文件  </p>
<p><code>-X</code> 指定包含要排除的文件列表</p>
<p><strong>常用组合：</strong></p>
<table>
<thead>
<tr>
<th align="left">组合参数</th>
<th align="left">意义</th>
<th align="left">压缩文件后缀</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cvf</code></td>
<td align="left">原始tar包，不压缩</td>
<td align="left"><code>.tar</code></td>
</tr>
<tr>
<td align="left"><code>zcvf</code></td>
<td align="left">先tar，后gzip压缩</td>
<td align="left"><code>tar.gz</code> 、<code>tgz</code></td>
</tr>
<tr>
<td align="left"><code>jcvf</code></td>
<td align="left">先tar，后bzip2压缩</td>
<td align="left"><code>tar.bz2</code> 、<code>tbz2</code></td>
</tr>
<tr>
<td align="left"><code>Jcvf</code></td>
<td align="left">先tar，后xz压缩</td>
<td align="left"><code>tar.xz</code>、<code>txz</code></td>
</tr>
<tr>
<td align="left"><code>xvf</code></td>
<td align="left">解压所有格式，通用解压命令</td>
<td align="left">-</td>
</tr>
</tbody></table>
<blockquote>
<p>tips: 在编写shell脚本打包的时候，我们通常不会用<code>v</code>选项，这样屏幕输出会比较乱，我们一般用echo在打包前后提示一下打包开始和打包完成，就ok了。举个我之前写的脚本例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;&#x3D;&#x3D;&gt;开始打包文件夹...&quot;<br>tar -czf Blog&#96;date +%Y%m%d&#96;.tar.gz Blog<br>echo &quot;&#x3D;&#x3D;&gt;打包成Blog&#96;date +%Y%m%d&#96;.tar.gz完毕.&quot;<br>echo &quot;&#x3D;&#x3D;&gt;移动打包文件到&#x2F;Volumes&#x2F;Transcend&#x2F;Backup&#x2F;Blog&#x2F;...&quot;<br>mv -f Blog&#96;date +%Y%m%d&#96;.tar.gz &#x2F;Volumes&#x2F;Transcend&#x2F;Backup&#x2F;Blog&#x2F;<br>echo &quot;&#x3D;&#x3D;&gt;移动完毕.&quot;<br></code></pre></td></tr></table></figure>

<p>执行效果就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">LongDream❄MBP:Scripts]# .&#x2F;backup_blog.sh<br>&#x3D;&#x3D;&gt;开始打包文件夹...<br>&#x3D;&#x3D;&gt;打包成Blog20170607.tar.gz完毕.<br>&#x3D;&#x3D;&gt;移动打包文件到&#x2F;Volumes&#x2F;Transcend&#x2F;Backup&#x2F;Blog&#x2F;...<br>&#x3D;&#x3D;&gt;移动完毕.<br></code></pre></td></tr></table></figure>

<h2 id="2-zip-amp-unzip"><a href="#2-zip-amp-unzip" class="headerlink" title="2. zip&amp;unzip"></a>2. zip&amp;unzip</h2><p>打包并压缩：<code>zip -r xxx.zip xxx</code><br>解压缩解包：<code>unzip xxx.zip</code></p>
<p>举个解压oracle安装包的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">unzip p13390677_112040_platform_1of7.zip &amp;&amp; unzip p13390677_112040_platform_2of7.zip &amp;&amp; unzip p13390677_112040_platform_4of7.zip<br></code></pre></td></tr></table></figure>

<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p><code>split</code>：<strong>切割打包</strong>。</p>
<p>默认包分割后的名字后缀是<code>aa, ab, ac, ...</code></p>
<ul>
<li><code>-b SIZE</code> 指定每个分割包的大小</li>
<li><code>-d DIGIT</code> 每个分割包名后缀按数字命名：<code>01, 02, ...</code></li>
</ul>
<p>例子1（不加-d）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian bin]# ll -h bin.tar.gz <br>-rw-r--r--. 1 root root 54M Jun  7 20:41 bin.tar.gz<br>[root@ashjian bin]# split -b 10M bin.tar.gz bin_<br>[root@ashjian bin]# ll -h bin_*<br>-rw-r--r--. 1 root root  10M Jun  7 20:44 bin_aa<br>-rw-r--r--. 1 root root  10M Jun  7 20:44 bin_ab<br>-rw-r--r--. 1 root root  10M Jun  7 20:44 bin_ac<br>-rw-r--r--. 1 root root  10M Jun  7 20:44 bin_ad<br>-rw-r--r--. 1 root root  10M Jun  7 20:44 bin_ae<br>-rw-r--r--. 1 root root 3.8M Jun  7 20:44 bin_af<br></code></pre></td></tr></table></figure>

<p>例子2（加-d）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian bin]# ll -h bin.tar.gz<br>-rw-r--r--. 1 root root 54M Jun  7 20:41 bin.tar.gz<br>[root@ashjian bin]# split -b 10M -d bin.tar.gz bin_<br>[root@ashjian bin]# ll -h bin_[0-9]?<br>-rw-r--r--. 1 root root  10M Jun  7 20:47 bin_00<br>-rw-r--r--. 1 root root  10M Jun  7 20:47 bin_01<br>-rw-r--r--. 1 root root  10M Jun  7 20:47 bin_02<br>-rw-r--r--. 1 root root  10M Jun  7 20:47 bin_03<br>-rw-r--r--. 1 root root  10M Jun  7 20:47 bin_04<br>-rw-r--r--. 1 root root 3.8M Jun  7 20:47 bin_05<br></code></pre></td></tr></table></figure>

<p><strong>合并切割的包</strong></p>
<p>例子：<code>cat mybackup-parts* &gt; mybackup.tar.gz</code></p>
<h3 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h3><p>作用：</p>
<ul>
<li><p>通过重定向的方式将文件进行打包备份，还原恢复</p>
</li>
<li><p>解压以 “.cpio”或者“.tar”结尾的文件</p>
</li>
</ul>
<p>选项</p>
<p><code>-o</code> :执行copy-out模式，建立备份档</p>
<p><code>-A</code>:向已存在的归档文件中追加文件<br><code>-i</code>:解包，将打包文件解压或将设备上的备份还原到系统<br><code>-t</code>:预览，查看文件内容或者输出到设备上的文件内容<br><code>-d</code>:解包生成目录，在cpio还原时，自动的建立目录<br><code>-v</code>:显示打包过程中的文件名称 </p>
<p><code>-O</code> filename :输出到指定的归档文件名</p>
<p><code>-I</code> filename :对指定的归档文件名解压</p>
<p><code>-F</code> filename :使用指定的文件名替代标准输入或输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">将etc目录备份：<br>find .&#x2F;etc -print |cpio -ov &gt;bak.cpio<br>将&#x2F;data内容追加bak.cpio<br>find &#x2F;data | cpio -oA -F  bak.cpio<br>内容预览<br>cpio –tv &lt; etc.cpio<br>解包文件<br>cpio –idv &lt; etc.cpio<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>02-文件传输协议FTP</title>
    <url>/02-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><ul>
<li><p>File Transfer Protocol 早期的三个应用级协议之一</p>
</li>
<li><p>基于C/S结构</p>
</li>
<li><p>双通道协议：<code>数据</code>和<code>命令</code>连接</p>
</li>
<li><p>数据传输格式：二进制（默认）和文本</p>
</li>
<li><p>两种模式：服务器角度<br>主动(PORT style)：服务器主动连接</p>
<p>​                命令（控制）：客户端：随机port — 服务器：tcp21 </p>
<p>​                数据：客户端：随机port —服务器：tcp20<br> 被动(PASV style)：客户端主动连接 </p>
<p>​                命令（控制）：客户端：随机port —-  服务器：tcp21 </p>
<p>​                数据：客户端：随机port —- 服务器：随机port  </p>
<p>​                服务器被动模式数据端口示例：</p>
<p>​                227 Entering Passive Mode (172,16,0,1,224,59) </p>
<p>​                服务器数据端口为：224*256+59 </p>
</li>
</ul>
<h2 id="FTP软件介绍"><a href="#FTP软件介绍" class="headerlink" title="FTP软件介绍"></a>FTP软件介绍</h2><h3 id="FTP服务器："><a href="#FTP服务器：" class="headerlink" title="FTP服务器："></a>FTP服务器：</h3><p>Wu-ftpd，Proftpd，Pureftpd，ServU，IIS<br>vsftpd:Very Secure FTP Daemon，CentOS默认FTP服务器 </p>
<p>高速，稳定，下载速度是WU-FTP的两倍<br>ftp.redhat.com数据:单机最多可支持15000个并发 </p>
<h3 id="客户端软件："><a href="#客户端软件：" class="headerlink" title="客户端软件："></a>客户端软件：</h3><p>ftp，lftp，lftpget，wget，curl </p>
<p>  ftp -A ftpserver port  -A主动模式 –p 被动模式   lftp –u username ftpserver<br>  lftp username@ftpserver<br>  lftpget <a href="ftp://ftpserver/pub/file">ftp://ftpserver/pub/file</a>  </p>
<p>gftp：GUI centos5  最新版2.0.19 (11/30/2008) </p>
<p>filezilla，CuteFtp，FlashFXP，LeapFtp<br>IE  <a href="ftp://username:password@ftpserver">ftp://username:password@ftpserver</a> </p>
<h2 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h2><h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><p>1XX：信息     125：数据连接打开 </p>
<p>2XX：成功类状态     200：命令OK     230：登录成功</p>
<p>3XX：补充类               331：用户名OK </p>
<p>4XX：客户端错误     425：不能打开数据连接 </p>
<p>5XX：服务器错误     530：不能登录</p>
<h3 id="用户认证："><a href="#用户认证：" class="headerlink" title="用户认证："></a>用户认证：</h3><p>匿名用户：ftp,anonymous,对应Linux用户ftp<br>系统用户：Linux用户,用户/etc/passwd,密码/etc/shadow ,至少禁止系统用户访问ftp服务，/etc/vsftpd/ftpusers,PAM（/etc/pam.d/vsftpd）<br>虚拟用户：非系统用户，不是可登录操作系统的用户账号(非/etc/passwd)，比如账号存放在数据库MySQL·中</p>
<p>​                    特定服务的专用用户，独立的用户/密码文件  </p>
<p>​                    nsswitch:network service switch名称解析框架 </p>
<p>​                    pam:pluggable authentication module 用户认证 </p>
<p>​                    /lib64/security  /etc/pam.d/  /etc/pam.conf  </p>
<p>​                        </p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>SCHEME://username:password@HOST:PORT/PATH/TO/FILE</p>
<p>用户的家目录映射成FTP协议URL的DocumentRoot</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>02-正则表达式(RegExp)</title>
    <url>/02-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-RegExp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Regular Expression</code>，正则表达式，简写为<code>RegExp</code>。</p>
<ul>
<li><code>BRE</code> ：Basic RegExp，基本正则表达式</li>
<li><code>ERE</code> ：Extend RegExp，扩展正则表达式</li>
<li><code>PCRE</code> ：Perl Compatible RegExp，Perl兼容的正则表达式</li>
</ul>
<hr>
<h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><blockquote>
<ul>
<li><code>.</code> 匹配任意单个字符：如<code>r..t</code></li>
<li><code>[]</code> 匹配指定范围内的任意单个字符：如<code>[abc]r</code></li>
<li><code>[^]</code> 匹配指定范围外的任意单个字符：如<code>[^abc]r</code></li>
<li><code>[:alnum:]</code> 字母和数字</li>
<li><code>[:alpha:]</code> 代表任何英文大小写字符，亦即 <code>A-Z, a-z</code></li>
<li><code>[:lower:]</code> 小写字母</li>
<li><code>[:upper:]</code> 大写字母</li>
<li><code>[:blank:]</code> 空白字符（空格和制表符）</li>
<li><code>[:space:]</code> 水平和垂直的空白字符（比[:blank:]包含的范围广）</li>
<li><code>[:cntrl:]</code> 不可打印的控制字符（退格、删除、警铃…）</li>
<li><code>[:digit:]</code> 十进制数字 </li>
<li><code>[:xdigit:]</code>十六进制数字</li>
<li><code>[:graph:]</code> 可打印的非空白字符</li>
<li><code>[:print:]</code> 可打印字符</li>
<li><code>[:punct:]</code> 标点符号</li>
</ul>
</blockquote>
<h3 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h3><blockquote>
<ul>
<li><code>*</code> 匹配前面的字符任意次，包括0次（贪婪模式，尽可能长的匹配）</li>
<li><code>.*</code> 任意长度的任意字符</li>
<li><code>\?</code> 匹配其前面的字符0或1次</li>
<li><code>\+</code> 匹配前面的字符1次或多次</li>
<li><code>\{n\}</code> 匹配前面的字符n次</li>
<li><code>\{m,n\}</code> 匹配前面的字符至少m次，至多n次</li>
<li><code>\{,n\}</code> 匹配前面的字符至多n次</li>
<li><code>\{n,\}</code> 匹配前面的字符至少n次</li>
</ul>
</blockquote>
<h3 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h3><p>位置锚定：定位出现的位置</p>
<blockquote>
<ul>
<li><code>^</code> 行首锚定，用于模式的最左侧(要跟字符匹配里的<code>[^]</code>区分开，那个是在中括号里面的)</li>
<li><code>$</code> 行尾锚定，用于模式的最右侧</li>
<li><code>^PATTERN$</code> 用于模式匹配整行</li>
<li><code>^$</code> 空行</li>
<li><code>^[[:space:]]*$</code> 空白行</li>
<li><code>\&lt;</code> 或 <code>\b</code> 词首锚定，用于单词模式的左侧</li>
<li><code>\&gt;</code> 或 <code>\b</code> 词尾锚定；用于单词模式的右侧</li>
<li><code>\&lt;PATTERN\&gt;</code> 匹配整个单词</li>
</ul>
</blockquote>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组：<code>\(\)</code>将一个或多个字符捆绑在一起，当作一个整体进 行处理，如：<code>\(root\)\+</code></p>
<p>分组括号中的模式匹配到的内容会被正则表达式引擎记录于 内部的变量中，这些变量的命名方式为: <code>\1</code>, <code>\2</code>, <code>\3</code>, …<br><code>\1</code> 表示从左侧起第一个左括号以及与之匹配右括号之间的 模式所匹配到的字符</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">\(string1\+\(string2\)*\)<br>\1&#96; ：&#96;string1\+\(string2\)*<br>\2&#96; ：&#96;string2<br></code></pre></td></tr></table></figure>

<p>后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep &quot;\(root\).*\1&quot; &#x2F;etc&#x2F;passwd<br></code></pre></td></tr></table></figure>

<h3 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">\|<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<p><code>a\|b</code>: a或b</p>
<p><code>C\|cat</code>: C或cat</p>
<p><code>\(C\|c\)at</code>:Cat或cat</p>
<hr>
<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">egrep&#96; &#x3D;&#x3D; &#96;grep -E<br></code></pre></td></tr></table></figure>

<p>egrep其实很简单，就是把grep里的斜线去掉了，不过有些还没有去掉。</p>
<h3 id="字符匹配："><a href="#字符匹配：" class="headerlink" title="字符匹配："></a>字符匹配：</h3><blockquote>
<ul>
<li><code>.</code> 任意单个字符</li>
<li><code>[]</code> 指定范围的字符</li>
<li><code>[^]</code> 不在指定范围的字符</li>
</ul>
</blockquote>
<h3 id="次数匹配："><a href="#次数匹配：" class="headerlink" title="次数匹配："></a>次数匹配：</h3><blockquote>
<ul>
<li><code>*</code>：匹配前面字符任意次</li>
<li><code>?</code>：0或1次</li>
<li><code>+</code>：1次或多次</li>
<li><code>{m}</code>：匹配m次</li>
<li><code>{m,n}</code>：至少m，至多n次</li>
</ul>
</blockquote>
<h3 id="位置锚定："><a href="#位置锚定：" class="headerlink" title="位置锚定："></a>位置锚定：</h3><blockquote>
<ul>
<li><code>^</code>：行首</li>
<li><code>$</code>：行尾</li>
<li><code>\&lt;</code>, <code>\b</code> :语首</li>
<li><code>\&gt;</code>, <code>\b</code> :语尾</li>
</ul>
</blockquote>
<h3 id="分组："><a href="#分组：" class="headerlink" title="分组："></a>分组：</h3><blockquote>
<ul>
<li><code>()</code></li>
<li>后向引用：<code>\1</code>, <code>\2</code>, …</li>
</ul>
</blockquote>
<h3 id="或者："><a href="#或者：" class="headerlink" title="或者："></a>或者：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">|<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<ul>
<li><code>a|b</code>: a或b</li>
<li><code>C|cat</code>: C或cat</li>
<li><code>(C|c)at</code>:Cat或cat</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>02-特殊权限</title>
    <url>/02-%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[root@ashjian app]#touch file1<br>[root@ashjian app]#chattr +i file1<br>[root@ashjian app]#lsattr file1<br>—-i———– file1<br>[root@ashjian app]#echo “yulongjun” &gt; file1<br>-bash: file1: Permission denied<br>[root@ashjian app]#echo “yulongjun” &gt;&gt; file1<br>-bash: file1: Permission denied<br>[root@ashjian app]#mv file1 /tmp<br>mv: cannot remove ‘file1’: Operation not permitted<br>[root@ashjian app]#rm file1<br>rm: remove regular empty file ‘file1’? y<br>rm: cannot remove ‘file1’: Operation not permitted<br>[root@ashjian app]#touch file2<br>[root@ashjian app]#chattr +a file2<br>[root@ashjian app]#lsattr file2<br>—–a———- file2<br>[root@ashjian app]#echo “yulongjun” &gt; file2<br>-bash: file2: Operation not permitted<br>[root@ashjian app]#echo “yulongjun” &gt;&gt; file2<br>[root@ashjian app]#cat file2<br>yulongjun<br>[root@ashjian app]#rm file2<br>rm: remove regular file ‘file2’? y<br>rm: cannot remove ‘file2’: Operation not permitted</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>02-用户和组文件</title>
    <url>/02-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a><code>/etc/passwd</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>whatis passwd<br>man 5 passwd<br><br>name:password:UID:GID:GECOS:directory:shell<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>name</code>：用户名</p>
</li>
<li><p><code>password</code>：密码占位符<code>x</code></p>
</li>
<li><p><code>UID</code>：User ID</p>
</li>
<li><p><code>GID</code>：Group ID</p>
</li>
<li><p><code>GECOS</code>：注释信息</p>
</li>
<li><p><code>directory</code>：用户的家目录</p>
</li>
<li><p><code>shell</code>：用户的默认shell，登录时候默认的shell程序</p>
</li>
</ul>
<blockquote>
<p>tips：用户的注释信息（GECOS）可以通过<code>chfn</code>更改：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# chfn LongDream<br>Changing finger information for LongDream. <br>Name [LongDream]: Yu Longjun<br>Longjun Office []: Beijing <br>Office Phone []: 010-8888888               <br>Home Phone []: 188888888<br><br>Finger information changed.<br>[root@ashjian ~]# finger LongDream<br>Login: LongDream      			Name: Yu Longjun<br>Directory: &#x2F;home&#x2F;LongDream          	Shell: &#x2F;bin&#x2F;bash<br>Office: Beijing, 010-8888888		Home Phone: +1-888-888-8888<br>Last login Thu May 25 08:59 (CST) on pts&#x2F;0<br>No mail.<br>No Plan.<br></code></pre></td></tr></table></figure>

<h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a><code>/etc/shadow</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root:$6$gzEdnxzX$na8Z8EEYpr.piY4jcCsC.52.4HG0uo6aSbvdg5Yu1TJetkmKGfYElSS&#x2F;&#x2F;AebAglmUoW.Z5QodAHYpatAfg7pR&#x2F;:16967:0:99999:7:::<br></code></pre></td></tr></table></figure>

<p>以冒号分割的各个段落的意思：</p>
<ul>
<li><code>account</code>:用户名</li>
<li><code>encrypted passwd</code>：加密后密码 。两个$符号之间：<ul>
<li>第一个6表示加密算法的第六种，<code>sha512sum</code></li>
<li>第二个是salt（随机数）</li>
<li>第三个是真正的密码块</li>
<li>如果整段为<code>!!</code>，表明被锁定，不能登录，去掉，就可以以空密码登录。可以直接改shadow文件，给有密码的前面加个！号，这个账号就无法登录了。</li>
</ul>
</li>
<li><code>date of last passwd change</code>：最后一次更改密码的日期。<br>最近一次更改密码的时间，从1970年1月1日开始的天数。如果是<code>0</code>，表示用户要在下次登录时候更改密码。空表示被禁用了</li>
<li><code>minimum passwd age</code>：最小密码年龄。<br>更改密码后，最短多长时间能更改密码，默认是0，随时可以更改</li>
<li><code>maximum password age</code>：最大密码年龄。<br>在更改密码多少天后，用户必须要更改密码，默认是99999，相当于永不过期</li>
<li><code>password warning period</code>：密码警告时间段<br>密码过期之前，提前警告用户的天数，一般是7，提前7天通知你。</li>
<li><code>password inactivity period</code>：密码禁用期<br>密码过期了之后，仍可以用旧密码的天数，过了这个天数，就给你锁定了，只能用root去解锁了。默认是空，永远可以用。</li>
<li><code>account expiration date</code>：账号过期日期<br>账户要多少天过期，从1970年1月1日起的天数来表示，如果过期了，这个账号就不能使用了。默认是空，永不过期。</li>
<li><code>reserved field</code>：保留字段，后续功能添加</li>
</ul>
<h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a><code>/etc/group</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root:x:0:<br>group_name:passwd:GID:user_list<br></code></pre></td></tr></table></figure>

<ul>
<li><code>group_name</code>：组名</li>
<li><code>passwd</code>：组密码</li>
<li><code>GID</code>：组ID</li>
<li><code>user_list</code>：附加组的用户</li>
</ul>
<blockquote>
<p>tips：由于安全问题，<code>group</code>的密码一般不设置，所以<code>gshadow</code>文件也不用去研究，基本不用。所以只讲了上面三个文件，不用研究<code>/etc/gshadow</code></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>用户和组</tag>
      </tags>
  </entry>
  <entry>
    <title>02-磁盘阵列（RAID）</title>
    <url>/02-%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%EF%BC%88RAID%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>独立硬盘冗余阵列</strong>（<strong>RAID</strong>, <strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>ndependent <strong>D</strong>isks），旧称<strong>廉价磁盘冗余阵列</strong>（<strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>nexpensive <strong>D</strong>isks），简称<strong>磁盘阵列</strong>。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。根据选择的版本不同，RAID比单颗硬盘有以下一个或多个方面的好处：增强数据集成度，增强容错功能，增加处理量或容量。另外，磁盘阵列对于电脑来说，看起来就像一个单独的硬盘或逻辑存储单元。<br>——<a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<p>目前常用的有：</p>
<ul>
<li>标准RAID<ul>
<li>RAID 0</li>
<li>RAID 1</li>
<li>RAID 5</li>
<li>RAID 6</li>
</ul>
</li>
<li>混合RAID<ul>
<li>RAID 10</li>
<li>RAID 50</li>
<li>RAID 60</li>
</ul>
</li>
</ul>
<h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p><a href="http://www.yulongjun.com/images/RAID_0.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202832.svg" alt="RAID_0"></a></p>
<p>RAID 0亦称为带区集。它将两个以上的磁盘并联起来，成为一个大容量的磁盘。在存放数据时，分段后分散存储在这些磁盘中，因为读写时都可以并行处理，所以在所有的级别中，RAID 0的速度是最快的。但是RAID 0既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失。</p>
<h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p><a href="http://www.yulongjun.com/images/RAID_1.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202912.svg" alt="RAID_1"></a></p>
<p>两组以上的N个磁盘相互作镜像，在一些多线程操作系统中能有很好的读取速度，理论上读取速度等于硬盘数量的倍数，与RAID 0相同。另外写入速度有微小的降低。只要一个磁盘正常即可维持运作，可靠性最高。其原理为在主硬盘上存放数据的同时也在镜像硬盘上写一样的数据。当主硬盘（物理）损坏时，镜像硬盘则代替主硬盘的工作。因为有镜像硬盘做数据备份，所以RAID 1的数据安全性在所有的RAID级别上来说是最好的。但无论用多少磁盘做RAID 1，仅算一个磁盘的容量，是所有RAID中磁盘利用率最低的一个级别。</p>
<p>如果用两个不同大小的磁盘建RAID 1，可用空间为较小的那个磁盘，较大的磁盘多出来的空间也可以分区成一个区来使用，不会造成浪费。</p>
<p>\begin{aligned}Size&amp;=\min \left(S<em>{1},S</em>{2},S_{3}\dots \right)\end{aligned}</p>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p><a href="http://www.yulongjun.com/images/RAID_5.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202821.svg" alt="RAID_5"></a></p>
<p>RAID Level 5是一种储存性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。RAID 5至少需要三块硬盘，RAID 5不是对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，可以利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。RAID 5可以理解为是RAID 0和RAID 1的折衷方案。RAID 5可以为系统提供数据安全保障，但保障程度要比镜像低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是因为多了一个奇偶校验信息，写入数据的速度相对单独写入一块硬盘的速度略慢，若使用“回写缓存”可以让性能改善不少。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，便宜。</p>
<p>\begin{aligned}Size&amp;=(N-1)\times \min \left(S<em>{1},S</em>{2},\dots ,S_{N}\right)\end{aligned}</p>
<h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p>与RAID 5相比，RAID 6增加第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，任意两块磁盘同时失效时不会影响数据完整性。RAID 6需要分配给奇偶校验信息更大的磁盘空间和额外的校验计算，相对于RAID 5有更大的IO操作量和计算量，其“写性能”强烈取决于具体的实现方案，因此RAID6通常不会通过软件方式来实现，而更可能通过硬件/固件方式实现。</p>
<p>同一数组中最多容许两个磁盘损坏。更换新磁盘后，数据将会重新算出并写入新的磁盘中。依照设计理论，RAID 6必须具备四个以上的磁盘才能生效。</p>
<p>可使用的容量为硬盘总数减去2的差，乘以最小容量，公式为：</p>
<p>\begin{aligned}Size&amp;=(N-2)\times \min \left(S<em>{1},S</em>{2},S<em>{3},\dots ,S</em>{N}\right)\end{aligned}</p>
<p>同理，数据保护区域容量则为最小容量乘以2。</p>
<p>RAID 6在硬件磁盘阵列卡的功能中，也是最常见的磁盘阵列档次。</p>
<h3 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h3><p><a href="http://www.yulongjun.com/images/RAID_10.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202750.svg" alt="RAID_10"></a></p>
<p>RAID 10是先镜射再分区数据，再将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。</p>
<p>当RAID 10有一个硬盘受损，其余硬盘会继续运作。</p>
<h3 id="RAID-50"><a href="#RAID-50" class="headerlink" title="RAID 50"></a>RAID 50</h3><p><a href="http://www.yulongjun.com/images/RAID_50.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202759.png" alt="RAID_50"></a></p>
<p>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而RAID 5至少需要3颗硬盘，因此要以多组RAID 5构成RAID 50，至少需要6颗硬盘。以RAID 50最小的6颗硬盘配置为例，先把6颗硬盘分为2组，每组3颗构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。</p>
<p>RAID 50在底层的任一组或多组RAID 5中出现1颗硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2颗或2颗以上硬盘损毁，整组RAID 50就会失效。</p>
<p>RAID 50由于在上层把多组RAID 5构成Stripe，性能比起单纯的RAID 5高，容量利用率比RAID5要低。比如同样使用9颗硬盘，由各3颗RAID 5再组成RAID 0的RAID 50，每组RAID 5浪费一颗硬盘，利用率为(1-3/9)，RAID 5则为(1-1/9)。</p>
<h3 id="RAID-60"><a href="#RAID-60" class="headerlink" title="RAID 60"></a>RAID 60</h3><p><a href="http://www.yulongjun.com/images/Raid_60.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202821.svg" alt="Raid_60"></a></p>
<p>RAID 6与RAID 0的组合：先作RAID 6，再作RAID 0。换句话说，就是对两组以上的RAID 6作Stripe访问。RAID 6至少需具备4颗硬盘，所以RAID 60的最小需求是8颗硬盘。</p>
<p>由于底层是以RAID 6组成，所以RAID 60可以容许任一组RAID 6中损毁最多2颗硬盘，而系统仍能维持运作；不过只要底层任一组RAID 6中损毁3颗硬盘，整组RAID 60就会失效，当然这种情况的概率相当低。</p>
<p>比起单纯的RAID 6，RAID 60的上层通过结合多组RAID 6构成Stripe访问，因此性能较高。不过使用门槛高，而且容量利用率低是较大的问题。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>磁盘存储</tag>
        <tag>RAID阵列</tag>
      </tags>
  </entry>
  <entry>
    <title>02-程序包管理工具yum</title>
    <url>/02-%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7yum/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>首先要有一个网络上或本地或远程的yum仓库。<br>然后需要yum安装程序的机器去yum仓库下载yum元数据（包括包信息和依赖信息）到本地的cache里。<br>当需要安装程序的时候，会查看yum源数据里是否有此包，并且查找此包的依赖信息，然后去yum仓库里面下载包和依赖包到本地cache里，并且进行安装。</p>
<p>校验码：远程仓库数据有可能发生改变，这样本地的信息就和仓库信息不符。这样根据校验码，来确定文件是否更改，这样可以节省网络带宽。（对于我们来说，yum一般配置本地仓库，yum源来自操作系统的iso镜像，一般不去校验）</p>
<h2 id="yum仓库-yum-repository"><a href="#yum仓库-yum-repository" class="headerlink" title="yum仓库(yum repository)"></a>yum仓库(yum repository)</h2><p>yum的意思是<code>Yellowdog Update Modifier</code></p>
<p><code>yum repository</code>存放了众多的rpm包，以及包的相关元数据文件（元数据存放于特定目录下：repodata）<br>CentOS和Redhat安装操作系统的时候，anaconda也会去调用yum来安装（不过是调用的本地的光盘上的yum repository）</p>
<blockquote>
<p>tips: 无论任何仓库，<code>repodata</code>目录的父目录就是yum源的目录。比如CentOS 5是在<code>光盘/Server/</code>下,6和7在<code>光盘/</code>下。</p>
</blockquote>
<ul>
<li><strong>网络文件服务器</strong>：CentOS已经配置好，联网可以直接使用（redhat不可使用，需要购买服务），是网络上的的文件服务器。</li>
<li><strong>本地文件服务器</strong>：<ul>
<li><code>file://</code>配置本地文件</li>
<li><code>ftp://</code>配置本地ftp服务器</li>
<li><code>http://</code>、<code>https://</code>配置本地http服务器</li>
</ul>
</li>
</ul>
<p>yum的配置文件：</p>
<ul>
<li><code>/etc/yum.conf</code>yum的公共配置文件</li>
<li><code>/etc/yum.repos.d/*.repo</code>具体的每个仓库的配置，分开文件是为了方便管理和配置。</li>
</ul>
<p><strong>/etc/yum.conf</strong></p>
<p>常用配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[main] #yum仓库id<br>cachedir&#x3D;&#x2F;var&#x2F;cache&#x2F;yum&#x2F;$basearch&#x2F;$releasever #缓存和数据库文件，baseserach指的架构，如&#96;x86_64&#96;，releaserver指的是版本，如&#96;6&#96;或&#96;7&#96;<br>keepcache&#x3D;0 #缓存源文件和安装成功后的下载包是否保存<br>debuglevel&#x3D;2 #debug级别<br>logfile&#x3D;&#x2F;var&#x2F;log&#x2F;yum.log #日志文件位置<br>exactarch&#x3D;1 #精确平台匹配<br>obsoletes&#x3D;1<br>gpgcheck&#x3D;1 #来源完整性和包完整性检查<br>plugins&#x3D;1 # 支不支持插件机制<br>installonly_limit&#x3D;5 # 允许同时安装几个程序包<br>bugtracker_url&#x3D;http:&#x2F;&#x2F;bugs.centos.org&#x2F;set_project.php?project_id&#x3D;19&amp;ref&#x3D;http:&#x2F;&#x2F;bugs.centos.org&#x2F;bug_report_page.php?category&#x3D;yum #bug报告<br>distroverpkg&#x3D;centos-release #ditribution version pkg 发行版版本号获取<br></code></pre></td></tr></table></figure>

<p><strong><code>/etc/yum.repos.d/\*.repo</code></strong></p>
<p>常用配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[repositoryid] # 仓库哦id<br>name&#x3D;Some name for this repository # 仓库名字<br>baseurl&#x3D;url:&#x2F;&#x2F;path&#x2F;to&#x2F;repository&#x2F; # 仓库地址<br>enable&#x3D;&#123;1|0&#125; # 是否可用<br>gpgcheck&#x3D;&#123;0|1&#125; # 是否检查gpg<br>gpgkey&#x3D;URL # 如果检查，写gpgkey地址<br></code></pre></td></tr></table></figure>

<p>yum安装日志：<code>/var/log/yum.log</code></p>
<h2 id="配置实战："><a href="#配置实战：" class="headerlink" title="配置实战："></a>配置实战：</h2><p><strong>yum仓库配置实战1-本地仓库</strong>：</p>
<blockquote>
<p>挂载iso镜像到media目录</p>
<blockquote>
<p>mount -t iso9660 -o loop /var/ftp/pub/CentOS-6.8-x86_64-bin-DVD1.iso /media</p>
</blockquote>
<p>配置/etc/yum.repos.d/local.repo</p>
<blockquote>
<p>[local]<br>name=Repo on Local Cdrom Media<br>baseurl=file:///media<br>gpgcheck=0<br>enable=1</p>
</blockquote>
<p>创建缓存看是否成功</p>
<blockquote>
<p>yum makecache</p>
</blockquote>
</blockquote>
<p><strong>yum仓库配置实战2-ftp仓库</strong>：</p>
<p>创建之前先删除之前的cache：<br><code>rm -rf /var/cache/yum</code></p>
<blockquote>
<p>配置/etc/yum.repos.d/ftp.repo</p>
<blockquote>
<p>[ftp]<br>name=Repo on 172.17.0.1<br>baseurl=<a href="ftp://172.17.0.1/pub/CentOS6u9">ftp://172.17.0.1/pub/CentOS6u9</a><br>gpgcheck=0<br>enable=1</p>
</blockquote>
<p>创建缓存看是否成功</p>
<blockquote>
<p>yum makecache</p>
</blockquote>
</blockquote>
<p>yum用法：</p>
<ul>
<li><p><code>yum makecache</code>：创建yum缓存</p>
</li>
<li><p><code>yum repolist</code>显示启用的仓库列表</p>
</li>
<li><p><code>yum grouplist</code>显示包组</p>
</li>
<li><p><code>yum list</code>显示所有可用包</p>
</li>
<li><p><code>yum list vsftpd*</code>显示和<code>vsftpd*</code>匹配的包</p>
</li>
<li><p><code>yum list installed</code>显示已安装的包</p>
</li>
<li><pre><code>yum install package1 [package2] [...]</code></pre><p>可以安装一个或多个包</p>
<ul>
<li><code>-y</code>参数，即yes，表示不用交互询问，直接安装。</li>
</ul>
</li>
<li><p><code>yum reinstall package1 [package2] [...]</code> 可以重新安装一个或多个包</p>
</li>
<li><p><code>yum update [package1] [package2]</code>不跟包名的话，是更新所有包，带包名的是更新具体的包</p>
</li>
<li><p><code>yum check-update</code>检查可用升级</p>
</li>
<li><p><code>yum remove|erase package1 [package2]</code>卸载程序包</p>
</li>
<li><p><code>yum info</code>查看程序包信息</p>
</li>
<li><p><code>yum provides COMMAND1 [COMMANDN]</code>COMMAND命令是由哪个包提供的。</p>
</li>
<li><p><code>yum search xxx</code>模糊搜索程序包</p>
</li>
<li><p><code>yum clean all</code>清除所有缓存(如果还清不了，可以手动删除<code>rm -rf /var/cache/yum</code>)</p>
</li>
</ul>
<p><strong>非常常用的几个个命令：</strong><br><code>yum clean all</code><br><code>yum makecache</code><br><code>yum -y install xxx yyy zzz</code><br><code>yum remove</code></p>
<h2 id="自制第三方yum源"><a href="#自制第三方yum源" class="headerlink" title="自制第三方yum源"></a>自制第三方yum源</h2><p><code>createrepo /rpmdir</code>会在目录下面生成一个<code>repodata</code>文件夹，存放了包的元数据。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>数据包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>02-管道</title>
    <url>/02-%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14975178915401.jpg" target="_blank" rel="noopener"><img src="02-%E7%AE%A1%E9%81%93.assets/14975178915401.jpg" alt="img"></a></p>
<h3 id="管道（-）基本用法"><a href="#管道（-）基本用法" class="headerlink" title="管道（|）基本用法"></a>管道（<code>|</code>）基本用法</h3><p>管道（<code>|</code>）用来连接命令</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">COMMAND1 | COMMAND2 | COMMAND3 | ...<br></code></pre></td></tr></table></figure>

<p>实现了把前一个命令的标准输出作为后面命令的输入。</p>
<blockquote>
<p>tips: IO重定向和管道的区别：<strong>IO重定向</strong>，是把前一个命令的标准输出，<strong>重定向</strong>到<strong>普通文件</strong>或者<strong>设备文件</strong>。而<strong>管道</strong>，是把前一个命令的<strong>标准输出</strong>作为后面命令的<strong>标准输入</strong>。一个是到<strong>文件</strong>，一个是作为后面命令的<strong>标准输入</strong>。</p>
</blockquote>
<p>例子：</p>
<p><code>ls -C | tr &#39;a-z&#39; &#39;A-Z&#39;</code>：<code>ls</code>出来的文件列表，作为tr的输入，这样小写被转化为大写。</p>
<p><code>ls -l /etc |less</code>：<code>ls</code>输出的文件列表，作为less的输入，这样可以逐行显示</p>
<p><code>echo &quot;test email&quot; | mail-s &quot;test&quot; user@example.com</code>：echo输出的字符串，作为mail 的输入</p>
<p><code>cat /etc/issue | tr &#39;a-z&#39; &#39;A-Z&#39;</code>：略</p>
<p><code>who | head -2 | tr &#39;a-z&#39; &#39;A-Z&#39; | tr -d &#39;0-9&#39;</code>：略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo &#39;Text through stdin&#39; | cat - file.txt<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：在上面代码中，<code>-</code>指的就是前面输出的内容，再举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@fedora Scripts]# touch 1 2 3 4 5<br>[root@fedora Scripts]# ls [0-9]<br>1  2  3  4  5<br>[root@fedora Scripts]# ls [0-9] |xargs rm -rf -<br>[root@fedora Scripts]# ls [0-9]<br>ls: cannot access &#39;[0-9]&#39;: No such file or directory<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="2-gt-amp-1和-amp"><a href="#2-gt-amp-1和-amp" class="headerlink" title="2&gt;&amp;1和|&amp;"></a><code>2&gt;&amp;1</code>和<code>|&amp;</code></h3><p>当既有标准输出又有错误输出的时候，标准输出是可以输入到后面命令的，错误输出是无法输入到后面命令。可以使用<code>2&gt;&amp;1</code>和<code>|&amp;</code>实现错误的也输入到后面命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 app]☭ ls &#x2F;app &#x2F;err | tr &#39;a-z&#39; &#39;A-Z&#39;<br>ls: cannot access &#x2F;err: No such file or directory<br>&#x2F;APP:<br>F1<br>ISSUE2<br>ISSUE3<br><br>[root❄centos7 app]☭ ls &#x2F;app &#x2F;err 2&gt;&amp;1 | tr &#39;a-z&#39; &#39;A-Z&#39;<br>LS: CANNOT ACCESS &#x2F;ERR: NO SUCH FILE OR DIRECTORY<br>&#x2F;APP:<br>F1<br>ISSUE2<br>ISSUE3<br><br>[root❄centos7 app]☭ ls &#x2F;app &#x2F;err |&amp; tr &#39;a-z&#39; &#39;A-Z&#39;<br>LS: CANNOT ACCESS &#x2F;ERR: NO SUCH FILE OR DIRECTORY<br>&#x2F;APP:<br>F1<br>ISSUE2<br>ISSUE3<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a><code>tee</code></h3><p><code>tee</code>：read from standard input and write to standard output and files<br>从标准输入读，写到<code>标准输出</code>和<code>文件</code>。当然如果再跟一个管道，标准输出就输出到另外一个命令了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 写到屏幕和文件&#x2F;tmp&#x2F;issue.tee<br>[root❄centos7 ~]☭ cat &#x2F;etc&#x2F;issue | tee &#x2F;app&#x2F;issue.tee<br>\S<br>Kernel \r on an \m<br><br>[root❄centos7 ~]☭ cat &#x2F;app&#x2F;issue.tee<br>\S<br>Kernel \r on an \m<br><br># 写到&#x2F;tmp&#x2F;issue.tee ，写到标准输出的通过管道又传递了一次<br>[root❄centos7 ~]☭ cat &#x2F;etc&#x2F;issue | tee &#x2F;tmp&#x2F;issue.tee | tr &#39;a-z&#39; &#39;A-Z&#39;<br>\S<br>KERNEL \R ON AN \M<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>管道</tag>
      </tags>
  </entry>
  <entry>
    <title>03-DNS记录类型</title>
    <url>/03-DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="区域文件-Zone-files"><a href="#区域文件-Zone-files" class="headerlink" title="区域文件(Zone files)"></a>区域文件(Zone files)</h3><p>区域文件是名称服务器存储其所知道的域名的信息的方式。名称服务器知道的每个域名都存储在区域文件中。对于名称服务器来说，大多数请求都不能在它自己服务器中找到区域文件。</p>
<p>如果它被配置成可以递归查询，如解析名称服务器，那它会递归找到结果并返回。否则，它会告诉请求者方下一步到哪里查询。</p>
<p>名称服务器具有的区域文件越多，它能够权威回答的请求越多。</p>
<p>区域文件描述 DNS “区域”，其基本上是整个 DNS 命名系统的子集。它通常只配置一个域名。它可以包含多个记录，定义了该域名下的资源位置。</p>
<p>区域文件的 <code>$ORIGIN</code> 表示该区域最高等级的权威。</p>
<p>所以如果一个区域文件被配置为 “example.com” 域，<code>$ORIGIN</code> 会被设置为<code>example.com</code>。</p>
<p>它配置在区域文件的顶部，或者可以在引用区域文件的 DNS 服务器的配置文件中定义。无论哪种方式，此参数描述区域将是什么等级的权威。</p>
<p>类似地，<code>$TTL</code> 配置它提供的信息的 “生存时间”。它基本上是一个计时器。高速缓存名称服务器可以使用先前查询的结果来回答问题，直到 TTL 值用完。</p>
<p>ZONE file的资源记录（RR:Resource Record)的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">name [TTL] IN rr_type value<br></code></pre></td></tr></table></figure>

<ul>
<li>TTL可以从全局继承，即在文件首行放一个类似这样的<code>$TTL 1D</code>的全局字段。</li>
<li>@可以用于表明当前区域的名字，属于省略的写法，如果name后面没有跟区域名，如<code>ns1</code>的话，默认就会补全区域名。</li>
</ul>
<p>rr_type,资源记录类型（RR:Resource Record)主要分为以下几种：</p>
<ul>
<li>SOA记录（Start Of Authority record）：起始授权记录</li>
<li>A 和 AAAA 记录（Adress record）</li>
<li>CNAME：Canonical Name record</li>
<li>MX 记录（Mail eXchange record）</li>
<li>NS 记录(Name Server record)</li>
<li>PTR 记录（PoinTer Record）</li>
</ul>
<p>下面详解一下各种记录类型：</p>
<h3 id="SOA记录（Start-Of-Authority-record）"><a href="#SOA记录（Start-Of-Authority-record）" class="headerlink" title="SOA记录（Start Of Authority record）"></a>SOA记录（Start Of Authority record）</h3><p>起始授权记录，或者说是 SOA，这种记录是所有区域性文件中的强制性记录。它必须是一个文件中的第一个记录（<code>$ORIGIN</code> 和 <code>$TTL</code> 会在它之前指定）。它还是最难理解的一种记录。</p>
<p>开始权限记录的看起来像这样：</p>
<p><a href="http://www.yulongjun.com/images/15010656300047.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828081440.jpg" alt="img"></a></p>
<p>我们来解释一下各部分分别表示什么：</p>
<ul>
<li><strong><code>domain.com.</code></strong>：这是区域的根。这表明该区域文件用于 domain.com 域名。通常，你会看到这个用 @ 代替，它只是一个占位符，表示我们之前学到的 <code>$ORIGIN</code> 变量的内容。</li>
<li><strong><code>IN SOA</code></strong>：”IN” 部分表示互联网（它会出现在许多记录中）, IN 可以省略不写。 SOA 是表示这是开始权限记录。</li>
<li><strong><code>ns1.domain.com.</code></strong>：这定义了该域的主名称服务器。名称服务器可以是主服务器或从服务器，如果配置了动态 DNS，就像这里，则一个服务器需要是 “主服务器”。如果你未配置动态 DNS，那么这只是你其中一个主名称服务器。</li>
<li><strong><code>admin.domain.com.</code></strong>：这是这个区域文件管理员的邮箱地址。邮箱地址的 @ 这里用一个 . 代替。如果你的名字中也有 . 它会用 \ 代替。（比如 <a href="mailto:your.name@domain.com">your.name@domain.com</a> 变成 your\name.domain.com）</li>
<li><strong><code>12083</code></strong>：这是区域文件的序列号。每次编辑区域文件时，必须增加此序列号以使区域文件能够正确传播。从服务器将检查主服务器的区域序列号是否大于它们在系统上的序列号。如果是，它请求新的区域文件，如果不是，它继续服务原始文件。</li>
<li><strong><code>3h</code></strong>：这是区域的刷新间隔。这是从服务器向主服务器轮询检查区域文件是否变更之间等待的时间量。</li>
<li><strong><code>30m</code></strong>：这是此区域的重试间隔。如果slave从机在刷新周期结束时无法连接到master主机，则它将等待此时间并重试轮询主机。</li>
<li><strong><code>3w</code></strong>：这是到期时间。如果slave从服务器在此时间内无法与master主服务器联系，则它不再作为此区域的权威来源的返回响应，并停止对外提供服务。</li>
<li><strong><code>1h</code></strong>：这是名称服务器在此文件中找不到所请求的名称时缓存找不到结果的时间量。</li>
</ul>
<h3 id="A-和-AAAA-记录（Adress-record）"><a href="#A-和-AAAA-记录（Adress-record）" class="headerlink" title="A 和 AAAA 记录（Adress record）"></a>A 和 AAAA 记录（Adress record）</h3><p>这两个记录都将主机映射到 IP 地址。 “A” 记录用于将主机映射到 IPv4 IP 地址，而 “AAAA” 记录用于将主机映射到 IPv6 地址。</p>
<p>这些记录的一般格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">host     IN      A       IPv4_address<br>host     IN      AAAA    IPv6_address<br></code></pre></td></tr></table></figure>

<p>因为我们的 SOA 记录指出了我们的主服务器是 “ns1.domain.com”，而 “ns1.domain.com” 也是 “domain.com” 区域文件定义的，所以我们需要把它指向一个 IP 地址。</p>
<p>这条记录可能看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ns1     IN  A       111.222.111.222<br></code></pre></td></tr></table></figure>

<p>请注意，我们不必提供全名。我们可以只给主机名，不需要 FQDN，然后 DNS 服务器会通过 <code>$ORIGIN</code> 补足其余部分。但是，我们也可以使用完整的 FQDN ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ns1.domain.com.     IN  A       111.222.111.222<br></code></pre></td></tr></table></figure>

<p>大多数情况下，在这里你可以将你的 web 服务器定义为 “www”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">www     IN  A       222.222.222.222<br></code></pre></td></tr></table></figure>

<p>我们还可以说明基本域解析到哪里。如下表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">domain.com.     IN  A       222.222.222.222<br></code></pre></td></tr></table></figure>

<p>我们还可以使用 “@” 来表示基本域名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@       IN  A       222.222.222.222<br></code></pre></td></tr></table></figure>

<p>我们还可以解析此域下未明确定义的任何内容到此服务器。可以使用 “*” 通配符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">*       IN  A       222.222.222.222<br></code></pre></td></tr></table></figure>

<p>以上这些对于 AAAA 记录同样适用。</p>
<h3 id="CNAME-记录（Canonical-Name-record）"><a href="#CNAME-记录（Canonical-Name-record）" class="headerlink" title="CNAME 记录（Canonical Name record）"></a>CNAME 记录（Canonical Name record）</h3><p>CNAME 记录为您的服务器（由A或AAAA记录定义的名称）定义规范名称的别名。</p>
<p>例如，我们可以有一个 A 记录定义 “server1” 主机，然后使用 “www” 作为此主机的别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server1     IN  A       111.111.111.111<br>www         IN  CNAME   server1<br></code></pre></td></tr></table></figure>

<p>请注意，这些别名会带来一些性能损失，因为它们需要对服务器进行额外的查询。大多数时候，通过使用附加的 A 或 AAAA 记录可以实现相同的结果。</p>
<p>推荐使用 CNAME 的一种情况是为当前区域之外的资源提供别名。</p>
<h3 id="MX-记录（Mail-eXchange-record）"><a href="#MX-记录（Mail-eXchange-record）" class="headerlink" title="MX 记录（Mail eXchange record）"></a>MX 记录（Mail eXchange record）</h3><p>MX 记录用来定义用于域的邮件交换。这有助于电子邮件正确到达您的邮件服务器。</p>
<p>与许多其他记录类型不同的是，邮件记录通常不会将主机映射到某些内容，因为它们适用于整个区域。因此，他们通常看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IN  MX  10   mail.domain.com.<br></code></pre></td></tr></table></figure>

<p>请注意，开头没有主机名。</p>
<p>还要注意，它还有一个额外的数字。如果定义了多个邮件服务器，这是帮助计算机决定发送邮件的服务器的首选项号。较低的数字具有较高的优先级。</p>
<p>MX 记录通常应指向由 A 或 AAAA 记录定义的主机，而不是由 CNAME 定义的主机。</p>
<p>所以，假设我们有两个邮件服务器。可以这样表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IN  MX  10  mail1.domain.com.<br>IN  MX  50  mail2.domain.com.<br>mail1   IN  A       111.111.111.111<br>mail2   IN  A       222.222.222.222<br></code></pre></td></tr></table></figure>

<p>在这个例子中，”mail1” 主机是首选电子邮件交换服务器。</p>
<p>我们也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IN  MX  10  mail1<br>IN  MX  50  mail2<br>mail1   IN  A       111.111.111.111<br>mail2   IN  A       222.222.222.222<br></code></pre></td></tr></table></figure>

<h3 id="NS-记录-Name-Server-record"><a href="#NS-记录-Name-Server-record" class="headerlink" title="NS 记录(Name Server record)"></a>NS 记录(Name Server record)</h3><p>此记录类型定义用于此区域的名称服务器。</p>
<p>你可能想知道，”如果区域文件放在名称服务器上，为什么它需要引用自身？”。DNS 如此成功的其中一个原因是它的多级缓存。在区域文件中定义名称服务器的一个原因是区域文件可能是另外一个名称服务器的缓存副本。至于其他原因，我们不在这里讨论。</p>
<p>与 MX 记录一样，它也有一些区域范围的参数，因此它们也不使用主机。一般来说，它们看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IN  NS     ns1.domain.com.<br>IN  NS     ns2.domain.com.<br></code></pre></td></tr></table></figure>

<p>你应该在每个区域文件中至少定义两个名称服务器，以便在一个服务器出现问题时还能正确运行。如果只有一个名称服务器，大多数 DNS 服务器软件都会认为区域文件无效。</p>
<p>同样，把主机的 A 或者 AAAA 映射也包含记录中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IN  NS     ns1.domain.com.<br>IN  NS     ns2.domain.com.<br>ns1     IN  A      111.222.111.111<br>ns2     IN  A      123.211.111.233<br></code></pre></td></tr></table></figure>

<p>你还可以使用很多其他记录类型，但这些可能是你会遇到的最常见的类型。</p>
<h3 id="PTR-记录（PoinTer-Record）"><a href="#PTR-记录（PoinTer-Record）" class="headerlink" title="PTR 记录（PoinTer Record）"></a>PTR 记录（PoinTer Record）</h3><p>PTR 记录用于定义与 IP 地址相关联的名称。 PTR 记录是 A 或 AAAA 记录的逆。 PTR 记录是唯一的，因为它们以 .arpa 根开始并被委派给 IP 地址的所有者。区域互联网注册管理机构（RIRs）管理 IP 地址到组织和服务提供商的指派。区域互联网注册管理机构包括 APNIC，ARIN，RIPE NCC，LACNIC 和 AFRINIC。</p>
<p>这里是一个 111.222.333.444 的 PTR 记录的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">444.333.222.111.in-addr.arpa.   33692   IN  PTR host.example.com.<br></code></pre></td></tr></table></figure>

<p>我们可以看到地址是反的，而且ip后面加了一个特定的后缀<code>.in-addr.arpa.</code>。</p>
<p>IPv6 地址的这个 PTR 记录示例使用了 Google IPv6 DNS 服务器(2001:4860:4860::8888)的逆转形式的半字节格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">8.8.8.8.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.6.8.4.0.6.8.4.1.0.0.2.ip6.arpa. 86400IN PTR google-public-dns-a.google.com.<br></code></pre></td></tr></table></figure>

<p><code>dig</code> 命令的 <code>-x</code> 参数可用于查找 IP 地址的反向 DNS 名称。</p>
<p>下面是一个 <code>dig</code> 命令的例子。<code>+short</code> 确保只输出反向 DNS 名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dig -x 8.8.4.4 +short<br></code></pre></td></tr></table></figure>

<p>上述 <code>dig</code> 命令的输出将是该 IP 地址的 PTR 记录中的域名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">google-public-dns-b.google.com.<br></code></pre></td></tr></table></figure>

<p>互联网上的服务器在日志中使用 PTR 记录，来做出明智的垃圾邮件处理决策，并显示其他设备上的易于阅读的详细信息。</p>
<p>最常用的电子邮件服务器将查找从其接收电子邮件的 IP 地址的 PTR 记录。如果源 IP 地址没有与其相关联的 PTR 记录，则发送的电子邮件可被视为垃圾邮件并被拒绝。PTR 中的 FQDN 与要发送的电子邮件的域名是否匹配并不重要，重要的是存在有效的 PTR 记录，具有对应的和匹配的前向 A 记录。</p>
<p>通常，互联网上的网络路由器会被赋予与其物理位置相对应的 PTR 记录。例如，你可能会在纽约市或芝加哥看到使用 “NYC” 或 “CHI”。这对于运行 traceroute 或者 MTR 来检查网络流量经过的路径很有用。</p>
<p>大多数提供专用服务器或 VPS 服务的提供商允许客户为其 IP 地址设置 PTR 记录。</p>
<blockquote>
<p>注意: PTR 记录中的 FQDN 具有对应的和匹配的正向 A 记录是非常重要的。示例：<code>111.222.333.444</code> 有一条指向 <code>server.example.com</code> 的 PTR 记录，那<code>server.example.com</code> 需要具有一条指向 <code>111.222.333.444</code> 的 A 记录。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>03-HAProxy 具体配置参数</title>
    <url>/03-HAProxy-%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>具体配置参数可以查看这里：</p>
<p>HAProxy 1.5：<a href="http://cbonte.github.io/haproxy-dconv/1.5/configuration.html" target="_blank" rel="noopener">http://cbonte.github.io/haproxy-dconv/1.5/configuration.html</a></p>
<p>HAProxy 1.7：<a href="http://cbonte.github.io/haproxy-dconv/1.7/configuration.html" target="_blank" rel="noopener">http://cbonte.github.io/haproxy-dconv/1.7/configuration.html</a></p>
<p>下面捡一些用的比较多的参数来说明：</p>
<h2 id="server：后端具体服务器"><a href="#server：后端具体服务器" class="headerlink" title="server：后端具体服务器"></a>server：后端具体服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &lt;name&gt; &lt;address&gt;[:[port]] [param*]<br></code></pre></td></tr></table></figure>

<p>name：跟服务器相关的内部名称，会出现在log日志和报警里。</p>
<p>[:[port]]：具体服务器ip地址和端口，不指定端口话默认为80。<br>[param*]：参数有很多，如<code>backup</code>、<code>check</code> <code>inter</code> <code>fall</code> <code>rise</code>等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind *:80<br>    default_backend websrvs<br><br>backend websrvs<br>    server nginx-web1 192.168.20.10:80 check<br>    server nginx-web2 192.168.20.20:80 check<br></code></pre></td></tr></table></figure>

<h2 id="backup：标记为备用主机"><a href="#backup：标记为备用主机" class="headerlink" title="backup：标记为备用主机"></a>backup：标记为备用主机</h2><p>标记为backup的主机，不负载均衡，在服务器全挂了的时候才会调用，一般用来做sorry Server。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server sorry-server 192.168.20.44 backup<br></code></pre></td></tr></table></figure>

<h2 id="balance：负载均衡算法"><a href="#balance：负载均衡算法" class="headerlink" title="balance：负载均衡算法"></a>balance：负载均衡算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">balance &lt;algorithm&gt; [ &lt;arguments&gt; ]<br>balance url_param &lt;param&gt; [check_post]<br></code></pre></td></tr></table></figure>

<p>负载均衡算法有以下几种：</p>
<ul>
<li><code>roundrobin</code>：(动态)轮询。可运行时调整权重，支持慢启动，最多支持4095个后端主机。（不过这种限制不算是限制了，已经很大了）</li>
<li><code>static-rr</code>：静态轮询。运行时不可调整权重，不支持慢启动，无后端主机数量限制。</li>
<li><code>leastconn</code>：最少连接，按最少连接来调度，此处是加权最少连接，支持指定权重，是动态的，所以也就支持权重的运行时调整和慢启动。</li>
<li><code>first</code>：制定先调度至一个主机，主机连接限制到了，再调度到另外一台。</li>
<li><code>source</code>：source ip hash，源地址hash。根据请求的源地址进行hash，同一个来源ip调度到同一台主机。</li>
<li><code>uri</code>：uri hash。根据请求的uri的hash值调度，这样可以提高缓存的命中率。</li>
<li><code>url_param</code>：根据url里的某个参数的hash来调度。读取url地址里给定的参数的hash值，来调度。</li>
<li><code>hdr(&lt;name&gt;)</code>：根据HTTP header 的hash值进行调度。如果name不存在，或者如果不包含任何值，则采用roundrobin算法。</li>
</ul>
<p>上述的<code>source</code>、 <code>uri</code>、 <code>url_param</code>、 <code>hdr(&lt;name&gt;)</code>采用的默认hash算法都是<code>map-based</code>，。还可以更改为另外一种算法<code>consistent</code>。</p>
<blockquote>
<p><code>map-based</code>: 静态映射，可以分配权重，但是一旦服务启动后，无法动态调整权重，也不支持慢启动。而且一旦服务器发生变动，影响是全局的，不适合用来做缓存代理。这种算法虽然不好，但是占用系统资源少。<br><code>consistent</code>: 一致性hash，服务器发生变动，只影响局部有限的服务器，可以运行中动态调整权重，支持慢启动。这种算法很好用，但是占用系统资源多。</p>
</blockquote>
<p>举几个例子：</p>
<p>1、想要对缓存比较友好，缓存命中率更高，使用基于uri的一致性hash算法。同一个uri地址，无论请求地址是多少，返回的信息始终来自于同一个后端主机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind *:80<br>    default_backend websrvs<br><br>backend websrvs<br>    balance uri<br>    server nginx-web1 192.168.20.10:80 check<br>    server nginx-web2 192.168.20.20:80 check<br>    hash-type consistent<br></code></pre></td></tr></table></figure>

<p>2、想要基于HTTP 头信息的浏览器来分类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind *:80<br>    default_backend websrvs<br><br>backend websrvs<br>    balance header(User-Agent)<br>    server nginx-web1 192.168.20.10:80 check<br>    server nginx-web2 192.168.20.20:80 check<br>    hash-type consistent<br></code></pre></td></tr></table></figure>

<h2 id="compression：压缩"><a href="#compression：压缩" class="headerlink" title="compression：压缩"></a>compression：压缩</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">compression algo &lt;algorithm&gt;<br>compression type &lt;mime type&gt;<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15073772100917.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135237.jpg" alt="img"></a></p>
<p>用在前段的例子例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind *:80<br>    default_backend websrvs<br>    compression algo gzip<br>    compression type text&#x2F;html text&#x2F;plain application&#x2F;xml application&#x2F;javascript<br><br>backend websrvs<br>    balance source<br>    server nginx-web1 192.168.20.10:80 check<br>    server nginx-web2 192.168.20.20:80 check<br>    hash-type consistent<br></code></pre></td></tr></table></figure>

<h2 id="mode：负载模式（四层TCP或7层HTTP）"><a href="#mode：负载模式（四层TCP或7层HTTP）" class="headerlink" title="mode：负载模式（四层TCP或7层HTTP）"></a>mode：负载模式（四层TCP或7层HTTP）</h2><p>负载模式：</p>
<ul>
<li><code>tcp</code>：默认模式，四层TCP负载均衡，被用于四层基于端口的协议，可以用来转发各种端口。</li>
<li><code>http</code>：七层HTTP负载均衡，这是HAProxy的价值所在，可以做很多比较复杂的七层策略。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind 192.168.20.111:80<br>    mode http<br>    default_backend websrvs<br><br>backend websrvs    mode http<br>    balance source<br>    server nginx-web1 192.168.20.10:80 check    server nginx-web2 192.168.20.20:80 check<br></code></pre></td></tr></table></figure>

<h2 id="server-中的params"><a href="#server-中的params" class="headerlink" title="server 中的params"></a>server 中的params</h2><h3 id="1-check、inter、fail、raise：（健康检查相关）"><a href="#1-check、inter、fail、raise：（健康检查相关）" class="headerlink" title="1. check、inter、fail、raise：（健康检查相关）"></a>1. check、inter、fail、raise：（健康检查相关）</h3><ul>
<li><code>check</code>：是否启用健康检查。不写则默认不启用健康检查。</li>
<li><code>addr</code>：可以不占用服务器主用的ip，换一个ip进行检测。</li>
<li><code>port</code>：同样，端口也可以换一个。</li>
<li><code>inter &lt;delay&gt;</code>：两个连续的检查之间的延时，默认为2000ms。</li>
<li><code>fall &lt;count&gt;</code>：在连续的几次健康检查中失败，则视为dead（当机），默认为3次。</li>
<li><code>rise &lt;count&gt;</code>：在连续的几次健康检查中成功，则视为operational（可操作的），默认为2次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind 192.168.20.111:443<br>    mode http<br>    default_backend websrvs<br><br>backend websrvs    mode http<br>    balance source<br>    server nginx-web1 192.168.20.10:443 check port 80 inter 1000 fall 3 rise 5    server nginx-web2 192.168.20.20:443 check port 80 inter 1000 fall 3 rise 5<br></code></pre></td></tr></table></figure>

<h2 id="option-httpcheck：基于http协议做健康检查"><a href="#option-httpcheck：基于http协议做健康检查" class="headerlink" title="option httpcheck：基于http协议做健康检查"></a>option httpcheck：基于http协议做健康检查</h2><p>可以指定method、uri、version</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">option httpchk<br>option httpchk &lt;uri&gt;<br>option httpchk &lt;method&gt; &lt;uri&gt;<br>option httpchk &lt;method&gt; &lt;uri&gt; &lt;version&gt;<br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># Relay HTTPS traffic to Apache instance and check service availability<br># using HTTP request &quot;OPTIONS * HTTP&#x2F;1.1&quot; on port 80.<br>backend https_relay<br>    mode tcp<br>    option httpchk OPTIONS * HTTP&#x2F;1.1\r\nHost:\ www<br>    server apache1 192.168.1.1:443 check port 80<br></code></pre></td></tr></table></figure>

<h2 id="还有-smtpchk、mysql-check、pgsql-check-、ssl-hello-chk"><a href="#还有-smtpchk、mysql-check、pgsql-check-、ssl-hello-chk" class="headerlink" title="还有 smtpchk、mysql-check、pgsql-check 、ssl-hello-chk"></a>还有 smtpchk、mysql-check、pgsql-check 、ssl-hello-chk</h2><p>不做赘述，也是应用层的复杂检测方法。</p>
<h2 id="maxconn：最大并发连接数-maxqueue：最大队列数"><a href="#maxconn：最大并发连接数-maxqueue：最大队列数" class="headerlink" title="maxconn：最大并发连接数 maxqueue：最大队列数"></a>maxconn：最大并发连接数 maxqueue：最大队列数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">maxconn &lt;maxconn&gt;<br>maxqueue &lt;maxqueue&gt;<br></code></pre></td></tr></table></figure>

<p>可以指定单台后端服务器的最大并发连接数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server nginx-web1 192.168.20.10:80 check maxconn 10000 maxqueue 2000<br></code></pre></td></tr></table></figure>

<h2 id="redir-：302临时重定向到另外一台服务器。"><a href="#redir-：302临时重定向到另外一台服务器。" class="headerlink" title="redir ：302临时重定向到另外一台服务器。"></a>redir ：302临时重定向到另外一台服务器。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">frontend myweb<br>    bind 192.168.20.111:443<br>    mode http<br>    default_backend websrvs<br><br>backend websrvs    mode http<br>    balance source<br>    server nginx-web1 192.168.20.10:443 check port 80 inter 1000 fall 3 rise 5    server nginx-web2 192.168.20.20:443 check port 80 inter 1000 fall 3 rise 5 redir http:&#x2F;&#x2F;&#x2F;www.baidu.com<br></code></pre></td></tr></table></figure>

<p>对<code>192.168.20.10</code>的访问，临时重定向到<code>http://www.baidu.com</code></p>
<h2 id="weight：权重"><a href="#weight：权重" class="headerlink" title="weight：权重"></a>weight：权重</h2><p>服务器的权重</p>
]]></content>
  </entry>
  <entry>
    <title>03-Keepalived各种模式配置</title>
    <url>/03-Keepalived%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/keepalive.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135640.png" alt="keepalive.png"></a></p>
<blockquote>
<p>由于图片花费很长时间制作，本文图片转载或使用请务必加上原文链接，图片中的作者信息也请勿删除，谢谢！</p>
</blockquote>
<p>下面仅仅是Keepalived配置里只关于Keepalived部分的相关的配置。从最简单的单网络单主模式，一直到双网络同步漂移的双主模式。</p>
<h2 id="单网络的Master-Backup主备模式（单主模式）"><a href="#单网络的Master-Backup主备模式（单主模式）" class="headerlink" title="单网络的Master-Backup主备模式（单主模式）"></a>单网络的<code>Master-Backup</code>主备模式（单主模式）</h2><p><a href="http://www.yulongjun.com/images/Keepalived-SingleNetwork-MasterBackup.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135641.png" alt="Keepalived-SingleNetwork-MasterBackup"></a></p>
<p><strong>ka1</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance VG_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ka2</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance VG_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="单网络的Active-Active双活模式（双主模式）"><a href="#单网络的Active-Active双活模式（双主模式）" class="headerlink" title="单网络的Active-Active双活模式（双主模式）"></a>单网络的<code>Active-Active</code>双活模式（双主模式）</h2><p><a href="http://www.yulongjun.com/images/Keepalived-SingleNetwork-ActiveActive.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135642.png" alt="Keepalived-SingleNetwork-ActivActive"></a></p>
<p><strong>ka1</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance VG_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br><br>vrrp_instance VG_2 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ka2</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance VG_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;  <br><br>&#125;<br><br>vrrp_instance VG_2 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="双网络（内外网）非同步漂移的Master-Backup主备模式（单主模式）"><a href="#双网络（内外网）非同步漂移的Master-Backup主备模式（单主模式）" class="headerlink" title="双网络（内外网）非同步漂移的Master-Backup主备模式（单主模式）"></a>双网络（内外网）非同步漂移的<code>Master-Backup</code>主备模式（单主模式）</h2><p>一般生产环境内外网是分开的，所以一般有两个网络，一个内网网络，一个外网网络，内网网络和外网网络不用同步漂移，比如<strong>Keepalived+LVS-DR</strong>、<strong>Keepalived+Nginx</strong>、<strong>Keepalived+HAProxy</strong>，都是不用同步漂移的。（<strong>Keepalived+LVS-NAT</strong>是需要同步漂移的。）</p>
<p><a href="http://www.yulongjun.com/images/Keepalived-DoubleNetwork-MasterBackup.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135643.png" alt="Keepalived-DoubleNetwork-MasterBackup"></a></p>
<p><strong>ka1</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_sync_group VG_1 &#123;<br>    group &#123;<br>        External_1<br>        Internal_1<br>    &#125;<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ka2</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="双网络（内外网）同步漂移的Master-Backup主备模式（单主模式）"><a href="#双网络（内外网）同步漂移的Master-Backup主备模式（单主模式）" class="headerlink" title="双网络（内外网）同步漂移的Master-Backup主备模式（单主模式）"></a>双网络（内外网）同步漂移的<code>Master-Backup</code>主备模式（单主模式）</h2><p>一般生产环境内外网是分开的，所以一般有两个网络，一个内网网络，一个外网网络，而且内网网络和外网网络要实现同步漂移，比如<strong>Keepalived+LVS-NAT</strong>模式，那么就用到<code>vrrp_sync_group</code>来设置同步漂移组</p>
<p><a href="http://www.yulongjun.com/images/Keepalived-DoubleNetwork-MasterBackup-SyncGroup.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135644.png" alt="Keepalived-DoubleNetwork-MasterBackup-SyncGroup"></a></p>
<p><strong>ka1</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_sync_group VG_1 &#123;<br>    group &#123;<br>        External_1<br>        Internal_1<br>    &#125;<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ka2</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_sync_group VG_1 &#123;<br>    group &#123;<br>        External_1<br>        Internal_1<br>    &#125;<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="双网络（内外网）非同步漂移的Active-Active双活模式（双主模式）"><a href="#双网络（内外网）非同步漂移的Active-Active双活模式（双主模式）" class="headerlink" title="双网络（内外网）非同步漂移的Active-Active双活模式（双主模式）"></a>双网络（内外网）非同步漂移的<code>Active-Active</code>双活模式（双主模式）</h2><p>一般生产环境内外网是分开的，所以一般有两个网络，一个内网网络，一个外网网络，内网网络和外网网络不用同步漂移，比如<strong>Keepalived+LVS-DR</strong>、<strong>Keepalived+Nginx</strong>、<strong>Keepalived+HAProxy</strong>，都是不用同步漂移的。（<strong>Keepalived+LVS-NAT</strong>是需要同步漂移的。）</p>
<p><a href="http://www.yulongjun.com/images/Keepalived-DoubleNetwork-AAmodel.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135645.png" alt="Keepalived-DoubleNetwork-AAmodel"></a></p>
<p><strong>ka1</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance External_2 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 172<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 9d3d15d5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br><br>vrrp_instance Internal_2 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ka2</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance External_2 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 172<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 9d3d15d5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br><br>vrrp_instance Internal_2 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="双网络（内外网）同步漂移的Active-Active双活模式（双主模式）"><a href="#双网络（内外网）同步漂移的Active-Active双活模式（双主模式）" class="headerlink" title="双网络（内外网）同步漂移的Active-Active双活模式（双主模式）"></a>双网络（内外网）同步漂移的<code>Active-Active</code>双活模式（双主模式）</h2><p>一般生产环境内外网是分开的，所以一般有两个网络，一个内网网络，一个外网网络，而且内网网络和外网网络要实现同步漂移，比如<strong>Keepalived+LVS-NAT</strong>模式，那么就用到<code>vrrp_sync_group</code>来设置同步漂移组，如果要做双活，那么就分别两端加两个vip，互为主备。</p>
<p><a href="http://www.yulongjun.com/images/Keepalived-DoubleNetwork-AAmodel-SyncGroup.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135646.png" alt="Keepalived-DoubleNetwork-AAmodel-SyncGroup"></a></p>
<p><strong>ka1</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_sync_group VG_1 &#123;<br>    group &#123;<br>        External_1<br>        Internal_1<br>    &#125;<br>&#125;<br><br>vrrp_sync_group VG_2 &#123;<br>    group &#123;<br>        External_2<br>        Internal_2<br>    &#125;<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance External_2 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 172<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 9d3d15d5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br><br>vrrp_instance Internal_2 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ka2</strong> 的<code>/etc/keepalived/keepalived.conf</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   router_id ka1<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_sync_group VG_1 &#123;<br>    group &#123;<br>        External_1<br>        Internal_1<br>    &#125;<br>&#125;<br><br>vrrp_sync_group VG_2 &#123;<br>    group &#123;<br>        External_2<br>        Internal_2<br>    &#125;<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1    <br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance External_2 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 172<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 9d3d15d5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br><br>&#125;<br><br>vrrp_instance Internal_2 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>notfiy.sh</code>脚本内容见上一节。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>03-Linux文件类型和文件相关命令</title>
    <url>/03-Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p><strong><code>ll</code>后可以看到文件详情：</strong></p>
<p><code>-</code>：常规文件（内部类型是什么，用<code>file</code>命令）</p>
<p><code>d</code>：directory，目录文件</p>
<p><code>b</code>：blobk device，块设备文件，支持以“block”为单位进行随机访问</p>
<ul>
<li>major number：主设备号，用来表示设备类型，进而确定要加载的驱动程序</li>
<li>minor number：次设备号，用于表示同一类型中的不同设备。</li>
</ul>
<p>如下图的<code>1,3</code> 、<code>1,5</code></p>
<p><a href="http://www.yulongjun.com/images/1495437389819.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200817111824.png" alt="img"></a></p>
<p><code>c</code>：character device，字符设备文件，支持以”character”为单位进行线性访问</p>
<p><code>l</code>：symbolic link，符号链接文件（软连接文件）</p>
<p><code>p</code>：pipe，命名管道</p>
<p><code>s</code>：socket，套接字文件</p>
<hr>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p><strong>绝对路径</strong>：以斜线开始的，从<code>/</code>开始的路径。</p>
<ul>
<li><code>/etc/syscofnig/network-scrpits</code><br>绝对路径分为两段，dirname和basename：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#dirname /etc/sysconfig/network-scripts/ifcfg-eth0</span><br>/etc/sysconfig/network-scripts<br>[root@ashjian ~]<span class="hljs-comment">#basename /etc/sysconfig/network-scripts/ifcfg-eth0</span><br>ifcfg-eth0<br></code></pre></td></tr></table></figure>

<p><strong>相对路径</strong>：不以斜线开始的路径。</p>
<ul>
<li><code>xxx/yyy</code> ：当前目录下的xxx子目录的yyy子目录</li>
<li><code>.</code>：当前目录</li>
<li><code>..</code>：上级目录</li>
<li><code>~</code>：用户的家目录</li>
<li><code>-</code>：切换上次输入的目录，和命令配合使用</li>
</ul>
<blockquote>
<p>tips:<code>-</code>原理，系统记住上一个工作目录，存储在环境变量<code>OLDPWD</code>，可以用<code>echo $OLDPWD</code>查看到。</p>
</blockquote>
<hr>
<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><h3 id="1-pwd：显示工作目录"><a href="#1-pwd：显示工作目录" class="headerlink" title="1. pwd：显示工作目录"></a>1. <code>pwd</code>：显示工作目录</h3><p><strong>printing working directory</strong></p>
<h3 id="2-cd：切换目录"><a href="#2-cd：切换目录" class="headerlink" title="2. cd：切换目录"></a>2. <code>cd</code>：切换目录</h3><p><strong>change directory</strong></p>
<ul>
<li><code>cd</code>：切换到家目录</li>
<li><code>cd ~</code>：切换到家目录</li>
<li><code>cd ~USERNAME</code>：切换到用户USERNAME的家目录</li>
<li><code>cd -</code>：在上一次所在目录与当前目录来回切换（PWD to OLDPWD）</li>
<li><code>cd ..</code>：切换到上级目录</li>
<li><code>cd /path/to/directory</code> 切换到一个绝对目录</li>
<li><code>cd path/to/directory</code>：切换到一个相对目录</li>
</ul>
<h3 id="3-ls：列出内容"><a href="#3-ls：列出内容" class="headerlink" title="3. ls：列出内容"></a>3. <code>ls</code>：列出内容</h3><p>list(用/var目录做例子)</p>
<ul>
<li><code>-a</code>， <code>--all</code>：列出所有文件包含隐藏文件</li>
<li><code>-A</code>，<code>--almost-all</code>：列出除<code>.</code>和<code>..</code>之蛙所有的文件</li>
<li><code>-F</code>：-F参数在目录名后加了正斜线（/），以方便用户在输出中分辨它们。类似地，它会在可执行 文件（比如上面的my_script文件）的后面加个星号，以便用户找出可在系统上运行的文件。</li>
</ul>
<p><a href="http://www.yulongjun.com/images/1495440447201.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200818210308.png" alt="img"></a></p>
<ul>
<li><code>l</code>，<code>--long</code>：长格式信息，列出文件的详细属性，命令可以简写为<code>ll</code>，<code>alias ll=&#39;ls -l --color=auto&#39;</code></li>
<li><code>-h</code>，<code>--human-readable</code>：size用人类可读的格式表示</li>
<li><code>-d</code>, <code>--directory</code>：查看目录本身而非内部的文件详情</li>
<li><code>-r</code>, <code>--reverse</code>：反转排序（降序）</li>
<li><code>-R</code>, <code>--recursive</code> 递归显示（基本不用这个，递归显示用<code>tree</code>命令更直观）</li>
<li><code>-t</code>：按修改时间排序</li>
</ul>
<h3 id="4-cat：文本文件输出到终端"><a href="#4-cat：文本文件输出到终端" class="headerlink" title="4. cat：文本文件输出到终端"></a>4. <code>cat</code>：文本文件输出到终端</h3><p><code>concatenate</code> 拼接</p>
<p>可以单独cat：<code>cat /etc/issue</code></p>
<p>可以连接多个文件显示<code>cat /etc/issue /etc/redhat-release</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@CentOS6 app]# cat &#x2F;etc&#x2F;issue<br>CentOS release 6.9 (Final)<br>Kernel \r on an \m<br><br>[root@CentOS6 app]# cat &#x2F;etc&#x2F;issue &#x2F;etc&#x2F;redhat-release<br>CentOS release 6.9 (Final)<br>Kernel \r on an \m<br><br>CentOS release 6.9 (Final)<br></code></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>cat -s file</code>：删除多余的空白行（多行空白行，删除到只剩一行空白行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ cat multi_blanks.txt <br>line 1<br><br><br>line2<br><br>line3<br><br><br>line4<br><br>$ cat -s multi_blanks.txt #压缩相邻的空白行 <br>line 1<br><br>line2<br><br>line3<br><br>line4<br></code></pre></td></tr></table></figure>

<ul>
<li><code>cat -T file</code>：将制表符显示为<code>^I</code></li>
</ul>
<p>用来看脚本里的制表符，通常我们写脚本要避免用制表符，而用多个空格。所以此命令通常用来查询哪里用了制表符。</p>
<ul>
<li><code>cat -n file</code>：显示行号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ cat lines.txt <br>line <br>line <br>line<br><br>$ cat -n lines.txt <br>1 line <br>2 line <br>3 line<br></code></pre></td></tr></table></figure>

<h3 id="5-tac：-跟cat相反，从后面行往前面行输出"><a href="#5-tac：-跟cat相反，从后面行往前面行输出" class="headerlink" title="5. tac： 跟cat相反，从后面行往前面行输出"></a>5. <code>tac</code>： 跟<code>cat</code>相反，从后面行往前面行输出</h3><h3 id="stat-查看文件状态"><a href="#stat-查看文件状态" class="headerlink" title="stat 查看文件状态"></a><code>stat</code> 查看文件状态</h3><p>可以看到<code>atime(Access)</code>、<code>mtime(Modify)</code>、<code>Ctime(Change)</code>，还有文件的权限，文件拥有者和拥有组，还有文件大小相关的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# stat &#x2F;etc&#x2F;issue<br>  File: ‘&#x2F;etc&#x2F;issue’<br>  Size: 23        	Blocks: 8          IO Block: 4096   regular file<br>Device: 802h&#x2F;2050d	Inode: 134320235   Links: 1<br>Access: (0644&#x2F;-rw-r--r--)  Uid: (    0&#x2F;    root)   Gid: (    0&#x2F;    root)<br>Context: system_u:object_r:etc_t:s0<br>Access: 2017-05-22 09:07:34.832999490 +0800<br>Modify: 2016-11-30 02:12:59.000000000 +0800<br>Change: 2017-05-17 16:53:20.670996867 +0800<br> Birth: -<br></code></pre></td></tr></table></figure>



<h3 id="6-文件通配符（globbing）"><a href="#6-文件通配符（globbing）" class="headerlink" title="6. 文件通配符（globbing）"></a>6. 文件通配符（globbing）</h3><ul>
<li><p><code>*</code> ：匹配零个或多个字符</p>
</li>
<li><p><code>?</code> ：匹配任何单个字符</p>
</li>
<li><p><code>~</code> ：当前用户家目录</p>
</li>
<li><p><code>~longdream</code> ：用户longdream的家目录</p>
</li>
<li><p><code>~+</code> ：当前工作目录</p>
</li>
<li><p><code>~-</code>：前一个工作目录</p>
</li>
<li><p><code>[0-9]</code>：匹配数字范围，匹配一个</p>
</li>
<li><p><code>[a-z]或[A-Z]</code>：字母，不区分大小写</p>
<blockquote>
<p>tips：因为不区分大小写，[a-d]代表的就是匹配<code>AaBbCcDd</code>中的一个</p>
</blockquote>
</li>
<li><p><code>[a-z0-9]</code>：字母或数字</p>
</li>
<li><p><code>[wang]</code>：匹配列表中的任何的一个字符,匹配<code>w</code>或<code>a</code>或<code>n</code>或<code>g</code></p>
</li>
<li><p><code>[^wang]</code> 匹配列表中的所有字符以外的字符，除了<code>w</code>、<code>a</code>、<code>n</code>、<code>g</code></p>
</li>
</ul>
<p><strong>只显示隐藏文件：</strong></p>
<p><a href="http://www.yulongjun.com/images/1495445024682.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200818210300.png" alt="img"></a></p>
<p><strong>预定义的字符类：<code>man 7 glob</code></strong></p>
<p><code>[:digit:]</code>：任意数字，相当于0-9</p>
<p><code>[:lower:]</code>：任意小写字母</p>
<p><code>[:upper:]</code>: 任意大写字母</p>
<p><code>[:alpha:]</code>: 任意大小写字母</p>
<p><code>[:alnum:]</code>：任意数字或字母</p>
<p><code>[:blank:]</code>：水平空白字符</p>
<p><code>[:space:]</code>：水平或垂直空白字符</p>
<p><code>[:punct:]</code>：标点符号</p>
<p><code>[:print:]</code>：可打印字符</p>
<p><code>[:cntrl:]</code>：控制（非打印）字符</p>
<p><code>[:graph:]</code>：图形字符</p>
<p><code>[:xdigit:]</code>：十六进制字符</p>
<p><strong>练习</strong></p>
<p>1、显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现至少一位数字的文件或目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#ls /var/l*[0-9]*[a-z]</span><br>/var/l2ehHm<br></code></pre></td></tr></table></figure>

<p>2、显示/etc目录下以任意一位数字开头，且以非数字结尾的文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]#ls -d &#x2F;etc&#x2F;[0-9]*[^[:digit:]]<br>&#x2F;etc&#x2F;125q5h  &#x2F;etc&#x2F;1alejl<br></code></pre></td></tr></table></figure>

<p>3、显示/etc/目录下以非字母开头，后面跟了一个字母及其它任意长度任意字符的文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls -d &#x2F;etc&#x2F;[^[:alpha:]][[:alpha:]]*<br>&#x2F;etc&#x2F;1alejl<br></code></pre></td></tr></table></figure>

<p>4、显示/etc/目录下所有以rc开头，并后面是0-6之间的数字，其它为任意字符的文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]#ls -d &#x2F;etc&#x2F;rc[0-6]*<br>&#x2F;etc&#x2F;rc0.d  &#x2F;etc&#x2F;rc1.d  &#x2F;etc&#x2F;rc2.d  &#x2F;etc&#x2F;rc3.d  &#x2F;etc&#x2F;rc4.d  &#x2F;etc&#x2F;rc5.d  &#x2F;etc&#x2F;rc6.d<br></code></pre></td></tr></table></figure>

<p>5、显示/etc目录下，所有以.d结尾的文件或目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#touch /etc/.mk.d	#创建一个隐藏文件来检验*是否能匹配.开头</span><br>[root@ashjian ~]<span class="hljs-comment">#ls -d /etc/&#123;.*.d,*.d&#125;</span><br>/etc/auto.master.d      /etc/grub.d          /etc/my.cnf.d        /etc/rc2.d      /etc/setuptool.d<br>/etc/bash_completion.d  /etc/init.d          /etc/pam.d           /etc/rc3.d      /etc/statetab.d<br>/etc/binfmt.d           /etc/krb5.conf.d     /etc/php.d           /etc/rc4.d      /etc/sudoers.d<br>/etc/chkconfig.d        /etc/ld.so.conf.d    /etc/popt.d          /etc/rc5.d      /etc/sysctl.d<br>/etc/cron.d             /etc/logrotate.d     /etc/prelink.conf.d  /etc/rc6.d      /etc/tmpfiles.d<br>/etc/depmod.d           /etc/.mk.d           /etc/profile.d       /etc/rc.d       /etc/xinetd.d<br>/etc/dracut.conf.d      /etc/modprobe.d      /etc/rc0.d           /etc/rsyslog.d  /etc/yum.repos.d<br>/etc/gdbinit.d          /etc/modules-load.d  /etc/rc1.d           /etc/rwtab.d<br>[root@ashjian ~]<span class="hljs-comment">#ls -d /etc/*.d	#表明*不能匹配.开头</span><br>/etc/auto.master.d      /etc/grub.d          /etc/pam.d           /etc/rc3.d        /etc/statetab.d<br>/etc/bash_completion.d  /etc/init.d          /etc/php.d           /etc/rc4.d        /etc/sudoers.d<br>/etc/binfmt.d           /etc/krb5.conf.d     /etc/popt.d          /etc/rc5.d        /etc/sysctl.d<br>/etc/chkconfig.d        /etc/ld.so.conf.d    /etc/prelink.conf.d  /etc/rc6.d        /etc/tmpfiles.d<br>/etc/cron.d             /etc/logrotate.d     /etc/profile.d       /etc/rc.d         /etc/xinetd.d<br>/etc/depmod.d           /etc/modprobe.d      /etc/rc0.d           /etc/rsyslog.d    /etc/yum.repos.d<br>/etc/dracut.conf.d      /etc/modules-load.d  /etc/rc1.d           /etc/rwtab.d<br>/etc/gdbinit.d          /etc/my.cnf.d        /etc/rc2.d           /etc/setuptool.d<br>所有考虑有.开头的隐藏文件,应酬用<br>ls -d /etc/&#123;.*.d,*.d&#125;<br></code></pre></td></tr></table></figure>

<p>6、显示/etc目录下，所有.conf结尾，且以m,n,r,p开头的文件或目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#ls -d /etc/[mnpr]*.conf</span><br>/etc/man_db.conf  /etc/mke2fs.conf  /etc/nsswitch.conf  /etc/resolv.conf  /etc/rsyslog.conf<br>/etc/mdadm.conf   /etc/named.conf   /etc/ntp.conf       /etc/rsyncd.conf<br></code></pre></td></tr></table></figure>

<p>7、只显示/root下的隐藏文件和目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]#ls -d &#x2F;etc&#x2F;.[^.]*    	#ls -d &#x2F;etc&#x2F;.* 会匹配到.和..<br>&#x2F;etc&#x2F;.mk.d  &#x2F;etc&#x2F;.pwd.lock  &#x2F;etc&#x2F;.updated<br></code></pre></td></tr></table></figure>

<p>8、只显示/etc下的非隐藏目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root@ashjian ~]#ls  -aI &quot;.*&quot; &#x2F;etc&#x2F;<br></code></pre></td></tr></table></figure>

<h3 id="7-touch"><a href="#7-touch" class="headerlink" title="7. touch"></a>7. touch</h3><p><strong><code>touch [OPTION]... FILE...</code></strong></p>
<p>一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；</p>
<p>二是用来创建新的空文件。</p>
<p><code>-a</code> ：仅改变 atime和ctime</p>
<p><code>-m</code> ：仅改变 mtime和ctime</p>
<p><code>-t [[CC]YY]MMDDhhmm[.ss]</code>：指定atime和mtime的时间戳</p>
<p><code>-c</code> ：如果文件不存在，则不予创建</p>
<h3 id="9-cp"><a href="#9-cp" class="headerlink" title="9. cp"></a>9. cp</h3><p><code>cp</code> ：copy</p>
<p><a href="http://www.yulongjun.com/images/1495966915640.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200818210242.png" alt="img"></a></p>
<p><code>cp /etc/fstab /app</code> ：复制单个文件到目录下面。<br><code>cp /etc/{fstab,issue} /app/dir/</code>，<code>cp /etc/fstab /etc/bashrc /app/dir/</code>：复制多个文件到某目录下。<br><code>cp /etc/fstab /app/1.txt</code> ：复制并覆盖目标文件（没有则创建）。</p>
<p>参数</p>
<ul>
<li><strong><code>-f</code></strong> ，<code>--force</code>：强制覆盖目标文件。</li>
<li><strong><code>-r</code></strong>，<code>-R</code>，``–recursive<code>：递归复制目录 (</code>-r<code>==</code>-R<code>)。</code>cp -r /var/log /app/log`</li>
<li><strong><code>-d</code></strong>：复制符号链接本身，而不是他指向的文件。<code>cp -d /etc/system-release /app</code></li>
<li><strong><code>-a</code></strong>，<code>--archive</code>：归档，等同于<code>-dr --preserv=all</code></li>
<li><strong><code>-p</code></strong>：复制文件的原来属性，等同于下面的<code>--preserv=[mode,ownership,timestamp]</code></li>
<li><code>-u --update</code> 只复制源比目标更新文件或目标不存在的文件</li>
<li><code>-b</code> 目标存在，覆盖前先备份，形式为 filename~</li>
<li><code>--backup=numbered</code> 目标存在，覆盖前先备份加数字后缀</li>
<li><code>--preserv[=ATTR_LIST]</code><ul>
<li><code>mode</code>：权限</li>
<li><code>ownership</code>：属主属组</li>
<li><code>timestamp</code>：时间戳</li>
<li><code>links</code>：复制链接的源文件</li>
<li><code>xattr</code></li>
<li><code>context</code>： 安全上下文</li>
<li><code>all</code>：所有</li>
</ul>
</li>
<li><strong><code>-v</code></strong>, <code>--verbose</code>：看到详细信息</li>
</ul>
<p><strong>练习：</strong></p>
<p>1、 每天将/etc/目录下所有文件，备份到/data独立的子目录下，并要求子目录格式为 backupYYYY-mm-dd，备份过程可见</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、	cp –avu &#x2F;etc&#x2F; &#x2F;.data&#x2F;back&#96;date +%F&#96;<br></code></pre></td></tr></table></figure>

<p>2、创建<code>/testdir/rootdir</code>目录，并复制<code>/root</code>下所有 文件到该目录内，要求保留原有权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mikdir &#x2F;data&#x2F;rootdir<br>cp –preserv&#x3D;mode &#x2F;root&#x2F;* &#x2F;data&#x2F;rootdir<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips: 小技巧 利用通配符来复制：<br><code>cp -a /etc/passwd{,.bak}</code><br>相当于 <code>cp -a /etc/passwd /etc/passwd.bak</code></p>
</blockquote>
<h3 id="10-mv"><a href="#10-mv" class="headerlink" title="10. mv"></a>10. mv</h3><p><code>mv</code>：move</p>
<ul>
<li><code>-f</code> 强制移动或覆盖</li>
</ul>
<p>移动文件（不在同一目录下），重命名文件（在同一目录下）<br>移动目录或重命名目录</p>
<h3 id="11-rename"><a href="#11-rename" class="headerlink" title="11. rename"></a>11. rename</h3><p>重命名后缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rename [options] expression replacement file...<br></code></pre></td></tr></table></figure>

<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">EXAMPLES<br>       Given the files foo1, ..., foo9, foo10, ..., foo278, the commands<br><br>              rename foo foo0 foo?<br>              rename foo foo0 foo??<br><br>       will turn them into foo001, ..., foo009, foo010, ..., foo278.  And<br><br>              rename .htm .html *.htm<br><br>       will fix the extension of your html files.<br>mkdir test<br>cd text<br>touch &#123;1,2,3,4,5&#125;.txt<br>rename -v .txt .txt.bak *.txt<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><p><code>rm</code>： remove</p>
<p>删除文件<br><code>-i</code>：interactive，交互式<br><code>-r</code> 递归删除<br><code>-f</code> 强制删除</p>
<p><code>rm -rf /</code>(5是可以删除根的，6和7是不可以删除的)</p>
<p>我们可以留一个习惯：<br>不用的文件，不要直接删除，可以用<code>mv</code> move到某个专用目录（比如都移动到/tmp下）</p>
<h3 id="12-tree"><a href="#12-tree" class="headerlink" title="12. tree"></a>12. tree</h3><p>参数：</p>
<ul>
<li><code>-d</code>: 只显示目录</li>
<li><code>-L level</code>：指定显示的层级数目</li>
<li><code>-P pattern</code>: 只显示由指定pattern匹配到的路径</li>
</ul>
<h3 id="13-mkdir、rmdir"><a href="#13-mkdir、rmdir" class="headerlink" title="13. mkdir、rmdir"></a>13. mkdir、rmdir</h3><p><code>mkdir</code>：make directory</p>
<ul>
<li><code>-p</code> 递归创建</li>
<li><code>-v</code> ：verbose，创建目录的详情</li>
<li><code>-m</code> mode，权限</li>
</ul>
<p><code>rmdir</code>:remove empty directory(只能删除空目录)</p>
<p><strong>练习</strong></p>
<p>练习1：创建<code>test1/x/y1</code>, <code>test1/x/y2</code>, <code>test1/x/y1/a</code>, <code>test1/x/y1/b</code></p>
<p>练习2： test2目录下面创建<code>a_c</code>, <code>a_d</code>,<code>b_c</code>, <code>b_d</code></p>
<p>练习3：在test3目录下创建以下目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">test3<br>├── bin<br>├── etc<br>│   └── sysconfig<br>│       └── network-scripts<br>├── sbin<br>├── usr<br>│   ├── bin<br>│   ├── lib<br>│   ├── lib64<br>│   ├── local<br>│   │   ├── bin<br>│   │   ├── etc<br>│   │   ├── lib<br>│   │   └── sbin<br>│   └── sbin<br>└── var<br>    ├── cache<br>    ├── log<br>    └── run<br></code></pre></td></tr></table></figure>

<p>练习3：创建<code>/testdir/dir1/x</code>, <code>/testdir/dir1/y,</code> <code>/testdir/dir1/x/a</code>,<code>/testdir/dir1/x/b</code>, <code>/testdir/dir1/y/a</code>, <code>/testdir/dir1/y/b</code></p>
<p>练习4：创建<code>/testdir/dir2/x</code>, <code>/testdir/dir2/y</code>, <code>/testdir/dir2/x/a</code>,<code>/testdir/dir2/x/b</code></p>
<p>练习5：创建/<code>testdir/dir3</code>, <code>/testdir/dir4</code>, <code>/testdir/dir5</code>, <code>/testdir/dir5/dir6</code>,<code>/testdir/dir5/dir7</code></p>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir -pv test1&#x2F;x&#x2F;&#123;y1&#x2F;&#123;a,b&#125;,y2&#125;<br><br>mkdir -pv test2&#x2F;&#123;a,b&#125;&#123;c,d&#125;<br><br>mkdir -pv test3&#x2F;&#123;bin,sbin,etc&#x2F;sysconfig&#x2F;network-scripts,usr&#x2F;&#123;bin,sbin,local&#x2F;&#123;bin,sbin,etc,lib&#125;,lib,lib64&#125;,var&#x2F;&#123;cache,log,run&#125;&#125;<br><br>mkdir -pv &#x2F;testdir&#x2F;dir1&#x2F;&#123;x,y&#125;&#x2F;&#123;a,b&#125;<br><br>mkdir -pv &#x2F;testdir&#x2F;dir2&#x2F;&#123;x&#x2F;&#123;a,b&#125;,y&#125;<br><br>mkdir -pv &#x2F;testdir&#x2F;dir&#123;3,4,5&#x2F;dir&#123;6,7&#125;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-延伸"><a href="#14-延伸" class="headerlink" title="14. 延伸"></a>14. 延伸</h3><p><strong>删除大文件的方法（没被释放删除，空间还占用的文件）：</strong></p>
<p>实验：<br>在一个会话下，<code>dd if=/dev/zero of=bigfile bs=1M count=2048</code>，<code>vim bigfile</code>，在vim模式下不要退出。</p>
<p>打开另外一个会话窗口，删除文件，结果发现，文件是删除了，但是空间没有释放，因为vim占用着文件。</p>
<p>这时候我们就可以用<code>&gt;</code>来搞定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; bigfile3<br>rm -rf bigfile3<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>&gt;</code> 和<code>&gt;&gt;</code>开单章讲，在后面的IO和重定向部分。</p>
</blockquote>
<p>未释放磁盘空间原因：</p>
<p>在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的文件夹结构上解除链接(unlink).然而假设文件是被打开的（有一个进程正在使用），那么进程将仍然能够读取该文件，磁盘空间也一直被占用。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Nginx主配置文件</title>
    <url>/03-Nginx%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nginx的程序架构"><a href="#Nginx的程序架构" class="headerlink" title="Nginx的程序架构"></a>Nginx的程序架构</h2><p><strong>Nginx进程：</strong></p>
<p>进程为为master/worker模式</p>
<ul>
<li>一个master进程：负载加载和分析配置文件、管理worker进程、平滑升级</li>
<li>一个或多个worker进程：处理并响应用户请求</li>
<li>缓存相关的进程：<ul>
<li>cache loader：载入缓存对象</li>
<li>cache manager：管理缓存对象</li>
</ul>
</li>
</ul>
<p><strong>Nginx模块：</strong></p>
<p>高度模块化，但其模块早期不支持DSO机制；近期版本支持动态装载和卸载；</p>
<p>模块分类：</p>
<ul>
<li><p>核心模块：</p>
<ul>
<li><strong>core module</strong></li>
</ul>
</li>
<li><p>常用的标准模块：</p>
<ul>
<li><p>HTTP modules</p>
<p>：</p>
<ul>
<li><strong><code>ngx_http_core_modules</code></strong> http核心功能模块（重要）</li>
<li><strong><code>ngx_http_ssl_module</code></strong> http信道加密模块（重要）</li>
<li><strong><code>ngx_http_upstream_module</code></strong> http定义服务器组模块（重要）</li>
<li><strong><code>ngx_http_fastcgi|uWSGI|SCGI_module</code></strong> http web api接口模块（重要）</li>
<li><strong><code>ngx_http_proxy_module</code></strong> http反向代理模块（重要）</li>
<li><code>ngx_http_gzip_module</code> http gzip压缩传输模块（次一级）</li>
<li><code>ngx_http_log_module</code> http日志模块（次一级）</li>
<li><code>ngx_http_referer_module</code> http防盗链模块（次一级）</li>
<li><code>ngx_http_rewrite_module</code> http重定向模块（次一级）</li>
<li><code>ngx_http_access_module</code> http权限控制模块</li>
<li><code>ngx_http_auth_basic_module</code> http认证模块</li>
<li><code>ngx_http_stub_status_module</code> http状态模块</li>
<li><code>ngx_http_headers_module</code> http首部信息模块</li>
</ul>
</li>
<li><p>Mail modules</p>
<p>：</p>
<ul>
<li>用的少</li>
</ul>
</li>
<li><p>Stream modules</p>
<p>：</p>
<ul>
<li><code>ngx_stream_core_module</code> http的伪四层负载均衡模块</li>
</ul>
</li>
</ul>
</li>
<li><p>第三方模块</p>
</li>
</ul>
<p><strong>Nginx的功用：</strong></p>
<ul>
<li>静态的web资源服务器；(图片服务器，或js/css/html/txt等静态资源服务器)</li>
<li>结合FastCGI/uwSGI/SCGI等协议反代动态资源请求；</li>
<li>http/https协议的反向代理；</li>
<li>imap4/pop3协议的反向代理；</li>
<li>tcp/udp协议的请求转发；</li>
</ul>
<h2 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h2><p>yum安装最新稳定版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo<br>[nginx]<br>name&#x3D;nginx repo<br>baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;<br>gpgcheck&#x3D;0<br>enabled&#x3D;1<br>yum install -y nginx<br></code></pre></td></tr></table></figure>

<p>epel源安装次新的稳定版：</p>
<p><code>yum install epel-release</code>这是安装的官方的epel源地址。</p>
<p>也可以安装国内的epel镜像源：</p>
<p>如阿里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo.backup<br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo<br></code></pre></td></tr></table></figure>

<h2 id="NGINX程序组成"><a href="#NGINX程序组成" class="headerlink" title="NGINX程序组成"></a>NGINX程序组成</h2><ul>
<li>主程序文件：<code>/usr/sbin/nginx</code></li>
<li>systemd服务：<code>nginx.service</code></li>
<li>配置文件(<code>/etc/nginx</code>下）：<ul>
<li>主配置文件：<code>nginx.conf</code>（include了<code>conf.d/*.conf</code>）</li>
<li>fastcgi， uwsgi，scgi等协议相关的配置文件：<code>fastcgi_params</code>、<code>uwsgi_params</code>、<code>scgi_params</code></li>
<li>支持的MIME类型配置文件：<code>mime.types</code></li>
</ul>
</li>
</ul>
<h2 id="NGINX主配置文件"><a href="#NGINX主配置文件" class="headerlink" title="NGINX主配置文件"></a>NGINX主配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br></code></pre></td></tr></table></figure>

<p>主配置文件各种配置段的的详细配置选项信息见：</p>
<p><a href="http://nginx.org/en/docs/ngx_core_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/ngx_core_module.html</a></p>
<p>我们要来理解配置文件的结构：</p>
<ul>
<li><strong><code>段</code></strong>：如<code>http{}</code> 、<code>event{}</code>、<code>server{}</code>、<code>location{}</code>等，段可以并列，也可以嵌套。</li>
<li><strong>块</strong>：指的就是在段里定义的一组directives（配置指令）。</li>
<li><strong>directive</strong>：指的就是块里的一条条配置指令。指令定义方法：<code>directive value [value2 ...];</code>。</li>
</ul>
<p>注意：<br>(1) 指令必须以分号结尾。<br>(2)嵌套的段是有层级结构的，比如http段里，遵循<code>http{}</code>–&gt;<code>server{}</code>–&gt;<code>location{}</code>这种嵌套结构。<br>(3) 支持使用配置变量：</p>
<ul>
<li>内建变量：由Nginx模块引入，可直接引用。</li>
<li>自定义变量：由用户使用set命令定义。<ul>
<li>定义变量：<code>set variable_name value;</code>。</li>
<li>引用变量：<code>$variable_name</code></li>
</ul>
</li>
</ul>
<p>主配置文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># main block：主配置段，也即全局配置段<br>...<br>events &#123;<br>    # 事件驱动相关的配置段<br>    ...<br>&#125;     <br>http &#123;<br>    # http block：http&#x2F;https 协议相关的公共配置段<br>    server &#123;<br>        # server block：虚拟主机公共相关配置段<br>        location &#x2F;xxx &#123;<br>            # location block：资源位置相关公共配置段<br>        &#125;<br>        ...  # 其他location<br>    &#125;    <br>    ...  # 其他server<br>&#125;     <br>mail &#123;<br>    ...<br>&#125;<br>stream &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="main-block主配置段，也即全局配置段"><a href="#main-block主配置段，也即全局配置段" class="headerlink" title="main block主配置段，也即全局配置段"></a>main block主配置段，也即全局配置段</h3><p>main block常见配置指令分类：</p>
<ul>
<li>正常运行必备的配置</li>
<li>优化性能相关的配置</li>
<li>用于调试及定位问题相关的配置</li>
<li>事件驱动相关的配置</li>
</ul>
<p><strong>正常运行必备的配置：</strong></p>
<p>1、 <code>user USERNAME;</code></p>
<blockquote>
<p>指定worker进程的运行身份，如组不指定，默认和用户名同名。如果不写user字段，默认为nobody用户和nobody组。</p>
</blockquote>
<p>2、<code>pid /PATH/TO/PID_FILE;</code></p>
<blockquote>
<p>指定存储nginx主进程进程号码的文件路径</p>
</blockquote>
<p>3、 <code>include file | mask;</code></p>
<blockquote>
<p>指明包含进来的其它配置文件片断</p>
</blockquote>
<p>4、<code>load_module file /usr/share/nginx/modules/*.conf</code></p>
<blockquote>
<p>指明要装载的动态模块路径。<br>例如<code>geoip.conf</code>文件里：<code>load_module &quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&quot;;</code></p>
</blockquote>
<p><strong>性能优化相关的配置：</strong></p>
<p>1、<code>worker_processes NUMBER | auto;</code></p>
<blockquote>
<p>worker进程的数量；NUMBER通常应该等于小于当前主机的cpu的物理核心数。<br>auto：自动为当前主机物理CPU核心数。<br>例如：<code>worker_processes 4</code></p>
</blockquote>
<p>2、<code>worker_cpu_affinity cpumask ...;</code></p>
<blockquote>
<p><code>worker_cpu_affinity auto |CPUMASK;</code><br>nginx进程的CPU亲缘性，配置cpumask可以指定绑定CPU</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CPU MASK：<br>0000 0001：0号CPU<br>0000 0010：1号CPU<br>0000 0100：2号CPU<br>... ...<br>0000 0011：0和1号CPU<br></code></pre></td></tr></table></figure>

<p>例如如果nginx进程为4个的话，<code>worker_cpu_affinity 0001 0010 0100 1000;</code>就是把4个nginx进程分别绑在<code>0123</code>号cpu上。<br>例如如果nginx进程为4个的话，<code>worker_cpu_affinity 0101 1010;</code>就是把第一个nginx进程绑在<code>0和2</code>号cpu上，第二个cpu进程绑在<code>1和3</code>号cpu上</p>
</blockquote>
<p>3、<code>worker_priority NUMBER;</code></p>
<blockquote>
<p>指定worker进程的nice值，设定worker进程优先级：[-20,20]</p>
</blockquote>
<p>4、<code>worker_rlimit_nofile NUMBER;</code></p>
<blockquote>
<p>单个worker进程所能够打开的文件数量上限,如65535</p>
</blockquote>
<p><strong>调试、定位问题相关配置：</strong></p>
<p>1、<code>daemon on|off;</code></p>
<blockquote>
<p>是否以守护进程方式运行nignx，默认是on，守护进程方式</p>
</blockquote>
<p>2、<code>master_process on|off;</code></p>
<blockquote>
<p>是否以master/worker模型运行nginx；默认为on，off将不启动worker</p>
</blockquote>
<p>3、<code>error_log PATH/TO/LOGFILE [LEVEL];</code></p>
<blockquote>
<p>PATH/TO/LOGFILE 为日志文件路径<br>LEVEL为日志级别,一般不修改，出于调试需要，可设定为debug。<br>系统默认为：<code>error_log /var/log/nginx/error.log;</code></p>
</blockquote>
<p><strong>事件驱动相关的配置:</strong></p>
<p>写在events里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">events &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>1、<code>worker_connections number;</code></p>
<blockquote>
<p>每个worker进程所能够打开的最大并发连接数数量，如 10240<br>总最大并发数：<code>worker_processes * worker_connections</code></p>
</blockquote>
<p>2、<code>use METHOD</code></p>
<p>指明并发连接请求的处理方法 ,一般不用设置，Nginx会默认自动选择适合系统的最优方法。</p>
<blockquote>
<p>如果系统是Linux，会自动使用<code>epoll</code>方法；如果是FreeBSD和macOS，会自动使用<code>kqueue</code>；如果是Solaris和HP/UX，会自动使用<code>/dev/poll</code>。<br>有两个普通方法<code>select</code>和<code>poll</code>，已经被淘汰，不做讨论。</p>
</blockquote>
<p>3、<code>accept_mutex on | off</code></p>
<blockquote>
<p>是否接受互斥。<br>指的是处理新的连接请求的方法；on指由各个worker轮流处理新请求 ，Off指每个新请求的到达都会通知(唤醒)所有的worker进程，但 只有一个进程可获得连接，造成“惊群”，影响性能，默认<code>on</code></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>03-SQL语句简单示例</title>
    <url>/03-SQL%E8%AF%AD%E5%8F%A5%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单的几个示例演示一下。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="1-数据库的创建（-CREATE-DATABASE-语句）"><a href="#1-数据库的创建（-CREATE-DATABASE-语句）" class="headerlink" title="1. 数据库的创建（ CREATE DATABASE 语句）"></a>1. 数据库的创建（ CREATE DATABASE 语句）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CREATE DATABASE &lt;数据库名称&gt; ;<br></code></pre></td></tr></table></figure>

<h3 id="2-表的创建（CREATE-TABLE-语句）"><a href="#2-表的创建（CREATE-TABLE-语句）" class="headerlink" title="2. 表的创建（CREATE TABLE 语句）"></a>2. 表的创建（CREATE TABLE 语句）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CREATE TABLE &lt;表名&gt;<br>(&lt;列名1&gt; &lt;数据类型&gt; &lt;该列所需约束&gt; ，<br>&lt;列名2&gt; &lt;数据类型&gt; &lt;该列所需约束&gt; ， &lt;列名3&gt; &lt;数据类型&gt; &lt;该列所需约束&gt; ，<br>&lt; 列名4&gt; &lt;数据类型&gt; &lt;该列所需约束&gt; ，<br>.<br>.<br>.<br>&lt;该表的约束1&gt; ， &lt;该表的约束2&gt; ，……）；<br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">CREATE TABLE Product<br>(product_id      CHAR(4)      NOT NULL,  -- 商品编号<br> product_name    VARCHAR(100) NOT NULL,  -- 商品名称<br> product_type    VARCHAR(32)  NOT NULL,  -- 商品种类<br> sale_price      INTEGER ,               -- 销售单价<br> purchase_price  INTEGER ,               -- 进货单价<br> regist_date     DATE ,                 -- 登记日期<br> PRIMARY KEY (product_id));<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15011654465637.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203150252.jpg" alt="img"></a></p>
<p>下面对上面内容进行分解：</p>
<h3 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3. 命名规则"></a>3. 命名规则</h3><p>标准SQL命名规则：</p>
<ul>
<li>标准SQL，只能使用半角英文字母、数字、下划线（_）作为数据库、表和列的名称。</li>
<li>标准SQL名称必须以半角英文字母开头。</li>
<li>名称不能重复。在同一个数据库中不能创建两个相同名称的表，在同一个表中也不能创建两个名称相同的列。</li>
</ul>
<h3 id="4-列的数据类型"><a href="#4-列的数据类型" class="headerlink" title="4. 列的数据类型"></a>4. 列的数据类型</h3><p>数据类型表示数据的种类，包括<strong>数字型</strong>、<strong>字符型</strong>和<strong>日期型</strong>等。</p>
<p>上文中的几种数据类型：</p>
<ul>
<li><strong>INTEGER</strong>：整数型</li>
<li><strong>CHAR</strong>：定长字符型</li>
<li><strong>VARCHAR</strong>：可变字符型</li>
<li><strong>DATE</strong>：日期型</li>
</ul>
<h3 id="5-约束设置"><a href="#5-约束设置" class="headerlink" title="5. 约束设置"></a>5. 约束设置</h3><ul>
<li><strong>NOT NULL</strong> 非空约束：字段不能为空。</li>
<li><strong>UNIQUE</strong> 唯一性约束：字段全列唯一，可以为空。</li>
<li><strong>PRIMARY KEY</strong> 主键约束：NOT NULL和UNIQUE结合起来，即字段不能为空，而且唯一。</li>
</ul>
<hr>
<h2 id="表的删除和更新"><a href="#表的删除和更新" class="headerlink" title="表的删除和更新"></a>表的删除和更新</h2><h3 id="1-表的删除（-DROP-TABLE-语句）"><a href="#1-表的删除（-DROP-TABLE-语句）" class="headerlink" title="1. 表的删除（ DROP TABLE 语句）"></a>1. 表的删除（ DROP TABLE 语句）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DROP TABLE &lt;表名&gt;;<br></code></pre></td></tr></table></figure>

<h3 id="2-表定义的更新（-ALTER-TABLE-语句）"><a href="#2-表定义的更新（-ALTER-TABLE-语句）" class="headerlink" title="2. 表定义的更新（ ALTER TABLE 语句）"></a>2. 表定义的更新（ ALTER TABLE 语句）</h3><p>添加列的 ALTER TABLE 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列的定义&gt;；<br></code></pre></td></tr></table></figure>

<p>删除列的 ALTER TABLE 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;；<br></code></pre></td></tr></table></figure>

<p>插入数据</p>
<p>向 Product 表中插入数据的SQL语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO Product VALUES (&#39;0001&#39;, &#39;T恤衫&#39;, &#39;衣服&#39;, 1000, 500, &#39;2009-09-20&#39;); <br>INSERT INTO Product VALUES (&#39;0002&#39;, &#39;打孔器&#39;, &#39;办公用品&#39;, 500, 320, &#39;2009-09-11&#39;); <br>INSERT INTO Product VALUES (&#39;0003&#39;, &#39;运动T恤&#39;, &#39;衣服&#39;, 4000, 2800, NULL); <br>INSERT INTO Product VALUES (&#39;0004&#39;, &#39;菜刀&#39;, &#39;厨房用具&#39;, 3000, 2800, &#39;2009-09-20&#39;); <br>INSERT INTO Product VALUES (&#39;0005&#39;, &#39;高压锅&#39;, &#39;厨房用具&#39;, 6800, 5000, &#39;2009-01-15&#39;); <br>INSERT INTO Product VALUES (&#39;0006&#39;, &#39;叉子&#39;, &#39;厨房用具&#39;, 500, NULL, &#39;2009-09-20&#39;); <br>INSERT INTO Product VALUES (&#39;0007&#39;, &#39;擦菜板&#39;, &#39;厨房用具&#39;, 880, 790, &#39;2008-04-28&#39;); <br>INSERT INTO Product VALUES (&#39;0008&#39;, &#39;圆珠笔&#39;, &#39;办公用品&#39;, 100, NULL,&#39;2009-11-11&#39;);<br><br>COMMIT;<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15011666530423.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203150253.jpg" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>03-Zabbix-Server设置主机监控</title>
    <url>/03-Zabbix-Server%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="设置主机的监控项"><a href="#设置主机的监控项" class="headerlink" title="设置主机的监控项"></a>设置主机的监控项</h2><p><strong>(1) 设置CPU用户使用率</strong>，键值为<code>sys.cpu.util[all,sys,avg1]</code></p>
<p><a href="http://www.yulongjun.com/images/15065862669269.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153854.jpg" alt="img"></a></p>
<p>由于用的百分号作为单位，所以要在进程里改为100倍：<br><a href="http://www.yulongjun.com/images/15065863160371.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153855.jpg" alt="img"></a></p>
<p><strong>(2)设置CPU用户使用率</strong>，同上，只是把键值变为<code>sys.cpu.util[all,user,avg1]</code><br><a href="http://www.yulongjun.com/images/15065866591972.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153856.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15065866752130.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153857.jpg" alt="img"></a></p>
<p>可以看到创建的两个监控项：<br><a href="http://www.yulongjun.com/images/15065867133732.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153858.jpg" alt="img"></a></p>
<h2 id="创建监控图形（grah"><a href="#创建监控图形（grah" class="headerlink" title="创建监控图形（grah)"></a>创建监控图形（grah)</h2><p>创建如macOS上的iStat Menus的效果：<br><a href="http://www.yulongjun.com/images/15065870975985.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153859.jpg" alt="img"></a></p>
<p>设置：</p>
<p><a href="http://www.yulongjun.com/images/15065893967976.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153900.jpg" alt="img"></a></p>
<p>最终效果：<br><a href="http://www.yulongjun.com/images/15065894162692.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153901.jpg" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>03-httpd软件</title>
    <url>/03-httpd%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="httpd"><a href="#httpd" class="headerlink" title="httpd"></a>httpd</h2><p>httpd是Apache旗下的一款实现http协议的web服务软件。</p>
<h2 id="httpd的特性："><a href="#httpd的特性：" class="headerlink" title="httpd的特性："></a>httpd的特性：</h2><p>​        高度模块化： core + modules<br>​        DSO：dynamic shared object</p>
<h3 id="MPM：Multipath-processing-Modules-多路处理模块"><a href="#MPM：Multipath-processing-Modules-多路处理模块" class="headerlink" title="MPM：Multipath processing Modules (多路处理模块)"></a>MPM：Multipath processing Modules (多路处理模块)</h3><ul>
<li><p>prefork：多进程模型，每个进程响应一个请求；</p>
<pre><code>一个主进程：负责生成子进程及回收子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；
n个子进程：每个子进程处理一个请求；
工作模型：会预先生成几个空闲进程，随时等待用于响应用户请求；最大空闲和最小空闲；- </code></pre></li>
<li><p>worker：多进程多线程模型，每线程处理一个用户请求；</p>
<pre><code>一个主进程：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；
多个子进程：每个子进程负责生成多个线程；
每个线程：负责响应用户请求；
并发响应数量：m*n
    m：子进程数量
    n：每个子进程所能创建的最大线程数量；</code></pre></li>
<li><p>event：事件驱动模型，多进程模型，每个进程响应多个请求；</p>
<pre><code>一个主进程 ：负责生成子进程；负责创建套接字；负责接收请求，并将其派发给某子进程进行处理；
子进程：基于事件驱动机制直接响应多个请求；</code></pre><p>​              httpd-2.2: 仍为测试使用模型；<br>​              httpd-2.4：event可生产环境中使用；            </p>
</li>
</ul>
<h2 id="httpd的程序版本："><a href="#httpd的程序版本：" class="headerlink" title="httpd的程序版本："></a>httpd的程序版本：</h2><p>​    httpd 1.3：官方已经停止维护；<br>​    httpd 2.0：<br>​    httpd 2.2:<br>​    httpd 2.4：目前最新稳定版；<br>​    </p>
<h2 id="httpd的功能特性："><a href="#httpd的功能特性：" class="headerlink" title="httpd的功能特性："></a>httpd的功能特性：</h2><p>​    CGI：Common Gateway Interface （适用于动态网站）<br>​    虚拟主机：IP，PORT， FQDN<br>​    反向代理<br>​    负载均衡<br>​    路径别名<br>​    丰富的用户认证机制<br>​        basic<br>​        digest<br>​    支持第三方模块<br>​    ……<br>​    </p>
<h2 id="安装httpd："><a href="#安装httpd：" class="headerlink" title="安装httpd："></a>安装httpd：</h2><p>​    rpm包：CentOS 发行版中直接提供；<br>​    编译安装：定制新功能，或其它原因；<br>​    </p>
<h2 id="CentOS-6：httpd-2-2"><a href="#CentOS-6：httpd-2-2" class="headerlink" title="CentOS 6：httpd-2.2"></a>CentOS 6：httpd-2.2</h2><p>​    程序环境：<br>​        配置文件：<br>​            /etc/httpd/conf/httpd.conf<br>​            /etc/httpd/conf.d/*.conf<br>​        服务脚本：<br>​            /etc/rc.d/init.d/httpd<br>​            脚本配置文件：/etc/sysconfig/httpd<br>​        主程序文件：<br>​            /usr/sbin/httpd<br>​            /usr/sbin/httpd.event<br>​            /usr/sbin/httpd.worker<br>​        日志文件：<br>​            /var/log/httpd:<br>​                access_log：访问日志<br>​                error_log：错误日志<br>​        站点文档：<br>​            /var/www/html<br>​        模块文件路径：</p>
<p>/usr/lib64/httpd/modules</p>
<p>服务控制和启动：<br>                chkconfig  httpd  on|off<br>                service  {start|stop|restart|status|configtest|reload}  httpd</p>
<h2 id="CentOS-7：httpd-2-4"><a href="#CentOS-7：httpd-2-4" class="headerlink" title="CentOS 7：httpd-2.4"></a>CentOS 7：httpd-2.4</h2><p>​    程序环境：<br>​        配置文件：<br>​            /etc/httpd/conf/httpd.conf<br>​            /etc/httpd/conf.d/<em>.conf<br>​            模块相关的配置文件：/etc/httpd/conf.modules.d/</em>.conf<br>​        systemd unit file：<br>​            /usr/lib/systemd/system/httpd.service<br>​        主程序文件：<br>​            /usr/sbin/httpd<br>​                httpd-2.4支持MPM的动态切换；<br>​        日志文件：<br>​            /var/log/httpd:<br>​                access_log：访问日志<br>​                error_log：错误日志<br>​        站点文档：<br>​            /var/www/html<br>​        模块文件路径：<br>​            /usr/lib64/httpd/modules<br>​        服务控制：<br>​            systemctl  enable|disable  httpd.service<br>​            systemctl  {start|stop|restart|status}  httpd.service</p>
<h2 id="MPM："><a href="#MPM：" class="headerlink" title="MPM："></a>MPM：</h2><p>​    prefork：多进程模型，一个进程响应一个请求；<br>​    worker：多进程多线程模型，一个线程响应一个请求；<br>​    event：事件驱动模型，一个进程响应n个请求；</p>
<p>httpd-2.2的常用配置</p>
<p>主配置文件：/etc/httpd/conf/httpd.conf</p>
<p>Section 1: Global Environment</p>
<p>Section 2: ‘Main’ server configuration                                #中心主机</p>
<p>Section 3: Virtual Hosts                                                        #虚拟主机</p>
<p>Tip;中心主机和虚拟主机可以共存在一个配置文件中，但是这两种类型配置只有一种生效            </p>
<p>​                    </p>
<p>配置格式：<br>    directive  value<br>        directive：不区分字符大小写；<br>        value：为路径时，是否区分字符大小写，取决于文件系统； </p>
<p>常用配置：<br>    1、修改监听的IP和PORT<br>        Listen  [IP:]PORT</p>
<p>​        (1) 省略IP表示为0.0.0.0；<br>​        (2) Listen指令可重复出现多次；<br>​            Listen  80<br>​            Listen  8080<br>​        (3) 修改监听socket，重启服务进程方可生效；<br>​<br>2、持久连续<br>​    Persistent Connection：tcp连续建立后，每个资源获取完成后不全断开连接，而是继续等待其它资源请求的进行；<br>​        如何断开？<br>​            数量限制<br>​            时间限制<br>​<br>​            副作用：对并发访问量较大的服务器，长连接机制会使得后续某些请求无法得到正常 响应；<br>​            折衷：使用较短的持久连接时长，以及较少的请求数量；<br>​<br>​        KeepAlive  On|Off<br>​        KeepAliveTimeout  15<br>​        MaxKeepAliveRequests  100<br>​<br>​    测试：<br>​        telnet  WEB_SERVER_IP  PORT<br>​        GET  /URL  HTTP/1.1<br>​        Host: WEB_SERVER_IP<br>​<br>3、MPM<br>​<br>​    httpd-2.2不支持同时编译多个MPM模块，所以只能编译选定要使用的那个；CentOS 6的rpm包为此专门提供了三个应用程序文件，httpd(prefork), httpd.worker, httpd.event，分别用于实现对不同的MPM机制的支持；确认现在使用的是哪下程序文件的方法：<br>​        ps  aux  | grep httpd<br>​<br>​    默认使用的为/usr/sbin/httpd，其为prefork的MPM模块 ；<br>​        查看httpd程序的模块列表：<br>​            查看静态编译的模块：</p>
<p>​                    httpd  -l</p>
<p>​                查看静态编译及动态编译的模块：</p>
<p>​                httpd  -M</p>
<p>​        更换使用httpd程序，以支持其它MPM机制；<br>​            /etc/sysconfig/httpd<br>​                HTTPD=/usr/sbin/httpd.{worker,event}<br>​<br>​        注意：重启服务进程方可生效<br>​<br>​        MPM配置：<br>​            prefork的配置<br>​                <IfModule prefork.c><br>​                StartServers       8<br>​                MinSpareServers    5<br>​                MaxSpareServers   20<br>​                ServerLimit      256<br>​                MaxClients       256<br>​                MaxRequestsPerChild  4000<br>​                </IfModule><br>​<br>​            worker的配置：<br>​                <IfModule worker.c><br>​                StartServers         4<br>​                MaxClients         300<br>​                MinSpareThreads     25<br>​                MaxSpareThreads     75<br>​                ThreadsPerChild     25<br>​                MaxRequestsPerChild  0<br>​                </IfModule><br>​<br>​        PV，UV<br>​            PV：Page View<br>​            UV: User View<br>​<br>​    4、DSO<br>​        配置指定实现模块加载</p>
<p>​            /etc/httpd/conf.modules.d/00-mpm.conf</p>
<p>​            LoadModule  <mod_name>  <mod_path><br>​<br>​            模块文件路径可使用相对路径：<br>​                相对于ServerRoot（默认/etc/httpd）<br>​<br>​    5、定义’Main’ server的文档页面路径<br>​        DocumentRoot  “”<br>​        文档路径映射：<br>​            DoucmentRoot指向的路径为URL路径的起始位置<br>​                其相当于站点URL的根路径；<br>​<br>​                    (FileSystem) /web/host1/index.html  –&gt;  (URL)  /index.html<br>​<br>​    6、站点访问控制常见机制<br>​<br>​        可基于两种机制指明对哪些资源进行何种访问控制<br>​<br>​            文件系统路径：<br>​                &lt;Directory  “”&gt;<br>​                …<br>​                </Directory><br>​<br>​                &lt;File  “”&gt;<br>​                …<br>​                </File><br>​<br>​                &lt;FileMatch  “PATTERN”&gt;<br>​                …<br>​                </FileMatch><br>​            URL路径：<br>​                &lt;Location  “”&gt;<br>​                …<br>​                </Location><br>​<br>​                &lt;LocationMatch “”&gt;<br>​                …<br>​                </LocationMatch><br>​<br>​        <Directory>中“基于源地址”实现访问控制：<br>​            (1) Options<br>​                后跟1个或多个以空白字符分隔的“选项”列表；<br>​                    Indexes：指明的URL路径下不存在与定义的主页面资源相符的资源文件时，返回索引列表给用户；</p>
<p>Tip：目录会继承上级的Indexes，如果不想Indexes生效，Options后面写-Indexes</p>
<p>​                    FollowSymLinks：允许跟踪符号链接文件所指向的源文件；<br>​                    None：<br>​                    All：<br>​<br>​            (2)  AllowOverride<br>​                与访问控制相关的哪些指令可以放在.htaccess文件（每个目录下都可以有一个）中；<br>​                    All:<br>​                    None：<br>​<br>​            (3) order和allow、deny<br>​                order：定义生效次序；写在后面的表示默认法则；<br>​<br>​                Allow from, Deny from<br>​                    来源地址：<br>​                        IP<br>​                        NetAddr:<br>​                            172.16<br>​                            172.16.0.0<br>​                            172.16.0.0/16<br>​                            172.16.0.0/255.255.0.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2.2配置<br>order：allow deney		#谁在最后就代表谁生效，deney在最后，就是deney拒绝所有<br>deney from 172.16.100<br>allow from 172.16<br><br>2.4配置<br>基于IP控制<br>Require ip IP<br>基于主机名控制<br>Require host HOSTNAME<br>&lt;RequireAll&gt;		#2.4需要带容器<br>Require no ip 172.16.100<br>Require ip 172.16<br>&lt;&#x2F;RequireAll&gt;<br>#2.4需要带容器&lt;RequireAll&gt;或者&lt;RequireAny&gt;<br></code></pre></td></tr></table></figure>

<p><code>2.4任何控制访问都需要加容器，比如&lt;Directory&gt;,注意要加Require all granted才能显式让别人访问</code><br>    7、定义站点主页面：<br>        DirectoryIndex  index.html  index.html.var</p>
<pre><code>8、定义路径别名
    格式：
        Alias  /URL/  &quot;/PATH/TO/SOMEDIR/&quot;

    DocumentRoot &quot;/www/htdocs&quot;
        http://www.magedu.com/download/bash-4.4.2-3.el6.x86_64.rpm 
            /www/htdocs/download/bash-4.4.2-3.el6.x86_64.rpm 

    Alias  /download/  &quot;/rpms/pub/&quot;
        http://www.magedu.com/download/bash-4.4.2-3.el6.x86_64.rpm 
            /rpms/pub/bash-4.4.2-3.el6.x86_64.rpm

        http://www.magedu.com/images/logo.png
            /www/htdocs/images/logo.png

9、设定默认字符集
    AddDefaultCharset  UTF-8

    中文字符集：GBK, GB2312, GB18030

10、日志设定
    日志类型：访问日志 和 错误日志

    错误日志：
        ErrorLog  logs/error_log
        LogLevel  warn
            Possible values include: debug, info, notice, warn, error, crit, alert, emerg.

    访问日志：
        LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined
        CustomLog  logs/access_log  combined

        LogFormat format strings:
            http://httpd.apache.org/docs/2.2/mod/mod_log_config.html#formats

            %h：客户端IP地址；
            %l：Remote User, 通常为一个减号（“-”）；
            %u：Remote user (from auth; may be bogus if return status (%s) is 401)；非为登录访问时，其为一个减号；
            %t：服务器收到请求时的时间；
            %r：First line of request，即表示请求报文的首行；记录了此次请求的“方法”，“URL”以及协议版本；
            %&gt;s：响应状态码；
            %b：响应报文的大小，单位是字节；不包括响应报文的http首部；
            %{Referer}i：请求报文中首部“referer”的值；即从哪个页面中的超链接跳转至当前页面的；
            %{User-Agent}i：请求报文中首部“User-Agent”的值；即发出请求的应用程序；

11、基于用户的访问控制

    认证质询：
        WWW-Authenticate：响应码为401，拒绝客户端请求，并说明要求客户端提供账号和密码；

    认证：
        Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，则服务器发送响应的资源；

        认证方式有两种：
            basic：明文 
            digest：消息摘要认证

    安全域：需要用户认证后方能访问的路径；应该通过名称对其进行标识，以便于告知用户认证的原因；

    用户的账号和密码存放于何处？
        虚拟账号：仅用于访问某服务时用到的认证标识

        存储：
            文本文件；
            SQL数据库；
            ldap目录存储；</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">使用digest认证的话，如果自己手动openssl加密对方发送方的密码太麻烦了，httpd-tools提供一个htpasswd工具用来加密密码<br>root@ashjian public]<span class="hljs-comment">#rpm -ql httpd-tools</span><br>/usr/bin/ab<br>/usr/bin/htdbm<br>/usr/bin/htdigest<br>/usr/bin/htpasswd<br>/usr/bin/httxt2dbm<br>/usr/bin/logresolve<br>/usr/share/doc/httpd-tools-2.4.6<br>/usr/share/doc/httpd-tools-2.4.6/LICENSE<br>/usr/share/doc/httpd-tools-2.4.6/NOTICE<br>/usr/share/man/man1/ab.1.gz<br>/usr/share/man/man1/htdbm.1.gz<br>/usr/share/man/man1/htdigest.1.gz<br>/usr/share/man/man1/htpasswd.1.gz<br>/usr/share/man/man1/httxt2dbm.1.gz<br>/usr/share/man/man1/logresolve.1.gz<br>[root@ashjian public]<span class="hljs-comment">#htpasswd -c /tmp/test.users ashjian #第一次创建用-c 指定文件</span><br>New password: <br>Re-type new password: <br>Adding password <span class="hljs-keyword">for</span> user ashjian<br>[root@ashjian public]<span class="hljs-comment">#cat /tmp/test.users </span><br>ashjian:<span class="hljs-variable">$apr1</span><span class="hljs-variable">$Av</span>.kK/cw<span class="hljs-variable">$Zgy0YQ6num0OsKE4NhHIf</span>/<br>[root@ashjian public]<span class="hljs-comment">#htpasswd -m /tmp/test.users tom #第二次用-m，表明使用md5加密，如果用-c会清空重新创建</span><br>New password: <br>Re-type new password: <br>Adding password <span class="hljs-keyword">for</span> user tom<br>[root@ashjian public]<span class="hljs-comment">#cat /tmp/test.users </span><br>ashjian:<span class="hljs-variable">$apr1</span><span class="hljs-variable">$Av</span>.kK/cw<span class="hljs-variable">$Zgy0YQ6num0OsKE4NhHIf</span>/<br>tom:<span class="hljs-variable">$apr1</span><span class="hljs-variable">$wMf9AhQD</span><span class="hljs-variable">$yKX</span>.EVMXtxgcQYG6x7biT1<br>[root@ashjian public]<span class="hljs-comment">#htpasswd -b -m /tmp/test.users wang magedu</span><br>Adding password <span class="hljs-keyword">for</span> user wang<br>[root@ashjian public]<span class="hljs-comment">#cat /tmp/test.users </span><br>ashjian:<span class="hljs-variable">$apr1</span><span class="hljs-variable">$Av</span>.kK/cw<span class="hljs-variable">$Zgy0YQ6num0OsKE4NhHIf</span>/<br>tom:<span class="hljs-variable">$apr1</span><span class="hljs-variable">$wMf9AhQD</span><span class="hljs-variable">$yKX</span>.EVMXtxgcQYG6x7biT1<br>wang:<span class="hljs-variable">$apr1</span><span class="hljs-variable">$44FLMz</span>/9<span class="hljs-variable">$fARbc3XooyRvrbj8znuXA1</span><br></code></pre></td></tr></table></figure>

<p>​        basic认证配置示例：<br>​            (1) 定义安全域<br>​                &lt;Directory “”&gt;<br>​                    Options None<br>​                    AllowOverride None<br>​                    AuthType Basic<br>​                    AuthName “String“<br>​                    AuthUserFile  “/PATH/TO/HTTPD_USER_PASSWD_FILE”<br>​                    Require  user  username1  username2 …<br>​                </Directory><br>​<br>​                允许账号文件中的所有用户登录访问：<br>​                    Require  valid-user<br>​<br>​            (2) 提供账号和密码存储（文本文件）<br>​                使用专用命令完成此类文件的创建及用户管理<br>​                    htpasswd  [options]   /PATH/TO/HTTPD_PASSWD_FILE  username<br>​                        -c：自动创建此处指定的文件，因此，仅应该在此文件不存在时使用；<br>​                        -m：md5格式加密<br>​                        -s: sha格式加密<br>​                        -D：删除指定用户<br>​<br>​            另外：基于组账号进行认证；<br>​                (1) 定义安全域<br>​                    &lt;Directory “”&gt;<br>​                        Options None<br>​                        AllowOverride None<br>​                        AuthType Basic<br>​                        AuthName “String“<br>​                        AuthUserFile  “/PATH/TO/HTTPD_USER_PASSWD_FILE”<br>​                        AuthGroupFile “/PATH/TO/HTTPD_GROUP_FILE”<br>​                        Require  group  grpname1  grpname2 …<br>​                    </Directory><br>​<br>​                (2) 创建用户账号和组账号文件；<br>​<br>​                    组文件：每一行定义一个组<br>​                        GRP_NAME: username1  username2  …<br>​<br>​    12、虚拟主机<br>​<br>​        站点标识： socket<br>​            IP相同，但端口不同；<br>​            IP不同，但端口均为默认端口；<br>​            FQDN不同；<br>​                请求报文中首部<br>​                Host: <a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a><br>​<br>​        有三种实现方案：<br>​            基于ip：<br>​                为每个虚拟主机准备至少一个ip地址；<br>​            基于port：<br>​                为每个虚拟主机使用至少一个独立的port；<br>​            基于FQDN:<br>​                为每个虚拟主机使用至少一个FQDN；<br>​<br>​        注意：一般虚拟机不要与中心主机混用；因此，要使用虚拟主机，得先禁用’main’主机；<br>​            禁用方法：注释中心主机的DocumentRoot指令即可；2.4不需要。<br>​<br>​        虚拟主机的配置方法：<br>​            <VirtualHost  IP:PORT><br>​                ServerName FQDN<br>​                DocumentRoot  “”<br>​            </VirtualHost><br>​<br>​            其它可用指令：<br>​                ServerAlias：虚拟主机的别名；可多次使用；<br>​                ErrorLog：<br>​                CustomLog：<br>​                &lt;Directory “”&gt;<br>​                …<br>​                </Directory><br>​                Alias<br>​                …<br>​<br>​            基于IP的虚拟主机示例：<br>​            &lt;VirtualHost 172.16.100.6:80&gt;<br>​                ServerName <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br>​                DocumentRoot “/www/a.com/htdocs”<br>​            </VirtualHost></p>
<p>​            &lt;VirtualHost 172.16.100.7:80&gt;<br>​                ServerName <a href="http://www.b.net" target="_blank" rel="noopener">www.b.net</a><br>​                DocumentRoot “/www/b.net/htdocs”<br>​            </VirtualHost></p>
<p>​            &lt;VirtualHost 172.16.100.8:80&gt;<br>​                ServerName <a href="http://www.c.org" target="_blank" rel="noopener">www.c.org</a><br>​                DocumentRoot “/www/c.org/htdocs”<br>​            </VirtualHost><br>​<br>​            基于端口的虚拟主机：<br>​            &lt;VirtualHost 172.16.100.6:80&gt;<br>​                ServerName <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br>​                DocumentRoot “/www/a.com/htdocs”<br>​            </VirtualHost></p>
<p>​            &lt;VirtualHost 172.16.100.6:808&gt;<br>​                ServerName <a href="http://www.b.net" target="_blank" rel="noopener">www.b.net</a><br>​                DocumentRoot “/www/b.net/htdocs”<br>​            </VirtualHost></p>
<p>​            &lt;VirtualHost 172.16.100.6:8080&gt;<br>​                ServerName <a href="http://www.c.org" target="_blank" rel="noopener">www.c.org</a><br>​                DocumentRoot “/www/c.org/htdocs”<br>​            </VirtualHost><br>​<br>​            基于FQDN的虚拟主机：<br>​            NameVirtualHost 172.16.100.6:80</p>
<p>​            &lt;VirtualHost 172.16.100.6:80&gt;<br>​                ServerName <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a><br>​                DocumentRoot “/www/a.com/htdocs”<br>​            </VirtualHost></p>
<p>​            &lt;VirtualHost 172.16.100.6:80&gt;<br>​                ServerName <a href="http://www.b.net" target="_blank" rel="noopener">www.b.net</a><br>​                DocumentRoot “/www/b.net/htdocs”<br>​            </VirtualHost></p>
<p>​            &lt;VirtualHost 172.16.100.6:80&gt;<br>​                ServerName <a href="http://www.c.org" target="_blank" rel="noopener">www.c.org</a><br>​                DocumentRoot “/www/c.org/htdocs”<br>​            </VirtualHost><br>​<br>​    13、status页面<br>​        LoadModule  status_module  modules/mod_status.so<br>​<br>​        &lt;Location /server-status&gt;<br>​            SetHandler server-status<br>​            Order allow,deny<br>​            Allow from 172.16<br>​        </Location></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>httpd</tag>
        <tag>虚拟主机</tag>
        <tag>web服务</tag>
      </tags>
  </entry>
  <entry>
    <title>03-vsftpd服务</title>
    <url>/03-vsftpd%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="vsftpd服务"><a href="#vsftpd服务" class="headerlink" title="vsftpd服务"></a>vsftpd服务</h2><ul>
<li>由vsftpd包提供</li>
<li>不再由xinetd管理</li>
<li>用户认证配置文件：/etc/pam.d/vsftpd</li>
<li>服务脚本： /usr/lib/systemd/system/vsftpd.service</li>
</ul>
<p>​                            /etc/rc.d/init.d/vsftpd </p>
<ul>
<li><p>主程序：/usr/sbin/vsftpd</p>
</li>
<li><p>根目录:/var/ftp</p>
</li>
<li><p>Systemd Unit File:   /usr/lib/systemd/system/vsftpd.service</p>
</li>
<li><p>主配置文件：/etc/vsftpd/vsftpd.conf</p>
</li>
</ul>
<p>​                             man 5 vsftpd.conf </p>
<p>​                             格式：option=value  </p>
<p>​                             注意：= 前后不要有空格 ,option前面最好没空格字符</p>
<ul>
<li>匿名用户（映射为系统用户ftp ）共享文件位置：/var/ftp</li>
<li>系统用户共享文件位置：用户家目录</li>
<li>虚拟用户共享文件位置：为其映射的系统用户的家目录</li>
</ul>
<h2 id="vsftpd服务配置"><a href="#vsftpd服务配置" class="headerlink" title="vsftpd服务配置"></a>vsftpd服务配置</h2><ul>
<li><p>命令端口    listen_port=21 </p>
</li>
<li><p>主动模式端口    </p>
<p>​                    connect_from_port_20=YES         主动模式端口为20 </p>
<p>​                    ftp_data_port=20 （默认）          指定主动模式的端口</p>
</li>
<li><p>被动模式端口范围</p>
</li>
</ul>
<p>​                linux                                                  客户端默认使用被动模式</p>
<p>​                windows                                              客户端默认使用主动模式<br>​                pasv_min_port=6000                         0为随机分配</p>
<p>​                pasv_max_port=6010 </p>
<ul>
<li>使用当地时间</li>
</ul>
<p>​                use_localtime=YES                             使用当地时间（默认为NO，使用GMT）   </p>
<ul>
<li><p>匿名用户</p>
<p>anonymous_enable=YES                                  支持匿名用户 </p>
<p>no_anon_password=YES(默认NO)                    匿名用户略过口令检查</p>
<p>anon_upload_enable=YES                                匿名上传，注意:文件系统权限 </p>
<p>anon_mkdir_write_enable=YES                         匿名建目录    匿名建目录<br>anon_world_readable_only (默认YES)                只能下载全部读的文件 </p>
<p>anon_umask=0333                                            指定匿名上传文件的umask，默认077 </p>
<p>anon_other_write_enable=YES                          可删除和修改上传的文件 </p>
</li>
<li><p>指定上传文件的默认的所有者和权限<br>chown_uploads=YES(默认NO)<br>chown_username=wang<br>chown_upload_mode=0644 </p>
</li>
<li><p>Linux系统用户</p>
<p>local_enable=YES                      是否允许linux用户登录 </p>
<p>write_enable=YES                     允许linux用户上传文件 </p>
<p>local_umask=022                         指定系统用户上传文件的默认权限</p>
<p>guest_enable=YES                       所有系统用户都映射成guest用户 </p>
<p>guest_username=ftp                     配合上面选项才生效，指定guest用户 </p>
<p>local_root=/ftproot                       guest用户登录所在目录 </p>
</li>
<li><p>禁锢所有系统用户在家目录中</p>
<p>chroot_local_user=YES（默认NO，不禁锢）禁锢系统用户 </p>
</li>
<li><p>禁锢或不禁锢特定的系统用户在家目录中，与上面设置功能相反</p>
<p>chroot_list_enable=YES<br>chroot_list_file=/etc/vsftpd/chroot_list<br>当chroot_local_user=YES时，则chroot_list中用户不禁锢 </p>
<p>当chroot_local_user=NO时，则chroot_list中用户禁锢 </p>
</li>
<li><p>wu-ftp日志：默认启用</p>
<p>xferlog_enable=YES （默认）            启用记录上传下载日志 </p>
<p>xferlog_std_format=YES （默认）         使用wu-ftp日志格式 </p>
<p>xferlog_file=/var/log/xferlog （默认）    可自动生成 </p>
</li>
<li><p>vsftpd日志：默认不启用</p>
<p>dual_log_enable=YES                                   使用vsftpd日志格式，默认不启用 </p>
<p>vsftpd_log_file=/var/log/vsftpd.log（默认）      可自动生成 </p>
</li>
<li><p>登录提示信息</p>
<p>ftpd_banner=“welcome to mage ftp server” </p>
<p>banner_file=/etc/vsftpd/ftpbanner.txt   </p>
</li>
<li><p>目录访问提示信息</p>
<p>dirmessage_enable=YES (默认) </p>
<p>message_file=.message(默认)              信息存放在指定目录下.message </p>
</li>
<li><p>使用pam(Pluggable Authentication Modules)完成用户认证</p>
<p>pam_service_name=vsftpd </p>
<p>​    pam配置文件:/etc/pam.d/vsftpd </p>
<p>​    /etc/vsftpd/ftpusers             默认文件中用户拒绝登录 </p>
</li>
<li><p>是否启用控制用户登录vsftpd服务的列表文件</p>
<p>userlist_enable=YES                      默认有此设置 </p>
<p>userlist_deny=YES(默认值)             黑名单,不提示口令，NO为白名单</p>
<p>userlist_file=/etc/vsftpd/users_list      此为默认值</p>
</li>
<li><p>vsftpd服务指定用户身份运行</p>
<p>nopriv_user=nobody (默认值) </p>
</li>
<li><p>连接数限制</p>
<p>max_clients=0            最大并发连接数 </p>
<p>max_per_ip=0            每个IP同时发起的最大连接数 </p>
</li>
<li><p>传输速率：字节/秒</p>
<p>anon_max_rate=0         匿名用户的最大传输速率</p>
<p>local_max_rate=0         本地用户的最大传输速率</p>
</li>
<li><p>连接时间：秒为单位</p>
<p>connect_timeout=60                主动模式数据连接超时时长 </p>
<p>accept_timeout=60                   被动模式数据连接超时时长 </p>
<p>data_connection_timeout=300  数据连接无数据输超时时长 </p>
<p>idle_session_timeout=60         无命令操作超时时长 </p>
</li>
<li><p>优先以文本方式传输</p>
<p>ascii_upload_enable=YES </p>
<p>ascii_download_enable=YES </p>
</li>
</ul>
<h2 id="实现基于SSL的FTPS"><a href="#实现基于SSL的FTPS" class="headerlink" title="实现基于SSL的FTPS"></a>实现基于SSL的FTPS</h2>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>03-文本处理练习题</title>
    <url>/03-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="grep练习题"><a href="#grep练习题" class="headerlink" title="grep练习题"></a>grep练习题</h3><p>1、显示/proc/meminfo文件中以大小s开头的行(要求：使用两 种方法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 第一种：<br>grep &quot;^[Ss] &#x2F;proc&#x2F;meminfo<br># 第二种：<br>grep -i &quot;^s&quot; &#x2F;proc&#x2F;meminfo<br># 第三种：<br>grep -i &quot;^\(S\|s\)&quot; &#x2F;proc&#x2F;meminfo<br># 第四种：<br>grep -e &quot;^s&quot; -e &quot;^S&quot; &#x2F;proc&#x2F;meminfo<br></code></pre></td></tr></table></figure>

<p>2、显示/etc/passwd文件中不以/bin/bash结尾的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep  -v &quot;&#x2F;bin&#x2F;bash$&quot; &#x2F;etc&#x2F;passwd<br></code></pre></td></tr></table></figure>

<p>3、显示用户rpc默认的shell程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep &quot;^rpc\&gt;&quot; &#x2F;etc&#x2F;passwd| cut -d : -f1,7<br></code></pre></td></tr></table></figure>

<p>4、找出/etc/passwd中的两位或三位数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep -o &quot;\&lt;[[:digit:]]\&#123;2,3\&#125;\&gt;&quot; &#x2F;etc&#x2F;passwd<br></code></pre></td></tr></table></figure>

<p>5、显示CentOS7的/etc/grub2.cfg文件中，至少以一个空白字符开头的且后面存非空白字符的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">grep &quot;^[[:space:]]\+[^[:space:]]\+&quot; &#x2F;etc&#x2F;grub2.cfg<br></code></pre></td></tr></table></figure>

<p>6、找出“netstat -tan”命令的结果中以‘LISTEN’后跟任意多个空白字符结尾的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">netstat -tan | grep &quot;\&lt;LISTEN\&gt;[[:space:]]*&quot;<br></code></pre></td></tr></table></figure>

<p>7、显示CentOS7上所有系统用户的用户名和UID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 第一种方法：<br>cat &#x2F;etc&#x2F;passwd |cut -d: -f1,3 | grep &quot;:[[:digit:]]\&#123;,3\&#125;$&quot;<br># 第二种方法：<br>cat &#x2F;etc&#x2F;passwd |cut -d: -f1,3 | grep &quot;\&lt;[[:digit:]]\&#123;,3\&#125;\&gt;$&quot;<br></code></pre></td></tr></table></figure>

<p>8、添加用户bash、testbash、basher、sh、nologin(其shell 为/sbin/nologin),找出/etc/passwd用户名同shell名的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo bash testbash basher sh nologin | xargs -n1 useradd<br>chsh -s &#x2F;sbin&#x2F;nologin nologin<br><br># grep：<br>cat &#x2F;etc&#x2F;passwd | grep  &quot;\(^.*\&gt;\).*&#x2F;\1$&quot;<br># egrep 扩展：<br>cat &#x2F;etc&#x2F;passwd | egrep  &quot;(^.*\&gt;).*&#x2F;\1$&quot;<br></code></pre></td></tr></table></figure>

<p>9、利用df和grep，取出磁盘各分区利用率，并从大到小排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">第一种方法：<br>df |grep &quot;&#x2F;dev&#x2F;sd&quot;|tr -s &quot; &quot;|cut -d&quot; &quot; -f1,5|sort -nr -k2<br>第二种方法：<br>df |grep &quot;&#x2F;dev&#x2F;sd&quot;|egrep -o &quot;[[:digit:]]+%&quot;|sort -nr<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="egrep练习题"><a href="#egrep练习题" class="headerlink" title="egrep练习题"></a>egrep练习题</h3><p>1、显示三个用户root、mage、wang的UID和默认shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">egrep &quot;^(root|mage|wang)\&gt;&quot; &#x2F;etc&#x2F;passwd | cut -d: -f1,3,7<br></code></pre></td></tr></table></figure>

<p>2、找出/etc/rc.d/init.d/functions文件中行首为某单词(包括下划线)后面跟一个小括号的行<br>用<code>[:alnum:]</code>或者单词边界<code>\&gt;</code>、<code>\b</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">egrep -o &quot;^[[:alnum:]_]+\(\)&quot; &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions<br>egrep -o &quot;^.*\&gt;\(\)&quot; &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions<br>egrep -o &quot;^.*\b\(\)&quot; &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions<br></code></pre></td></tr></table></figure>



<p>3、使用egrep取出/etc/rc.d/init.d/functions中其基名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 文件，或者目录后面不带&#x2F;：<br>echo &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions |egrep -o &quot;[[:alnum:]]+$&quot;<br>echo &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions |egrep -o &quot;[^&#x2F;]+$&quot;<br># 文件或目录，后面带不带&#x2F;都行，通用写法：<br>echo &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions&#x2F; |egrep -o &quot;[[:alnum:]]+&#x2F;?$&quot;<br>echo &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions&#x2F; |egrep -o &quot;[^&#x2F;]+&#x2F;?$&quot;<br></code></pre></td></tr></table></figure>

<p>4、使用egrep取出上面路径的目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br></code></pre></td></tr></table></figure>

<p>5、统计last命令中以root登录的每个主机IP地址登录次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">last |tr -s &quot; &quot; |cut -d&quot; &quot; -f1,3|egrep &quot;root.*[[:digit:]].+&quot;|sort|uniq -c<br></code></pre></td></tr></table></figure>

<p>6、利用扩展正则表达式分别表示0-9、10-99、100-199、 200-249、250-255</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo &#123;0..1000&#125; |egrep -o &quot;\&lt;[0-9]\&gt;&quot;<br>echo &#123;0..1000&#125; |egrep -o &quot;\&lt;[1-9][0-9]\&gt;&quot;<br>echo &#123;0..1000&#125; |egrep -o &quot;\&lt;1[0-9]&#123;2&#125;\&gt;&quot;<br>echo &#123;0..1000&#125; |egrep -o &quot;\&lt;2[0-4][0-9]\&gt;&quot;<br>echo &#123;0..1000&#125; |egrep -o &quot;\&lt;25[0-5]\&gt;&quot;<br></code></pre></td></tr></table></figure>

<p>7、显示ifconfig命令结果中所有IPv4地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ifconfig | egrep -o &quot;\&lt;(([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])&quot;<br></code></pre></td></tr></table></figure>

<p>8、将此字符串：welcome to magedu linux 中的每个字符 去重并排序，重复次数多的排到前面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo welcom to magedu linux |grep -o . |sort|uniq -c|sort -nr<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
        <tag>练习题</tag>
      </tags>
  </entry>
  <entry>
    <title>03-查看命令的帮助</title>
    <url>/03-%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a><code>whatis</code></h2><p>如果不知道某命令的用法意义，并列出在哪个手册，可以使用<strong>whatis</strong>查询。比如下面搜索date，会列出条目和简介里带date字眼的所有命令字段。前面是命令，后面是简介。命令后面括号里的数字指的就是man手册的序号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-variable">$whatis</span> date<br>date (1)             - <span class="hljs-built_in">print</span> or <span class="hljs-built_in">set</span> the system date and time<br></code></pre></td></tr></table></figure>

<p>执行的<code>whatis</code> 命令是查询数据库提供的，并不一定是最新的，可手动更新数据库，第一次运行可能会有点慢：</p>
<ul>
<li>CentOS 6 上：<code>makewhatis</code></li>
<li>CentOS 7 上：<code>mandb</code></li>
</ul>
<hr>
<h2 id="help-amp-help"><a href="#help-amp-help" class="headerlink" title="help &amp; --help"></a><code>help</code> &amp; <code>--help</code></h2><p>大部分命令都有<code>--help</code>选项，也是一个简要的帮助文档。</p>
<hr>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a><code>man</code></h2><h3 id="man后的格式和内容"><a href="#man后的格式和内容" class="headerlink" title="man后的格式和内容"></a><code>man</code>后的格式和内容</h3><p>详细的帮助文档：<code>man COMMAND</code></p>
<ul>
<li><p><code>NAME</code> 功能能行说明</p>
</li>
<li><p><code>SYNOPSIS</code> 语法概要</p>
<ul>
<li><p><code>[]</code>表示可选选项</p>
<ul>
<li><p><code>&lt;&gt;</code>表示必需提供的</p>
<ul>
<li><code>|</code>多选一<ul>
<li><code>{}</code>分组的</li>
</ul>
</li>
<li><code>...</code>前面的内容可以出现多次</li>
<li><code>DESCRIPTION</code> 描述</li>
<li><code>OPTIONS</code> 选项</li>
<li><code>EXAMPLES</code> 使用示例</li>
<li><code>AUTHOR</code> 作者</li>
<li><code>REPORTING BUGS</code> 报告bug方式</li>
<li><code>COPYRIGHT</code> 版权</li>
<li><code>SEE ALSO</code> 参考其他</li>
</ul>
<p><strong>man的序号 1-9</strong></p>
<ol>
<li>用户命令</li>
<li>系统调用</li>
<li>库调用</li>
<li>设备文件</li>
<li>文件格式</li>
<li>游戏</li>
<li>杂项</li>
<li>管理命令</li>
</ol>
<p><code>whatis COMMAND</code>：可以查看命令有哪几个manual</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# whatis tar<br>tar (1)              - manual page for tar 1.26<br>tar (5)              - format of tape archive files<br>[root@centos7 ~]# whatis ifcfg<br>ifcfg (8)            - simplistic script which replaces ifconfig IP management<br></code></pre></td></tr></table></figure>

<p>默认查的是序号最小的那个man手册，如要要查其它的，可以用<code>man 序号 COMMAND</code>来查看命令,例如<code>man 5 tar</code></p>
<h3 id="man手册操作方法"><a href="#man手册操作方法" class="headerlink" title="man手册操作方法"></a>man手册操作方法</h3><h4 id="翻屏操作："><a href="#翻屏操作：" class="headerlink" title="翻屏操作："></a>翻屏操作：</h4><p>很多特别像vim的命令</p>
<table>
<thead>
<tr>
<th align="left">键盘按键</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>f</code> 或 <code>空格键</code></td>
<td align="left">向下滚动一屏</td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">向上滚动一屏</td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left">向下滚动半屏</td>
</tr>
<tr>
<td align="left"><code>u</code></td>
<td align="left">向上滚动半屏</td>
</tr>
<tr>
<td align="left"><code>j</code></td>
<td align="left">向上移动一行</td>
</tr>
<tr>
<td align="left"><code>k</code>或<code>回车</code></td>
<td align="left">向下移动一行</td>
</tr>
<tr>
<td align="left"><code>gg</code></td>
<td align="left">跳转至第一行</td>
</tr>
<tr>
<td align="left"><code>5g</code></td>
<td align="left">跳转到第5行</td>
</tr>
<tr>
<td align="left"><code>G</code></td>
<td align="left">跳转到最后一行</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left">退出</td>
</tr>
</tbody></table>
<h4 id="文本搜索"><a href="#文本搜索" class="headerlink" title="文本搜索"></a>文本搜索</h4><table>
<thead>
<tr>
<th align="left">键盘按键</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/keyword</td>
<td align="left">向下查找，不区分大小写</td>
</tr>
<tr>
<td align="left">?keyword</td>
<td align="left">向上查找，不区分大小写</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">查找下一个，与查找方向相同</td>
</tr>
<tr>
<td align="left">N</td>
<td align="left">查找上一个，与查找方向相反</td>
</tr>
</tbody></table>
<p>man选项：<br><code>man -M /path/to/somedir</code>： 某些程序man目录不在标准的<code>/usr/share/man</code>到指定目录下查找命令手册并打开它。</p>
<hr>
<h2 id="程序自带帮助文档"><a href="#程序自带帮助文档" class="headerlink" title="程序自带帮助文档"></a>程序自带帮助文档</h2><p>很多会放在<code>/usr/share/doc/APP-VERSION</code>下</p>
<ul>
<li>README：程序的相关信息</li>
<li>INSTALL：安装帮助</li>
<li>CHANGES：版本改动信息</li>
</ul>
<h2 id="主流发行版官方文档"><a href="#主流发行版官方文档" class="headerlink" title="主流发行版官方文档"></a>主流发行版官方文档</h2><p><a href="http://www.redhat.com/doc" target="_blank" rel="noopener">http://www.redhat.com/doc</a><br>等</p>
<hr>
<h2 id="程序的官方文档"><a href="#程序的官方文档" class="headerlink" title="程序的官方文档"></a>程序的官方文档</h2><p>官方站点上会有docs/documents/documentation等字眼</p>
<hr>
<h2 id="善用搜索引擎"><a href="#善用搜索引擎" class="headerlink" title="善用搜索引擎"></a>善用搜索引擎</h2><p>google<br>搜pdf文档这样： <code>centos filetype:pdf</code></p>
<p>搜站点里资源都这样：<code>centos site:centos.org</code></p>
<hr>
<h2 id="书籍出版社"><a href="#书籍出版社" class="headerlink" title="书籍出版社"></a>书籍出版社</h2><ul>
<li>O’REILLY</li>
<li>Wrox</li>
<li>人民邮电出版社</li>
<li>机械工业出版社</li>
<li>电子工业出版社</li>
<li>清华大学出版社</li>
<li>图灵社区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>03-用户和用户组的管理命令</title>
    <url>/03-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用到的命令主要有：</p>
<p><strong>组命令</strong>：<code>groupadd</code>、<code>groupdel</code>、<code>groupmod</code>、<code>gpasswd</code>、<code>groupmems</code>、 <code>newgrp</code></p>
<p><strong>用户命令</strong>：<code>useradd</code>、<code>userdel</code>、<code>usermod</code>、<code>passwd</code></p>
<p><strong>其他相关命令</strong>：</p>
<ul>
<li><code>getent</code>：<code>getent passwd USERNAME</code>、<code>getent shadow GROUPNAME</code></li>
<li><code>chage</code></li>
<li><code>chsh</code></li>
<li><code>id</code></li>
<li><code>su</code></li>
</ul>
<hr>
<h3 id="用户组命令："><a href="#用户组命令：" class="headerlink" title="用户组命令："></a>用户组命令：</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p><code>groupadd GROUP_NAME</code>:创建新组</p>
<p>可选参数：</p>
<ul>
<li><code>-g GID</code>：手动指定GID，默认是上一个组的GID+1</li>
<li><code>-r</code>：创建系统组</li>
</ul>
<h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p><code>groupmod GROUP_NAME</code> 修改组信息</p>
<ul>
<li><code>-g GID</code>：修改GID</li>
<li><code>-n NEW_NAME OLD_NAME</code>：修改组名</li>
</ul>
<h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p><code>groupdel GROUP_NAME</code>：删除组</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">groupadd grp<br>groupadd -g 2000 grp1<br>groupadd -r sysgrp<br>groupadd -r -g 306 sysgrp1<br>groupmod -g 702 sysgrp1<br>groupmod -n newsysgrp1 sysgrp1<br><br>groupdel grp<br></code></pre></td></tr></table></figure>



<h4 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h4><p><code>gpasswd GROUP_NAME</code>：给组加密码，一般默认不加，不加的话，用户就不能用<code>newgrp</code>切换属组（组密码那里是两<code>!!</code>，表示无密码，无密码的组，用户也不能临时切换到这个组。）</p>
<h4 id="groupmems"><a href="#groupmems" class="headerlink" title="groupmems"></a>groupmems</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">用法：groupmems [选项] [动作]<br><br>选项：<br>  -g, --group groupname         更改组 groupname，而不是用户的组(只 root)<br><br>动作：<br>  -a, --add username            将用户 username 添加到组成员中<br>  -d, --delete username         从组的成员中删除用户 username<br>  -p, --purge                   从组中移除所有成员<br>  -l, --list                    列出组中的所有成员<br></code></pre></td></tr></table></figure>

<p>比如下面，就是列出<code>admins</code>组里的所有成员，然后删除其中的一个成员<code>natasha</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian blog]# groupmems -g admins -l<br>natasha  harry <br>[root@ashjian blog]# groupmems -g admins -l<br>harry<br></code></pre></td></tr></table></figure>

<h4 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">newgrp GROUPNAME<br></code></pre></td></tr></table></figure>

<p>临时切换主组，如果切换不属于的组，要输入组密码。如果不属于的组而且没有设置组密码，则无法切换。</p>
<hr>
<h3 id="用户命令"><a href="#用户命令" class="headerlink" title="用户命令"></a>用户命令</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p><code>useradd</code> ：创建新用户或者更新默认新用户信息</p>
<ul>
<li><code>-u</code>：指定UID</li>
<li><code>-g</code>：指定基本组GID，组名必须存在才行，不能用来新建GID。</li>
<li><code>-G GROUP1[,GROUP2,...[GROUPN]]</code>：指定GID，指明用户的附加组，多个组之间用逗号分隔。</li>
<li><code>-c COMMENT</code>：注释信息</li>
<li><code>-d HOME_DIR</code>：指定家目录（本质是通过复制/<code>etc/skel</code>目录并重命名实现的），如果目录路径本身就存在，则不会为用户复制<code>/etc/skel</code>下的内容。</li>
<li><code>-s SHELL</code>： 指定用户的默认shell，可用于所有shell列表存在的shell(shell列表：<code>/etc/shells</code>)</li>
<li><code>-r</code> ：创建系统用户</li>
<li><code>-m</code> : 创建家目录，用于系统用户 </li>
<li><code>-M</code> : 不创建家目录，用于非系统用户 </li>
<li><code>-N</code> : 不创建私用组做主组，使用users组做主组 </li>
<li><code>-o</code> : 合-u 选项，不检查UID的唯一性</li>
<li><code>-D</code>：修改创建用户时候的默认选项（<code>man useradd</code>可以看一下详情,，其实更改的就是<code>/etc/default/useradd</code>）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">useradd docker<br><br>useradd -u 3000 openstack<br><br>useradd -u 3001 -g 3001 openshift<br><br>useradd -g cloudgroup cloudstack<br><br>useradd -G grp,grp1 archlinux<br><br>useradd -c &quot;Hacker Linux&quot; kalilinux<br><br>useradd -d &#x2F;opt&#x2F;sybase sybase<br><br>mkdir &#x2F;tmp&#x2F;test1<br>useradd -d &#x2F;tmp&#x2F;test1 test1<br><br>useradd -s &#x2F;bin&#x2F;csh test2<br><br>useradd -s &#x2F;sbin&#x2F;nologin test3<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：要查看useradd的默认规则，可以查看<code>/etc/default/useradd</code>文件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 default]# cat &#x2F;etc&#x2F;default&#x2F;useradd<br># useradd defaults file<br>GROUP&#x3D;100<br>HOME&#x3D;&#x2F;home<br>INACTIVE&#x3D;-1<br>EXPIRE&#x3D;<br>SHELL&#x3D;&#x2F;bin&#x2F;bash<br>SKEL&#x3D;&#x2F;etc&#x2F;skel<br>CREATE_MAIL_SPOOL&#x3D;yes<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们可以看到有个<code>SKEL</code>，<code>skel</code>里存放的是环境变量文件，当创建新用户时候，会复制一份到用户家目录里面。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 default]# cd &#x2F;etc&#x2F;skel&#x2F;<br>[root@ashjian blog]# ls -a<br>.  ..  .bash_logout  .bash_profile  .bashrc  .mozilla<br></code></pre></td></tr></table></figure>

<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p><code>usermod</code>：修改用户属性</p>
<p><code>-u UID</code>：修改用户的UID<br><code>-g</code>：修改用户所属的基本组<br><code>-G</code> ：修改用户的附加组，原来的附加组会被覆盖掉<br><code>-a</code>：append，和<code>-G</code>结合使用，表示新添加的组，兵不会覆盖掉原来的组<br><code>-c COMMENT</code>：修改注释信息<br><code>-d</code>：修改用户的家目录，用户原有的文件不会被转移到新位置。<br><code>-m</code>：move-home，更改用户主目录，和-d配合使用，会移动原来家目录的文件。<br><code>-l</code>：修改用户名</p>
<ul>
<li><code>-s SHELL</code>： 修改用户的默认shell，可用于所有shell列表存在的shell(shell列表：<code>/etc/shells</code>)</li>
<li><code>-L</code>：Lock，锁定用户密码（在原来的密码字符串之前加一个<code>!</code>）</li>
<li><code>-U</code>：unlock，解锁用户的密码（删掉<code>!</code>）</li>
</ul>
<h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p><code>userdel</code>：删除用户<br><code>-r</code>：删除用户并删除其<strong>家目录</strong>和<strong>mail</strong> spool</p>
<h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p><code>passwd</code>修改用户自己的密码<br><code>passwd USERNAME</code>修改其他用户的密码（root有此权限）</p>
<ul>
<li><code>-- stdin</code> 参数<br><code>echo ‘test2&#39; | passwd --stdin test2</code><br>记住echo后面的字符串要用弱引用，强引用的话如果密码串里有特殊字符，就会不是原始密码了。</li>
</ul>
<hr>
<h2 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h2><h4 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h4><p><code>chage</code>：change age 更改用户密码过期时间</p>
<p><code>chage USERNAME</code>：<strong>不跟参数</strong>，会进入一个交互式的模式来修改各个时间，如下面：设置最短修改密码时间为<code>0</code>；最长密码时间为<code>92</code>天过期，上次更改密码时间保持默认那天（<code>20170526</code>），快过期的开始警告设置的在快过期前<code>7</code>天开始，密码过期后，<code>7</code>天内要修改密码，否则变为不活动（Inactive，即锁住），最后一条是设置账号过期时间，设置为默认不过期（<code>-1</code>）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian skel]# chage gentoo<br>Changing the aging information for gentoo<br>Enter the new value, or press ENTER for the default<br><br>	Minimum Password Age [0]: 0<br>	Maximum Password Age [99999]: 92<br>	Last Password Change (YYYY-MM-DD) [2017-05-26]: <br>	Password Expiration Warning [7]: 7<br>	Password Inactive [-1]: 7<br>	Account Expiration Date (YYYY-MM-DD) [-1]:<br></code></pre></td></tr></table></figure>

<p><strong>带参数</strong>，下面是参数设置，和上面类似，就是把交互式变成了参数选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">chage [option] USERNAME<br></code></pre></td></tr></table></figure>

<p><code>-d</code> LAST_DAY <code>-d 0</code>:第一次登陆，强制让你该口令。</p>
<p><code>-E</code> –expiredate EXPIRE_DATE</p>
<p><code>-I</code> –inactive INACTIVE</p>
<p><code>-m</code> –mindays MIN_DAYS</p>
<p><code>-M</code> –maxdays MAX_DAYS</p>
<p><code>-W</code> –warndays WARN_DAYS</p>
<p><code>–l</code> 显示密码策略</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">chage -d 0 tom #下一次登录强制重设密码<br><br>chage -m 0 –M 42 –W 14 –I 7 tom<br><br>chage -E 2016-09-10 tom<br></code></pre></td></tr></table></figure>

<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>id [USERNAME]</code>：显示用户的<code>uid</code>和<code>gid</code>，<code>USERNAME</code>省略的话表示只显示当前用户的id信息。</p>
<ul>
<li><code>-u</code>显示用户id</li>
<li><code>-g</code>显示基本组id</li>
<li><code>-G</code>显示所有组id</li>
<li><code>-n</code>显示名字而不是id</li>
</ul>
<h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p><code>su</code>命令：switch user，切换用户</p>
<ul>
<li>登录式切换：会通过读取目标用户的配置文件来重新初始化<ul>
<li><code>su - USERNAME</code><br>*<code>su -l USERNAME</code>l就表示login</li>
</ul>
</li>
<li>非登陆式切换：不会读取目标用户的配置文件来进行初始化<ul>
<li><code>su USERNAME</code></li>
</ul>
</li>
</ul>
<p>Note：管理员可无密码切换到其他任意用户。</p>
<p>参数：<br><code>-c &#39;COMMAND&#39;</code>：仅以目标用户登录，后执行后面的命令，然后就退出</p>
<p>示例：<code>su -test -c &#39;whoami&#39;</code></p>
<h4 id="getent"><a href="#getent" class="headerlink" title="getent"></a>getent</h4><p><code>get entries from Name Service Switch libraries</code><br>从命名服务切换库获得条目</p>
<p><code>getent passwd [USERNAME]</code>：不输入USERNAME默认是全部用户，如果输入了，就是指定的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian skel]# getent passwd gentoo<br>gentoo:x:1001:1001:Gentoo Distribution:&#x2F;home&#x2F;gentoo:&#x2F;bin&#x2F;csh<br></code></pre></td></tr></table></figure>

<p><code>getent shadow [GROUPNAME]</code>：不输入GROUPNAME默认是全部用户组信息，如果输入了，就是指定的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# getent shadow gentoo<br>gentoo:!!:17312:0:92:7:7::<br></code></pre></td></tr></table></figure>

<h4 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h4><p>查看用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# finger root<br>Login: root           			Name: root<br>Directory: &#x2F;root                    	Shell: &#x2F;bin&#x2F;bash<br>On since Sun May 28 16:17 (CST) on pts&#x2F;0 from 172.17.251.64<br>   4 seconds idle<br>On since Wed May 24 20:40 (CST) on :0 from :0 (messages off)<br>On since Wed May 24 20:40 (CST) on pts&#x2F;2 from :0<br>   3 days 19 hours idle<br>No mail.<br>No Plan.<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>用户和组</tag>
      </tags>
  </entry>
  <entry>
    <title>03-编译安装</title>
    <url>/03-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编译安装，是指从源码进行编译，然后根据安装规则把编译好的文件，分发到预先设置好的目录，目录可以自定义。</p>
<p>我们以在 CentOS 7 上安装<code>apache2.4</code>为例：</p>
<ol>
<li>在<a href="http://httpd.apache.org/download.cgi#apache24" target="_blank" rel="noopener">apache官网</a>下载源码,解压。</li>
<li><code>yum groups install Development Tools</code>安装开发包。</li>
<li>cd <code>httpd-2.4</code></li>
<li>查看一下 README INSTALL</li>
<li><code>./configure --prefix=/app/appche24</code>按照配置生成配置文件。</li>
<li>如果报错，查看下报错提示缺什么包，把缺失的包装上，一般新版本的选<code>xxx-devel</code>包就可以支持。</li>
<li><code>make</code>编译</li>
<li><code>make install</code>复制到规定的目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir &#x2F;app&#x2F;apache24<br>tar -xvf httpd-2.4.25.tar.bz2<br>cd httpd-2.4.25<br>yum groups install &quot;Development Tools&quot;<br>.&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;apache24 --sysconfdir&#x3D;&#x2F;etc&#x2F;apache24 --enable-rewrite<br>yum install apr-devel<br>.&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;apache24 --sysconfdir&#x3D;&#x2F;etc&#x2F;apache24 --enable-rewrite<br>yum install apr-util-devel<br>.&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;apache24 --sysconfdir&#x3D;&#x2F;etc&#x2F;apache24 --enable-rewrite<br>yum install pcre-devel<br>.&#x2F;configure --prefix&#x3D;&#x2F;app&#x2F;apache24 --sysconfdir&#x3D;&#x2F;etc&#x2F;apache24 --enable-rewrite<br>make<br>make install<br></code></pre></td></tr></table></figure>

<p>把bin目录加到PATH里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;profile.d&#x2F;apache24.sh<br>PATH&#x3D;$PATH:&#x2F;app&#x2F;apache24&#x2F;bin<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>程序包管理</tag>
        <tag>编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title>03-计划任务at、cron</title>
    <url>/03-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1at%E3%80%81cron/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14993424423759.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002738.png" alt="img"></a></p>
<ul>
<li><code>at</code> 未来的某时间点执行一次任务</li>
<li><code>batch</code> 系统自行选择空闲时间去执行此处指定（用的比较少）</li>
<li><code>cron</code> 周期性运行某任务</li>
</ul>
<h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><p>系统中的服务名叫<code>atd</code></p>
<p><strong><code>at [option] TIME</code></strong></p>
<p><strong>[option]</strong></p>
<p><code>at -l</code> 显示计划任务<br><code>at -c NO</code>: 按编号（NO）查看具体作业任务<br><code>at -d NO</code>按编号（NO）删除计划任务<br><code>-f /path/from/somefile</code>：从指定的文件中读取任务<br><code>-m</code>:当任务被完成之后，将给用户发送邮件，即使没有标准输出</p>
<p><strong>TIME</strong><br>定义出什么时候进行 at 这项任务的时间</p>
<ul>
<li><code>HH:MM [YYYY-mm-dd]</code></li>
<li><code>noon, midnight, teatime（4pm）</code></li>
<li><code>tomorrow</code></li>
<li><code>now+#{minutes,hours,days, OR weeks}</code></li>
<li><code>HH:MM</code>: 在今日的 HH:MM 进行，若该时刻已过，则明天此时执行任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">at 02:00<br></code></pre></td></tr></table></figure>

<ul>
<li><code>HH:MM YYYY-MM-DD</code>: 规定在某年某月的某一天的特殊时刻进行该项任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">at 02:00 2016-09-20<br></code></pre></td></tr></table></figure>

<ul>
<li><code>HH:MM[am|pm] [Month] [Date]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">at 04pm March 17<br>at 17:20 tomorrow<br></code></pre></td></tr></table></figure>

<ul>
<li><code>HH:MM[am|pm] + number [minutes|hours|days|weeks]</code>: 在某个时间点再加几个时间后才进行该项任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">at now + 5 minutes<br>at 02pm + 3 days<br></code></pre></td></tr></table></figure>

<p><strong>查看生成的计划任务文件：</strong><br><code>ls /var/spool/at</code></p>
<p><strong>执行at命令的用户的黑白名单：</strong><br><code>/etc/at.{allow,deny}</code></p>
<ul>
<li><strong>白名单</strong>：<code>/etc/at.allow</code> 默认这个文件不存在，只有该文件中的用户才能执行<code>at</code>命令。<strong>白名单优先级高，有了白名单，黑名单不生效了</strong>（同一个用户又在白名单又在黑名单，只生效白名单，即允许此用户）</li>
<li><strong>黑名单</strong>：<code>/etc/at.deny</code> 默认存在，拒绝该文件中用户执行<code>at</code>命令，而没有在<code>at.deny</code>文件中的使用者则可执行。</li>
<li>如果两个文件都<strong>不存在</strong>，只有 <strong>root</strong> 可以执行<code>at</code>命令</li>
</ul>
<hr>
<h2 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h2><p>安装包叫<code>cronie</code></p>
<p>默认一般安装并启用服务了,服务名叫<code>crond</code>：</p>
<p>可以查看服务状态，如果没启动，start启动一下：<br>CentOS 6: <code>service crond status</code><br>CentOS 7: <code>systemctl status crond</code></p>
<p>计划周期性执行的任务提交给<code>crond</code>，到指定时间会自动运行。</p>
<h3 id="etc-crontab文件"><a href="#etc-crontab文件" class="headerlink" title="/etc/crontab文件"></a><code>/etc/crontab</code>文件</h3><p>系统cron任务：系统维护作业。</p>
<p><a href="http://www.yulongjun.com/images/14987946642783.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002747.jpg" alt="img"></a></p>
<p><code>x</code>：特定值x。给定时间点有效取值范围内的值<br><code>*</code> ：每{分钟，小时，日，月等}。给定时间点上有效取值范围内的所有值<br><code>x,y</code> ：x或y。离散取值。<br><code>x-y</code> ：x到y。连续取值。<br><code>/x</code> ：每过多少{分钟，小时，日，月等}执行。在指定时间范围上，定义步长。</p>
<table>
<thead>
<tr>
<th align="left">简写</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@reboot</td>
<td align="left">Run once after reboot.</td>
</tr>
<tr>
<td align="left">@yearly</td>
<td align="left">0 0 1 1 *</td>
</tr>
<tr>
<td align="left">@annually</td>
<td align="left">0 0 1 1 *</td>
</tr>
<tr>
<td align="left">@monthly</td>
<td align="left">0 0 1</td>
</tr>
<tr>
<td align="left">@weekly</td>
<td align="left">0 0 0</td>
</tr>
<tr>
<td align="left">@daily</td>
<td align="left">0 0 *</td>
</tr>
<tr>
<td align="left">@hourly</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>示例：每3小时echo和wall命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">0 *&#x2F;3 * * * centos &#x2F;bin&#x2F;echo “howdy”;&#x2F;usr&#x2F;bin&#x2F;wall “welcome to Magedu!”<br></code></pre></td></tr></table></figure>

<ul>
<li>用户cron任务：<code>crontab</code>命令</li>
</ul>
<p><strong>日志</strong>：<code>/var/log/cron</code></p>
<h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a><code>crontab</code>命令</h3><p>用户<code>cron</code>：<code>crontab</code>命令定义，每个用户都有专用的<code>cron</code>任务文件：<code>/var/spool/cron/USERNAME</code></p>
<p>命令用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">crontab [-u user] [-l | -r | -e] [-i]<br></code></pre></td></tr></table></figure>

<ul>
<li><code>-l</code>: 列出所有任务</li>
<li><code>-e</code>: 编辑任务</li>
<li><code>-r</code>: 移除所有任务</li>
<li><code>-i</code>：同-r一同使用，以交互式模式移除指定任务</li>
<li><code>-u USERNAME</code>: 仅root可运行<code>-u</code>选项，管理某个用户的cron任务。</li>
</ul>
<h3 id="etc-cron-allow-deny"><a href="#etc-cron-allow-deny" class="headerlink" title="/etc/cron.{allow,deny}"></a><code>/etc/cron.{allow,deny}</code></h3><p>控制计划任务的用户黑白名单。</p>
<p>规则同前面讲到的<code>at.{allow,deny}</code></p>
<blockquote>
<p>Notes: 运行结果的标准输出和错误以邮件通知给相关用户。</p>
<ul>
<li>(1) COMMAND &gt; /dev/null</li>
<li>(2) COMMAND &amp;&gt; /dev/null</li>
</ul>
<p>对于cron任务来讲，%有特殊用途；如果在命令中要使用%， 则需要转义，将%放置于单引号中，则可不用转义</p>
</blockquote>
<hr>
<h2 id="anacron"><a href="#anacron" class="headerlink" title="anacron"></a>anacron</h2><p>个人电脑用的比较多，时间段属于人的作息时间段。</p>
<p>安装包叫<code>cronie-annacron</code><br><a href="http://www.yulongjun.com/images/14988034800270.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827002903.jpg" alt="img"></a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计划任务</tag>
      </tags>
  </entry>
  <entry>
    <title>03-访问控制列表（ACL）</title>
    <url>/03-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%EF%BC%88ACL%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>ACL：Access Control List</strong> 访问控制列表</p>
<p>除了文件原本的权限位设置，可以自定义用户访问控制。</p>
<p>CentOS 7 默认创建的xfs和ext4文件系统具有ACL功能</p>
<p>CentOS 7 之前版本，系统安装时候创建的文件系统有ACL功能，默认手工创建的ext4文件系统无ACL功 能，需手动增加。</p>
<p>比如在6上新加一块磁盘，创建了sdb1分区，可以用下面命令使其支持ACL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tune2fs –o acl &#x2F;dev&#x2F;sdb1<br><br>mount –o acl &#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;test<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="基本命令用法"><a href="#基本命令用法" class="headerlink" title="基本命令用法"></a>基本命令用法</h3><h4 id="getfacl-XXX"><a href="#getfacl-XXX" class="headerlink" title="getfacl XXX"></a><code>getfacl XXX</code></h4><p>获取文件或文件夹的权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian app]# touch a<br>[root@ashjian app]# getfacl a<br># file: a<br># owner: root<br># group: root<br>user::rw-<br>group::r--<br>other::r--<br><br><br>[root@ashjian app]# mkdir dir1<br>[root@ashjian app]# getfacl dir1<br># file: dir1<br># owner: root<br># group: root<br>user::rwx<br>group::r-x<br>other::r-x<br></code></pre></td></tr></table></figure>

<h4 id="setfacl-set-file-acl"><a href="#setfacl-set-file-acl" class="headerlink" title="setfacl(set file acl)"></a><code>setfacl</code>(set file acl)</h4><p>给一个文件加了facl的话，整个权限位后面会有个<code>+</code>号，表示设置了facl权限。</p>
<p>-m 参数，表示modify</p>
<p>禁止<code>yu</code>用户访问<code>file1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian app]# setfacl -m u:yu:000 file1<br>[root@ashjian app]# getfacl file1<br># file: file1<br># owner: root<br># group: root<br>user::rw-<br>user:yu:---<br>group::r--<br>mask::r--<br>other::r--<br></code></pre></td></tr></table></figure>

<p>禁止<code>yu</code>组访问<code>file2</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian app]# setfacl -m g:yu:000 file2<br>[root@ashjian app]# getfacl file2<br># file: file2<br># owner: root<br># group: root<br>user::rw-<br>group::r--<br>group:yu:---<br>mask::r--<br>other::r--<br></code></pre></td></tr></table></figure>

<p>禁止其它用户访问file1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian app]# setfacl -m o:0 file3<br>[root@ashjian app]# getfacl file3<br># file: file3<br># owner: root<br># group: root<br>user::rw-<br>group::r--<br>other::---<br></code></pre></td></tr></table></figure>

<p>默认的从上到下的权限依次是：</p>
<blockquote>
<p>#owner:文件的拥有者<br>#group：文件的拥有组<br>user：自定义的用户（可多个）<br>group：自定义的组（可多个）<br>other：自定义的其它用户（可多个）</p>
</blockquote>
<p>如果一个用户属于多个自定义的组，权限是这几个组的权限的累加。</p>
<hr>
<h3 id="setfacl的其他用法"><a href="#setfacl的其他用法" class="headerlink" title="setfacl的其他用法"></a>setfacl的其他用法</h3><p><code>setfacl -Rb *</code>：清除所有acl</p>
<p><code>setfacl -M TEXT</code>：利用列表来批量设置权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# cat file.acl <br>u:yu:-<br>g:yu:rwx<br>[root@ashjian ~]# setfacl -M file.acl xxx<br>[root@ashjian ~]# getfacl xxx<br># file: xxx<br># owner: root<br># group: root<br>user::rw-<br>user:yu:---<br>group::rw-<br>group:yu:rwx<br>mask::rwx<br>other::rw-<br></code></pre></td></tr></table></figure>

<p><code>-d</code> 参数（default的意思），默认在facl权限下的目录，新创建的文件和文件夹继承上一级目录的权限。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">setfacl -md d:u:yu:rwx &#x2F;app&#x2F;dir2<br></code></pre></td></tr></table></figure>

<p>那么在dir2下新创建的目录就默认继承dir2的acl权限。</p>
<p><code>-x</code>删除某个权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">setfacl -x u:yu:rwx &#x2F;app&#x2F;dir2<br></code></pre></td></tr></table></figure>

<p><code>-X</code>按照文件里的内容来批量删除权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">setfacl -X file.acl xxx<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="acl中的mask"><a href="#acl中的mask" class="headerlink" title="acl中的mask"></a>acl中的<code>mask</code></h3><p>facl的mask是高压线，是影响自定义用户和自定义组的权限，有了mask后，会与自定义的用户和组的权限做逻辑与，这之后是自定义用户和组的真实权限。</p>
<p>默认是没有高压线的，默认值一般都是所有自定义用户和组的最高权限累加。</p>
<p>如果设置了，就相当于设定了高压线，高于这个高压线的权限，会降低到高压线之下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian app]# touch file4<br>[root@ashjian app]# setfacl -m u:yu:rwx file4 <br>[root@ashjian app]# setfacl -m g:yu:rw- file4<br>[root@ashjian app]# getfacl file4<br># file: file4<br># owner: root<br># group: root<br>user::rw-<br>user:yu:rwx<br>group::r--<br>group:yu:rw-<br>mask::rwx<br>other::r--<br><br>[root@ashjian app]# setfacl -m m:r-- file4<br>[root@ashjian app]# getfacl file4<br># file: file4<br># owner: root<br># group: root<br>user::rw-<br>user:yu:rwx			#effective:r--<br>group::r--<br>group:yu:rw-			#effective:r--<br>mask::r--<br>other::r--<br></code></pre></td></tr></table></figure>

<p>我们可以看到，设置了高压线后，自定义用户和自定义组的有效值（effective）是不超过mask的<code>r--</code></p>
<hr>
<h3 id="facl权限的复制、备份和恢复"><a href="#facl权限的复制、备份和恢复" class="headerlink" title="facl权限的复制、备份和恢复"></a>facl权限的复制、备份和恢复</h3><p>复制acl权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">getfacl file1 | setfacl --set-file&#x3D;- file2<br></code></pre></td></tr></table></figure>

<p>主要的文件操作命令cp和mv都支持ACL，只是cp命令需要 加上-p 参数。但是tar等常见的备份工具是不会保留目录 和文件的ACL信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 得到app目录及其目录里所有文件的acl权限（-R参数），写入到&#x2F;root&#x2F;app.acl文件里<br>[root@ashjian app]# getfacl -R &#x2F;app &gt;&#x2F;root&#x2F;app.acl<br># 去掉&#x2F;app目录及其目录里所有文件的acl权限（-b去除）<br>[root@ashjian app]# setfacl -R -b &#x2F;app<br><br># 恢复权限<br><br># 绝对路径法：<br>setfacl --set-file&#x3D;&#x2F;root&#x2F;app.acl &#x2F;app<br><br>#相对路径法（需要在要恢复的文件夹或文件的上一级目录运行）：<br>setfacl --restore &#x2F;root&#x2F;app.acl<br></code></pre></td></tr></table></figure>

<h4 id="Default-ACL"><a href="#Default-ACL" class="headerlink" title="Default ACL"></a>Default ACL</h4><p>上面我们所有讲的都是Access ACL，也就是对文件而言。下面我简单讲一下Default ACL。Default ACL是指对于一个目录进行Default ACL设置，并且在此目录下建立的文件都将继承此目录的ACL。</p>
<p>同样我们来做一个试验说明，比如现在root用户建立了一个dir目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost ~]# mkdir dir<br></code></pre></td></tr></table></figure>

<p>他希望所有在此目录下建立的文件都可以被john用户所访问，那么我们就应该对dir目录设置Default ACL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost ~]# setfacl -d -m user:john:rw .&#x2F;dir<br>[root@localhost ~]# getfacl --omit-header .&#x2F;dir<br>user::rwx<br>group::rwx<br>other::r-x<br>default:user::rwx<br>default:user:john:rwx<br>default:group::rwx<br>default:mask::rwx<br>default: other::r-x<br></code></pre></td></tr></table></figure>

<p>这里我们可以看到ACL定义了default选项，john用户拥有了default的read, write, excute/search permission。所有没有定义的default都将从file permission里copy过来，现在root用户在dir下建立一个test.txt文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost ~]# touch .&#x2F;dir&#x2F;test.txt<br>[root@localhost ~]# ls -l .&#x2F;dir&#x2F;test.txt<br>-rw-rw-r--+ 1 root root 0 Jul 3 23:46 .&#x2F;dir&#x2F;test.txt<br>[root@localhost ~]# getfacl --omit-header .&#x2F;dir&#x2F;test.txt <br>user::rw-<br>user:john:rw-<br>group::rwx #effective:rw-<br>mask::rw-<br>other::r--<br></code></pre></td></tr></table></figure>

<p>这里我们看到在dir下建立的文件john用户自动就有了read and write permission</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
        <tag>ACL</tag>
      </tags>
  </entry>
  <entry>
    <title>03-运算</title>
    <url>/03-%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>bash中的算术运算:help let</p>
<p>+, -, <em>, /, %取模（取余）, *</em>（乘方），乘法符号有些场景中需要转义 实现算术运算： </p>
<ul>
<li>let var=算术表达式</li>
<li>var=$[算术表达式]</li>
<li>var=$((算术表达式))</li>
<li>var=$(expr arg1 arg2 arg3 …)</li>
<li>declare –i var = 数值</li>
<li>echo ‘算术表达式’ | bc</li>
</ul>
<blockquote>
<p>tips: <code>$RANDOM</code>：随机数<code>0~32767</code><br><code>echo $[$RANDOM%50]</code>：随机数<code>0-49</code></p>
</blockquote>
<h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p>普通赋值： <code>=</code><br>增强型赋值： <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code><br><del>自增自减</del>：不推荐使用。</p>
<blockquote>
<p>tips: 不推荐使用自增自检，在c语言里，为了计算机好识别，采用了自增自减。在比较新的语言，如Python，Ruby都不使用自增自减（很容易实现，但是不做），代码读起来不<strong>流畅</strong>，JavaScript支持自增自减，但是官方也不推荐使用。</p>
</blockquote>
<h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><h3 id="与-amp"><a href="#与-amp" class="headerlink" title="与&amp;"></a>与&amp;</h3><p>1 与 1 = 1</p>
<p> 1 与 0 = 0 </p>
<p> 0 与 1 = 0 </p>
<p> 0 与 0 = 0 </p>
<h3 id="或"><a href="#或" class="headerlink" title="或|"></a>或|</h3><p> 1 或 1 = 1 </p>
<p> 1 或 0 = 1 </p>
<p> 0 或 1 = 1 </p>
<p> 0 或 0 = 0</p>
<h3 id="非：！"><a href="#非：！" class="headerlink" title="非：！"></a>非：！</h3><p> !    1 = 0<br> !    0 = 1</p>
<h3 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h3><h4 id="短路与-amp-amp"><a href="#短路与-amp-amp" class="headerlink" title="短路与&amp;&amp;"></a>短路与&amp;&amp;</h4><p> 第一个为0，结果必定为0<br> 第一个为1，第二个必须要参与运算  短路或 </p>
<h4 id="短路或"><a href="#短路或" class="headerlink" title="短路或||"></a>短路或||</h4><p> 第一个为1，结果必定为1<br> 第一个为0，第二个必须要参与运算</p>
<h3 id="异或："><a href="#异或：" class="headerlink" title="异或：^"></a>异或：^</h3><p> 异或的两个值，相同为假，不同为真</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL编程</tag>
      </tags>
  </entry>
  <entry>
    <title>04-DNS主从复制</title>
    <url>/04-DNS%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主DNS正向解析、从DNS正向解析，主DNS反向解析，从DNS反向解析。</p>
<p>正向解析和反向解析是两个完全不同的系统，可以分别来设置。</p>
<p>只有一个主，但是可以有多个从服务器，从服务器可以接从服务器（不一定接主服务器)。</p>
<p>一个从服务器，可以从多个主服务器同步数据。</p>
<h2 id="定义从区域的方法"><a href="#定义从区域的方法" class="headerlink" title="定义从区域的方法"></a>定义从区域的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">zone &quot;ZONE_NAME&quot; IN &#123;<br>    type slave;<br>    masters &#123; MASTER_IP; &#125;;<br>    file &quot;slaves&#x2F;ZONE_NAME.zone&quot;<br>&#125;<br>​&#96;&#96;&#96;  <br><br>&gt; 前提：无论正向解析反向解析，主服务器的zone文件里，要有从的NS服务器的定义。<br><br>我们可以查看要被被服务器同步的主服务器的正向解析和反向解析的zone文件，来确认下：<br><br>![](&#x2F;images&#x2F;15020237612906.jpg)<br><br>![](&#x2F;images&#x2F;15086450357684.jpg)<br><br><br>NS记录有从服务器的记录才可以配置从服务器。<br><br><br>## 实验1:增加从服务器正向解析<br><br>我们把之前设置的&#96;192.168.111.254&#96;设为主DNS服务器<br><br>我们在设置一个&#96;192.168.111.253&#96;作为从dns服务器，从主服务器同步dns信息。<br><br>同步的目录默认为&#96;&#x2F;var&#x2F;named&#x2F;slaves&#96;，系统已经默认在这个目录下面创建一个&#96;slaves&#96;的文件夹(属主属组都是named，&#96;&#x2F;var&#x2F;named&#96;目录只有属组是named，而属组没有写权限）<br><br><br><br><br><br>### 1. 更改&#96;&#x2F;etc&#x2F;named.conf&#96;<br><br>​&#96;&#96;&#96;bash<br>options &#123;<br>        listen-on port 53 &#123; 192.168.111.253; &#125;; &#x2F;&#x2F; 监听端口配置为本机的一个网卡的地址<br>        listen-on-v6 port 53 &#123; ::1; &#125;;<br>        directory       &quot;&#x2F;var&#x2F;named&quot;;<br>        dump-file       &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;cache_dump.db&quot;;<br>        statistics-file &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named_stats.txt&quot;;<br>        memstatistics-file &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named_mem_stats.txt&quot;;<br>        allow-query     &#123; 192.168.111.0&#x2F;24; &#125;; &#x2F;&#x2F; 只允许192.168.11.0&#x2F;24网段查询<br>recursion yes;<br><br>        dnssec-enable no;  &#x2F;&#x2F; 关闭安全<br>        dnssec-validation no; &#x2F;&#x2F; 关闭安全<br>        <br>&#x2F;&#x2F; 下面保持不变，就不贴了<br></code></pre></td></tr></table></figure>

<h2 id="2-更改-etc-named-rfc1912-zones"><a href="#2-更改-etc-named-rfc1912-zones" class="headerlink" title="2. 更改/etc/named.rfc1912.zones"></a>2. 更改<code>/etc/named.rfc1912.zones</code></h2><p>/etc/named.rfc1912.zones填加下面内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">zone &quot;ashjian.com&quot; IN &#123;<br>        type slave;<br>        masters &#123; 192.168.111.254; &#125;;<br>        file &quot;slaves&#x2F;ashjian.com.zone&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>type</code> 和主不同的是，要改为<code>slave</code></li>
<li>然后需要写<code>masters</code>是谁，可以有多个master，即使就一个，也要写<code>masters</code>，后面跟大括号</li>
<li>file指向的从主同步下来的文件。写<code>slaves/ashjian.com.zone</code>，即<code>/var/named/slaves/ashjian.com.zone</code>(自动加了参数里的默认directory<code>/var/named</code>)</li>
</ul>
<h3 id="3-重启服务"><a href="#3-重启服务" class="headerlink" title="3. 重启服务"></a>3. 重启服务</h3><p>改完了后 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rndc reload<br></code></pre></td></tr></table></figure>

<p><code>tail -20 /var/log/messages</code>查看日志可以看到成功了</p>
<p><a href="http://www.ashjian.com/images/15020194531692.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828081341.jpg" alt="img"></a></p>
<p><code>ls /var/named/slaves/</code>可以看到同步过来的zone文件。</p>
<p><a href="http://www.ashjian.com/images/15020198192593.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828081354.jpg" alt="img"></a></p>
<h3 id="4-主服务器发生更改"><a href="#4-主服务器发生更改" class="headerlink" title="4. 主服务器发生更改"></a>4. 主服务器发生更改</h3><p>主服务器发生更改，然后<code>rndc reload</code>，会通知所有的从服务器立即进行更改。</p>
<p><a href="http://www.ashjian.com/images/15020212577735.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828081400.jpg" alt="img"></a></p>
<h2 id="实验2-增加从服务器反向解析"><a href="#实验2-增加从服务器反向解析" class="headerlink" title="实验2:增加从服务器反向解析"></a>实验2:增加从服务器反向解析</h2><h2 id="1-更改-etc-named-rfc1912-zones"><a href="#1-更改-etc-named-rfc1912-zones" class="headerlink" title="1. 更改/etc/named.rfc1912.zones"></a>1. 更改<code>/etc/named.rfc1912.zones</code></h2><p>/etc/named.rfc1912.zones填加下面内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">zone &quot;111.168.192.in-addr.arpa&quot; IN &#123;<br>        type slave;<br>        masters &#123; 192.168.111.254; &#125;;<br>        file &quot;slaves&#x2F;192.168.111.zone&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-重启从服务器的服务"><a href="#2-重启从服务器的服务" class="headerlink" title="2. 重启从服务器的服务"></a>2. 重启从服务器的服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rndc reload<br></code></pre></td></tr></table></figure>

<p><a href="http://www.ashjian.com/images/15020235407506.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200828081407.jpg" alt="img"></a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>04-HAProxy 统计页面</title>
    <url>/04-HAProxy-%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HAProxy的统计页面，可以定义在frontend listen backend中，不过一般都定义在listen段中，专门开辟一个端口作为监听端口，然后对外提供状态页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">listen stats<br>    mode http<br>    bind 192.168.20.222:9999<br>    stats enable<br>    stats hide-version<br>    log global<br>    stats uri &#x2F;haproxy-stats<br>    stats auth haadmin:haadmin123<br></code></pre></td></tr></table></figure>

<p>重启服务，<code>systemctl restart haproxy</code>，输入统计页地址<code>192.168.20.222:9999/haproxy-stats</code>，输入上面定义的用户名和密码：</p>
<p><a href="http://www.yulongjun.com/images/15073860612283.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135244.jpg" alt="img"></a></p>
<p>如果在添加一个参数：<code>stats admin</code>，可以提供后端主机的管理功能，还可以限定只允许某台主机进行管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">stats admin &#123; if | unless &#125; &lt;cond&gt;<br></code></pre></td></tr></table></figure>

<p>例如不设置限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">stats admin if TRUE  # 任何主机都可以管理<br></code></pre></td></tr></table></figure>



<p>设置完重启服务，可以看到每个服务器前面会多一个勾选用的复选框，可以直接设置服务器状态：</p>
<p><a href="http://www.yulongjun.com/images/15074432397594.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135245.jpg" alt="img"></a></p>
<p>还可以设置页面自动刷新间隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">stats refresh 15s<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>04-Nginx的默认http配置选项</title>
    <url>/04-Nginx%E7%9A%84%E9%BB%98%E8%AE%A4http%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="http配置结构"><a href="#http配置结构" class="headerlink" title="http配置结构"></a>http配置结构</h2><p>http配置，可以写在<code>/etc/nginx/nginx.conf</code>的http配置字段里。也可以单独来写，一般是单独写在<code>/etc/nginx/conf.d/xxx.conf</code>文件里，不同的虚拟主机写在不同的配置文件里，清晰明了。</p>
<p>在http的配置文件里，和主配置一样，分为{}括起来的，我们称之为段，比如<code>http{}</code>、<code>server{}</code>、<code>location {}</code>、<code>if CONDITION {}</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">http &#123;<br>     # http block: http&#x2F;https 协议相关的公共配置块<br>     ...<br>    server &#123;   # server虚拟主机配置段，可以定义多个server<br>        # server block: 某一虚拟主机的详细配置块<br>        ... <br>        location &#x2F;URI1&#x2F; &#123;  # 资源位置location的配置段，可以定义多个location<br>        # location block: 某一资源位置的详细配置块<br>            if CONDITION &#123;<br>            # if in location block: 在location配置段里的if条件判断块。<br>            &#125;<br>        ...<br>        &#125;<br>        location &#x2F;URI2&#x2F; &#123;<br>        ...  <br>        &#125;<br>        location ...  # 多个location<br>    &#125;    <br>    server &#123;<br>    &#125;<br>    server ...  # 多个server   <br>&#125;<br></code></pre></td></tr></table></figure>

<p>http各种配置段的的详细配置选项信息见：</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_core_module.html</a></p>
<p>与http相关的配置指令仅能够放置于<code>http</code>,<code>server</code>,<code>location</code>,<code>upstream</code>,<code>if CONDITION</code>段里。而且每个指令都有对应的可以放的段，并不是所有段都可以放。</p>
<p>比如<code>default_type</code>配置指令，只支持<code>http</code>，<code>server</code>，<code>location</code>段：</p>
<blockquote>
<p>Syntax: <strong>default_type</strong> <em>mime-type</em>;<br>Default: default_type text/plain;<br>Context: http, server, location</p>
</blockquote>
<hr>
<h2 id="通过默认的http配置来简单了解http配置文件。"><a href="#通过默认的http配置来简单了解http配置文件。" class="headerlink" title="通过默认的http配置来简单了解http配置文件。"></a>通过默认的http配置来简单了解http配置文件。</h2><blockquote>
<p>1.10版本时候，http默认配置还是写在<code>/etc/nginx/nginx.conf</code>中，新版本（1.12）的http默认配置是在`/etc/nginx/conf.d/default.conf</p>
</blockquote>
<p>我们通过理解nginx.conf里默认的http配置来管中窥豹。后续再去理解一些更精细的参数。</p>
<p>HTTP协议的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">http &#123;<br>    # 日志格式 日志别名<br>    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;<br>                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;<br>                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;<br>    # 定义日志路径和使用的日志格式（用上面定义的别名）<br>    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;<br><br>    sendfile            on;    # sendfile零拷贝<br>    tcp_nopush          on;    # 在sendfile模式下，是否启用TCP_CORK选项<br>    tcp_nodelay         on;    # 在keepalived模式下的连接是否启用TCP_NODELAY选项<br>    keepalive_timeout   65;    # 设定保持连接的超时时长，0表示禁止长连接；默认为65s<br>    types_hash_max_size 2048;<br><br>    include             &#x2F;etc&#x2F;nginx&#x2F;mime.types;     # 支持的MIME类型文件<br>    default_type        application&#x2F;octet-stream;  # <br><br>    # Load modular configuration files from the &#x2F;etc&#x2F;nginx&#x2F;conf.d directory.<br>    # See http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;ngx_core_module.html#include<br>    # for more information.<br>    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;  # 载入confi.d下的子配置文件<br><br>    server &#123;<br>        listen       80 default_server;  # 监听地址；default_server表示是设定为默认虚拟主机<br>        listen       [::]:80 default_server; # ipv6的监听地址<br>        server_name  _;  # 列出所有服务器名称。<br>        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;  # http服务器的根目录相对于系统的路径<br><br>        # Load configuration files for the default server block.<br>        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf; # 载入default.d下的配置文件<br><br>        location &#x2F; &#123; # 根据请求URI设置配置，这里请求的URI是&#x2F;<br>        &#125;<br><br>        error_page 404 &#x2F;404.html; #设置404错误页面为&#x2F;404.html,<br>            location &#x3D; &#x2F;40x.html &#123; # 这里又缩进了一层location，表示404的error_page实际指向是http root目录的40x.html,根据上文root路径，可得出是系统下&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;40x.html<br>        &#125;<br><br>        error_page 500 502 503 504 &#x2F;50x.html;<br>            location &#x3D; &#x2F;50x.html &#123;<br>        &#125; 原理同上，是把500，502 503，504的error_page都定位到&#x2F;50x.html上<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>HTTPS(HTTP with TLS)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># Settings for a TLS enabled server.<br><br>    server &#123;<br>        listen       443 ssl http2 default_server;   # 端口为443，开启了ssl，协议为HTTP2.0标准，设置为默认服务器。<br>        listen       [::]:443 ssl http2 default_server;  # ipv6的<br>        server_name  _;  #服务器名字列表<br>        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;  # https服务根目录<br><br>        ssl_certificate &quot;&#x2F;etc&#x2F;pki&#x2F;nginx&#x2F;server.crt&quot;;  # 服务器证书<br>        ssl_certificate_key &quot;&#x2F;etc&#x2F;pki&#x2F;nginx&#x2F;private&#x2F;server.key&quot;; # 服务器认证私钥<br>        ssl_session_cache shared:SSL:1m; # SSL会话缓存模式为共享，时间为1分钟。<br>        ssl_session_timeout  10m; # SSL会话超时时间10分钟<br>        ssl_ciphers HIGH:!aNULL:!MD5;<br>        ssl_prefer_server_ciphers on;<br><br>        # Load configuration files for the default server block.<br>        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;  # 下同http，略<br><br>        location &#x2F; &#123;<br>        &#125;<br><br>        error_page 404 &#x2F;404.html;<br>            location &#x3D; &#x2F;40x.html &#123;<br>        &#125;<br><br>        error_page 500 502 503 504 &#x2F;50x.html;<br>            location &#x3D; &#x2F;50x.html &#123;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>术语：关于<strong><code>sendfile</code></strong>零拷贝，见<a href="http://blog.csdn.net/hnlyyk/article/details/50856268" target="_blank" rel="noopener">Linux网络编程–sendfile零拷贝高效率发送文件</a>。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>04-SELECT语句</title>
    <url>/04-SELECT%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以看《SQL基础教程（第2版）》第二章，这本书是2017年5月出的最新版。<br><a href="http://www.yulongjun.com/images/15011680237550.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203150329.jpg" alt="img"></a></p>
<p>第二章内容：</p>
<p><a href="http://www.yulongjun.com/images/15011679934159.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203150330.jpg" alt="img"></a></p>
<blockquote>
<p><strong>（下面内容请忽略，笔者已会SQL语句，下面内容是查漏补缺写的笔记）</strong></p>
</blockquote>
<h2 id="聚合函数-Group-Function"><a href="#聚合函数-Group-Function" class="headerlink" title="聚合函数(Group Function)"></a>聚合函数(Group Function)</h2><ul>
<li><code>count()</code></li>
<li><code>sum()</code></li>
<li><code>max()</code></li>
<li><code>min()</code></li>
</ul>
<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>使用 GROUP BY 子句可以像切蛋糕那样将表分割。通过使用聚合函数和 GROUP BY 子句，可以根据“商品种类”或者“登记日期”等将表分割后再 进行汇总。<br>聚合键中包含 NULL 时，在结果中会以“不确定”行（空行）的形式表现出来。<br>使用聚合函数和 GROUP BY 子句时需要注意以下4点。<br>① 只能写在 SELECT 子句之中<br>② GROUP BY 子句中不能使用 SELECT 子句中列的别名<br>③ GROUP BY 子句的聚合结果是无序的<br>④ WHERE 子句中不能使用聚合函数</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">GROUP BY&#96; 和 &#96;WHERE&#96; 并用时 &#96;SELECT&#96; 语句的执行顺：<br>&#96;FROM → WHERE → GROUP BY → SELECT<br></code></pre></td></tr></table></figure>
</blockquote>
<p>所以这样使用会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SELECT product_type AS pt, COUNT(*) <br>FROM Product <br>GROUP BY pt;<br></code></pre></td></tr></table></figure>

<p>在WHERE子句里不能使用聚合函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SELECT product_type, COUNT(*)<br>FROM Product <br>WHERE COUNT(*) &#x3D; 2<br>GROUP BY product_type;<br></code></pre></td></tr></table></figure>

<p>上面这个会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ERROR 1111 (HY000): <br>Invalid use of group function<br></code></pre></td></tr></table></figure>

<p>想要在子句里使用聚合函数，可以用<code>having</code>子句。</p>
<h2 id="GROUP-BY和DISTINCT"><a href="#GROUP-BY和DISTINCT" class="headerlink" title="GROUP BY和DISTINCT"></a><code>GROUP BY</code>和<code>DISTINCT</code></h2><p><a href="http://www.yulongjun.com/images/15012252297050.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203150331.jpg" alt="img"></a></p>
<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>说到指定条件，估计大家都会首先想到 WHERE 子句。但是， WHERE 子句只能指定记录（行）的条件，而不能用来指定<strong>组</strong>的条件（例如，“聚合结果正好为2行的组”或者“平均值为500的组”等）。</p>
<p><code>HAVING</code> 子句必须写在 <code>GROUP BY</code> 子句之后，其在 DBMS 内部的执行顺序也排在 <code>GROUP BY</code> 子句之后。</p>
<blockquote>
<p>使用 <code>HAVING</code> 子句时 <code>SELECT</code> 语句的顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SELECT → FROM → WHERE → GROUP BY → HAVING<br></code></pre></td></tr></table></figure>
</blockquote>
<p>sale_price<code>group by</code> 后，<code>count(*)</code>大于2的显示出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SELECT product_type, COUNT(*) <br>FROM Product <br>GROUP BY product_type <br>HAVING COUNT(*) &#x3D; 2;<br></code></pre></td></tr></table></figure>

<p>sale_price <code>group by</code> 后，平均值大于2的显示出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SELECT product_type, AVG(sale_price) <br>FROM Product <br>GROUP BY product_type <br>HAVING AVG(sale_price) &gt;&#x3D; 2500;<br></code></pre></td></tr></table></figure>

<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><blockquote>
<p>子句的书写顺序：<br><code>1. SELECT 子句 → 2. FROM 子句 → 3. WHERE 子句 → 4. GROUP BY 子句 → 5. HAVING 子句 → 6. ORDER BY 子句</code></p>
</blockquote>
<p>默认是升序<code>ASC</code>（Ascendent），可以加<code>DESC</code>(Descendent)就变成降序。</p>
<p>可以指定<strong>多个排序键</strong>，那么就先排序第一个排序键，然后再第一个排序键有相同的值的情况下，第二个再排序。</p>
<p><strong>NULL</strong>在ASC排序里是排在最后，DESC排序里排在最前面。</p>
<blockquote>
<p><strong>在 ORDER BY 子句中可以使用 SELECT 子句中未使用的列和聚合函数。</strong></p>
</blockquote>
<h2 id="总的顺序："><a href="#总的顺序：" class="headerlink" title="总的顺序："></a>总的顺序：</h2><p>WGHO原则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">WHERE<br>GROUP BY<br>HAVING<br>ORDER BY<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>04-Zabbix-Web中文字体显示问题</title>
    <url>/04-Zabbix-Web%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>abbix中文字体问题，我们可以通过拷贝中文字体文件到zabbix的目录来实现。</p>
<p>上传一个中文字体文件到<code>/usr/share/zabbix/fonts</code>下，这里我拷贝的是windows下的微软雅黑<code>msyh.ttf</code>。</p>
<blockquote>
<p>tips：只能支持ttf格式的字体文件，不能支持ttc的，本来copy了macOS下的一个苹方简体（PingFang.ttc)，结果不支持ttc类型的字体文件，最后换成微软雅黑（msyh.ttf)字体</p>
</blockquote>
<p>原来配置文件里面配置的是<code>graphfont.ttf</code>，我们grep一下配置文件<code>/usr/share/zabbix/include/defines.inc.php</code>发现有两条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;include&#x2F;defines.inc.php |grep graphfont<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15065908096135.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153942.jpg" alt="img"></a></p>
<p>把这两个替换了就好：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sed -i &#39;s&#x2F;graphfont&#x2F;msyh&#x2F;g&#39; &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;include&#x2F;defines.inc.php<br></code></pre></td></tr></table></figure>

<p>OK，替换完毕，可以grep验证一下：</p>
<p><a href="http://www.yulongjun.com/images/15065916332767.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153943.jpg" alt="img"></a></p>
<p>刷新一下页面，即可看到中文正常显示：</p>
<p><a href="http://www.yulongjun.com/images/15065916897337.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203153944.jpg" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>04-http进阶</title>
    <url>/04-http%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="http跟踪"><a href="#http跟踪" class="headerlink" title="http跟踪"></a>http跟踪</h2><p>http协议：stateless（无状态），服务器无法持续追踪访问者来源<br>        依靠客户端的cookie存放客户端用户的id身份证（令牌）, 服务器的session保存对应的用户的浏览行为，完成服务器跟踪用户的身份和浏览行为</p>
<h2 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h2><h3 id="报文语法格式："><a href="#报文语法格式：" class="headerlink" title="报文语法格式："></a>报文语法格式：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">request报文<br>​			&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;<br>​			&lt;headers&gt;<br><br>​			&lt;entity-body&gt;<br><br>​		response报文<br>​			&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;<br>​			&lt;headers&gt;<br><br>​			&lt;entity-body&gt;<br><br>​		method: 请求方法，标明客户端希望服务器对资源执行的动作<br>​			GET、HEAD、POST<br>​		version:<br>​			HTTP/&lt;major&gt;.&lt;minor&gt;<br>​		status:<br>​			三位数字，如200，301, 302, 404, 502; 标记请求处理过程中发生的情况；<br>​		reason-phrase：<br>​			状态码所标记的状态的简要描述；<br>​		headers：<br>​			每个请求或响应报文可包含任意个首部；每个首部都有首部名称，后面跟一个冒号，而后跟上一个可选空格，接着是一个值；<br>​		entity-body：请求时附加的数据或响应时附加的数据；<br></code></pre></td></tr></table></figure>



<h3 id="method-方法-："><a href="#method-方法-：" class="headerlink" title="method(方法)："></a>method(方法)：</h3><p>​        GET：从服务器获取一个资源；<br>​        HEAD：只从服务器获取文档的响应首部；<br>​        POST：向服务器发送要处理的数据；<br>​        PUT：将请求的主体部分存储在服务器上；<br>​        DELETE：请求删除服务器上指定的文档；<br>​        TRACE：追踪请求到达服务器中间经过的代理服务器；<br>​        OPTIONS：请求服务器返回对指定资源支持使用的请求方法；</p>
<p>​        协议查看或分析的工具：<br>​            tcpdump, tshark, wireshark</p>
<h3 id="status-状态码-："><a href="#status-状态码-：" class="headerlink" title="status(状态码)："></a>status(状态码)：</h3><p>​        1xx：100-101, 信息提示；<br>​        2xx：200-206, 成功<br>​        3xx：300-305, 重定向<br>​        4xx：400-415, 错误类信息，客户端错误<br>​        5xx：500-505, 错误类信息，服务器端错误</p>
<p>​        常用的状态码：<br>​            200： 成功，请求的所有数据通过响应报文的entity-body部分发送；OK<br>​            301： 请求的URL指向的资源已经被删除；但在响应报文中通过首部Location指明了资源现在所处的新位置；Moved Permanently<br>​            302： 与301相似，但在响应报文中通过Location指明资源现在所处临时新位置; Found<br>​            304： 客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过响应此响应状态码通知客户端；Not Modified<br>​            401： 需要输入账号和密码认证方能访问资源；Unauthorized<br>​            403： 请求被禁止；Forbidden<br>​            404： 服务器无法找到客户端请求的资源；Not Found<br>​            500： 服务器内部错误；Internal Server Error<br>​            502： 代理服务器从后端服务器收到了一条伪响应；Bad Gateway</p>
<h3 id="首部headers："><a href="#首部headers：" class="headerlink" title="首部headers："></a>首部headers：</h3><h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h4><p>​            Name: Value</p>
<p>​            Cache-Control:public, max-age=600<br>​            Connection:keep-alive<br>​            Content-Type:image/png<br>​            Date:Tue, 28 Apr 2015 01:43:54 GMT<br>​            ETag:”5af34e-ce6-504ea605b2e40”<br>​            Last-Modified:Wed, 08 Oct 2014 14:46:09 GMT</p>
<p>​            Accept:image/webp,<em>/</em>;q=0.8<br>​                Accept-Encoding:gzip, deflate, sdch<br>​                Accept-Language:zh-CN,zh;q=0.8<br>​                Cache-Control:max-age=0<br>​                Connection:keep-alive<br>​                Host:access.redhat.com<br>​                If-Modified-Since:Wed, 08 Oct 2014 14:46:09 GMT<br>​                If-None-Match:”5af34e-ce6-504ea605b2e40”<br>​                Referer:<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html-single/Installation_Guide/index.html" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html-single/Installation_Guide/index.html</a><br>​                User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36</p>
<h4 id="首部的分类："><a href="#首部的分类：" class="headerlink" title="首部的分类："></a>首部的分类：</h4><p>​            通用首部<br>​            请求首部<br>​            响应首部<br>​            实体首部<br>​            扩展首部</p>
<p>​            通用首部：<br>​                Date: 报文的创建时间<br>​                Connection：连接状态，如keep-alive, close<br>​                Via：显示报文经过的中间节点（代理服务器）<br>​                Cache-Control：控制缓存<br>​                Pragma：</p>
<p>​            请求首部：<br>​                Accept：通过服务器自己可接受的媒体类型(MIME)；<br>​                Accept-Charset：<br>​                Accept-Encoding：接受编码格式，如gzip<br>​                Accept-Language：接受的语言</p>
<p>​                Client-IP:<br>​                Host: 请求的服务器名称和端口号<br>​                Referer：包含当前正在请求的资源的上一级资源；<br>​                User-Agent：客户端代理</p>
<p>​                条件式请求首部：<br>​                    Expect：<br>​                    If-Modified-Since：自从指定的时间之后，请求的资源是否发生过修改；<br>​                    If-Unmodified-Since：<br>​                    If-None-Match：本地缓存中存储的文档的ETag标签是否与服务器文档的Etag不匹配；<br>​                    If-Match：</p>
<p>​                安全请求首部：<br>​                    Authorization：向服务器发送认证信息，如账号和密码；<br>​                    Cookie: 客户端向服务器发送cookie<br>​                    Cookie2：</p>
<p>​                代理请求首部：<br>​                    Proxy-Authorization: 向代理服务器认证</p>
<p>​            响应首部：<br>​                信息性：<br>​                    Age：响应持续时长<br>​                    Server：服务器程序软件名称和版本</p>
<p>​                协商首部：某资源有多种表示方法时使用<br>​                    Accept-Ranges：服务器可接受的请求范围类型<br>​                    Vary：服务器查看的其它首部列表；</p>
<p>​                安全响应首部：<br>​                    Set-Cookie：向客户端设置cookie；<br>​                    Set-Cookie2:<br>​                    WWW-Authenticate：来自服务器的对客户端的质询认证表单</p>
<p>​            实体首部：<br>​                Allow: 列出对此实体可使用的请求方法<br>​                Location：告诉客户端真正的实体位于何处</p>
<p>​                Content-Encoding:<br>​                Content-Language:<br>​                Content-Length: 主体的长度<br>​                Content-Location: 实体真正所处位置；<br>​                Content-Type：主体的对象类型</p>
<p>​                缓存相关：<br>​                    ETag：实体的扩展标签；<br>​                    Expires：实体的过期时间；<br>​                    Last-Modified：最后一次修改的时间</p>
<h2 id="httpd-2-2的常见配置-2"><a href="#httpd-2-2的常见配置-2" class="headerlink" title="httpd-2.2的常见配置(2)"></a>httpd-2.2的常见配置(2)</h2><p>​    </p>
<h3 id="15、user-group"><a href="#15、user-group" class="headerlink" title="15、user/group"></a>15、user/group</h3><p>​    httpd如果启动子进程建议指定一个普通用户来运行该进程，避免被黑客截获了该进程，获得了该进程的用户级别的权限。httpd默认用户是apache。</p>
<p>为什么httpd主进程要管理员身份启动？</p>
<p>答：因为httpd要监听80端口。而1-1023端口是特权端口，仅限管理员使用。</p>
<p>指定以哪个用户的身份运行httpd服务进程；<br>    User apache<br>    Group apache</p>
<p>比如当某个路径映射到另一个路径，而那个路径的权限必须某个用户时，而apache用户无法访问时，用SUexec（不建议使用，非常的不安全，要加载模块mod_unixd）</p>
<p>SUexec(j访问某个文件时临时切换用户)</p>
<h3 id="16、使用mod-deflate模块压缩页面优化传输速度"><a href="#16、使用mod-deflate模块压缩页面优化传输速度" class="headerlink" title="16、使用mod_deflate模块压缩页面优化传输速度"></a>16、使用mod_deflate模块压缩页面优化传输速度</h3><p>​    适用场景：<br>​        (1) 节约带宽，额外消耗CPU；同时，可能有些较老浏览器不支持；<br>​        (2) 压缩适于压缩的资源，例如文件文件；</p>
<p>​    SetOutputFilter DEFLATE  #设置过滤器，针对特定文件类型压缩，DEFLATE是过滤器名字，可自定义    </p>
<p>​     #mod_deflate configuration</p>
<p>​      # Restrict compression to these MIME types<br>​        AddOutputFilterByType DEFLATE text/plain<br>​        AddOutputFilterByType DEFLATE text/html<br>​        AddOutputFilterByType DEFLATE application/xhtml+xml<br>​        AddOutputFilterByType DEFLATE text/xml<br>​        AddOutputFilterByType DEFLATE application/xml<br>​        AddOutputFilterByType DEFLATE application/x-javascript<br>​        AddOutputFilterByType DEFLATE text/javascript<br>​        AddOutputFilterByType DEFLATE text/css</p>
<p>​        # Level of compression (Highest 9 - Lowest 1)</p>
<p>​            DeflateCompressionLevel 9<br>​             </p>
<p>Netscape 4.x has some problems.</p>
<p>​        BrowserMatch ^Mozilla/4  gzip-only-text/html<br>​         </p>
<p>Netscape 4.06-4.08 have some more problems</p>
<p>​        BrowserMatch  ^Mozilla/4.0[678]  no-gzip<br>​         </p>
<p>MSIE masquerades as Netscape, but it is fine</p>
<p>​        BrowserMatch \bMSI[E]  !no-gzip !gzip-only-text/html</p>
<h3 id="https-http-over-ssl"><a href="#https-http-over-ssl" class="headerlink" title="https,  http over ssl"></a>https,  http over ssl</h3><p>https是http在SSL协议之上完成的安全加密通信的web服务。需要mod_ssl模块</p>
<p>https默认只能基于IP地址作为主机，无法为同一个IP的多个域名同时使用https</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#以下配置https</span><br>[root@ashjian ~]<span class="hljs-comment">#yum info mod_ssl #mod_ssl提供ssl，需要</span><br>Loaded plugins: fastestmirror, langpacks<br>Repository epel is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel-debuginfo is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel-source is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast<br>Loading mirror speeds from cached hostfile<br><br> * base: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.aliyun.com<br>   Installed Packages<br>   Name        : mod_ssl<br>   Arch        : x86_64<br>   Epoch       : 1<br>   Version     : 2.4.6<br>   Release     : 90.el7.centos<br>   Size        : 224 k<br>   Repo        : installed<br>   From repo   : base<br>   Summary     : SSL/TLS module <span class="hljs-keyword">for</span> the Apache HTTP Server<br>   URL         : http://httpd.apache.org/<br>   License     : ASL 2.0<br>   Description : The mod_ssl module provides strong cryptography <span class="hljs-keyword">for</span> the Apache Web<br>            : server via the Secure Sockets Layer (SSL) and Transport Layer<br>            : Security (TLS) protocols.<br><br>Available Packages<br>Name        : mod_ssl<br>Arch        : x86_64<br>Epoch       : 1<br>Version     : 2.4.6<br>Release     : 93.el7.centos<br>Size        : 113 k<br>Repo        : base/7/x86_64<br>Summary     : SSL/TLS module <span class="hljs-keyword">for</span> the Apache HTTP Server<br>URL         : http://httpd.apache.org/<br>License     : ASL 2.0<br>Description : The mod_ssl module provides strong cryptography <span class="hljs-keyword">for</span> the Apache Web<br>            : server via the Secure Sockets Layer (SSL) and Transport Layer<br>            : Security (TLS) protocols<br>[root@ashjian ~]<span class="hljs-comment">#rpm -ql mod_ssl</span><br>/etc/httpd/conf.d/ssl.conf<br>/etc/httpd/conf.modules.d/00-ssl.conf<br>/usr/lib64/httpd/modules/mod_ssl.so<br>/usr/libexec/httpd-ssl-pass-dialog<br>/var/cache/httpd/ssl <span class="hljs-comment">#SSL会话缓存</span><br>.[root@ashjian ~]<span class="hljs-comment">#httpd -M | grep ssl </span><br> ssl_module (shared)  <span class="hljs-comment">#装载模块完成</span><br>  <br>如果证书已经申请成功，将其证书和私钥放到/etc/httpd/ssl目录中<br>[root@ashjian img]<span class="hljs-comment">#ls /etc/httpd/ssl</span><br>1_root_bundle.crt  2_www.ashjian.xyz.crt  3_www.ashjian.xyz.key <br>``<br><span class="hljs-comment">### 编辑httpd的SSL配置文件</span><br>[root@ashjian img]<span class="hljs-comment">#vim /etc/httpd/conf.d/ssl.conf</span><br><span class="hljs-comment"># General setup for the virtual host, inherited from global configuration</span><br>DocumentRoot <span class="hljs-string">"/var/www/html"</span>	<span class="hljs-comment">#设置文档的根目录</span><br>ServerName www.ashjian.xyz:443 <span class="hljs-comment">#设置服务器的访问名</span><br>&lt;Directory <span class="hljs-string">"/var/www/html"</span>&gt;  <span class="hljs-comment">#设置了访问的目录，就要显式地控制访问目录</span><br>   Options Indexes<br>   Allowoverride none<br>   IndexOptions Charset=UTF-8	<span class="hljs-comment">#原先的目录下的文档名乱码，要设置UTF-8的中文编码才正常</span><br>   Require all granted<br>&lt;/Directory&gt;<br><span class="hljs-comment">#   Server Certificate:</span><br><span class="hljs-comment"># Point SSLCertificateFile at a PEM encoded certificate.  If</span><br><span class="hljs-comment"># the certificate is encrypted, then you will be prompted for a</span><br><span class="hljs-comment"># pass phrase.  Note that a kill -HUP will prompt again.  A new</span><br><span class="hljs-comment"># certificate can be generated using the genkey(1) command.</span><br><span class="hljs-comment">#SSLCertificateFile /etc/pki/tls/certs/localhost.crt</span><br>SSLCertificateFile /etc/httpd/ssl/2_www.ashjian.xyz.crt<br><span class="hljs-comment">#设置CA证书的位置</span><br><span class="hljs-comment">#   Server Private Key:</span><br><span class="hljs-comment">#   If the key is not combined with the certificate, use this</span><br><span class="hljs-comment">#   directive to point at the key file.  Keep in mind that if</span><br><span class="hljs-comment">#   you've both a RSA and a DSA private key you can configure</span><br><span class="hljs-comment">#   both in parallel (to also allow the use of DSA ciphers, etc.)</span><br><span class="hljs-comment">#SSLCertificateKeyFile /etc/pki/tls/private/localhost.key</span><br>SSLCertificateKeyFile /etc/httpd/ssl/3_www.ashjian.xyz.key<br><span class="hljs-comment">#设置私钥的位置</span><br>[root@ashjian img]<span class="hljs-comment">#systemctl restart httpd.service </span><br><span class="hljs-comment">#重启后即可基于SSL访问</span><br></code></pre></td></tr></table></figure>

<p>​    SSL会话的简化过程​            </p>
<p>​            (1) 客户端发送可供选择的加密方式，并向服务器请求证书；<br>​            (2) 服务器端发送证书以及选定的加密方式给客户端；<br>​            (3) 客户端取得证书并进行证书验正：<br>​                如果信任给其发证书的CA：<br>​                    (a) 验正证书来源的合法性；用CA的公钥解密证书上数字签名；<br>​                    (b) 验正证书的内容的合法性：完整性验正<br>​                    (c) 检查证书的有效期限；<br>​                    (d) 检查证书是否被吊销；<br>​                    (e) 证书中拥有者的名字，与访问的目标主机要一致；<br>​            (4) 客户端生成临时会话密钥（对称密钥），并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换；<br>​            (5) 服务用此密钥加密用户请求的资源，响应给客户端；</p>
<p>​            注意：SSL会话是基于IP地址创建；所以单IP的主机上，仅可以使用一个https虚拟主机；</p>
<p>​        回顾几个术语：PKI，CA，CRL，X.509 (v1, v2, v3)</p>
<p>​        配置httpd支持https：<br>​            (1) 为服务器申请数字证书；<br>​                测试：通过私建CA发证书<br>​                    (a) 创建私有CA<br>​                    (b) 在服务器创建证书签署请求<br>​                    (c) CA签证<br>​<br>​            (2) 配置httpd支持使用ssl，及使用的证书；</p>
<p>yum -y install mod_ssl</p>
<p>​                配置文件：/etc/httpd/conf.d/ssl.conf<br>​                    DocumentRoot<br>​                    ServerName<br>​                    SSLCertificateFile<br>​                    SSLCertificateKeyFile<br>​<br>​            (3) 测试基于https访问相应的主机；</p>
<p>openssl  s_client  [-connect host:port] [-cert filename] [-CApath directory] [-CAfile filename]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">建立https：<br>将httpd.csr向CA申请证书签署后的httpd.crt放在&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;ssl目录中才进行以下步骤<br>[root@ashjian ~]#cd &#x2F;etc&#x2F;httpd&#x2F;conf.d<br>[root@ashjian conf.d]#ls<br>autoindex.conf  README  ssl.conf  ssl.conf.bak  userdir.conf  welcome.conf<br>[root@ashjian conf.d]#vim ssl.conf<br># General setup for the virtual host, inherited from global configuration<br>DocumentRoot &quot;&#x2F;var&#x2F;www&#x2F;html&quot;<br>ServerName www.ashjian.xyz:443<br></code></pre></td></tr></table></figure>

<h3 id="18、httpd自带的工具程序"><a href="#18、httpd自带的工具程序" class="headerlink" title="18、httpd自带的工具程序"></a>18、httpd自带的工具程序</h3><p>​<br>​        htpasswd：basic认证基于文件实现时，用到的账号密码文件生成工具；<br>​        apachectl：httpd自带的服务控制脚本，支持start和stop；<br>​        apxs：由httpd-devel包提供，扩展httpd使用第三方模块的工具；<br>​        rotatelogs：日志滚动工具；<br>​            access.log –&gt;<br>​                access.log, access.1.log  –&gt;<br>​                    access.log, acccess.1.log, access.2.log<br>​        suexec：访问某些有特殊权限配置的资源时，临时切换至指定用户身份运行；<br>​        ab： apache bench<br>​        </p>
<h3 id="19、httpd的压力测试工具"><a href="#19、httpd的压力测试工具" class="headerlink" title="19、httpd的压力测试工具"></a>19、httpd的压力测试工具</h3><p>​            压力测试 ：benchmark<br>​        ab, webbench, http_load, seige<br>​        jmeter, loadrunner<br>​        tcpcopy：网易产品，复制生产环境中的真实请求，并将之保存下来；可用于将真实请求运用到测试模型中<br>​<br>​        ab  [OPTIONS]  URL<br>​            -n：总请求数；<br>​            -c：模拟的并行数；<br>​            -k：以持久连接模式 测试；</p>
<p>课外作业：理解ab命令执行结果输出信息的意义；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#ab -n 10000 -c 10 http://www.ashjian.xyz/index.html </span><br><span class="hljs-comment">#ab访问URL要制定具体内容</span><br>This is ApacheBench, Version 2.3 &lt;<span class="hljs-variable">$Revision</span>: 1430300 $&gt;<br>Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>Licensed to The Apache Software Foundation, http://www.apache.org/<br><br>Benchmarking www.ashjian.xyz (be patient)<br>Completed 1000 requests<br>Completed 2000 requests<br>Completed 3000 requests<br>Completed 4000 requests<br>Completed 5000 requests<br>Completed 6000 requests<br>Completed 7000 requests<br>Completed 8000 requests<br>Completed 9000 requests<br>Completed 10000 requests<br>Finished 10000 requests<br><br><br>Server Software:        Apache/2.4.6<br>Server Hostname:        www.ashjian.xyz<br>Server Port:            80<br><br>Document Path:          /index.html<br>Document Length:        13 bytes<br><br>Concurrency Level:      10  <span class="hljs-comment">#并发级别</span><br>Time taken <span class="hljs-keyword">for</span> tests:   81.149 seconds <span class="hljs-comment">#总共测试花费时间</span><br>Complete requests:      10000<br>Failed requests:        0<br>Write errors:           0<br>Total transferred:      2920000 bytes <span class="hljs-comment">#总共传输数据量，2.7MB，需要带宽.2.7*8=21.6Mb的带宽，而本机带宽为1Mb</span><br>HTML transferred:       130000 bytes <span class="hljs-comment">#实际响应返回的内容主体总共数据量，去除了报文首部</span><br>Requests per second:    123.23 [<span class="hljs-comment">#/sec] (mean) #每秒钟完成的请求数量</span><br>Time per request:       81.149 [ms] (mean) <span class="hljs-comment">#同时并发X个请求，这X个请求总共花费的时间</span><br>Time per request:       8.115 [ms] (mean, across all concurrent requests)<br><span class="hljs-comment">#重要指标，平均每个请求要花费的时间</span><br>Transfer rate:          35.14 [Kbytes/sec] received <span class="hljs-comment">#传输速率。测试环境可以查看这个需要线上需妖多大的带宽</span><br><br>Connection Times (ms)<br>              min  mean[+/-sd] median   max<br>                 <span class="hljs-comment">#平均时间      #中间时间</span><br>Connect:        0   65 257.3      0    3008<br>Processing:     0   16  89.3      0    3024<br>Waiting:        0   15  89.0      0    3024<br>Total:          1   80 275.7      1    4026<br><br>Percentage of the requests served within a certain time (ms)<br>  50%      1  <span class="hljs-comment">#50%的请求时，大概每个花费了1ms</span><br>  66%      1<br>  75%      1<br>  80%      1 <br>  90%    201<br>  95%   1002<br>  98%   1003<br>  99%   1004<br> 100%   4026 (longest request)<br></code></pre></td></tr></table></figure>

<h2 id="httpd-2-4："><a href="#httpd-2-4：" class="headerlink" title="httpd-2.4："></a>httpd-2.4：</h2><h3 id="新特性："><a href="#新特性：" class="headerlink" title="新特性："></a>新特性：</h3><p>​    (1) MPM支持运行为DSO机制；以模块形式按需加载；<br>​    (2) event MPM生产环境可用；<br>​    (3) 异步读写机制；<br>​    (4) 支持每模块及每目录的单独日志级别定义；<br>​    (5) 每请求相关的专用配置；<br>​    (6) 增强版的表达式分析式；<br>​    (7) 毫秒级持久连接时长定义；<br>​    (8) 基于FQDN的虚拟主机也不再需要NameVirutalHost指令；<br>​    (9) 新指令，AllowOverrideList；<br>​    (10) 支持用户自定义变量；<br>​    (11) 更低的内存消耗；<br>​<br>新模块：<br>​    (1) mod_proxy_fcgi<br>​    (2) mod_proxy_scgi<br>​    (3) mod_remoteip<br>​    </p>
<h3 id="安装httpd-2-4"><a href="#安装httpd-2-4" class="headerlink" title="安装httpd-2.4"></a>安装httpd-2.4</h3><p>​    依赖于apr-1.4+, apr-util-1.4+, [apr-iconv]<br>​        apr： apache portable runtime<br>​<br>​    CentOS 6：<br>​        默认：apr-1.3.9, apr-util-1.3.9<br>​<br>​        开发环境包组：Development Tools, Server Platform Development<br>​        开发程序包：pcre-devel<br>​<br>​        编译安装步骤：<br>​            (1) apr-1.4+</p>
<p>./configure  –prefix=/usr/local/apr</p>
<p>make &amp;&amp; make install</p>
<p>​                (2) apr-util-1.4+<br>​                    # ./configure  –prefix=/usr/local/apr-util  –with-apr=/usr/local/apr<br>​                    # make &amp;&amp; make install</p>
<p>​                (3) httpd-2.4<br>​                    # ./configure –prefix=/usr/local/apache24 –sysconfdir=/etc/httpd24  –enable-so –enable-ssl –enable-cgi –enable-rewrite –with-zlib –with-pcre –with-apr=/usr/local/apr –with-apr-util=/usr/local/apr-util –enable-modules=most –enable-mpms-shared=all –with-mpm=prefork<br>​                    # make  &amp;&amp; make install</p>
<p>​                    自带的服务控制脚本：apachectl<br>​<br>​        CentOS 7：<br>​            # yum install  httpd</p>
<p>​            配置文件：<br>​                /etc/httpd/conf/httpd.conf<br>​                /etc/httpd/conf.modules.d/<em>.conf<br>​                /etc/httpd/conf.d/</em>.conf<br>​<br>​            配置应用：<br>​                (1) 切换使用的MPM<br>​                    编辑配置文件/etc/httpd/conf.modules.d/00-mpm.conf，启用要启用的MPM相关的LoadModule指令即可。<br>​<br>​                (2) 基于IP的访问控制<br>​                    允许所有主机访问：Require  all  granted<br>​                    拒绝所有主机访问：Require  all  deny<br>​<br>​                    控制特定的IP访问：<br>​                        Require  ip  IPADDR：授权指定来源的IP访问；<br>​                        Require  not  ip  IPADDR：拒绝<br>​<br>​                    控制特定的主机访问：<br>​                        Require  host  HOSTNAME：授权指定来源的主机访问；<br>​                        Require  not  host  HOSTNAME：拒绝<br>​<br>​                        HOSTNAME：<br>​                            FQDN：特定主机<br>​                            domin.tld：指定域名下的所有主机<br>​<br>​                    <RequireAll><br>​                        Require all granted<br>​                        Require not ip 172.16.100.2<br>​                    </RequireAll><br>​<br>​                (3) 虚拟主机<br>​                    基于FQDN的虚拟主机也不再需要NameVirutalHost指令；<br>​<br>​                    &lt;VirtualHost *:80&gt;<br>​                        ServerName <a href="http://www.b.net" target="_blank" rel="noopener">www.b.net</a><br>​                        DocumentRoot “/apps/b.net/htdocs”<br>​                        &lt;Directory “/apps/b.net/htdocs”&gt;<br>​                            Options None<br>​                            AllowOverride None<br>​                            Require all granted<br>​                        </Directory><br>​                    </VirtualHost><br>​<br>​                    注意：任意目录下的页面只有显式授权才能被访问；<br>​<br>​                (4) ssl<br>​<br>​                (5)  KeepAliveTimeout  #ms<br>​                    毫秒级持久连接时长定义；<br>​<br>练习题：分别使用httpd-2.2和httpd-2.4实现；</p>
<p>​    1、建立httpd服务，要求：<br>​        (1) 提供两个基于名称的虚拟主机：<br>​            www1.stuX.com，页面文件目录为/web/vhosts/www1；错误日志为/var/log/httpd/www1/error_log，访问日志为/var/log/httpd/www1/access_log；<br>​            www2.stuX.com，页面文件目录为/web/vhosts/www2；错误日志为/var/log/httpd/www2/error_log，访问日志为/var/log/httpd/www2/access_log；<br>​        (2) 通过www1.stuX.com/server-status输出其状态信息，且要求只允许提供账号的用户访问；<br>​        (3) www1不允许192.168.1.0/24网络中的主机访问；<br>​<br>​    2、为上面的第2个虚拟主机提供https服务，使得用户可以通过https安全的访问此web站点；<br>​        (1) 要求使用证书认证，证书中要求使用国家（CN），州（Beijing），城市（Beijing），组织为(MageEdu)；<br>​        (2) 设置部门为Ops, 主机名为www2.stuX.com；</p>
<p>​<br>​            </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>04-inode和软硬链接</title>
    <url>/04-inode%E5%92%8C%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14975178420460.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200817212137.png" alt="img"></a></p>
<p>关于inode是什么，可以看这篇文章：<a href="http://www.cnblogs.com/adforce/p/3522433.html" target="_blank" rel="noopener">http://www.cnblogs.com/adforce/p/3522433.html</a></p>
<hr>
<h3 id="如何查看inode"><a href="#如何查看inode" class="headerlink" title="如何查看inode"></a>如何查看inode</h3><p><code>ll -di /boot / /app</code><br>查看文件和文件夹的inode号</p>
<p><code>df -i</code><br>查看挂载点文件夹的inode号</p>
<hr>
<h3 id="做inode增长实验"><a href="#做inode增长实验" class="headerlink" title="做inode增长实验"></a>做inode增长实验</h3><p><strong>创建60万个文件的方法1（效率不高）：</strong><br><code>for i in {1..600000}; do touch file$1; echo file$i is created;done</code><br><strong>创建60万个文件的方法2（效率高）：</strong><br><code>echo file{1..600000} | touch</code><br><strong>删除前20万个文件：<code>echo file{1..200000} |args rm</code></strong></p>
<p><strong>在创建的过程中，可以另开一个窗口，用下面命令，每隔1秒运行df -hi命令，可以查看inode的增长情况：</strong><br><code>watch -n1 df -hi</code></p>
<blockquote>
<p>tips：文件粉碎工具<code>shred</code>：<code>shred -uzvn10 FILE</code>重复随机写入10次覆盖源文件，然后最后删除此文件。</p>
</blockquote>
<hr>
<h3 id="硬链接、软链接"><a href="#硬链接、软链接" class="headerlink" title="硬链接、软链接"></a>硬链接、软链接</h3><p>软链接就相当于Windows的快捷方式，删掉源文件，快捷方式和就失效了，软链接就找不到源文件了。</p>
<p>硬链接相当于多个链接指向同一份数据存储区域，每多一个硬链接，硬链接数+1，如果一个文件，有n个硬链接，删除n-1个硬链接，源文件还在，直到删除所有硬链接，才会删除源文件。</p>
<p><strong>1. 复制（<code>cp</code>）</strong></p>
<p>在<strong>复制</strong>过程中，复制<strong>软连接</strong>相当于复制了快捷方式，速度很快，而且可以跨分区。</p>
<p>在<strong>复制</strong>过程中，复制<strong>硬链接</strong>分为两种情形：</p>
<ul>
<li>在<strong>同一分区</strong>复制，相当于多创建一个链接指向原数据存储位置，速度很快。</li>
<li>在<strong>不同分区</strong>复制，相当于把原来分区的数据拷贝过去存储，同时创建一个指向新数据区域的指针，速度比较慢。</li>
</ul>
<p><strong>2. 删除（<code>rm</code>）</strong><br>在<strong>删除</strong>过程中，删除<strong>软连接</strong>相当于删除了快捷方式，源文件还在。<br>在<strong>删除</strong>过程中，删除<strong>硬连接</strong>相当于删除了一个到数据块的指针，，除非删除所有硬链接文件，源文件才删除。</p>
<p><strong>3. 移动（<code>mv</code>）</strong><br>在<strong>移动</strong>过程中，移动<strong>软连接</strong>相当于移动了快捷方式而已。<br>在<strong>移动</strong>过程中，移动<strong>硬连接</strong>分为两种情形：</p>
<ul>
<li>在<strong>同一分区</strong>移动，相当于创建了一个新inode，指向数据块，并把原来的inode删掉</li>
<li>在<strong>不同分区</strong>移动，要把数据块复制到新分区，然后在新分区创建新的inode号指向新的数据块，并且把原来分区的inode号和数据块都删掉。</li>
</ul>
<p><strong>4. 软连接支持对目录创建，硬链接不支持</strong></p>
<p><code>ln dir1 dir2</code>不成功</p>
<p><code>ln /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/ens33</code>成功</p>
<blockquote>
<p>tips1：当我们看到一个磁盘，使用空间没满，但是却提示”no space left on device”，那可能是inode用完了。</p>
<p>tips2：如何删除数量很多的文件（比如前面做实验创建的60万个文件。）:<br>技巧是使用管道<code>|</code>和<code>xargs</code>，管道<code>|</code>后面会讲，管道是指的是前面命令的输出作为后面命令的输入。<code>xargs</code>，前面命令多个输出，可以用<code>xargs</code>一个个的传给后面的命令，而不是已下载全传给后面命令，可以解决参数太长的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls | xargs rm<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>5. 如何写软连接相对路径</strong></p>
<p>软连接写相对路径，要根据<strong>软连接文件的路径</strong>来写。</p>
<p>例如要在把/etc/issue 软连接到/app/d1/d2/d3/ilink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ln -s ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;issue &#x2F;app&#x2F;d1&#x2F;d1&#x2F;d3&#x2F;ilink<br></code></pre></td></tr></table></figure>

<hr>
<p><strong>6. 如何软链接设备文件</strong></p>
<p>设备文件比较特殊，如果要创建设备文件的链接，需要用到<code>mknod</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 etc]# ll &#x2F;dev&#x2F;sda<br>brw-rw----. 1 root disk 8, 0 May 22 09:06 &#x2F;dev&#x2F;sda #得到主设备号和复设备号。<br>mknod &#x2F;app&#x2F;sda b 8 0<br><br>ll -i &#x2F;dev&#x2F;sda &#x2F;app&#x2F;sda<br></code></pre></td></tr></table></figure>

<h4 id="软链接练习："><a href="#软链接练习：" class="headerlink" title="软链接练习："></a>软链接练习：</h4><ol>
<li>创建一个目录<code>tomcat-8.5.23</code>，创建一个软连接tomcat到这个目录；在创建一个目录<code>tomcat-9.0.1</code>, 把tomcat的软连接指向新的<code>tomcat-9.0.1</code>目录。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ln -sv tomcat-8.5.23 tomcat<br>rm -rf tomcat<br>ln -sv tomcat-9.0.1 tomcat<br></code></pre></td></tr></table></figure>

<ol>
<li>创建一个目录<code>/mnt/lfs/tools</code>， 然后创建<code>/mnt/lfs/tools</code>的软连接<code>/tools</code>，一般有这样的命令：<code>ln -sv /mnt/lfs/tools /tools</code>，如何可以更短？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir -v &#x2F;mnt&#x2F;lfs&#x2F;tools<br>ln -sv &#x2F;mnt&#x2F;lfs&#x2F;tools &#x2F;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><p>常用选项:</p>
<p><code>-b</code> 列出文件辨识结果时，不显示文件名称</p>
<p><code>-f</code> 列出文件中文件名的文件类型</p>
<p><code>-F</code> 使用指定分隔符号替换输出文件名后默认的”:”分隔符</p>
<p><code>-L</code> 查看对应软链接对应文件的文件类型</p>
<p><code>--help</code> 显示命令在线帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">file &#x2F;etc&#x2F;system-relase<br></code></pre></td></tr></table></figure>

<p>file命令就是查看的文件头部的信息，可以用<code>hexdump</code>查看源文件源码信息 （也可以用<code>xxd</code>命令看）。</p>
<p>如果是二进制文件，会显示二进制的头信息。</p>
<p>如果是文本文件，就直接是文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# hexdump -C -n 100 &#x2F;bin&#x2F;ls<br>00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|<br>00000010  02 00 3e 00 01 00 00 00  48 4b 40 00 00 00 00 00  |..&gt;.....HK@.....|<br>00000020  40 00 00 00 00 00 00 00  18 c4 01 00 00 00 00 00  |@...............|<br>00000030  00 00 00 00 40 00 38 00  09 00 40 00 1e 00 1d 00  |....@.8...@.....|<br>00000040  06 00 00 00 05 00 00 00  40 00 00 00 00 00 00 00  |........@.......|<br>00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|<br>00000060  f8 01 00 00                                       |....|<br>00000064<br><br>[root@centos7 ~]# hexdump -C -n 100 &#x2F;etc&#x2F;issue<br>00000000  5c 53 0a 4b 65 72 6e 65  6c 20 5c 72 20 6f 6e 20  |\S.Kernel \r on |<br>00000010  61 6e 20 5c 6d 0a                                 |an \m.|<br>00000016<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="readlink命令"><a href="#readlink命令" class="headerlink" title="readlink命令"></a>readlink命令</h2><p>读取软连接指向的真实路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 ~]☭ readlink &#x2F;etc&#x2F;redhat-release <br>centos-release<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>inodes</tag>
      </tags>
  </entry>
  <entry>
    <title>04-别名（Alias）的使用</title>
    <url>/04-%E5%88%AB%E5%90%8D%EF%BC%88Alias%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>主要用到两个命令：alias<code>&amp;</code>unalias`</strong></p>
<ul>
<li><code>alias</code>：显示当前使用的别名。</li>
<li><code>alias NAME=&quot;XXXX&quot;</code>：给某段命令或路径加别名</li>
<li><code>unalias NAME</code>：去掉某个命令的别名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-variable">$alias</span> cdnet=<span class="hljs-string">"cd /etc/sysconfig/network-scripts/"</span><br>[root@ashjian ~]<span class="hljs-variable">$cdnet</span><br>[root@ashjian network-scripts]<span class="hljs-variable">$pwd</span><br>/etc/sysconfig/network-scripts<br>[root@ashjian network-scripts]<span class="hljs-variable">$alias</span><br><span class="hljs-built_in">alias</span> cdnet=<span class="hljs-string">'cd /etc/sysconfig/network-scripts/'</span><br><span class="hljs-built_in">alias</span> cp=<span class="hljs-string">'cp -i'</span><br><span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">'egrep --color=auto'</span><br><span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">'fgrep --color=auto'</span><br><span class="hljs-built_in">alias</span> grep=<span class="hljs-string">'grep --color=auto'</span><br><span class="hljs-built_in">alias</span> l.=<span class="hljs-string">'ls -d .* --color=auto'</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">'ls -l --color=auto'</span><br><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">'ls --color=auto'</span><br><span class="hljs-built_in">alias</span> mv=<span class="hljs-string">'mv -i'</span><br><span class="hljs-built_in">alias</span> rm=<span class="hljs-string">'rm -i'</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">which</span>=<span class="hljs-string">'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span><br>[root@ashjian network-scripts]<span class="hljs-variable">$unalias</span> cdnet<br>[root@ashjian network-scripts]<span class="hljs-variable">$alias</span><br><span class="hljs-built_in">alias</span> cp=<span class="hljs-string">'cp -i'</span><br><span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">'egrep --color=auto'</span><br><span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">'fgrep --color=auto'</span><br><span class="hljs-built_in">alias</span> grep=<span class="hljs-string">'grep --color=auto'</span><br><span class="hljs-built_in">alias</span> l.=<span class="hljs-string">'ls -d .* --color=auto'</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">'ls -l --color=auto'</span><br><span class="hljs-built_in">alias</span> ls=<span class="hljs-string">'ls --color=auto'</span><br><span class="hljs-built_in">alias</span> mv=<span class="hljs-string">'mv -i'</span><br><span class="hljs-built_in">alias</span> rm=<span class="hljs-string">'rm -i'</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">which</span>=<span class="hljs-string">'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span><br></code></pre></td></tr></table></figure>

<p><strong>不用别名，用原始命令的话，可以用下面的方法：</strong></p>
<ul>
<li><code>\COMMAND</code></li>
<li><code>&#39;COMMAND&#39;</code></li>
<li><code>&#39;/PATH/TO/COMMAND&#39;</code></li>
</ul>
<p>如下图，ls原始命令是带颜色的，用<code>\ls</code>后不带颜色了</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816144605.png" alt="image-20200815111321051"></p>
<p><strong>永久保存alias的方法：</strong></p>
<ul>
<li>针对一个用户的环境变量：更改<code>vim ~/.bashrc</code>文件</li>
<li>针对全局用户：更改<code>/etc/bashrc</code>文件（不推荐，不同用户有不同需要和偏好）</li>
</ul>
<p>下面是某些alias设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">alias vi &#x3D;&quot;vim&quot;<br>alias cdnet&#x3D;&quot;cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&quot;<br>alias vimnet1&#x3D;&quot;vim &#x2F;etc&#x2F;syscofig&#x2F;network-scripts&#x2F;eth0&quot;<br>alias vimnet2&#x3D;&quot;vim &#x2F;etc&#x2F;syscofnig&#x2F;network-scripts&#x2F;eth1&quot;<br></code></pre></td></tr></table></figure>



<p>更改完成后，可以用<code>source</code>或<code>.</code>命令来使之立即生效，或者重启shell：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# source ~&#x2F;.bashrc <br>[root@centos7 ~]# . ~&#x2F;.bashrc<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>04-单网络双活模式的Keepalived+LVS-DR配置</title>
    <url>/04-%E5%8D%95%E7%BD%91%E7%BB%9C%E5%8F%8C%E6%B4%BB%E6%A8%A1%E5%BC%8F%E7%9A%84Keepalived+LVS-DR%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vagrant配置实验环境"><a href="#Vagrant配置实验环境" class="headerlink" title="Vagrant配置实验环境"></a>Vagrant配置实验环境</h2><p><code>Vagrantfile</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- mode: ruby -*-<br># vi: set ft&#x3D;ruby :<br><br>Vagrant.configure(&quot;2&quot;) do |config|<br>  # Vagrant Global Config<br>  # &#96;longdream&#x2F;centos7&#96; is a custom centos7 box made by YuLongjun.<br>  config.vm.box &#x3D; &quot;longdream&#x2F;centos7&quot;<br>  # If this box is add online, set true will check update.<br>  # Also set &#96;false&#96; will not update it.<br>  # If this box is added locally, this setting is invalid.<br>  config.vm.box_check_update &#x3D; false<br>  # you need &#96;vagrant plugin install vagrant-vbguest&#96;<br>  # You also need &#96;vagrant plugin install vagrant-hostmanager&#96;<br>  config.hostmanager.enabled &#x3D; true<br>  # Allow update &#96;&#x2F;etc&#x2F;hosts&#96; file in VMs.<br>  config.hostmanager.manage_guest &#x3D; true<br>  # Allow update &#96;&#x2F;etc&#x2F;hosts&#96; file in Hosts.<br>  config.hostmanager.manage_host &#x3D; true<br><br>  # Create VM ka1.<br>  config.vm.define &quot;ka1&quot; do |ka1|<br>    ka1.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.10&quot;<br>    ka1.vm.hostname &#x3D; &quot;ka1&quot;<br>  end<br><br>  # Create VM ka2.<br>  config.vm.define &quot;ka2&quot; do |ka2|<br>    ka2.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.20&quot;<br>    ka2.vm.hostname &#x3D; &quot;ka2&quot;<br>  end<br><br>  # Create VM web1.<br>  config.vm.define &quot;web1&quot; do |web1|<br>    web1.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.30&quot;<br>    web1.vm.hostname &#x3D; &quot;web1&quot;<br>  end<br><br>  # Create VM web2<br>  config.vm.define &quot;web2&quot; do |web2|<br>    web2.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.40&quot;<br>    web2.vm.hostname &#x3D; &quot;web2&quot;<br>  end<br><br>end<br></code></pre></td></tr></table></figure>

<p><code>vagrant up</code>启动4台虚拟机。</p>
<h2 id="配置Keepalived"><a href="#配置Keepalived" class="headerlink" title="配置Keepalived"></a>配置Keepalived</h2><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><p>（1）时间同步，略<br>（2）关闭SELinux和防火墙，略<br>（3）互相之间/etc/hosts文件添加对方主机名，略<br>（4）确认接口支持多播（组播），略，基本新的网卡都支持。</p>
<h3 id="配置ka1的keepalived服务"><a href="#配置ka1的keepalived服务" class="headerlink" title="配置ka1的keepalived服务"></a>配置ka1的keepalived服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y keepalived<br>systemctl enable keepalived<br>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf<br>global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 60<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br><br>vrrp_instance VI_2 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="配置ka2"><a href="#配置ka2" class="headerlink" title="配置ka2"></a>配置ka2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y keepalived<br>systemctl enable keepalived<br>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf<br>global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka2@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 60<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 191<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br>&#125;<br><br>vrrp_instance VI_2 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 192<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br>&#125;<br></code></pre></td></tr></table></figure>

<p>ka1和ka2分别放一个同样的脚本：<code>/etc/keepalived/notify.sh</code>，实现切换通知功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;keepalived&#x2F;notify.sh<br>#!&#x2F;bin&#x2F;bash<br>#<br>contact&#x3D;&#39;root@localhost&#39;<br>                <br>notify() &#123;<br>    local mailsubject&#x3D;&quot;$(hostname) to be $1, vip floating&quot;<br>    local mailbody&#x3D;&quot;$(date +&#39;%F %T&#39;): vrrp transition, $(hostname) changed to be $1&quot;<br>    echo &quot;$mailbody&quot; | mail -s &quot;$mailsubject&quot; $contact<br>&#125;<br>                <br>case $1 in<br>master)<br>    notify master   <br>    ;;<br>backup)<br>    notify backup   <br>    ;;<br>fault)<br>    notify fault    <br>    ;;<br>*)<br>    echo &quot;Usage: $(basename $0) &#123;master|backup|fault&#125;&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<h2 id="测试keepalived功能"><a href="#测试keepalived功能" class="headerlink" title="测试keepalived功能"></a>测试keepalived功能</h2><p>ka1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start keepalived.service<br>systemctl status keepalived.service<br>ip a<br></code></pre></td></tr></table></figure>

<p>在ka2没启动前，ka1先添加了ip<code>192.168.111.100</code>，监测不到<code>192.168.111.200</code>，又添加了<code>192.168.111.200</code>。<br><a href="http://www.yulongjun.com/images/15048045240806.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135739.jpg" alt="img"></a></p>
<p>ka2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start keepalived.service<br>systemctl status keepalived.service<br>ip a<br></code></pre></td></tr></table></figure>

<p>ka2一启动，ka1就移除了<code>192.168.111.200</code>，ka2就添加了<code>192.168.111.200</code></p>
<p><a href="http://www.yulongjun.com/images/15048046348253.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135740.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15048048822883.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135741.jpg" alt="img"></a></p>
<p>我们停掉ka1的keepalived服务：</p>
<p>ka1就移除了了<code>192.168.111.100</code><br>ka2就添加了<code>192.168.111.100</code></p>
<p>我们还可以通过<code>tcpdump</code>命令来分别查看组播状态。</p>
<p>ka1和ka2都可运行下面命令来查看组播地址检查心跳的状态:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tcpdump -nn -i eth1 host 224.111.111.111<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15048046896714.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135742.jpg" alt="img"></a></p>
<blockquote>
<p>tips：在虚拟机软件里，关闭网卡物理连接，ip也是可以漂移的。</p>
</blockquote>
<p>至此，vrrp的的高可用测试完毕。我们继续配置LVS相关的配置。</p>
<h2 id="配置LVS相关的配置。"><a href="#配置LVS相关的配置。" class="headerlink" title="配置LVS相关的配置。"></a>配置LVS相关的配置。</h2><h3 id="配置VS-Virtual-Server-也叫Director"><a href="#配置VS-Virtual-Server-也叫Director" class="headerlink" title="配置VS(Virtual Server,也叫Director)"></a>配置VS(Virtual Server,也叫Director)</h3><p>我们分别在ka1(ka1也是vs1)和ka2(ka2也是vs2)上安装lvs，然后停止keepalived服务，添加VS配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl stop keepalived<br></code></pre></td></tr></table></figure>

<p>分别修改<code>/etc/keepalived/keepalived.conf</code>,在后面添加Virtual Server相关的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">virtual_server 192.168.111.100 80 &#123;<br>    delay_loop 3<br>    lb_algo rr<br>    lb_kind DR<br>    protocol TCP<br>    sorry_server 127.0.0.1 80<br><br>    real_server 192.168.111.30 80 &#123;<br>        weight 1<br>        HTTP_GET &#123;<br>            url &#123;<br>              path &#x2F;<br>              status_code 200<br>            &#125;<br>            connect_timeout 1<br>            nb_get_retry 3<br>            delay_before_retry 1<br>        &#125;<br>    &#125;<br>    real_server 192.168.111.40 80 &#123;<br>        weight 1<br>        HTTP_GET &#123;<br>            url &#123;<br>              path &#x2F;<br>              status_code 200<br>            &#125;<br>            connect_timeout 1<br>            nb_get_retry 3<br>            delay_before_retry 1<br>        &#125;<br>    &#125;<br>&#125;<br><br>virtual_server 192.168.111.200 80 &#123;<br>    delay_loop 3<br>    lb_algo rr<br>    lb_kind DR<br>    protocol TCP<br>    sorry_server 127.0.0.1 80<br><br>    real_server 192.168.111.30 80 &#123;<br>        weight 1<br>        HTTP_GET &#123;<br>            url &#123;<br>              path &#x2F;<br>              status_code 200<br>            &#125;<br>            connect_timeout 1<br>            nb_get_retry 3<br>            delay_before_retry 1<br>        &#125;<br>    &#125;<br>    real_server 192.168.111.40 80 &#123;<br>        weight 1<br>        HTTP_GET &#123;<br>            url &#123;<br>                path &#x2F;<br>                status_code 200<br>            &#125;<br>            connect_timeout 1<br>            nb_get_retry 3<br>            delay_before_retry 1<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述keepalived设置中的设置了<code>sorry_server</code>为本地的http服务，即要在ka1和ka2上做一个<br>Sorry Server，所以分别提供一个web服务（可采用httpd或者apache都行，这里采用的是httpd）对外say sorry：</p>
<p>ka1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y httpd<br>echo &quot;&lt;h1&gt;Sorry Server@ka1&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html<br>systemctl start httpd<br>systemctl enable httpd<br>systemctl start keepalived<br>systemctl enable keepalived<br></code></pre></td></tr></table></figure>

<p>ka2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y httpd<br>echo &quot;&lt;h1&gt;Sorry Server@ka2&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html<br>systemctl start httpd<br>systemctl enable httpd<br>systemctl start keepalived<br>systemctl enable keepalived<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实验环境为了显示不同，故意设置成不同的页面，实际生产获取的内容应该保持一致。</p>
</blockquote>
<h3 id="配置RS-Real-Server-web1和web2"><a href="#配置RS-Real-Server-web1和web2" class="headerlink" title="配置RS(Real Server)web1和web2"></a>配置RS(Real Server)web1和web2</h3><p>web1和web2分别安装httpd或者nginx作为http服务，这里安装的httpd：</p>
<p>web1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y httpd<br>echo &quot;&lt;h1&gt;Real Server 1&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html<br>systemctl start httpd<br>systemctl enable httpd<br></code></pre></td></tr></table></figure>

<p>web2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y httpd<br>echo &quot;&lt;h1&gt;Real Server 2&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html<br>systemctl start httpd<br>systemctl enable httpd<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实验环境为了显示不同，故意设置成不同的页面，实际生产中获取的内容应该一致。</p>
</blockquote>
<p>web1 和web2 上添加脚本<strong><code>set_rs.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim ~&#x2F;set_rs.sh<br>#!&#x2F;bin&#x2F;bash<br>vip1&#x3D;192.168.111.100<br>vip2&#x3D;192.168.111.200<br>dev1&#x3D;lo:1<br>dev2&#x3D;lo:2<br><br>case $1 in<br>start)<br>    echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore<br>    echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore<br>    echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce<br>    echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce<br>    ifconfig $dev1 $vip1 netmask 255.255.255.255 broadcast $vip1 up<br>    ifconfig $dev2 $vip2 netmask 255.255.255.255 broadcast $vip2 up<br>    echo &quot;VS Server is Ready!&quot;<br>    ;;<br>stop)<br>    ifconfig $dev down<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce<br>    echo &quot;VS Server is Cancel!&quot;<br>    ;;<br>*)<br>    echo &quot;Usage &#96;basename $0&#96; start|stop&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<p>分别运行<code>bash set_rs.sh start</code>。</p>
<h2 id="总体测试"><a href="#总体测试" class="headerlink" title="总体测试"></a>总体测试</h2><p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for i in &#96;seq 5&#96;; do <br>    curl 192.168.111.100<br>    curl 192.168.111.200<br>done<br></code></pre></td></tr></table></figure>

<p>全部开启的情况下测试：<br><a href="http://www.yulongjun.com/images/15048061557723.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135743.jpg" alt="img"></a></p>
<p>关闭web2的httpd服务：</p>
<p><a href="http://www.yulongjun.com/images/15048062543906.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135744.jpg" alt="img"></a></p>
<p>关闭ka2的keepalived服务：</p>
<p><a href="http://www.yulongjun.com/images/15048063509732.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135745.jpg" alt="img"></a></p>
<p>关闭 web1的httpd服务：</p>
<p><a href="http://www.yulongjun.com/images/15048064413294.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135746.jpg" alt="img"></a></p>
<h2 id="完整配置文件附录"><a href="#完整配置文件附录" class="headerlink" title="完整配置文件附录"></a>完整配置文件附录</h2><p>附上所有完整配置文件的下载链接：(用的七牛云存储，点击即可下载，或者右键“链接另存为”下载）</p>
<p>实验环境的Vagrant配置文件<code>Vagrantfile</code>：<a href="http://ovzo6osb0.bkt.clouddn.com/Vagrantfile" target="_blank" rel="noopener">Vagrantfile</a></p>
<p>ka1的Keepalived配置文件<code>/etc/keepalived/keepalived.conf</code>：<a href="http://ovzo6osb0.bkt.clouddn.com/keepalived.conf(ka1)" target="_blank" rel="noopener">keepalived.conf(ka1)</a></p>
<p>ka2的Keepalived配置文件<code>/etc/keepalived/keepalived.conf</code>： <a href="http://ovzo6osb0.bkt.clouddn.com/keepalived.conf(ka2)" target="_blank" rel="noopener">keepalived.conf(ka2)</a></p>
<p>ka1和ka2的Keepalived调用的通知脚本<code>/etc/keepalived/notify.sh</code>：<a href="http://ovzo6osb0.bkt.clouddn.com/notify.sh" target="_blank" rel="noopener">notify.sh</a></p>
<p>ღ ღ ღ 如果觉得文章对您有用，不妨打赏一下ღ ღ ღ</p>
<p>赏</p>
<ul>
<li><strong>本文作者：</strong> 于龙君</li>
<li><strong>本文链接：</strong> <a href="http://www.yulongjun.com/lb/20170904-04-keepalived-lvs/" target="_blank" rel="noopener">http://www.yulongjun.com/lb/20170904-04-keepalived-lvs/</a></li>
<li><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>04-单网络双活模式的Keepalived+LVS-DR配置</title>
    <url>/04-%E5%8D%95%E7%BD%91%E7%BB%9C%E5%8F%8C%E6%B4%BB%E6%A8%A1%E5%BC%8F%E7%9A%84Keepalived-LVS-DR%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>04-安装使用vsftpd</title>
    <url>/04-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8vsftpd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[root@ashjian videos]#yum install -y vsftpd<br>[root@ashjian videos]#rpm -ql vsftpd<br>/etc/logrotate.d/vsftpd<br>/etc/pam.d/vsftpd<br>/etc/vsftpd<br>/etc/vsftpd/ftpusers<br>/etc/vsftpd/user_list<br>/etc/vsftpd/vsftpd.conf<br>/etc/vsftpd/vsftpd_conf_migrate.sh<br>/usr/lib/systemd/system-generators/vsftpd-generator<br>/usr/lib/systemd/system/vsftpd.service #作为独立的进程的unit file，独立进程在在系统启动后启动<br>/usr/lib/systemd/system/vsftpd.target #作为托管进程给systemd的unit file，托管进程在系统启动后不一启动<br>/usr/lib/systemd/system/vsftpd@.service<br>/usr/sbin/vsftpd #主程序<br>[root@ashjian videos]#systemctl start vsftpd<br>[root@ashjian videos]#ps aux | grep vsftpd<br>root      6893  0.0  0.0  53284   576 ?        Ss   20:37   0:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf<br>root     16837  0.0  0.0 112712   968 pts/0    R+   21:25   0:00 grep –color=auto vsftpd<br>[root@ashjian videos]#ss -ntl 查看10和21端口是否开启<br>[root@ashjian videos]#grep “^ftp” /etc/passwd<br>ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin #ftp的家目录，则vsftp默认访问的根目录是ftp的家目录，默认是匿名访问则是访问ftp的用户，匿名默认只有查看权限<br>[root@ashjian videos]#curl <a href="ftp://www.ashjian.xyz/">ftp://www.ashjian.xyz/</a><br>drwxr-xr-x    2 0        0            4096 Apr 01 04:55 pub<br>[root@ashjian videos]#ll /var/ftp/<br>total 4<br>drwxr-xr-x. 2 root root 4096 Apr  1 12:55 pub<br>[root@ashjian videos]#lftp -u ftp 172.16.0.3 #使用lftp工具来访问<br>Password:  #密码为空，直接回车。对应匿名访问和ftp用户来说，密码是空的<br>lftp <a href="mailto:ftp@172.16.0.3">ftp@172.16.0.3</a>:~&gt; ls<br>drwxr-xr-x    2 0        0            4096 Apr 01 04:55 pub<br>root@ashjian videos]#lftp -u anonymous 172.16.0.3 #匿名登录也可以用anonymous代替ftp<br>[root@ashjian videos]#cp -a /etc/vsftpd/vsftpd.conf{,.bak}<br>[root@ashjian videos]#vim /etc/vsftpd/vsftpd.conf</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>04-权限和ACL练习题</title>
    <url>/04-%E6%9D%83%E9%99%90%E5%92%8CACL%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、在<code>/testdir/dir</code>里创建的新文件自动属于<code>g1</code>组，组 <code>g2</code>的成员如：<code>alice</code>能对这些新文件有读写权限，组<code>g3</code> 的成员如：<code>tom</code>只能对新文件有读权限，其它用户（不 属于<code>g1</code>,<code>g2</code>,<code>g3</code>）不能访问这个文件夹。</p>
<p>前期准备：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# echo g&#123;1,2,3&#125; |xargs -n 1 groupadd<br>[root@ashjian ~]# tail -n 3 &#x2F;etc&#x2F;group<br>g1:x:1002:<br>g2:x:1003:<br>g3:x:1004:<br>[root@ashjian ~]# useradd alice -g g2<br>[root@ashjian ~]# useradd tom -g g3<br></code></pre></td></tr></table></figure>

<p>题目解答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">chgrp g1 &#x2F;testdir&#x2F;dir<br>chmod g+s &#x2F;testdir&#x2F;dir<br>setfacl -Rm d:g:g2:rw &#x2F;testdir&#x2F;dir  #default_acl的除了-d另一种设置方法d:<br>setfacl -Rm d:g:g3:r &#x2F;testdir&#x2F;dir<br>chmod o&#x3D; &#x2F;testdir&#x2F;dir<br></code></pre></td></tr></table></figure>

<hr>
<p>2、备份<code>/testdir/dir</code>里所有文件的ACL权限到<code>/root/acl.txt</code>中，清除<code>/testdir/dir</code>中所有ACL权限 ，最后还原ACL权限。</p>
<p>题目解答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 备份权限<br>[root@ashjian &#x2F;]# getfacl -R &#x2F;testdir&#x2F;dir &gt; &#x2F;root&#x2F;acl.txt<br># 清除&#x2F;testdir&#x2F;dir权限<br>[root@ashjian &#x2F;]# setfacl -Rb &#x2F;testdir&#x2F;dir<br><br># 还原ACL权限，两种方法。<br># 第一种绝对路径法：<br>setfacl --set-file&#x3D;&#x2F;root&#x2F;acl.txt &#x2F;testdir&#x2F;dir<br><br># 第二种相对路径法（查看acl.txt看是相对路径testdir&#x2F;dir,是相对于&#x2F;的，所以先cd到&#x2F;,这步不能省）：<br>[root@ashjian &#x2F;]# cd &#x2F;<br>[root@ashjian &#x2F;]# setfacl --restore &#x2F;root&#x2F;acl.txt<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
        <tag>ACL</tag>
      </tags>
  </entry>
  <entry>
    <title>04-条件测试</title>
    <url>/04-%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>条件测试分为三种，我们通过<code>man test</code>可以看到大部分的条件测试。</p>
<p><code>test</code> 命令可以写成<code>[ EXPRESSION ]</code>，这种写法，中括号两边要有空格，表达式是比较的，每一段都要有空格。</p>
<blockquote>
<p>tips: 还有一种<code>[[ EXPRESSION ]]</code>的写法，这种写法支持通配符（globing）,一般用通配符的时候才会去用，尽量用单中括号来写。</p>
</blockquote>
<p><code>test</code>命令可以判断三类条件：</p>
<ul>
<li>数值比较</li>
<li>字符串比较</li>
<li>文件比较</li>
</ul>
<hr>
<h2 id="算术比较"><a href="#算术比较" class="headerlink" title="算术比较"></a>算术比较</h2><table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">英文描述</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>n1 -eq n2</code></td>
<td align="left">equal</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left"><code>n1 -ge n2</code></td>
<td align="left">greater equal</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left"><code>n1 -gt n2</code></td>
<td align="left">greater than</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left"><code>n1 -le n2</code></td>
<td align="left">less equal</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left"><code>n1 -lt n2</code></td>
<td align="left">less than</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left"><code>n1 -ne n2</code></td>
<td align="left">not equal</td>
<td align="left">不等于</td>
</tr>
</tbody></table>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="EXPRESSION"><a href="#EXPRESSION" class="headerlink" title="[ EXPRESSION ]"></a><code>[ EXPRESSION ]</code></h3><blockquote>
<p>tips：<code>[ EXPRESSION ]</code>这种方法的时候，<code>&gt;``&lt;</code>号记得加<code>\</code>转义。</p>
<p>用于字符串比较时的用到的操作数都应该使用引号</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>str1 == str2</code></td>
<td align="left">相同</td>
</tr>
<tr>
<td align="left"><code>str1 != str2</code></td>
<td align="left">不同</td>
</tr>
<tr>
<td align="left"><code>str1 &lt; str2</code></td>
<td align="left">ascii值比较</td>
</tr>
<tr>
<td align="left"><code>str1 &gt; str2</code></td>
<td align="left">ascii值比较</td>
</tr>
<tr>
<td align="left"><code>-n str1</code></td>
<td align="left">not zero ，是否为非空</td>
</tr>
<tr>
<td align="left"><code>-z str1</code></td>
<td align="left">zero ，是否为空</td>
</tr>
</tbody></table>
<blockquote>
<p>tips: <code>test</code> 命令和<code>测试表达式</code>使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较。这个细微的特性被很多程序员理解反了。如果你对数值使用了数学运算符号， shell会将它们当成字符串值，可能无法得到正确的结果。</p>
</blockquote>
<hr>
<h3 id="EXPRESSION-1"><a href="#EXPRESSION-1" class="headerlink" title="[[ EXPRESSION ]]"></a><code>[[ EXPRESSION ]]</code></h3><p>先看看系统中用<code>[[ EXPESSION ]]</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄CentOS6 ~]# cat &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit| grep &quot;\[\[&quot;<br>if [[ &quot;$system_release&quot; &#x3D;&#x3D; *&quot;Red Hat&quot;* ]]; then<br>elif [[ &quot;$system_release&quot; &#x3D;&#x3D; *Fedora* ]]; then<br>elif [[ &quot;$system_release&quot; &#x3D;~ &quot;CentOS&quot; ]]; then<br></code></pre></td></tr></table></figure>

<p>这个文档很长，但是很多都是用的单括号，只有涉及到通配符的，才会去用双中括号，所以，我们可以借鉴大牛的做法：普通测试都用单中括号，只有用到通配符的时候，才去用双中括号。</p>
<h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><p>我们可以使用不同的条件标志测试不同的文件系统相关的属性。</p>
<ul>
<li><code>[ -f $file_var ]</code>：如果给定的变量是文件，则返回真。</li>
<li><code>[ -d $dict_var ]</code>：如果给定的变量是目录，则返回真。</li>
<li><code>[ -e $file_dict_var ]</code>：如果给定的变量是文件或文件夹，则返回真。等同<code>-a</code></li>
<li><code>[-s FILE ]</code>: 文件是否存在且非空</li>
<li><code>[ -r $readable_var ]</code>：如果给定的变量包含的文件可读，则返回真。</li>
<li><code>[ -w $write_var ]</code>：如果给定的变量包含的文件可写，则返回真。</li>
<li><code>[ -x $x_fvar ]</code>：如果给定的变量包含的文件可执行，则返回真。</li>
<li><code>[ -c $char_var ]</code>：如果给定的变量包含的是一个字符设备文件的路径，则返回真。</li>
<li><code>[ -b $block_var ]</code>：如果给定的变量包含的是一个块设备文件的路径，则返回真。</li>
<li><code>[ -L $link_var ]</code>：如果给定的变量包含的是一个符号链接，则返回真。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: FILE1是否是FILE2的硬链接</li>
<li><code>[ FILE1 -nt FILE2 ]</code>: FILE1是否新于FILE2（mtime） </li>
<li><code>[ FILE1 -ot FILE2 ]</code>: FILE1是否旧于FILE2 </li>
</ul>
<h3 id="Bash的组合测试条件"><a href="#Bash的组合测试条件" class="headerlink" title="Bash的组合测试条件"></a>Bash的组合测试条件</h3><p>第一种方式：</p>
<p>EXPRESSION1 -a EXPRESSION2 并且 </p>
<p>EXPRESSION1 -o EXPRESSION2 或者</p>
<p>!EXPRESSION<br>必须使用测试命令test进行，[[ ]] 不支持</p>
<p>第二种方式：</p>
<p>COMMAND1 &amp;&amp; COMMAND2  并且，短路与，代表条件性的AND  THEN </p>
<p>COMMAND1 || COMMAND2  或者，短路或，代表条件性的OR  ELSE </p>
<p>!COMMAND   非<br>如：<code>[ -f “$FILE” ] &amp;&amp; [[  “$FILE”=~ .*\.sh$  ]]</code></p>
<h2 id="使用read命令来接受输入"><a href="#使用read命令来接受输入" class="headerlink" title="使用read命令来接受输入"></a>使用read命令来接受输入</h2><p>使用read来把输入值分配给一个或多个shell变量<br>-p 指定要显示的提示<br>-s   静默输入，一般用于密码<br>-n  N 指定输入的字符长度N<br>-d ‘字符’  输入结束符<br>-t  N  TIMEOUT为N秒<br>read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量<br>read -p “Enter a filename: “ FILE</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL编程</tag>
      </tags>
  </entry>
  <entry>
    <title>04-用户和组练习题</title>
    <url>/04-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>创建用户<code>gentoo</code>，附加组为<code>bin</code>和<code>root</code>，默认shell为 <code>/bin/csh</code>，注释信息为”Gentoo Distribution”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 skel]# useradd gentoo -G bin,root -s &#x2F;bin&#x2F;csh -c &quot;Gentoo Distribution&quot;<br>[root❄centos7 skel]# cat &#x2F;etc&#x2F;passwd |grep gentoo<br>gentoo:x:1001:1001:Gentoo Distribution:&#x2F;home&#x2F;gentoo:&#x2F;bin&#x2F;csh<br></code></pre></td></tr></table></figure>

<h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>创建下面的用户、组和组成员关系</p>
<p>名字为<code>admins</code> 的组</p>
<p>用户<code>natasha</code>，使用<code>admins</code> 作为附属组</p>
<p>用户<code>harry</code>，也使用<code>admins</code> 作为附属组</p>
<p>用户<code>sarah</code>，不可交互登录系统，且不是<code>admins</code> 的成员，<code>natasha</code>，<code>harry</code>，<code>sarah</code>密码都是<code>centos</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root❄centos7 skel]☭ groupadd admins<br>[root❄centos7 skel]☭ useradd natasha -G admins<br>[root❄centos7 skel]☭ useradd harry -G admins<br>[root❄centos7 skel]☭ useradd sarah -s &#x2F;sbin&#x2F;nologin<br>[root❄centos7 skel]☭ echo centos | passwd --stdin natasha<br>Changing password for user natasha.<br>passwd: all authentication tokens updated successfully.<br>[root❄centos7 skel]☭ echo centos | passwd --stdin harry<br>Changing password for user harry.<br>passwd: all authentication tokens updated successfully.<br>[root❄centos7 skel]☭ echo centos | passwd --stdin sarah<br>Changing password for user sarah.<br>passwd: all authentication tokens updated successfully.<br><br>[root❄centos7 skel]☭ tail -n 3 &#x2F;etc&#x2F;passwd<br>natasha:x:1002:1003::&#x2F;home&#x2F;natasha:&#x2F;bin&#x2F;bash<br>harry:x:1003:1004::&#x2F;home&#x2F;harry:&#x2F;bin&#x2F;bash<br>sarah:x:1004:1005::&#x2F;home&#x2F;sarah:&#x2F;sbin&#x2F;nologin<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>用户和组</tag>
      </tags>
  </entry>
  <entry>
    <title>05-INSERT、DELETE、UPDATE语句</title>
    <url>/05-INSERT%E3%80%81DELETE%E3%80%81UPDATE%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO &lt;表名&gt; (列名1, 列名2, ...) Values (value1, value2, ...);<br></code></pre></td></tr></table></figure>

<p>省略列名不写，就得写每一列的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO &lt;表名&gt;<br>Values (value1, value2, ...);<br></code></pre></td></tr></table></figure>

<p>非空约束的列，不能插入Null值，否则报错。</p>
<p>有默认值约束的列，在列的列表里可以不写，这样就会插入默认值。如果要列表里有列名，想设置默认值需要写<code>DEFAULT</code>。</p>
<p>可以从其他表中取数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO &lt;表名1&gt; (列名1, 列名2, ...) <br>SELECT 列名a, 列名b, ... <br>from &lt;表名2&gt;<br>           ...;  -- 子select可以接WGHO<br></code></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>清空表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DELETE FROM &lt; 表名 &gt;;<br></code></pre></td></tr></table></figure>

<p>加条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DELETE FROM &lt; 表名 &gt; WHERE &lt; 条件 &gt;;<br></code></pre></td></tr></table></figure>

<p>截断表，速度快，DELETE相当于一条条删除，截断一下子就截断了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">TRUNCATE &lt; 表名 &gt;;<br></code></pre></td></tr></table></figure>

<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p><strong><code>UPDATE</code> 语句的基本语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UPDATE &lt; 表名 &gt; <br>SET &lt; 列名 &gt; &#x3D; &lt; 表达式 &gt;;<br></code></pre></td></tr></table></figure>

<p><strong>指定条件的 <code>UPDATE</code> 语句（搜索型 <code>UPDATE</code> ）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UPDATE &lt; 表名 &gt;<br><br>SET &lt; 列名 &gt; &#x3D; &lt; 表达式 &gt; WHERE &lt; 条件 &gt;;<br></code></pre></td></tr></table></figure>

<p><strong>使用NULL进行更新</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">UPDATE Product<br>SET regist_date &#x3D; NULL <br>WHERE product_id &#x3D; &#39;0008&#39;;<br></code></pre></td></tr></table></figure>

<p><strong>多列更新</strong></p>
<p><strong>方法①：</strong>代码清单4-19　将代码清单4-18的处理合并为一条 UPDATE 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">-- 使用逗号对列进行分隔排列 UPDATE Product<br><br>SET sale_price &#x3D; sale_price * 10, purchase_price &#x3D; purchase_price &#x2F; 2 <br>WHERE product_type &#x3D; &#39; 厨房用具 &#39;;<br></code></pre></td></tr></table></figure>

<p><strong>方法②：</strong>代码清单4-20　将代码清单4-18的处理合并为一条 UPDATE 语句</p>
<blockquote>
<p>方法②只可以在PostgreSQL和DB2中使用，MySQL和Oracle不支持。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">-- 将列用 () 括起来的清单形式 UPDATE Product<br><br>SET (sale_price, purchase_price) &#x3D; (sale_price * 10, purchase_price &#x2F; 2) <br>WHERE product_type &#x3D; &#39; 厨房用具<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>05-NFS服务</title>
    <url>/05-NFS%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="nfs："><a href="#nfs：" class="headerlink" title="nfs："></a>nfs：</h2><p>​        nfs: Network File System<br>​            nis：Network Information Service；<br>​            ldap：lightweight directory access protocol; ldap over ssl/tls；<br>​            </p>
<p>​    NFSv1<br>​    NFSv2, NFSv3, NFSv4;<br>​<br>​    nfsd: 2049/tcp<br>​<br>​    辅助类的服务：rpc, portmapper<br>​        rpc.mountd：认证；检查客户端主机地址是否本机所允许连接的IP的地址<br>​        rpc.lockd：加锁；<br>​        rpc.statd：状态；<br>​<br>​        rpc: remote procedure call </p>
<p>​            </p>
<h3 id="NFS-Server："><a href="#NFS-Server：" class="headerlink" title="NFS  Server："></a>NFS  Server：</h3><h3 id="nfs-utils："><a href="#nfs-utils：" class="headerlink" title="nfs-utils："></a>nfs-utils：</h3><p>​            The nfs-utils package provides a daemon for the kernel NFS server and related tools, which provides a much higher level of performance than the traditional Linux NFS server used by most users.<br>​<br>​        /etc/exports或/etc/exports.d/*<br>​            /PATH/TO/SOME_DIR     clients1(export_options, …)  clients2(export_options, …)<br>​                clients：<br>​                    single host：ipv4, ipv6, FQDN；<br>​                    network：address/netmask， 支持长短格式的掩码；<br>​                    wildcards：主机名通配，例如：*.magedu.com;<br>​                    netgroups：NIS域内的主机组；@group_name；<br>​                    anonymous：使用*通配所有主机；<br>​<br>​                General Options:<br>​                    ro：只读<br>​                    rw：读写；<br>​                    sync：同步；<br>​                    async：异步；<br>​                    secure：客户端端口小于1024，否则就要使用insecure选项；<br>​                User ID Mapping：<br>​                     root_squash：压缩root用户，一般指将其映射为nfsnobody；<br>​                     no_root_squash：不压缩root用户；<br>​                     all_squash：压缩所有用户；<br>​                     anonuid and anongid：将压缩的用户映射为此处指定的用户；<br>​                     </p>
<h3 id="NFS-Client"><a href="#NFS-Client" class="headerlink" title="NFS Client:"></a>NFS Client:</h3><p>​        mount -t nfs servername:/path/to/share /path/to/mount_point  [-rvVwfnsh ] [-o options]<br>​        </p>
<p>exportfs -ar</p>
<p>exportfs -au</p>
<p>​     showmount - show mount information for an NFS server<br>​<br>​        showmount -e NFS_SERVER_IP: 查看指定的nfs server上导出的所有文件系统；<br>​        showmount -a：在nfs server上查看nfs服务的所有客户端列表；<br>​<br>​    exportfs：<br>​        exportfs<br>​            -r：重新导出；<br>​            -a：所有文件系统；<br>​            -v：详细信息；<br>​            -u：取消导出文件系统； </p>
<p>​            </p>
<p>​    其它参考文档：<br>​        man nfs：获取nfs文件系统专用的挂载选项；</p>
<p>​            </p>
<p>博客实践作业：<br>    (1) nfs server导出/data/application/web，在目录中提供wordpress;<br>    (2) nfs client挂载nfs server导出的文件系统至/var/www/html；<br>    (3) 客户端（lamp）部署wordpress，并让其正常访问；要确保能正常发文章，上传图片；<br>    (4) 客户端2(lamp)，挂载nfs server导出的文件系统至/var/www/html；验正其wordpress是否可被访问； 要确保能正常发文章，上传图片；</p>
<p>博客实践作业：<br>    (1) nfs server导出/data/目录；<br>    (2) nfs client挂载/data/至本地的/mydata目录；本地的mysqld或mariadb服务的数据目录设置为/mydata, 要求服务能正常启动，且可正常 存储数据；</p>
<h2 id="nfs安装使用"><a href="#nfs安装使用" class="headerlink" title="nfs安装使用"></a>nfs安装使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian videos]<span class="hljs-comment">#lsmod | grep nfs</span><br>[root@ashjian videos]<span class="hljs-comment">#yum info nfs-utils #内核不会创建套接字，需要一个包的工具来调用套接字</span><br>[root@ashjian videos]<span class="hljs-comment">#yum install nfs-utils</span><br>[root@ashjian videos]<span class="hljs-comment">#mount #传统的mount命令只能挂载ext系列和xfs文件系统</span><br>mount       mount.nfs   mount.nfs4  mountpoint  mountstats<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Zabbix-trigger（触发器）设置</title>
    <url>/05-Zabbix-trigger%EF%BC%88%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%89%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设置一个监控项–进站包数，当进站包数&gt;50触发器报警。</p>
<p>先设置一个进站包数的监控项（item)：</p>
<p><a href="http://www.yulongjun.com/images/15066012210541.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154044.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15066014949084.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154045.jpg" alt="img"></a></p>
<p>针对进站包数设置触发器（tragger），&gt;5000为警告，&gt;10000为严重：</p>
<p><a href="http://www.yulongjun.com/images/15066014454287.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154046.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15066014693803.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154047.jpg" alt="img"></a></p>
<p>设置图形（graph）<br><a href="http://www.yulongjun.com/images/15066015675247.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154048.jpg" alt="img"></a></p>
<p>记得勾选<code>查看触发器</code>，我们预览一下，可以看到两条虚线，就是触发器的阈值线，黄色的是上面定义的告警线，红色的是严重线。</p>
<p><a href="http://www.yulongjun.com/images/15066016520534.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154049.jpg" alt="img"></a></p>
<p>测试一下效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hping --flood 192.168.0.10<br></code></pre></td></tr></table></figure>

<p>我们可以看到有问题告警：<br><a href="http://www.yulongjun.com/images/15066018815414.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154050.jpg" alt="img"></a></p>
<p>停掉hping，问题告警变绿，变成已解决：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203154956.jpg" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>05-bash配置相关</title>
    <url>/05-bash%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>profile</code>类：为交互式登录的shell提供配置，只有第一次登陆时执行</p>
<p><code>bashrc</code>类：为非交互式和交互式登录的shell提供配置，每一次打开新的SHELL进程就执行一次</p>
<p>bash的配置文件，按<strong>生效范围</strong>划分，存在两类：</p>
<ul>
<li><strong>全局配置</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">配置文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/etc/profile</code></td>
<td align="left">为登录程序而设置的系统广泛使用的环境和启动程序。官方建议不动，想自定义全局配置的话建议改/etc/profile.d里面的内容。</td>
</tr>
<tr>
<td align="left"><code>/etc/profile.d/*.sh</code></td>
<td align="left">各种配置，如<code>256term.sh</code>（终端配色方案）、<code>vim.sh</code>（vim相关配置）、<code>less.sh</code>（less命令相关）、<code>colorls.sh</code>（命令显示颜色相关）、<code>lang.sh</code>（语言相关）等。</td>
</tr>
<tr>
<td align="left"><code>/etc/bashrc</code></td>
<td align="left">主要设置用户的<code>PS1</code>、<code>history</code>、<code>umask</code>等的全局设置。</td>
</tr>
</tbody></table>
<ul>
<li><strong>个人配置</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">配置文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>~/.bash_profile</code></td>
<td align="left">个人定义的一些bash变量。</td>
</tr>
<tr>
<td align="left"><code>~/.bashrc</code></td>
<td align="left">个人定义的一些别名和功能。</td>
</tr>
</tbody></table>
<blockquote>
<p>tips：个人配置其实写上面哪个文件都行，都可以生效。</p>
</blockquote>
<hr>
<h2 id="登录方式"><a href="#登录方式" class="headerlink" title="登录方式"></a>登录方式</h2><p><strong>登录方式</strong>分为两种方式：</p>
<ul>
<li><strong>交互式登录</strong>。分为下面几种：<ul>
<li>直接通过终端输入账号密码登录</li>
<li>使用 <code>su - UserName</code> 切换的用户</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行顺序：<code>/etc/profile</code> –&gt; <code>/etc/profile.d/*.sh</code> –&gt; <code>~/.bash_profile</code> –&gt;<code>~/.bashrc</code> –&gt; /<code>etc/bashrc</code></p>
</blockquote>
<ul>
<li><strong>非交互式登录</strong>。分为下面几种：<ul>
<li>使用<code>su UserName</code>切换用户</li>
<li>图形界面下打开的终端</li>
<li>执行脚本</li>
<li>任何其它的bash实例</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行顺序： <code>~/.bashrc</code> –&gt; <code>/etc/bashrc</code> –&gt; <code>/etc/profile.d/*.sh</code></p>
</blockquote>
<hr>
<h2 id="退出配置"><a href="#退出配置" class="headerlink" title="退出配置"></a>退出配置</h2><p>退出配置保存在用户的<code>~/.bash_logout</code>文件中，在退出登录shell时运行。</p>
<p>通常配置里写：</p>
<ul>
<li>创建自动备份</li>
<li>清除临时文件</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL编程</tag>
        <tag>BASH</tag>
      </tags>
  </entry>
  <entry>
    <title>05-curl命令</title>
    <url>/05-curl%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>​    curl是基于URL语法在命令行方式下工作的文件传输工具，它支持FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE及LDAP等协议。curl支持HTTPS认证，并且支持HTTP的POST、PUT等方法， FTP上传， kerberos认证，HTTP上传，代理服务器， cookies， 用户名/密码认证， 下载文件断点续传，上载文件断点续传, http代理服务器管道（ proxy tunneling）， 甚至它还支持IPv6， socks5代理服务器,，通过http代理服务器上传文件到FTP服务器等等，功能十分强大。<br>​<br>​    MIME： major/minor,  image/png, image/gif</p>
<p>​    curl  [options]  [URL…]</p>
<p>​    curl的常用选项：</p>
<p>​        -A/–user-agent <string> 设置用户代理发送给服务器<br>​        –basic 使用HTTP基本认证<br>​        –tcp-nodelay 使用TCP_NODELAY选项<br>​        -e/–referer <URL> 来源网址<br>​        –cacert <file> CA证书 (SSL)<br>​        –compressed 要求返回是压缩的格式<br>​        -H/–header <line>自定义首部信息传递给服务器<br>​        -I/–head 只显示响应报文首部信息<br>​        –limit-rate <rate> 设置传输速度<br>​        -u/–user &lt;user[:password]&gt;设置服务器的用户和密码<br>​        -0/–http1.0 使用HTTP 1.0    </p>
<p>​    用法：curl [options] [URL…]</p>
<p>​    另一个工具：elinks<br>​        elinks  [OPTION]… [URL]…<br>​            -dump: 不进入交互式模式，而直接将URL的内容输出至标准输出； </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>05-ngx_http_core_module详解</title>
    <url>/05-ngx-http-core-module%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ngx_http_core_module,规定了一些http功能相关的核心配置。</p>
<h2 id="与套接字相关配置"><a href="#与套接字相关配置" class="headerlink" title="与套接字相关配置"></a>与套接字相关配置</h2><h3 id="1、server设置虚拟服务器全局配置"><a href="#1、server设置虚拟服务器全局配置" class="headerlink" title="1、server设置虚拟服务器全局配置"></a>1、<code>server</code>设置虚拟服务器全局配置</h3><p><a href="http://www.yulongjun.com/images/15034948621371.jpg" target="_blank" rel="noopener"><img src="05-ngx_http_core_module%E8%AF%A6%E8%A7%A3.assets/15034948621371.jpg" alt="img"></a></p>
<p>配置一个虚拟主机的全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &#123;<br>listen address[:PORT]|PORT;<br>server_name SERVER_NAME;<br>root &#x2F;PATH&#x2F;TO&#x2F;DOCUMENT_ROOT;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、listen设置监听端口和IP"><a href="#2、listen设置监听端口和IP" class="headerlink" title="2、listen设置监听端口和IP"></a>2、<code>listen</code>设置监听端口和IP</h3><p><a href="http://www.yulongjun.com/images/15034948189199.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130221731.jpg" alt="img"></a></p>
<ul>
<li><code>default_server</code>：设定为默认虚拟主机</li>
<li><code>ssl</code>：限制仅能够通过ssl连接提供服务</li>
<li><code>backlog=NUMBER</code> 设置调用中限制挂起连接队列的最大长度的backlog参数 listen()。默认情况下， backlog在FreeBSD，DragonFly BSD和macOS上设置为-1，在其他平台上设置为511。</li>
<li><code>rcvbuf=SIZE</code> 设置所监听端口的接收缓存大小（SO_RCVBUF选项）</li>
<li><code>sndbuf=SIZE</code> 设置所监听端口的发送缓存大小（SO_SNDBUF选项）</li>
</ul>
<blockquote>
<p>注意：<br>(1) <strong>基于port</strong>：<code>listen PORT</code><br>指令监听在不同的端口<br>(2) <strong>基于hostname</strong>：<code>server_name</code><br>指令指向不同的主机名<br>(3) <strong>基于ip的虚拟主机</strong><br><code>listen IP:PORT</code>&gt; IP 地址不同</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">listen 192.168.0.100:8000; # 监听192.168.0.100的8000端口<br>listen 192.168.0.100;  # 监听192.168.0.100，不写端口则默认为80端口<br>listen 8000;  # 监听本地8000端口<br>listen *:8000;  # 同上<br>listen localhost:8000;  # 同上<br>listen [::]:8000;  # 监听本地的ipv6的8000端口<br>listen [::1];  # 监听本地的ipv6地址，不写端口则默认为80<br></code></pre></td></tr></table></figure>

<h3 id="3、server-name设置虚拟服务器名字"><a href="#3、server-name设置虚拟服务器名字" class="headerlink" title="3、server_name设置虚拟服务器名字"></a>3、<code>server_name</code>设置虚拟服务器名字</h3><p><a href="http://www.yulongjun.com/images/15034949217884.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130221748.jpg" alt="img"></a></p>
<ul>
<li>虚拟主机的主机名称后可跟多个由空白字符分隔的字符串。</li>
<li>支持*通配任意长度的任意字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server_name *.yulongjun.com www.yulongjun.*<br></code></pre></td></tr></table></figure>

<p>支持~起始的字符做正则表达式模式匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server_name ~^www\d+\.yulongjun\.com$<br></code></pre></td></tr></table></figure>

<blockquote>
<p>\d 表示 [0-9]</p>
</blockquote>
<p>匹配机制:</p>
<ol>
<li>首先是字符串精确匹配 如:<code>www.yulongjun.com</code></li>
<li>左侧<em>通配符 如:`</em>.yulongjun.com`</li>
<li>侧<em>通配符 如:`<a href="http://www.yulongjun" target="_blank" rel="noopener">www.yulongjun</a>.</em>`</li>
<li>正则表达式 如: <code>~^.*\.yulongjun\.com$</code></li>
<li>都没写，则匹配<code>default_server</code></li>
</ol>
<h3 id="4、tcp-nodelay-on-off"><a href="#4、tcp-nodelay-on-off" class="headerlink" title="4、tcp_nodelay on | off;"></a>4、<code>tcp_nodelay on | off;</code></h3><p><a href="http://www.yulongjun.com/images/15034959000906.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130221754.jpg" alt="img"></a></p>
<p>在keepalived模式下的连接是否启用<code>TCP_NODELAY</code>选项。off时，延迟发送，合并多个请求后再发送 默认On时，不延迟发送。</p>
<h3 id="5、sendfile-零拷贝是否开启"><a href="#5、sendfile-零拷贝是否开启" class="headerlink" title="5、sendfile 零拷贝是否开启"></a>5、<code>sendfile</code> 零拷贝是否开启</h3><p><a href="http://www.yulongjun.com/images/15034959526228.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130221801.jpg" alt="img"></a></p>
<p>是否启用<code>sendfile</code>零拷贝功能，即在内核中封装报文直接发送。默认Off。</p>
<hr>
<h2 id="定义路径相关的配置"><a href="#定义路径相关的配置" class="headerlink" title="定义路径相关的配置"></a>定义路径相关的配置</h2><h3 id="1、root"><a href="#1、root" class="headerlink" title="1、root"></a>1、<code>root</code></h3><p><a href="http://www.yulongjun.com/images/15034969060891.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130221808.jpg" alt="img"></a></p>
<p>设置web资源的路径映射;用于指明请求的URL所对应的文档 的目录路径，可用于http, server, location, if in location</p>
<p>```<br>server { …<br>root /data/www/vhost1;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; 例如：网络上&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;logo.jpg&#96;,实际是服务器上的&#96;&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;images&#x2F;logo.jpg&#96;### 2、&#96;location&#96;![](&#x2F;images&#x2F;15034969496035.jpg)<br>在一个server中location配置段可存在多个，用于实现从uri到 文件系统的路径映射;ngnix会根据用户请求的URI来检查定义的所有 location，并找出一个最佳匹配，而后应用其配置<br><br>示例:<br></code></pre></td></tr></table></figure>
<p>server {…<br>    server_name <a href="http://www.yulongjun.com" target="_blank" rel="noopener">www.yulongjun.com</a>;     location /images/ {<br>        root /data/imgs/;<br>    } }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br><br>&gt; 例如：网络上的&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;logo.jpg&#96;，实际是服务器上的&#96;&#x2F;data&#x2F;imgs&#x2F;images&#x2F;logo.jpg&#96;<br><br>**&#96;&#x3D;&#96;：对URI做精确匹配。**<br></code></pre></td></tr></table></figure>
<p>location = / {<br>…<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 可以匹配&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;&#96; ，不能匹配&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;index.html&#96;<br><br>- **&#96;~&#96;：对URI做正则表达式模式匹配，区分字符大小写**<br>- **&#96;~\*&#96;：对URI做正则表达式模式匹配，不区分字符大小写**<br>- **&#96;^~&#96;：对URI的最左边部分做匹配检查，不区分字符大小写**<br>- **&#96;不带符号&#96;：匹配起始于此uri的所有的uri**<br><br>**匹配优先级**：&#96;&#x3D;&#96;&gt;&#96;^~&#96;&gt; &#96;～&#96;&gt; &#96;～*&#96;&gt;&#96;不带符号&#96;。<br><br>示例：<br></code></pre></td></tr></table></figure>
<p>root /vhosts/www/htdocs/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/index.html" target="_blank" rel="noopener">http://www.yulongjun.com/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>–&gt; &#96;&#x2F;vhosts&#x2F;www&#x2F;htdocs&#x2F;index.html&#96; <br></code></pre></td></tr></table></figure>
<p>server {<br>    root /vhosts/www/htdocs/<br>    location /admin/ {<br>       root /webapps/app1/data/<br>    }<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/admin/index.html`–&gt;`/webapps/app1/data/admin/index.html" target="_blank" rel="noopener">http://www.yulongjun.com/admin/index.html`–&gt;`/webapps/app1/data/admin/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>### 3、&#96;alias PATH;&#96;<br><br>[![img](05-ngx_http_core_module详解.assets&#x2F;15034969755802.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034969755802.jpg)<br><br>路径别名，文档映射的另一种机制；仅能用于location上下文<br><br>示例： <br></code></pre></td></tr></table></figure>
<p>location /bbs/ {<br>    alias /web/forum/;<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/bbs/index.php`–&gt;" target="_blank" rel="noopener">http://www.yulongjun.com/bbs/index.php`–&gt;</a> `/web/forum/index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>相比之下，root是这样的： <br></code></pre></td></tr></table></figure>
<p>location /bbs/ {<br>    root /web/forum/;<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/bbs/index.php`–&gt;" target="_blank" rel="noopener">http://www.yulongjun.com/bbs/index.php`–&gt;</a> `/web/forum/bbs/index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>注意：location中使用&#96;root&#96;指令和&#96;alias&#96;指令的意义不同<br><br>(a) root，给定的路径对应于location中的&#96;&#x2F;uri&#x2F;&#96;**左**侧的&#96;&#x2F;&#96;<br><br>(b) alias，给定的路径对应于location中的&#96;&#x2F;uri&#x2F;&#96;**右**侧的&#96;&#x2F;&#96;<br><br>### 4、&#96;index file&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221826.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034971105980.jpg)<br>指定默认网页资源，注意,这个是在&#96;ngx_http_index_module&#96;模块。<br><br>### 5、&#96;error_page&#96; 错误页404<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221834.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034978784852.jpg) <br></code></pre></td></tr></table></figure>
<p>error_page 404 /404.html;<br>error_page 500 502 503 504 /50x.html;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>这将导致内部重定向到*uri* 客户端请求方法指定的内部重定向更改为“GET”（对于除“GET”和“HEAD” 之外的所有方法）。<br><br>此外，可以使用*&#x3D;response*语法将响应代码更改为另一个，例如：<br></code></pre></td></tr></table></figure>
<p>error_page 404 = 200 /empty.gif;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>如果代理服务器或&#96;FastCGI&#x2F;uwsgi&#x2F;SCGI&#96;服务器处理错误响应，并且服务器可能返回不同的响应代码（例如200、302、401或404），则可以使用返回的代码进行响应：<br></code></pre></td></tr></table></figure>
<p>error_page 404 = /404.php;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>如果在内部重定向期间不需要更改URI和方法，则可以将错误处理传递到命名位置：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    error_page 404 = @fallback;<br>} </p>
<p>location @fallback {<br>    proxy_pass http：//后端;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 如果*uri*处理导致错误，则将最后发生的错误的状态代码返回给客户端。<br><br>还可以使用URL重定向进行错误处理：<br></code></pre></td></tr></table></figure>
<p>error_page 403 <a href="http://example.com/forbidden.html" target="_blank" rel="noopener">http://example.com/forbidden.html</a>;<br>error_page 404 = 301 <a href="http://example.com/notfound.html" target="_blank" rel="noopener">http://example.com/notfound.html</a>;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 在这种情况下，默认情况下，将响应代码302返回给客户端。它只能更改为重定向状态代码之一（301,302,303,307和308）。<br>&gt; 当且仅当没有error_page 在当前级别上定义指令时，这些指令才能从上一级继承 。<br><br>### 6、try_files<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221844.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034979377926.jpg)<br><br>以指定的顺序检查文件的存在，并使用第一个找到的文件进行请求处理; 该处理在当前上下文中执行。文件的路径是*file*根据根和别名指令的参数 构建的 。可以通过在名称末尾指定斜杠来检查目录的存在，例如“ *$uri&#x2F;*”。如果没有找到任何文件，则会*uri*进行最后一个参数中指定的内部重定向 。例如：<br></code></pre></td></tr></table></figure>
<p>location /images/ {<br>    try_files $uri /images/default.gif;<br>}</p>
<p>location = /images/default.gif {<br>    expires 30s;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>最后一个参数也可以指向一个命名的位置，如下面的例子所示。从0.7.51版本开始，最后一个参数也可以是 *code*：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/index.html $uri.html =404;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&#96;Drupal&#x2F;FastCGI&#96;示例：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/ @drupal;<br>}</p>
<p>location ~ .php$ {<br>    try_files $uri @drupal;</p>
<pre><code>fastcgi_pass ...;

fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
fastcgi_param SCRIPT_NAME     $fastcgi_script_name;
fastcgi_param QUERY_STRING    $args;

... other fastcgi_param&apos;s</code></pre><p>}</p>
<p>location @drupal {<br>    fastcgi_pass …;</p>
<pre><code>fastcgi_param SCRIPT_FILENAME /path/to/index.php;
fastcgi_param SCRIPT_NAME     /index.php;
fastcgi_param QUERY_STRING    q=$uri&amp;$args;

... other fastcgi_param&apos;s</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>在上面的例子中，<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/ @drupal;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>该*try_files*指令相当于下面两端代码的结合：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    error_page 404 = @drupal;<br>    log_not_found off;<br>}<br>location ~ .php$ {<br>    try_files $uri @drupal;</p>
<pre><code>fastcgi_pass ...;

fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;

...</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>*try_files* 在将请求传递给FastCGI服务器之前检查PHP文件的存在。<br><br>Wordpress和Joomla的示例：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/ @wordpress;<br>}</p>
<p>location ~ .php$ {<br>    try_files $uri @wordpress;</p>
<pre><code>fastcgi_pass ...;

fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
... other fastcgi_param&apos;s</code></pre><p>}</p>
<p>location @wordpress {<br>    fastcgi_pass …;</p>
<pre><code>fastcgi_param SCRIPT_FILENAME /path/to/index.php;
... other fastcgi_param&apos;s</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>------<br><br>## 定义客户端请求的相关配置<br><br>### 1、&#96;keepalive_timeout&#96;设定长连接的超时时长<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221853.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034986592949.jpg)<br><br>第一个参数设置保持连接的超时时长，0表示禁止长连接。默认为75s，推荐120s<br><br>可选的第二个参数在“Keep-Alive：timeout &#x3D; time”响应头域中设置一个值。两个参数可能不同。<br><br>Mozilla和Konqueror可以识别 &#96;Keep-Alive：timeout &#x3D; time&#96;头域。MSIE在大约60秒内自行关闭保持连接。<br><br>### 2、&#96;keepalive_requests&#96;长连接允许请求的资源的最大数量<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221858.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034986843839.jpg)<br><br>在一次长连接上所允许请求的资源的最大数量。默认为100<br><br>### 3、&#96;keepalive_disable&#96;对哪种浏览器禁用长连接<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221904.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034987149301.jpg)<br><br>### 4、&#96;send_timeout&#96;设置用于向客户端发送响应的超时时间<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221917.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034987424203.jpg)<br><br>设置用于向客户端发送响应的超时时间。超时仅在两个连续的写入操作之间设置，而不是传输整个响应。如果客户端在这段时间内没有收到任何内容，则连接被关闭。<br><br>### 5、&#96;client_body_buffer_size&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221932.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034997030744.jpg)<br><br>设置读取客户端请求体的缓冲区大小。如果请求体大于缓冲区，则整个身体或仅将其部分写入 临时文件。默认情况下，缓冲区大小等于两个内存页面。这是x86上的8K，其他32位平台和x86-64。其他64位平台通常为16K。<br><br>### 6、&#96;client_body_temp_path&#96;<br><br>定义用于存储持有客户机请求主体的临时文件的目录。最多可以在指定目录下使用三级子目录层次结构。例如，在以下配置中：<br></code></pre></td></tr></table></figure>
<p>client_body_temp_path /spool/nginx/client_temp 1 2;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>临时文件hash：<br><br>85c9d32c3526a1bbb3996525ec80b3e0f7aa83dd<br></code></pre></td></tr></table></figure>
<p>ls /spool/nginx/client_temp/d/3d/a83/<br>85c9d32c3526a1bbb3996525ec80b3e0f7aa83dd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>我们可以看到就是逐级从右边截取hash值<br><br>目录名为16进制的数字；<br><br>1 1级目录占1位16进制，即2^4&#x3D;16个目录 0-f<br><br>2 2级目录占2位16进制，即2^8&#x3D;256个目录 00-ff<br><br>2 3级目录占2位16进制，即2^8&#x3D;256个目录 00-ff<br><br>------<br><br>## 对客户端进行限制的相关配置<br><br>### 1、&#96;limit_rate&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221939.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15042666972847.jpg)<br><br>限制响应给客户端的传输速率，单位是bytes&#x2F;second<br><br>默认值0表示无限制<br><br>### 19、&#96;limit_except&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221945.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15042667307350.jpg)<br><br>限制客户端使用除了指定的请求方法之外的其它方法，只能用在location上下文。<br><br>**&#96;Method&#96;**:GET, HEAD, POST, PUT, DELETE<br><br>MKCOL, COPY, MOVE, OPTIONS, PROPFIND,<br><br>PROPPATCH, LOCK, UNLOCK, PATCH<br></code></pre></td></tr></table></figure>
<p>limit_except GET HEAD POST {<br>    deny 192.168.111.200<br>    allow 192.168.111.0/24;<br>    deny all;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>表示除了GET、HEAD、POST方法其他方法都限制，主机范围为：禁止192.168.111.200、允许192.168.111.0&#x2F;24、禁止所有。即仅允许192.168.111.0网段访问，但是禁止192.168.111.200的地址访问。<br><br>------<br><br>## 文件操作优化的配置<br><br>### 1. &#96;aio&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222535.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035371542671.jpg)<br><br>是否启用Linux的aio功能。<br><br>### 2. &#96;directio&#96;<br><br>[![img](05-ngx_http_core_module详解.assets&#x2F;15035371833381.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035371833381.jpg)<br><br>是否同步写磁盘，在Linux主机启用O_DIRECT标记，意味文件大于等于给定的大小时使用，例如&#96;directio 4m&#96;<br><br>### 3. &#96;open_file_cache&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222542.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035372196986.jpg)<br><br>nginx可以缓存以下三种信息：<br><br>1. 文件元数据：文件的描述符、文件大小和最近一次的修改时间<br>2. 打开的目录结构<br>3. 没有找到的或者没有权限访问的文件的相关信息<br><br>&#96;max&#x3D;N&#96;：可缓存的缓存项上限；达到上限后会使用LRU算法实现管理。<br>&#96;inactive&#x3D;time&#96;：缓存项的非活动时长，在此处指定的时长内未被命中的或命中的次数少于&#96;open_file_cache_min_uses&#96;指令所指定的次数的缓存项 即为非活动项，将被删除。<br><br>### 4. &#96;open_file_cache_errors&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222607.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035373075583.jpg)<br><br>是否缓存查找时发生错误的文件一类的信息。<br><br>### 5. &#96;open_file_cache_min_uses&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222613.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035373927696.jpg)<br><br>open_file_cache指令的inactive参数指定的时长内，至少被命中此处指定的次数方可被归类为活动项。<br><br>### 6. &#96;open_file_cache_valid&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130230601.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035374264499.jpg)<br><br>缓存项有效性的检查频率。<br><br>综上来个例子：<br></code></pre></td></tr></table></figure>
<p>aio                      on;<br>directio                 4m;<br>open_file_cache          max=1000 inactive=20s;<br>open_file_cache_valid    30s;<br>open_file_cache_min_uses 2;<br>open_file_cache_errors   on;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>------<br><br>&gt; 其他模块暂时没时间写，有时间再写。可以去查看[官方文档](http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;)的&#96;Module reference&#96;(模块参考），用的比较多的是[NGINX主配置文件](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;linux&#x2F;20170821-03-nginx-main-config&#x2F;)里讲到的那些模块，这里再次列出来。<br><br>- 核心模块：<br><br>  - **core module**<br><br>- 常用的标准模块：<br><br>  - HTTP modules<br><br>    ：<br><br>    - **&#96;ngx_http_core_modules&#96;** http核心功能模块（重要）<br>    - **&#96;ngx_http_ssl_module&#96;** http信道加密模块（重要）<br>    - **&#96;ngx_http_upstream_module&#96;** http定义服务器组模块（重要）<br>    - **&#96;ngx_http_fastcgi|uWSGI|SCGI_module&#96;** http web api接口模块（重要）<br>    - **&#96;ngx_http_proxy_module&#96;** http反向代理模块（重要）<br>    - **&#96;ngx_http_gzip_module&#96;** http gzip压缩传输模块（次一级）<br>    - **&#96;ngx_http_log_module&#96;** http日志模块（次一级）<br>    - **&#96;ngx_http_referer_module&#96;**http防盗链模块（次一级）<br>    - **&#96;ngx_http_rewrite_module&#96;** http重定向模块（次一级）<br>    - **&#96;ngx_http_access_module&#96;** http权限控制模块<br>    - **&#96;ngx_http_auth_basic_module&#96;** http认证模块<br>    - **&#96;ngx_http_stub_status_module&#96;** http状态模块<br>    - **&#96;ngx_http_headers_module&#96;** http首部信息模块<br><br>  - Mail modules<br><br>    ：<br><br>    - 用的少<br><br>  - Stream modules<br><br>    ：<br><br>    - **&#96;ngx_stream_core_module&#96;** http的伪四层负载均衡模块ngx_http_core_module,规定了一些http功能相关的核心配置。<br><br>## 与套接字相关配置<br><br>### 1、&#96;server&#96;设置虚拟服务器全局配置<br><br>[![img](05-ngx_http_core_module详解.assets&#x2F;15034948621371.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034948621371.jpg)<br><br>配置一个虚拟主机的全局配置<br></code></pre></td></tr></table></figure>
<p>server {<br>listen address[:PORT]|PORT;<br>server_name SERVER_NAME;<br>root /PATH/TO/DOCUMENT_ROOT;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>### 2、&#96;listen&#96;设置监听端口和IP<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221731.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034948189199.jpg)<br><br>- &#96;default_server&#96;：设定为默认虚拟主机<br>- &#96;ssl&#96;：限制仅能够通过ssl连接提供服务<br>- &#96;backlog&#x3D;NUMBER&#96; 设置调用中限制挂起连接队列的最大长度的backlog参数 listen()。默认情况下， backlog在FreeBSD，DragonFly BSD和macOS上设置为-1，在其他平台上设置为511。<br>- &#96;rcvbuf&#x3D;SIZE&#96; 设置所监听端口的接收缓存大小（SO_RCVBUF选项）<br>- &#96;sndbuf&#x3D;SIZE&#96; 设置所监听端口的发送缓存大小（SO_SNDBUF选项）<br><br>&gt; 注意：<br>&gt; (1) **基于port**：&#96;listen PORT&#96;<br>&gt; 指令监听在不同的端口<br>&gt; (2) **基于hostname**：&#96;server_name&#96;<br>&gt; 指令指向不同的主机名<br>&gt; (3) **基于ip的虚拟主机**<br>&gt; &#96;listen IP:PORT&#96;&gt; IP 地址不同<br><br>例如：<br></code></pre></td></tr></table></figure>
<p>listen 192.168.0.100:8000; # 监听192.168.0.100的8000端口<br>listen 192.168.0.100;  # 监听192.168.0.100，不写端口则默认为80端口<br>listen 8000;  # 监听本地8000端口<br>listen *:8000;  # 同上<br>listen localhost:8000;  # 同上<br>listen [::]:8000;  # 监听本地的ipv6的8000端口<br>listen [::1];  # 监听本地的ipv6地址，不写端口则默认为80</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>### 3、&#96;server_name&#96;设置虚拟服务器名字<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221748.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034949217884.jpg)<br><br>- 虚拟主机的主机名称后可跟多个由空白字符分隔的字符串。<br>- 支持*通配任意长度的任意字符<br></code></pre></td></tr></table></figure>
<p>server_name <em>.yulongjun.com <a href="http://www.yulongjun" target="_blank" rel="noopener">www.yulongjun</a>.</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>支持~起始的字符做正则表达式模式匹配<br></code></pre></td></tr></table></figure>
<p>server_name ~^www\d+.yulongjun.com$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; \d 表示 [0-9]<br><br>匹配机制:<br><br>1. 首先是字符串精确匹配 如:&#96;www.yulongjun.com&#96;<br>2. 左侧*通配符 如:&#96;*.yulongjun.com&#96;<br>3. 侧*通配符 如:&#96;www.yulongjun.*&#96;<br>4. 正则表达式 如: &#96;~^.*\.yulongjun\.com$&#96;<br>5. 都没写，则匹配&#96;default_server&#96;<br><br>### 4、&#96;tcp_nodelay on | off;&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221754.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034959000906.jpg)<br><br>在keepalived模式下的连接是否启用&#96;TCP_NODELAY&#96;选项。off时，延迟发送，合并多个请求后再发送 默认On时，不延迟发送。<br><br>### 5、&#96;sendfile&#96; 零拷贝是否开启<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221801.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034959526228.jpg)<br><br>是否启用&#96;sendfile&#96;零拷贝功能，即在内核中封装报文直接发送。默认Off。<br><br>------<br><br>## 定义路径相关的配置<br><br>### 1、&#96;root&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221808.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034969060891.jpg)<br><br>设置web资源的路径映射;用于指明请求的URL所对应的文档 的目录路径，可用于http, server, location, if in location<br><br>\<br></code></pre></td></tr></table></figure>
<p>server { …<br>root /data/www/vhost1;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; 例如：网络上&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;logo.jpg&#96;,实际是服务器上的&#96;&#x2F;data&#x2F;www&#x2F;vhosts&#x2F;images&#x2F;logo.jpg&#96;### 2、&#96;location&#96;![](&#x2F;images&#x2F;15034969496035.jpg)<br>在一个server中location配置段可存在多个，用于实现从uri到 文件系统的路径映射;ngnix会根据用户请求的URI来检查定义的所有 location，并找出一个最佳匹配，而后应用其配置<br><br>示例:<br></code></pre></td></tr></table></figure>
<p>server {…<br>    server_name <a href="http://www.yulongjun.com" target="_blank" rel="noopener">www.yulongjun.com</a>;     location /images/ {<br>        root /data/imgs/;<br>    } }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br><br>&gt; 例如：网络上的&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;logo.jpg&#96;，实际是服务器上的&#96;&#x2F;data&#x2F;imgs&#x2F;images&#x2F;logo.jpg&#96;<br><br>**&#96;&#x3D;&#96;：对URI做精确匹配。**<br></code></pre></td></tr></table></figure>
<p>location = / {<br>…<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 可以匹配&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;&#96; ，不能匹配&#96;http:&#x2F;&#x2F;www.yulongjun.com&#x2F;index.html&#96;<br><br>- **&#96;~&#96;：对URI做正则表达式模式匹配，区分字符大小写**<br>- **&#96;~\*&#96;：对URI做正则表达式模式匹配，不区分字符大小写**<br>- **&#96;^~&#96;：对URI的最左边部分做匹配检查，不区分字符大小写**<br>- **&#96;不带符号&#96;：匹配起始于此uri的所有的uri**<br><br>**匹配优先级**：&#96;&#x3D;&#96;&gt;&#96;^~&#96;&gt; &#96;～&#96;&gt; &#96;～*&#96;&gt;&#96;不带符号&#96;。<br><br>示例：<br></code></pre></td></tr></table></figure>
<p>root /vhosts/www/htdocs/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/index.html" target="_blank" rel="noopener">http://www.yulongjun.com/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>–&gt; &#96;&#x2F;vhosts&#x2F;www&#x2F;htdocs&#x2F;index.html&#96; <br></code></pre></td></tr></table></figure>
<p>server {<br>    root /vhosts/www/htdocs/<br>    location /admin/ {<br>       root /webapps/app1/data/<br>    }<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/admin/index.html`–&gt;`/webapps/app1/data/admin/index.html" target="_blank" rel="noopener">http://www.yulongjun.com/admin/index.html`–&gt;`/webapps/app1/data/admin/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>### 3、&#96;alias PATH;&#96;<br><br>[![img](05-ngx_http_core_module详解.assets&#x2F;15034969755802.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034969755802.jpg)<br><br>路径别名，文档映射的另一种机制；仅能用于location上下文<br><br>示例： <br></code></pre></td></tr></table></figure>
<p>location /bbs/ {<br>    alias /web/forum/;<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/bbs/index.php`–&gt;" target="_blank" rel="noopener">http://www.yulongjun.com/bbs/index.php`–&gt;</a> `/web/forum/index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>相比之下，root是这样的： <br></code></pre></td></tr></table></figure>
<p>location /bbs/ {<br>    root /web/forum/;<br>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.yulongjun.com/bbs/index.php`–&gt;" target="_blank" rel="noopener">http://www.yulongjun.com/bbs/index.php`–&gt;</a> `/web/forum/bbs/index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>注意：location中使用&#96;root&#96;指令和&#96;alias&#96;指令的意义不同<br><br>(a) root，给定的路径对应于location中的&#96;&#x2F;uri&#x2F;&#96;**左**侧的&#96;&#x2F;&#96;<br><br>(b) alias，给定的路径对应于location中的&#96;&#x2F;uri&#x2F;&#96;**右**侧的&#96;&#x2F;&#96;<br><br>### 4、&#96;index file&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221826.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034971105980.jpg)<br>指定默认网页资源，注意,这个是在&#96;ngx_http_index_module&#96;模块。<br><br>### 5、&#96;error_page&#96; 错误页404<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221834.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034978784852.jpg) <br></code></pre></td></tr></table></figure>
<p>error_page 404 /404.html;<br>error_page 500 502 503 504 /50x.html;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>这将导致内部重定向到*uri* 客户端请求方法指定的内部重定向更改为“GET”（对于除“GET”和“HEAD” 之外的所有方法）。<br><br>此外，可以使用*&#x3D;response*语法将响应代码更改为另一个，例如：<br></code></pre></td></tr></table></figure>
<p>error_page 404 = 200 /empty.gif;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>如果代理服务器或&#96;FastCGI&#x2F;uwsgi&#x2F;SCGI&#96;服务器处理错误响应，并且服务器可能返回不同的响应代码（例如200、302、401或404），则可以使用返回的代码进行响应：<br></code></pre></td></tr></table></figure>
<p>error_page 404 = /404.php;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>如果在内部重定向期间不需要更改URI和方法，则可以将错误处理传递到命名位置：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    error_page 404 = @fallback;<br>} </p>
<p>location @fallback {<br>    proxy_pass http：//后端;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 如果*uri*处理导致错误，则将最后发生的错误的状态代码返回给客户端。<br><br>还可以使用URL重定向进行错误处理：<br></code></pre></td></tr></table></figure>
<p>error_page 403 <a href="http://example.com/forbidden.html" target="_blank" rel="noopener">http://example.com/forbidden.html</a>;<br>error_page 404 = 301 <a href="http://example.com/notfound.html" target="_blank" rel="noopener">http://example.com/notfound.html</a>;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&gt; 在这种情况下，默认情况下，将响应代码302返回给客户端。它只能更改为重定向状态代码之一（301,302,303,307和308）。<br>&gt; 当且仅当没有error_page 在当前级别上定义指令时，这些指令才能从上一级继承 。<br><br>### 6、try_files<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221844.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034979377926.jpg)<br><br>以指定的顺序检查文件的存在，并使用第一个找到的文件进行请求处理; 该处理在当前上下文中执行。文件的路径是*file*根据根和别名指令的参数 构建的 。可以通过在名称末尾指定斜杠来检查目录的存在，例如“ *$uri&#x2F;*”。如果没有找到任何文件，则会*uri*进行最后一个参数中指定的内部重定向 。例如：<br></code></pre></td></tr></table></figure>
<p>location /images/ {<br>    try_files $uri /images/default.gif;<br>}</p>
<p>location = /images/default.gif {<br>    expires 30s;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>最后一个参数也可以指向一个命名的位置，如下面的例子所示。从0.7.51版本开始，最后一个参数也可以是 *code*：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/index.html $uri.html =404;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>&#96;Drupal&#x2F;FastCGI&#96;示例：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/ @drupal;<br>}</p>
<p>location ~ .php$ {<br>    try_files $uri @drupal;</p>
<pre><code>fastcgi_pass ...;

fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
fastcgi_param SCRIPT_NAME     $fastcgi_script_name;
fastcgi_param QUERY_STRING    $args;

... other fastcgi_param&apos;s</code></pre><p>}</p>
<p>location @drupal {<br>    fastcgi_pass …;</p>
<pre><code>fastcgi_param SCRIPT_FILENAME /path/to/index.php;
fastcgi_param SCRIPT_NAME     /index.php;
fastcgi_param QUERY_STRING    q=$uri&amp;$args;

... other fastcgi_param&apos;s</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>在上面的例子中，<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/ @drupal;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>该*try_files*指令相当于下面两端代码的结合：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    error_page 404 = @drupal;<br>    log_not_found off;<br>}<br>location ~ .php$ {<br>    try_files $uri @drupal;</p>
<pre><code>fastcgi_pass ...;

fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;

...</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>*try_files* 在将请求传递给FastCGI服务器之前检查PHP文件的存在。<br><br>Wordpress和Joomla的示例：<br></code></pre></td></tr></table></figure>
<p>location / {<br>    try_files $uri $uri/ @wordpress;<br>}</p>
<p>location ~ .php$ {<br>    try_files $uri @wordpress;</p>
<pre><code>fastcgi_pass ...;

fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
... other fastcgi_param&apos;s</code></pre><p>}</p>
<p>location @wordpress {<br>    fastcgi_pass …;</p>
<pre><code>fastcgi_param SCRIPT_FILENAME /path/to/index.php;
... other fastcgi_param&apos;s</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>------<br><br>## 定义客户端请求的相关配置<br><br>### 1、&#96;keepalive_timeout&#96;设定长连接的超时时长<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221853.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034986592949.jpg)<br><br>第一个参数设置保持连接的超时时长，0表示禁止长连接。默认为75s，推荐120s<br><br>可选的第二个参数在“Keep-Alive：timeout &#x3D; time”响应头域中设置一个值。两个参数可能不同。<br><br>Mozilla和Konqueror可以识别 &#96;Keep-Alive：timeout &#x3D; time&#96;头域。MSIE在大约60秒内自行关闭保持连接。<br><br>### 2、&#96;keepalive_requests&#96;长连接允许请求的资源的最大数量<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221858.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034986843839.jpg)<br><br>在一次长连接上所允许请求的资源的最大数量。默认为100<br><br>### 3、&#96;keepalive_disable&#96;对哪种浏览器禁用长连接<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221904.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034987149301.jpg)<br><br>### 4、&#96;send_timeout&#96;设置用于向客户端发送响应的超时时间<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221917.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034987424203.jpg)<br><br>设置用于向客户端发送响应的超时时间。超时仅在两个连续的写入操作之间设置，而不是传输整个响应。如果客户端在这段时间内没有收到任何内容，则连接被关闭。<br><br>### 5、&#96;client_body_buffer_size&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221932.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15034997030744.jpg)<br><br>设置读取客户端请求体的缓冲区大小。如果请求体大于缓冲区，则整个身体或仅将其部分写入 临时文件。默认情况下，缓冲区大小等于两个内存页面。这是x86上的8K，其他32位平台和x86-64。其他64位平台通常为16K。<br><br>### 6、&#96;client_body_temp_path&#96;<br><br>定义用于存储持有客户机请求主体的临时文件的目录。最多可以在指定目录下使用三级子目录层次结构。例如，在以下配置中：<br></code></pre></td></tr></table></figure>
<p>client_body_temp_path /spool/nginx/client_temp 1 2;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>临时文件hash：<br><br>85c9d32c3526a1bbb3996525ec80b3e0f7aa83dd<br></code></pre></td></tr></table></figure>
<p>ls /spool/nginx/client_temp/d/3d/a83/<br>85c9d32c3526a1bbb3996525ec80b3e0f7aa83dd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>我们可以看到就是逐级从右边截取hash值<br><br>目录名为16进制的数字；<br><br>1 1级目录占1位16进制，即2^4&#x3D;16个目录 0-f<br><br>2 2级目录占2位16进制，即2^8&#x3D;256个目录 00-ff<br><br>2 3级目录占2位16进制，即2^8&#x3D;256个目录 00-ff<br><br>------<br><br>## 对客户端进行限制的相关配置<br><br>### 1、&#96;limit_rate&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221939.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15042666972847.jpg)<br><br>限制响应给客户端的传输速率，单位是bytes&#x2F;second<br><br>默认值0表示无限制<br><br>### 19、&#96;limit_except&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130221945.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15042667307350.jpg)<br><br>限制客户端使用除了指定的请求方法之外的其它方法，只能用在location上下文。<br><br>**&#96;Method&#96;**:GET, HEAD, POST, PUT, DELETE<br><br>MKCOL, COPY, MOVE, OPTIONS, PROPFIND,<br><br>PROPPATCH, LOCK, UNLOCK, PATCH<br></code></pre></td></tr></table></figure>
<p>limit_except GET HEAD POST {<br>    deny 192.168.111.200<br>    allow 192.168.111.0/24;<br>    deny all;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>表示除了GET、HEAD、POST方法其他方法都限制，主机范围为：禁止192.168.111.200、允许192.168.111.0&#x2F;24、禁止所有。即仅允许192.168.111.0网段访问，但是禁止192.168.111.200的地址访问。<br><br>------<br><br>## 文件操作优化的配置<br><br>### 1. &#96;aio&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222535.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035371542671.jpg)<br><br>是否启用Linux的aio功能。<br><br>### 2. &#96;directio&#96;<br><br>[![img](05-ngx_http_core_module详解.assets&#x2F;15035371833381.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035371833381.jpg)<br><br>是否同步写磁盘，在Linux主机启用O_DIRECT标记，意味文件大于等于给定的大小时使用，例如&#96;directio 4m&#96;<br><br>### 3. &#96;open_file_cache&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222542.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035372196986.jpg)<br><br>nginx可以缓存以下三种信息：<br><br>1. 文件元数据：文件的描述符、文件大小和最近一次的修改时间<br>2. 打开的目录结构<br>3. 没有找到的或者没有权限访问的文件的相关信息<br><br>&#96;max&#x3D;N&#96;：可缓存的缓存项上限；达到上限后会使用LRU算法实现管理。<br>&#96;inactive&#x3D;time&#96;：缓存项的非活动时长，在此处指定的时长内未被命中的或命中的次数少于&#96;open_file_cache_min_uses&#96;指令所指定的次数的缓存项 即为非活动项，将被删除。<br><br>### 4. &#96;open_file_cache_errors&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222607.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035373075583.jpg)<br><br>是否缓存查找时发生错误的文件一类的信息。<br><br>### 5. &#96;open_file_cache_min_uses&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130222613.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035373927696.jpg)<br><br>open_file_cache指令的inactive参数指定的时长内，至少被命中此处指定的次数方可被归类为活动项。<br><br>### 6. &#96;open_file_cache_valid&#96;<br><br>[![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130230601.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15035374264499.jpg)<br><br>缓存项有效性的检查频率。<br><br>综上来个例子：<br></code></pre></td></tr></table></figure>
<p>aio                      on;<br>directio                 4m;<br>open_file_cache          max=1000 inactive=20s;<br>open_file_cache_valid    30s;<br>open_file_cache_min_uses 2;<br>open_file_cache_errors   on;</p>
<p>```</p>
<hr>
<blockquote>
<p>其他模块暂时没时间写，有时间再写。可以去查看<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">官方文档</a>的<code>Module reference</code>(模块参考），用的比较多的是<a href="http://www.yulongjun.com/linux/20170821-03-nginx-main-config/" target="_blank" rel="noopener">NGINX主配置文件</a>里讲到的那些模块，这里再次列出来。</p>
</blockquote>
<ul>
<li><p>核心模块：</p>
<ul>
<li><strong>core module</strong></li>
</ul>
</li>
<li><p>常用的标准模块：</p>
<ul>
<li><p>HTTP modules</p>
<p>：</p>
<ul>
<li><strong><code>ngx_http_core_modules</code></strong> http核心功能模块（重要）</li>
<li><strong><code>ngx_http_ssl_module</code></strong> http信道加密模块（重要）</li>
<li><strong><code>ngx_http_upstream_module</code></strong> http定义服务器组模块（重要）</li>
<li><strong><code>ngx_http_fastcgi|uWSGI|SCGI_module</code></strong> http web api接口模块（重要）</li>
<li><strong><code>ngx_http_proxy_module</code></strong> http反向代理模块（重要）</li>
<li><strong><code>ngx_http_gzip_module</code></strong> http gzip压缩传输模块（次一级）</li>
<li><strong><code>ngx_http_log_module</code></strong> http日志模块（次一级）</li>
<li><strong><code>ngx_http_referer_module</code></strong>http防盗链模块（次一级）</li>
<li><strong><code>ngx_http_rewrite_module</code></strong> http重定向模块（次一级）</li>
<li><strong><code>ngx_http_access_module</code></strong> http权限控制模块</li>
<li><strong><code>ngx_http_auth_basic_module</code></strong> http认证模块</li>
<li><strong><code>ngx_http_stub_status_module</code></strong> http状态模块</li>
<li><strong><code>ngx_http_headers_module</code></strong> http首部信息模块</li>
</ul>
</li>
<li><p>Mail modules</p>
<p>：</p>
<ul>
<li>用的少</li>
</ul>
</li>
<li><p>Stream modules</p>
<p>：</p>
<ul>
<li><strong><code>ngx_stream_core_module</code></strong> http的伪四层负载均衡模块</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>05-关机重启命令</title>
    <url>/05-%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p><code>poweroff</code> ：关机</p>
</li>
<li><p><code>halt</code> ：关机，CentOS 6 断电，CentOS 7 不断电</p>
</li>
<li><p><code>reboot</code> ：重启</p>
</li>
<li><p>init方式：</p>
<ul>
<li><code>init 0</code>：关机</li>
<li><code>init 3</code>：CLI界面(Command Line Interface)</li>
<li><code>init 5</code>：图形界面(GUI Graphycal U Interface)</li>
<li><code>init 6</code>：重启</li>
</ul>
</li>
<li><p><code>shutdown</code>：关机或重启</p>
<ul>
<li><p>USAGE：<strong><code>shutdown [OPTIONS] ... TIME [MESSAGE]</code></strong></p>
</li>
<li><p>OPTIONS:</p>
<ul>
<li><p><code>-h</code>：halt，关机</p>
</li>
<li><p><code>-r</code>：reboot，重启</p>
</li>
<li><p><code>-c</code>：cancel，取消关机或重启</p>
</li>
<li><pre><code>TIME</code></pre><p>:</p>
<ul>
<li><code>now</code>: 立刻</li>
<li><code>+m</code>: 相对时间表示法，多久之后；例如 +3</li>
<li><code>hh:mm</code>: 绝对时间表示，指明具体时间</li>
<li><code>MESSAGE</code>：关机前发送的消息广播</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>shutdown</code>的几个例子：</p>
<ul>
<li><code>shutdown -h now</code></li>
<li><code>shutdown -r now</code></li>
<li><code>shutdown -r +60</code></li>
<li><code>shutdown -h 18:30 &quot;系统即将关机&quot;</code></li>
<li><code>shutdown -c</code></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>05-双网络双活模式的Keepalived+Nginx配置</title>
    <url>/05-%E5%8F%8C%E7%BD%91%E7%BB%9C%E5%8F%8C%E6%B4%BB%E6%A8%A1%E5%BC%8F%E7%9A%84Keepalived+Nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/Keepalived-Nginx-AAmodel.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135832.jpg" alt="Keepalived-Nginx-AAmodel"></a></p>
<h2 id="Vagrant配置实验环境"><a href="#Vagrant配置实验环境" class="headerlink" title="Vagrant配置实验环境"></a>Vagrant配置实验环境</h2><p><code>Vagrantfile</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- mode: ruby -*-<br># vi: set ft&#x3D;ruby :<br><br>Vagrant.configure(&quot;2&quot;) do |config|<br>  # Vagrant Global Config<br>  # &#96;longdream&#x2F;centos7&#96; is a custom centos7 box made by YuLongjun.<br>  config.vm.box &#x3D; &quot;longdream&#x2F;centos7&quot;<br>  # If this box is add online, set true will check update.<br>  # Also set &#96;false&#96; will not update it.<br>  # If this box is added locally, this setting is invalid.<br>  config.vm.box_check_update &#x3D; false<br>  # you need &#96;vagrant plugin install vagrant-vbguest&#96;<br>  # You also need &#96;vagrant plugin install vagrant-hostmanager&#96;<br>  config.hostmanager.enabled &#x3D; true<br>  # Allow update &#96;&#x2F;etc&#x2F;hosts&#96; file in VMs.<br>  config.hostmanager.manage_guest &#x3D; true<br>  # Allow update &#96;&#x2F;etc&#x2F;hosts&#96; file in Hosts.<br>  config.hostmanager.manage_host &#x3D; true<br><br>  # Create VM ka1.<br>  config.vm.define &quot;ka1&quot; do |ka1|<br>    ka1.vm.network &quot;public_network&quot;, ip: &quot;172.16.111.10&quot;, bridge: &quot;en0: Wi-Fi (AirPort)&quot;<br>    ka1.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.10&quot;<br>    ka1.vm.hostname &#x3D; &quot;ka1&quot;<br>  end<br><br>  # Create VM ka2.<br>  config.vm.define &quot;ka2&quot; do |ka2|<br>    ka2.vm.network &quot;public_network&quot;, ip: &quot;172.16.111.20&quot;, bridge: &quot;en0: Wi-Fi (AirPort)&quot;<br>    ka2.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.20&quot;<br>    ka2.vm.hostname &#x3D; &quot;ka2&quot;<br>  end<br><br>  # Create VM web1.<br>  config.vm.define &quot;web1&quot; do |web1|<br>    web1.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.30&quot;<br>    web1.vm.hostname &#x3D; &quot;web1&quot;<br>  end<br><br>  # Create VM web2<br>  config.vm.define &quot;web2&quot; do |web2|<br>    web2.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.40&quot;<br>    web2.vm.hostname &#x3D; &quot;web2&quot;<br>  end<br><br>end<br></code></pre></td></tr></table></figure>

<p><code>vagrant up</code>启动4台虚拟机。</p>
<h2 id="配置Keepalived"><a href="#配置Keepalived" class="headerlink" title="配置Keepalived"></a>配置Keepalived</h2><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><p>（1）时间同步，略<br>（2）关闭SELinux和防火墙，略<br>（3）互相之间/etc/hosts文件添加对方主机名，略<br>（4）确认接口支持多播（组播），略，基本新的网卡都支持。</p>
<h3 id="打开ka1和ka2的ip-forward"><a href="#打开ka1和ka2的ip-forward" class="headerlink" title="打开ka1和ka2的ip_forward"></a>打开ka1和ka2的ip_forward</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo &quot;net.ipv4.ip_forward&#x3D;1&quot; &gt;&gt;&#x2F;etc&#x2F;sysctl.conf<br>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br></code></pre></td></tr></table></figure>

<h3 id="配置ka1"><a href="#配置ka1" class="headerlink" title="配置ka1"></a>配置ka1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y keepalived<br>systemctl enable keepalived<br>cp &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf&#123;,.bak&#125;<br></code></pre></td></tr></table></figure>

<p><code>vim /etc/keepalived/keepalived.conf</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka1@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;  <br>&#125;<br><br>vrrp_instance External_2 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 172<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 9d3d15d5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;  <br>&#125;<br><br>vrrp_instance Internal_1 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 191<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br><br>vrrp_instance Internal_2 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 192<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="配置ka2"><a href="#配置ka2" class="headerlink" title="配置ka2"></a>配置ka2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">global_defs &#123;<br>   notification_email &#123;<br>     root@localhost<br>   &#125;<br>   notification_email_from ka2@localhost<br>   smtp_server 127.0.0.1<br>   smtp_connect_timeout 30<br>   vrrp_mcast_group4 224.111.111.111<br>&#125;<br><br>vrrp_instance External_1 &#123;<br>    state BACKUP<br>    interface eth1<br>    virtual_router_id 171<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1402b1b5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br> &#125;<br> <br>vrrp_instance External_2 &#123;<br>    state MASTER<br>    interface eth1<br>    virtual_router_id 172<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 9d3d15d5<br>    &#125;<br>    virtual_ipaddress &#123;<br>        172.16.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br>   &#125;<br>   <br>vrrp_instance Internal_1 &#123;<br>    state BACKUP<br>    interface eth2<br>    virtual_router_id 191<br>    priority 95<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 0702f7ab<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.100<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br>&#125;<br><br>vrrp_instance Internal_2 &#123;<br>    state MASTER<br>    interface eth2<br>    virtual_router_id 192<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 85c9a27b<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.111.200<br>    &#125;<br>    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;<br>    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;<br>    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;          <br>&#125;<br></code></pre></td></tr></table></figure>

<p>ka1和ka2分别放一个同样的脚本：<code>/etc/keepalived/notify.sh</code>，实现切换通知功能。</p>
<p><code>vim /etc/keepalived/notify.sh</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>#<br>contact&#x3D;&#39;root@localhost&#39;<br>                <br>notify() &#123;<br>    local mailsubject&#x3D;&quot;$(hostname) to be $1, vip floating&quot;<br>    local mailbody&#x3D;&quot;$(date +&#39;%F %T&#39;): vrrp transition, $(hostname) changed to be $1&quot;<br>    echo &quot;$mailbody&quot; | mail -s &quot;$mailsubject&quot; $contact<br>&#125;<br>                <br>case $1 in<br>master)<br>    notify master   <br>    ;;<br>backup)<br>    notify backup<br>    systemctl start nginx   # 此处配置后，Nginx服务挂了能自动启动   <br>    ;;<br>fault)<br>    notify fault    <br>    ;;<br>*)<br>    echo &quot;Usage: $(basename $0) &#123;master|backup|fault&#125;&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<h2 id="测试keepalived功能"><a href="#测试keepalived功能" class="headerlink" title="测试keepalived功能"></a>测试keepalived功能</h2><p>ka1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start keepalived.service<br>systemctl status keepalived.service<br>ip a<br></code></pre></td></tr></table></figure>

<p>在ka2没启动前，ka1添加了4个ip<code>192.168.111.100</code>、<code>192.168.111.200</code>、<code>172.16.111.100</code>、<code>172.16.111.200</code><br><a href="http://www.yulongjun.com/images/15048548588627.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135833.jpg" alt="img"></a></p>
<p>ka2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start keepalived.service<br>systemctl status keepalived.service<br>ip a<br></code></pre></td></tr></table></figure>

<p>ka2一启动，ka1就移除了<code>192.168.111.200</code>、<code>172.16.111.200</code>，ka2就添加了<code>192.168.111.200</code>、<code>172.16.111.200</code></p>
<p><a href="http://www.yulongjun.com/images/15048549886577.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135834.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15048551350346.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135835.png" alt="img"></a></p>
<p>我们停掉ka1：</p>
<p>ka1移除了了<code>192.168.111.100</code>和<code>172.16.111.100</code></p>
<p><a href="http://www.yulongjun.com/images/15048552668973.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135836.png" alt="img"></a></p>
<p>ka2添加了<code>192.168.111.100</code>和<code>172.16.111.100</code> ,然后拥有了4个vip。</p>
<p><a href="http://www.yulongjun.com/images/15048553119650.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135837.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15048553464461.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135838.jpg" alt="img"></a></p>
<p>我们还可以通过tcpdump命令来分别查看组播状态。</p>
<p>ka1和ka2都可运行下面命令来查看组播地址检查心跳的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tcpdump -nn -i eth1 host 224.111.111.111<br>tcpdump -nn -i eth2 host 224.111.111.111<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15048553827519.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135839.jpg" alt="img"></a></p>
<blockquote>
<p>tips：在虚拟机软件里，关闭网卡物理连接，ip也是可以漂移的。</p>
</blockquote>
<p>至此，vrrp的的高可用测试完毕。我们继续配置Nginx服务。</p>
<hr>
<h2 id="安装后端Web服务器"><a href="#安装后端Web服务器" class="headerlink" title="安装后端Web服务器"></a>安装后端Web服务器</h2><p>web1和web2分别安装httpd或者nginx作为http服务，这里安装的httpd：</p>
<p>web1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y httpd<br>echo &quot;&lt;h1&gt;Real Server 1&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html<br>systemctl start httpd<br>systemctl enable httpd<br></code></pre></td></tr></table></figure>

<p>web2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y httpd<br>echo &quot;&lt;h1&gt;Real Server 2&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;index.html<br>systemctl start httpd<br>systemctl enable httpd<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实验环境为了显示不同，故意设置成不同的页面，实际生产中获取的内容应该一致。</p>
</blockquote>
<p><strong>测试httpd功能：</strong></p>
<p>ka1或ka2上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">curl 192.168.111.30<br>curl 192.168.111.40<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15048744833355.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135840.jpg" alt="img"></a></p>
<h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>在ka1和ka2上分别yum安装Nginx最新稳定版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo &lt;&lt;EOF<br>[nginx]<br>name&#x3D;nginx repo<br>baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;\$releasever&#x2F;\$basearch&#x2F;<br>gpgcheck&#x3D;0<br>enabled&#x3D;1<br>EOF<br><br>yum install -y nginx<br><br> mv &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf&#123;,.bak&#125;<br> <br>cat &gt;&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;vhost1.conf &lt;&lt;EOF<br>upstream websrvs &#123;<br>    server 192.168.111.30:80;<br>    server 192.168.111.40:80;<br>&#125;<br><br>server &#123;<br>    location &#x2F; &#123;<br>    proxy_pass http:&#x2F;&#x2F;websrvs;<br>    &#125;<br>&#125;<br>EOF<br><br>systemctl start nginx<br></code></pre></td></tr></table></figure>

<p>分别在ka1和ka2上测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for i in &#96;seq 10&#96;; do curl 192.168.111.10; done<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15048745812444.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135841.jpg" alt="img"></a></p>
<p>至此，Nginx功能也实现了。我们接下来把Nginx和Keepalived结合起来，使Nginx支持高可用。</p>
<h2 id="配置Keepalived使Nginx实现高可用"><a href="#配置Keepalived使Nginx实现高可用" class="headerlink" title="配置Keepalived使Nginx实现高可用"></a>配置Keepalived使Nginx实现高可用</h2><p>在ka1和ka2的<code>/etc/keepalived/keepalived.conf</code>的全局配置块<code>global_defs</code>下方配置<code>vrrp_script</code>块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vrrp_script chk_nginx &#123;<br>    script &quot;killall -0 nginx&quot;<br>    interval 2<br>    weight -10<br>    fall 2<br>    rise 2<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在所有<code>vrrp_instance</code>实例块里，添加<code>track_script</code>块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">track_script &#123;<br>    chk_nginx<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置完后，重启ka1和ka2的keepalived服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl stop keepalived<br>systemctl start keepalived<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="一开始……实验并未成功"><a href="#一开始……实验并未成功" class="headerlink" title="一开始……实验并未成功"></a>一开始……实验并未成功</h2><blockquote>
<p>警告：此处测试没有成功，o(╯□╰)o，Keepalived正常，但是停掉Nginx后，不会降权，查了好久配置……，最后准备自己写个脚本shell自检测Nginx的时候，写完脚本运行时候发现，没装killall命令！所以不会降权！……坑啊！</p>
</blockquote>
<p><a href="http://www.yulongjun.com/images/keng.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135842.jpg" alt="keng"></a></p>
<p>安装psmisc包，包含killall命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install psmisc<br></code></pre></td></tr></table></figure>

<h2 id="安装完killall后，测试完美"><a href="#安装完killall后，测试完美" class="headerlink" title="安装完killall后，测试完美"></a>安装完killall后，测试完美</h2><p>开一个循环，查看效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">while True;do curl 172.16.111.100; curl 172.16.111.200;sleep 0.5; done<br></code></pre></td></tr></table></figure>



<ol>
<li>关闭任意一个Keepalived服务，不受影响。</li>
<li>在Keepalived服务启动的时候，停掉Nginx服务，过一会儿，会自行恢复，如下：</li>
</ol>
<p><a href="http://www.yulongjun.com/images/15048936718711.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203135843.jpg" alt="img"></a></p>
<h2 id="完整配置文件附录"><a href="#完整配置文件附录" class="headerlink" title="完整配置文件附录"></a>完整配置文件附录</h2><p>附上所有完整配置文件的下载链接：(用的七牛云存储，点击即可下载，或者右键“链接另存为”下载）</p>
<p>实验环境的Vagrant配置文件<code>Vagrantfile</code>：<a href="http://ovzl48njw.bkt.clouddn.com/Vagrantfile" target="_blank" rel="noopener">Vagrantfile</a></p>
<p>ka1的Keepalived配置文件<code>/etc/keepalived/keepalived.conf</code>：<a href="http://ovzl48njw.bkt.clouddn.com/keepalived.conf(ka1)" target="_blank" rel="noopener">keepalived.conf(ka1)</a></p>
<p>ka2的Keepalived配置文件<code>/etc/keepalived/keepalived.conf</code>： <a href="http://ovzl48njw.bkt.clouddn.com/keepalived.conf(ka2)" target="_blank" rel="noopener">keepalived.conf(ka2)</a></p>
<p>ka1和ka2的Keepalived调用的通知脚本<code>/etc/keepalived/notify.sh</code>：<a href="http://ovzl48njw.bkt.clouddn.com/notify.sh" target="_blank" rel="noopener">notify.sh</a></p>
<p>ka1和ka2的Nginx配置文件<code>/etc/nginx/conf.d/vhost1.conf</code>：<a href="http://ovzl48njw.bkt.clouddn.com/vhost1.conf" target="_blank" rel="noopener">vhost1.conf</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>05-双网络双活模式的Keepalived+Nginx配置</title>
    <url>/05-%E5%8F%8C%E7%BD%91%E7%BB%9C%E5%8F%8C%E6%B4%BB%E6%A8%A1%E5%BC%8F%E7%9A%84Keepalived-Nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>05-实践：Linux用户、组和密码相关文件被破坏如何恢复系统</title>
    <url>/05-%E5%AE%9E%E8%B7%B5%EF%BC%9ALinux%E7%94%A8%E6%88%B7%E3%80%81%E7%BB%84%E5%92%8C%E5%AF%86%E7%A0%81%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E8%A2%AB%E7%A0%B4%E5%9D%8F%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们先看一下用户用户组和密码相关文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]#ll &#x2F;etc&#x2F;passwd* &#x2F;etc&#x2F;shadow* &#x2F;etc&#x2F;group* &#x2F;etc&#x2F;gshadow*<br>-rw-r--r--. 1 root root  988 May 28 02:34 &#x2F;etc&#x2F;group<br>-rw-r--r--. 1 root root  975 May 28 02:29 &#x2F;etc&#x2F;group-<br>----------. 1 root root  801 May 28 02:34 &#x2F;etc&#x2F;gshadow<br>----------. 1 root root  790 May 28 02:19 &#x2F;etc&#x2F;gshadow-<br>-rw-r--r--. 1 root root 2247 May 28 02:19 &#x2F;etc&#x2F;passwd<br>-rw-r--r--. 1 root root 2247 May 28 02:19 &#x2F;etc&#x2F;passwd-<br>----------. 1 root root 1257 May 28 02:19 &#x2F;etc&#x2F;shadow<br>----------. 1 root root 1262 May 28 02:19 &#x2F;etc&#x2F;shadow-<br></code></pre></td></tr></table></figure>

<p>我们可以看到每一个文件都有一个带<code>-</code>后缀的文件。如果我们不小心破坏了原来的文件，可以用后面的带<code>-</code>文件恢复，基本上能恢复所有的账号和密码。</p>
<p>下面进行破坏模拟实验：</p>
<hr>
<h3 id="CentOS-7-破坏模拟"><a href="#CentOS-7-破坏模拟" class="headerlink" title="CentOS 7 破坏模拟"></a>CentOS 7 破坏模拟</h3><p>1、 在/etc/passwd文件的首行root行加注释<code>#</code>，保存退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>...<br></code></pre></td></tr></table></figure>

<p>2、 然后重启服务器，发现进不去系统。</p>
<p>3、 然后我们重启下，然后再按<code>e</code>修改启动方法：</p>
<p><a href="http://www.yulongjun.com/images/1496030332470.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819175313.png" alt="img"></a></p>
<p>4、 进入到这个界面后，找到<code>linux16</code>那行：</p>
<p><a href="http://www.yulongjun.com/images/1496030433049.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819193939.png" alt="img"></a></p>
<p>5、 在这行的尾部添加<code>init=/bin/bash</code>，然后按<code>&lt;Ctrl-x&gt;</code>后启动：</p>
<p><a href="http://www.yulongjun.com/images/1496030579927.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819175322.png" alt="img"></a></p>
<p>6、 然后我们进入bash：</p>
<p><a href="http://www.yulongjun.com/images/1496030715114.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819175353.png" alt="img"></a></p>
<p>7、 这时候系统是无法写入的，我们要重新以<code>rw</code>的模式<code>remount</code>一下，命令为<code>mount -o rw,remount /</code></p>
<p><a href="http://www.yulongjun.com/images/1496030909833.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819175601.png" alt="img"></a></p>
<p>8、 我们可以修复被修改的<code>/etc/passwd</code>文件，记得先给原<code>/etc/passswd</code>做个备份，然后再复制<code>/etc/passwd-</code>文件去覆盖<code>/etc/passwd</code>，（如果有其他文件如/etc/shadow等被破坏，也可以用此方法）</p>
<p><a href="http://www.yulongjun.com/images/1496031045994.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819175621.png" alt="img"></a></p>
<blockquote>
<p>tips：备份是个好习惯，更改重要文件前最好都要先备份下。</p>
</blockquote>
<p>9、重启服务器（reboot，init，shutdown等重启命令都无法使用，只能硬重启），正常进入操作系统。</p>
<p><a href="http://www.yulongjun.com/images/1496031575578.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819175639.png" alt="img"></a></p>
<hr>
<h3 id="CentOS-6-破坏模拟"><a href="#CentOS-6-破坏模拟" class="headerlink" title="CentOS 6 破坏模拟"></a>CentOS 6 破坏模拟</h3><p>1、 在/etc/shadow文件的首行root行加注释<code>#</code>，保存退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#root:$6$6P086Sg8NUDccylN$O1g3CU1Jhfxp.RwBvwylXF.yVml2dQvAGIAAM.LzIDDqsueS8FrFWfDa&#x2F;S4JZ.4uLs.&#x2F;iQ9f6Ifm7qCYlVV6U.:17313:0:99999:7:::<br>...<br></code></pre></td></tr></table></figure>

<p>2、 然后重启服务器，发现可以进入系统，但是输入root密码后，提示不正确（不输入密码直接进也进不去）。</p>
<p><a href="http://www.yulongjun.com/images/1496032592762.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819190637.png" alt="img"></a></p>
<p>3、 然后我们重启下，在这个界面按任意键进入启动菜单：</p>
<p><a href="http://www.yulongjun.com/images/1496032727123.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819193925.png" alt="img"></a></p>
<p>4、按<code>a</code>修改启动内核启动参数：</p>
<p><a href="http://www.yulongjun.com/images/1496032861610.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819193745.png" alt="img"></a></p>
<p>5、进入到这个界面后，在后面输入<code>init=/bin/bash</code>，然后按回车：</p>
<p><a href="http://www.yulongjun.com/images/1496032960488.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819193917.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1496032978802.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819193758.png" alt="img"></a></p>
<p>6、 然后我们进入bash：</p>
<p><a href="http://www.yulongjun.com/images/1496033120211.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200819193851.png" alt="img"></a></p>
<p>7、 这时候系统是无法写入的，我们要重新以<code>rw</code>的模式<code>remount</code>一下，命令为<code>mount -o rw,remount /</code>（和CentOS 7 一样，就不贴图了）</p>
<p>8、 我们可以修复被修改的<code>/etc/shadow</code>文件，记得先给原<code>/etc/shadow</code>做个备份，然后再复制<code>/etc/shadow-</code>文件去覆盖<code>/etc/shadow</code>，（如果有其他文件如/etc/shadow等被破坏，也可以用此方法）（和CentOS7 一样，就不贴图了）</p>
<blockquote>
<p>tips：备份是个好习惯，更改重要文件前最好都要先备份下。</p>
</blockquote>
<p>9、重启服务器（reboot，init，shutdown等重启命令都无法使用，只能硬重启），正常进入操作系统。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>用户和组</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Nginx的HTTP相关的杂项模块</title>
    <url>/06-Nginx%E7%9A%84HTTP%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9D%82%E9%A1%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要介绍下面几个模块：</p>
<h2 id="ngx-http-access-module"><a href="#ngx-http-access-module" class="headerlink" title="ngx_http_access_module"></a>ngx_http_access_module</h2><p><code>http_access_module</code>包含了http的访问权限控制的一个模块，前面一节的<code>limit_except</code>指令里用过，还可以用在http, server, location等地方。</p>
<p><strong><code>allow</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042681401675.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235102.jpg" alt="img"></a></p>
<p><strong><code>deny</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042681508555.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235103.jpg" alt="img"></a></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location &#x2F;admin &#123;<br>    deny  192.168.1.1;<br>    allow 192.168.1.0&#x2F;24;<br>    allow 10.1.1.0&#x2F;16;<br>    allow 2001:0db8::&#x2F;32;<br>    deny  all;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ngx-http-auth-basic-module"><a href="#ngx-http-auth-basic-module" class="headerlink" title="ngx_http_auth_basic_module"></a>ngx_http_auth_basic_module</h2><p>实现基于用户的访问控制，使用basic机制进行用户认证</p>
<p><strong><code>auth_basic</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042686684419.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235104.jpg" alt="img"></a></p>
<p><strong><code>auth_basic_user_file</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042686761224.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235105.jpg" alt="img"></a></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y http-tools  # htpasswd工具在这个包里<br>htpasswd -c -m &#x2F;etc&#x2F;nginx&#x2F;.htpasswd  admin1  # 之后输入admin1的两次密码<br>htpasswd -m &#x2F;etc&#x2F;nginx&#x2F;.htpasswd  admin2  # 之后设置admin2 的密码<br></code></pre></td></tr></table></figure>

<p>修改nginx的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location &#x2F;admin &#123;<br>    auth_basic           &quot;Admin Area&quot;;<br>    auth_basic_user_file &#x2F;etc&#x2F;nginx&#x2F;.htpasswd;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ngx-sub-status-module"><a href="#ngx-sub-status-module" class="headerlink" title="ngx_sub_status_module"></a>ngx_sub_status_module</h2><p>用于输出nginx的基本状态信息。</p>
<p><strong><code>stub_status</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042694008699.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235106.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location<br><br>&#x2F;basic_status &#123;<br>    stub_status;<br>    allow 172.16.0.0&#x2F;16;<br>    deny all;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Active connections: 291<br>server accepts handled requests<br>16630948 16630948 31070465<br>Reading: 6 Writing: 179 Waiting: 106</p>
</blockquote>
<ul>
<li><code>Active connections</code>: 活动状态的连接数</li>
<li><code>accepts</code>：已经接受的客户端请求的总数</li>
<li><code>handled</code>：已经处理完成的客户端请求的总数</li>
<li><code>requests</code>：客户端发来的总的请求数</li>
<li><code>Reading</code>：正在读取客户端请求报文首部的连接的连接数</li>
<li><code>Writing</code>：正在向客户端发送响应报文过程中的连接数</li>
<li><code>Waiting</code>：正在等待客户端发出请求的空闲连接数</li>
</ul>
<h2 id="ngx-http-log-module"><a href="#ngx-http-log-module" class="headerlink" title="ngx_http_log_module"></a>ngx_http_log_module</h2><p>指定http访问日志格式和路径的模块。</p>
<p><strong><code>log_format</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042721093915.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235107.jpg" alt="img"></a></p>
<p>string可以使用nginx核心模块及其它模块内嵌的变量。<br>Nginx内嵌变量：<a href="http://nginx.org/en/docs/varindex.html" target="_blank" rel="noopener">http://nginx.org/en/docs/varindex.html</a></p>
<p>我们可以看到<code>/etc/nginx/nginx.conf</code>的默认的format格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;<br>                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;<br>                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;<br></code></pre></td></tr></table></figure>

<p>具体分析一下：</p>
<ul>
<li><code>$remote_addr</code>：指的就是客户端地址。</li>
<li><code>$remote_user</code>：Basic认证时候的用户名</li>
<li><code>[$time_local]</code>： 中括号括起来的本地时间(通用的日志格式的那种）</li>
<li><code>$request</code>：request URI</li>
<li><code>$status</code>：响应码</li>
<li><code>body_bytes_sent</code>：返回的body大小</li>
<li><code>http_referer</code>：跳转链接，从哪个网页跳转过来，可以用来看外链。</li>
<li><code>http_user_agent</code>：用户浏览器类型</li>
<li><code>http_x_forwarded_for</code>：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，在通过了HTTP 代理或者负载均衡服务器时会添加该项。</li>
</ul>
<blockquote>
<p>httpd的日志格式默认使用的combined模式，combined格式的默认定义为：<br><code>LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined</code><br>这里写了各种参数代表的意义：<a href="http://blog.csdn.net/hytfly/article/details/11209909" target="_blank" rel="noopener">http://blog.csdn.net/hytfly/article/details/11209909</a><br>官方详细参数解析：<a href="http://httpd.apache.org/docs/2.4/mod/mod_log_config.html#formats" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/mod/mod_log_config.html#formats</a></p>
</blockquote>
<p><strong><code>access_log</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042721383996.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235108.jpg" alt="img"></a></p>
<p>可以在不同的区域自定义访问日志文件路径和文件名，还有日志格式，以及相关的缓冲的配置：</p>
<ul>
<li>buffer=size</li>
<li>flush=time</li>
</ul>
<p><strong><code>open_log_file_cache</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15042721222468.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235109.jpg" alt="img"></a></p>
<p>缓存各日志文件相关的元数据信息。</p>
<ul>
<li>max：缓存的最大文件描述符数量</li>
<li>min_uses：在inactive指定的时长内访问大于等于此值方 可被当作活动项</li>
<li>inactive：非活动时长</li>
<li>valid：验正缓存中各缓存项是否为活动项的时间间隔</li>
</ul>
<h2 id="ngx-gzip-module"><a href="#ngx-gzip-module" class="headerlink" title="ngx_gzip_module"></a>ngx_gzip_module</h2><p><strong><code>gzip</code></strong></p>
<p>是否开启gzip。</p>
<p><a href="http://www.yulongjun.com/images/15042767219690.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235110.jpg" alt="img"></a></p>
<p><strong><code>gzip_comp_level</code></strong></p>
<p>gzip压缩级别。级别1-9。</p>
<p><a href="http://www.yulongjun.com/images/15042767486590.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235111.jpg" alt="img"></a></p>
<p><strong><code>gzip disable</code></strong></p>
<p>禁止IE6之类的浏览器压缩。</p>
<p><a href="http://www.yulongjun.com/images/15042767723557.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235112.jpg" alt="img"></a></p>
<p><strong><code>gzip_min_length</code></strong></p>
<p>不能多大的文件都压缩吧，那样效率很低，这里规定了gzip压缩的最小响应报文大小。</p>
<p><a href="http://www.yulongjun.com/images/15042767839800.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235113.jpg" alt="img"></a></p>
<p><strong><code>gzip_buffers</code></strong></p>
<p>支持实现压缩功能时为其配置的缓冲区数量及每个缓存区的大小。</p>
<p><a href="http://www.yulongjun.com/images/15042767368732.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235114.jpg" alt="img"></a></p>
<p><strong><code>gzip_proxied</code></strong></p>
<p>nginx作为代理服务器接收到从被代理服务器发送的响应报文后，在何种条件下启用压缩功能的。</p>
<p><a href="http://www.yulongjun.com/images/15042769199720.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235023.jpg" alt="img"></a></p>
<p><code>off</code>：对代理的请求不启用。<br><code>no-cache, no-store，private</code>：表示从被代理服务器收到的响应报文首部的Cache-Control的值为此三者中任何一个，则启用压缩功能。</p>
<p><strong><code>gzip_types mime-type</code></strong></p>
<p>压缩过滤器，仅对此处设定的MIME类型的内容启用压缩功能。</p>
<p><a href="http://www.yulongjun.com/images/15042769348380.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235018.jpg" alt="img"></a></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">gzip  on;<br>gzip_comp_level 6;<br>gzip_min_length 64;<br>gzip_proxied any;<br>gzip_types text&#x2F;xml text&#x2F;css  application&#x2F;javascript;<br></code></pre></td></tr></table></figure>

<h2 id="ngx-http-ssl-module"><a href="#ngx-http-ssl-module" class="headerlink" title="ngx_http_ssl_module"></a>ngx_http_ssl_module</h2><p><strong><code>ssl</code></strong></p>
<p>开启或关闭ssl。</p>
<p><a href="http://www.yulongjun.com/images/15042783534830.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235010.jpg" alt="img"></a></p>
<p><strong><code>ssl_certificate</code></strong></p>
<p>当前虚拟主机使用PEM格式的证书文件。</p>
<p><a href="http://www.yulongjun.com/images/15042783667235.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235004.jpg" alt="img"></a></p>
<p><strong><code>ssl_certificate_key</code></strong></p>
<p>当前虚拟主机上与其证书匹配的私钥文件。</p>
<p><a href="http://www.yulongjun.com/images/15042783865794.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234959.jpg" alt="img"></a></p>
<p><strong><code>ssl_protocols</code></strong></p>
<p>支持ssl协议版本，默认为1、1.1、1.2，为了安全可以改为1.3，1.2是有安全漏洞的。</p>
<p><a href="http://www.yulongjun.com/images/15042784116536.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234951.jpg" alt="img"></a></p>
<p><strong><code>ssl_session_cache</code></strong></p>
<p>builtin[:size]：使用OpenSSL内建的缓存，此缓存为每worker进程私有。<br>[shared:name:size]：在各worker之间使用一个共享的缓存。</p>
<p><a href="http://www.yulongjun.com/images/15042784835696.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234945.jpg" alt="img"></a></p>
<p><strong><code>ssl_session_timeout</code></strong></p>
<p>客户端一侧的连接可以复用ssl session cache中缓存的ssl参数的有效时长。</p>
<p><a href="http://www.yulongjun.com/images/15042785149633.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234935.jpg" alt="img"></a></p>
<p><code>ngx_http_ssl_module</code>参数示例：</p>
<p>生成自签名证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cd &#x2F;etc&#x2F;pki&#x2F;CA<br>openssl genrsa -out  private&#x2F;cakey.pem 4096<br>chmod go&#x3D; private&#x2F;cakey.pem<br>openssl req -new -x509 -key private&#x2F;cakey.pem -out  cacert.pem -days 365<br>touch index.txt<br>echo 01&gt; serial<br>cd &#x2F;etc&#x2F;nginx<br>mkdir ssl<br>cd ssl<br>(umask 077; openssl genrsa -out nginx.key 2048)<br>openssl req -new -key nginx.key -out nginx.csr<br>openssl ca -in nginx.csr -out nginx.crt<br></code></pre></td></tr></table></figure>



<p>配置ssl模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &#123;<br>	listen 443 ssl;<br>	server_name www.yulongjun.com;<br>	root &#x2F;vhosts&#x2F;ssl&#x2F;htdocs;<br>	ssl on;<br>	ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.crt;<br>	ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.key;<br>	ssl_session_cache shared:sslcache:20m;<br>	ssl_session_timeout 600s;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="ngx-http-rewrite-module（URL重写）"><a href="#ngx-http-rewrite-module（URL重写）" class="headerlink" title="ngx_http_rewrite_module（URL重写）"></a>ngx_http_rewrite_module（URL重写）</h2><p>有下面几种url重写：</p>
<blockquote>
<p><a href="http://bbs.yulongjun.com/" target="_blank" rel="noopener">http://bbs.yulongjun.com/</a> –&gt; <a href="http://www.yulongjun.com/bbs/" target="_blank" rel="noopener">http://www.yulongjun.com/bbs/</a><br><a href="http://www.yulongjun.com/" target="_blank" rel="noopener">http://www.yulongjun.com/</a> –&gt; <a href="https://www.yulongjun.com/" target="_blank" rel="noopener">https://www.yulongjun.com/</a><br><a href="http://www.yulongjun.com/login.php;username=tom" target="_blank" rel="noopener">http://www.yulongjun.com/login.php;username=tom</a> –&gt;<a href="http://www.yulongjun.com/tom/" target="_blank" rel="noopener">http://www.yulongjun.com/tom/</a></p>
<p><a href="http://www.yulongjun.io/bbs/" target="_blank" rel="noopener">http://www.yulongjun.io/bbs/</a> –&gt; <a href="http://bbs.yulongjun.io/" target="_blank" rel="noopener">http://bbs.yulongjun.io/</a></p>
</blockquote>
<p>将用户请求的URI基于regex所描述的模式进行检查，而后完成替换。</p>
<p><strong><code>rewrite</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15043158084593.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234852.jpg" alt="img"></a></p>
<p>将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定的新的URI。</p>
<p>注意：如果在同一级配置块中存在多个rewrite规则，那么会自下而下逐个检查；被某条件规则替换完成后，会重新一轮的替换检查，因此，隐含有循环机制；[flag]所表示的标志位用于控制此循环机制。</p>
<p>如果replacement是以<a href="http://xn--https-wm6j//开头，则替换结果会直接以重定向返回给客户端。" target="_blank" rel="noopener">http://或https://开头，则替换结果会直接以重定向返回给客户端。</a></p>
<p><code>[flag]</code>：</p>
<ul>
<li><strong>last</strong>：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环(类似于continue)；</li>
<li><strong>break</strong>：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置；结束循环；</li>
<li><strong>redirect</strong>：重写完成后以临时重定向方式(302 Moved</li>
<li>Temprarily)直接返回重写后生成的新URI给客户端，由客户端重新发起请求；不能以<a href="http://xn--https-wm6j//开头；" target="_blank" rel="noopener">http://或https://开头；</a></li>
<li><strong>permanent</strong>：重写完成后以永久重定向方式(301 Moved Permanently)直接返回重写后生成的新URI给客户端，由客户端重新发起请求；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rewrite &#x2F;(.*)$ https:&#x2F;&#x2F;www.yulongjun.io&#x2F;$1;<br>rewrite &#x2F;bbs<br></code></pre></td></tr></table></figure>

<p><strong><code>return</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15043174234909.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234544.jpg" alt="img"></a></p>
<p>停止处理，然后返回一个特殊响应码给客户端。还可以指定返回的url页面。</p>
<p><strong><code>rewrite_log</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15043205846502.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130234841.jpg" alt="img"></a></p>
<p>是否开启重写日志</p>
<p><strong><code>if</code></strong></p>
<p><a href="http://www.yulongjun.com/images/15043205419834.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130232105.jpg" alt="img"></a></p>
<p>引入一个新的配置上下文 ；条件满足时，执行配置块中的配置指令。只支持在server, location。</p>
<p>condition：</p>
<ul>
<li>比较操作符：<ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>~</code>：模式匹配，区分字符大小写；</li>
<li><code>~*</code>：模式匹配，不区分字符大小写；</li>
<li><code>!~</code>：模式不匹配，区分字符大小写；</li>
<li><code>!~</code>*：模式不匹配，不区分字符大小写；</li>
</ul>
</li>
<li>文件及目录存在性判断：<br><code>-e</code>, <code>!-e</code><br><code>-f</code>, <code>!-f</code><br><code>-d</code>, <code>!-d</code><br><code>-x</code>, <code>!-x</code></li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if ($http_user_agent ~ MSIE) &#123;<br>    rewrite ^(.*)$ &#x2F;msie&#x2F;$1 break;<br>&#125;<br><br>if ($http_cookie ~* &quot;id&#x3D;([^;]+)(?:;|$)&quot;) &#123;<br>    set $id $1;<br>&#125;<br><br>if ($request_method &#x3D; POST) &#123;<br>    return 405;<br>&#125;<br><br>if ($slow) &#123;<br>    limit_rate 10k;<br>&#125;<br><br>if ($invalid_referer) &#123;<br>    return 403;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>set</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">![](&#x2F;images&#x2F;15043208822285.jpg)<br></code></pre></td></tr></table></figure>

<p>设置用户自定义变量。</p>
<h2 id="ngx-http-referer-module"><a href="#ngx-http-referer-module" class="headerlink" title="ngx_http_referer_module"></a>ngx_http_referer_module</h2><p>访问有通过地址直接访问，或者从其他网站跳转过来。</p>
<p>用过滤<code>referer</code>头域的方法可以来防止盗链。</p>
<p><strong><code>valid_referers</code></strong></p>
<p>定义referer首部的合法 可用值。</p>
<p><a href="http://www.yulongjun.com/images/15043213666497.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130232052.jpg" alt="img"></a></p>
<ul>
<li><strong>none</strong>：请求报文首部没有referer首部。</li>
<li><strong>blocked</strong>：请求报文的referer首部没有值。</li>
<li><strong>server_names</strong>：参数，其可以有值作为主机名或主机名模式。<ul>
<li><strong>arbitrary_string</strong>：直接字符串，但可使用<code>*</code>作通配符。</li>
<li><strong>regular expression</strong>：被指定的正则表达式模式匹配到的字符串；要使用<code>~</code>打头，例如 <code>~.*\.yulongjun\.com</code>。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">valid_referers none block server_names *.yulongjun.com yulongjun.* ~\.yulongjun\.;<br><br>if($invalid_referer) &#123;<br>	return http:&#x2F;&#x2F;www.yulongjun.com&#x2F;invalid.jpg;<br>&#125;<br>valid_referers none blocked server_names<br>               *.example.com example.* www.example.org&#x2F;galleries&#x2F;<br>               ~\.google\.;<br><br>if ($invalid_referer) &#123;<br>    return 403;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>06-Zabbix-Actions设置</title>
    <url>/06-Zabbix-Actions%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们触发器触发了问题，要通知运维人员去解决问题，动作（Actions)就是用来通知运维人员的设置。</p>
<p>动作分为几个定义块：</p>
<p>（1）触发动作的条件：（这里的条件是：1 不在维护状态；2 触发了触发器 “网络进站包数&gt;10000”)<br><a href="http://www.yulongjun.com/images/15066023466376.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203155231.jpg" alt="img"></a></p>
<p>（2）触发了动作后，相应的操作：（通过MyEmail(<a href="mailto:zabbix@yulongjun.com">zabbix@yulongjun.com</a>)发送给用户Admin（<a href="mailto:ops@yulongjun.com">ops@yulongjun.com</a>)。（此段邮箱设置，在第一节<a href="http://www.yulongjun.com/linux/20170927-01-zabbix-server-installation" target="_blank" rel="noopener">Zabbix Server安装指南</a>上有）</p>
<p><a href="http://www.yulongjun.com/images/15066092870970.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203155232.jpg" alt="img"></a></p>
<p>测试一下效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hping 192.168.0.10<br></code></pre></td></tr></table></figure>

<p>右上角有报警提示，并且有报警音：</p>
<p><a href="http://www.yulongjun.com/images/15066099495635.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203155233.jpg" alt="img"></a></p>
<p>仪表盘上也有报警信息，还可以看到报警邮件已经发送：</p>
<p><a href="http://www.yulongjun.com/images/15066099227096.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203155234.jpg" alt="img"></a></p>
<p>去邮箱查看，确实有报警邮件：（因为阀值设置的比较大，hping一会达到阀值，一会儿不到阈值，所以会看到问题和解决两种邮件。）<br><a href="http://www.yulongjun.com/images/15066100256102.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203155235.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15066097950230.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203155236.jpg" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>06-httpd服务启用压缩功能</title>
    <url>/06-httpd%E6%9C%8D%E5%8A%A1%E5%90%AF%E7%94%A8%E5%8E%8B%E7%BC%A9%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了减少网络带宽的压力，可以对文件进行压缩后才传输，但是缺点是要消耗CPU和内存的资源，CPU和内存的资源和网络的资源要平衡分配，如果带宽足够，CPU和内存不够，就不要过多压缩了。有些资源比如图片压缩率本来就高了，再压缩也没意义。</p>
<h2 id="一、加载压缩模块"><a href="#一、加载压缩模块" class="headerlink" title="一、加载压缩模块"></a>一、加载压缩模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim   &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;gzip.conf <br>LoadModule  deflate_module modules&#x2F;mod_deflate.so<br>    加载模块<br>SetOutputFilter deflate<br>    生效模块<br><br>#http -M 可以查看已经加载的模块，如果有，就不用再次加载1234567<br></code></pre></td></tr></table></figure>

<h2 id="二、定义模块功能"><a href="#二、定义模块功能" class="headerlink" title="二、定义模块功能"></a>二、定义模块功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim   &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;gzip.conf <br><br><br>DeflateCompressionLevel 6<br>    定义压缩比（1-9）<br>        默认是9<br>#压缩格式<br>    AddOutputFilterByType DEFLATE text&#x2F;xml<br>        可以压缩text&#x2F;xml格式文件<br>    AddOutputFilterByType DEFLATE application&#x2F;xml<br>        可以压缩application&#x2F;xml格式文件<br>    AddOutputFilterByType DEFLATE text&#x2F;plain<br>        可以压缩普通文本格式文件<br>    AddOutputFilterByType DEFLATE application&#x2F;xhtml+xml<br>    AddOutputFilterByType DEFLATE application&#x2F;x-javascript<br>    AddOutputFilterByType DEFLATE text&#x2F;javascript<br>    AddOutputFilterByType DEFLATE text&#x2F;css1234567891011121314151617<br></code></pre></td></tr></table></figure>

<h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><h3 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.服务器"></a>1.服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_log &#x2F;var&#x2F;www&#x2F;html&#x2F;m.html1<br></code></pre></td></tr></table></figure>

<p><strong>日志</strong><br><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201129171747" alt="这里写图片描述"><br><strong>源文件大小是13861bytes，传输时是1461bytes</strong></p>
<h3 id="2-测试机"><a href="#2-测试机" class="headerlink" title="2.测试机"></a>2.测试机</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">curl --compressed   172.17.16.169&#x2F;m.html<br>    --compressed 要求返回是压缩的格式<br></code></pre></td></tr></table></figure>

<p>1、检查模块是否已经安装：</p>
<p>[root@wyq63 ~]# httpd -M | grep deflate</p>
<p> deflate_module (shared)#弹出此种结果，则为 DSO 方式安装的</p>
<p>deflate_module (static)#弹出此种结果，则为编译安装时装的</p>
<p>安装了的话，就可以直接迚行压缩配置了，如果没有安装，下面为安装方法</p>
<p>2、安装deflate模块</p>
<p>a）编译时安装方法<br>编译的时候跟上–enable-deflate 即可实现安装</p>
<p>b）DSO 方式安装。<br>扩展：DSO： Dynamic shared object 劢态共享对象 。DSO 模块可以在编译服务器之后编译，也可以<br>用 Apache 扩展工具(apxs)编译并增加<br>使用 DSO 方式安装，/usr/local/httpd/bin/apxs 后跟的参数详解<br>-c 此选项表明需要执行编译操作。它首先会编译 c 源程序（.c）files 为对应的目标代码文件（.c），然<br>后连接这些目标代码和 files 中其余的目标代码文件（.c 和.a），以生成劢态共享对象 dsofile。如果没有<br>指定-s 选项，则此输出文件名由 files 中的第一个文件名推测得出，也就是默认 mod_name.so。<br>-i 此选项表示需要执行安装操作，以安装一个戒多个劢态共享对象到服务器的 modules 目录。<br>-a 此选项自劢增加一个 LoadModule 行到 httpd.conf 文件中，以激活此模块，或者，如果此行已经<br>存在，则启用之。</p>
<p>[root@wyq63  filters]#  /usr/local/httpd/bin/apxs  -c  -i  -a /usr/local/src/httpd/modules/filters/mod_deflate.c</p>
<p>/usr/local/src/httpd/modules/filters/mod_deflate.c 为源码包路径</p>
<p>安装完后查看：</p>
<p>[root@wyq63 ~]# ll /usr/local/httpd/modules/mod_deflate.so<br>-rwxr-xr-x. 1 root root 53072 Jan 26 18:36 /usr/local/httpd/modules/mod_deflate.so</p>
<p><strong>注意，此时检测配置文件，会报错</strong>：[root@wyq63 ~]# httpd -t<br>httpd: Syntax error on line 106 of /usr/local/httpd/conf/httpd.conf: Cannot load modules/mod_deflate.so into server: /usr/local/httpd/modules/mod_deflate.so: undefined symbol: inflate</p>
<p>解决方法：vim /usr/local/httpd/conf/httpd.conf</p>
<p>　在LoadModule deflate_module  modules/mod_deflate.so这一行上面添加 LoadFile /usr/lib64/libz.so即可</p>
<p>3、配置deflate模块</p>
<p>[root@wyq63 ~]# vim /usr/local/httpd/conf/httpd.conf #配置文件最下面添加如下内容</p>
<IfModule mod_deflate.c>
DeflateCompressionLevel 9 #压缩等级，越大效率越高，消耗 CPU 也越高。一般压缩等级使用 6 或 8
SetOutputFilter DEFLATE #启用压缩
DeflateFilterNote Input instream #声明输入流的 byte 数量
DeflateFilterNote Output outstream #声明输出流的 byte 数量
DeflateFilterNote Ratio ratio #声明压缩的百分比
AddOutputFilterByType DEFLATE text/html text/plain text/xml text/css application/javascript #仅压缩，限制特定的 MIME 类型文件
</IfModule>

<p>总结：我们在生产环境中，在使用 mod_deflate 时，一定要注意，对亍太小的文件和某些栺式的图片不要对它们进行压缩，有可能越压越大。<br>扩展：AddOutputFilterByTypeDEFLATE 后跟的所有的压缩文件类型，后期可以参照选择。<br>text/plain text/html text/php text/xml text/css text/javascript<br>application/xhtml+xml  application/xml  application/rss+xml  application/atom_xml<br>application/x-javascript application/x-httpd-php image/svg+xml image/gif image/png<br>image/jpe image/swf image/jpeg image/bmp</p>
<p>4、测试使用谷歌的YSLOW插件</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201129171757" alt="img"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>06-samba服务</title>
    <url>/06-samba%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h2><p>smb: Service message block 是cifs协议的实现，也可当成一种cifs变名协议<br>cifs: common internet filesystem  一种协议，实现window主机之间的文件系统共享。</p>
<p>NetBIOS：协议，window主机使用广播解析网段内的主机名</p>
<p>samba：Andrew Tridgell；用于实现window和linux操作系统上的文件系统共享，而nfs只能实现window、linux各自系统的文件系统共享<br>    功能：<br>        文件系统共享；<br>        打印机共享；<br>        NetBIOS协议；</p>
<p>peer/peer(workgroup model)<br>domain model</p>
<p>程序环境：<br>    服务端程序包：samba，samba-common, samba-libs<br>        Server and Client software to interoperate with Windows machines.<br>    主配置文件：/etc/samba/smb.conf， 由samba-common包提供；<br>    主程序：<br>        nmbd：NetBIOS name server<br>        smbd：SMB/CIFS services<br>    Unit File：<br>        smb.service<br>        nmb.service </p>
<p>监听的端口：<br>    137/udp, 138/udp<br>    139/tcp, 445/tcp </p>
<p>主配置文件的配置段：<br>~ ]# grep -E -i “#(====| —)”  /etc/samba/smb.conf<br>#======================= Global Settings =====================================<br># ———————– Network-Related Options ————————-<br># ————————— Logging Options —————————–<br># ———————– Standalone Server Options ————————<br># ———————– Domain Members Options ————————<br># ———————– Domain Controller Options ————————<br># ———————– Browser Control Options —————————-<br># ————————— Printing Options —————————–<br># ————————— File System Options —————————<br>#============================ Share Definitions ==============================</p>
<p>d:\data\tools：共享，共享名（software）<br>    servicename:<br>        //172.18.0.70/software</p>
<p>客户端程序：<br>    smbclient：交互式命令行客户端，类似于lftp；<br>    mount.cifs：挂载cifs文件系统的专用命令；</p>
<p>samba的配置：<br>    smb.conf</p>
<p>​    两类配置段：<br>​        全局配置<br>​            [global]<br>​                Network-Related Options<br>​                    workgroup =<br>​                    server string =<br>​                    interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24<br>​                    hosts allow = 127.  192.168.12.  192.168.13.<br>​                 Logging Options<br>​                    log file = /var/log/samba/log.%m<br>​                    max log size = 50<br>​                Standalone Server Options<br>​                    security = user<br>​                        设定安全级别：取值有四个；<br>​                            share：匿名共享；<br>​                            user：使用samba服务自我管理的账号和密码进行用户认证；用户必须是系统用户，但密码非为/etc/shadow中的密码，而由samba自行管理的文件，其密码文件的格式由passdb backend进行定义；<br>​                            server：由第三方服务进行统一认证；<br>​                            domain：使用DC进行认证；基于kerberos协议进行；<br>​                    passdb backend = tdbsam<br>​                Printing Options<br>​                    load printers = yes<br>​                    cups options = raw<br>​<br>​        共享文件系统配置<br>​            [SHARED_NAME]<br>​<br>​            有三类：<br>​                [homes]：为每个samba用户定义其是否能够通过samba服务访问自己的家目录；<br>​                [printers]：定义打印服务；<br>​                [shared_fs]：定义共享的文件系统；<br>​<br>​            常用指令：<br>​                comment：注释信息；<br>​                path：当前共享所映射的文件系统路径；<br>​                browseable：是否可浏览，指是否可被用户查看；<br>​                guest ok：是否允许来宾账号访问；<br>​                public：是否公开所有用户；<br>​                writable：是否可写；<br>​                read only：是否为只读；<br>​                write list：拥有写权限的用户列表；<br>​                    用户名<br>​                    @组名<br>​                    +组名<br>​        </p>
<h3 id="samba用户管理："><a href="#samba用户管理：" class="headerlink" title="samba用户管理："></a>samba用户管理：</h3><p>​        smbpasswd<br>​            smbpasswd [options] USERNAME<br>​                -a：添加<br>​                -x：删除<br>​                -d：禁用<br>​                -e：启用<br>​        pdbedit<br>​            -L：列出samba服务中的所有用户；<br>​            -a, –create：添加用户为samba用户；<br>​                -u, –user=USER：要管理的用户；<br>​            -x, –delete：删除用户；<br>​            -t, –password-from-stdin：从标准输出接收字符串作为用户密码；<br>​                使用空提示符，而后将密码输入两次；<br>​<br>​    查看服务器端的共享：<br>​        smbclient -L SMB_SERVER  [-U USERNAME]<br>​<br>​    交互式文件访问：<br>​        smbclient //SMB_SERVER/SHARE_NAME [-U USERNAME]<br>​<br>​    挂载访问：<br>​        mount -t cifs //SMB_SERVER/SAHRE_NAME  -o username=USERNAME,password=PASSWORD<br>​<br>​        注意：挂载操作的用户，与-o选项中指定用户直接产生映射关系；<br>​            此时，访问挂载点，是以-o选项中的username指定的用户身份进行；本地用户对指定的路径访问，首先得拥有对应的本地文件系统权限；<br>​<br>smbstatus命令：<br>​    显示samba服务的相关共享的访问状态信息；<br>​        -b：显示简要格式信息；<br>​        -v：显示详细格式信息； </p>
<p>练习：<br>    创建一个共享data，路径为/var/ftp/data；要求仅centos和gentoo用户能上传；此路径对其他用户不可见；</p>
<p>博客实践作业：<br>    (1) samba server导出/data/application/web，在目录中提供wordpress;<br>    (2) samba  client挂载nfs server导出的文件系统至/var/www/html；<br>    (3) 客户端（lamp）部署wordpress，并让其正常访问；要确保能正常发文章，上传图片；<br>    (4) 客户端2(lamp)，挂载samba  server导出的文件系统至/var/www/html；验正其wordpress是否可被访问； 要确保能正常发文章，上传图片；</p>
<p>博客实践作业：<br>    (1) samba  server导出/data/目录；<br>    (2) samba  client挂载/data/至本地的/mydata目录；本地的mysqld或mariadb服务的数据目录设置为/mydata, 要求服务能正常启动，且可正常 存储数据；<br>        /etc/my.cnf<br>        [mysqld]<br>        datadir=/mydata<br>        mysql服务的数据目录的属主属组得是运行进程的用户，一般为mysql；</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>06-日期时间相关命令</title>
    <url>/06-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linux的两种时钟"><a href="#Linux的两种时钟" class="headerlink" title="Linux的两种时钟"></a>Linux的两种时钟</h2><ul>
<li><p>系统时钟：由Linux内核通过CPU的工作频率进行的 </p>
</li>
<li><p>硬件时钟：主板 </p>
</li>
</ul>
<p><code>date</code></p>
<p>默认直接输入<code>date</code>显示当前系统时间</p>
<p><strong>date [-d |–date=STRING</strong>]，<strong>STRING</strong>指定时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#date</span><br>Sat Aug 15 14:26:20 CST 2020<br>[root@ashjian ~]<span class="hljs-comment">#date -d '2 days ago'</span><br>Thu Aug 13 15:23:00 CST 2020<br>[root@ashjian ~]<span class="hljs-comment">#date -d '3 months 1 day' #显示3月1天后的时间</span><br>Mon Nov 16 15:28:59 CST 2020<br>[root@ashjian ~]]<span class="hljs-comment">#date -d @4509536033	#可以将%s的时间转为为默认格式时间</span><br>Sat Nov 26 00:53:53 CST 2112<br></code></pre></td></tr></table></figure>

<p>高级使用方法：</p>
<ol>
<li><strong><code>date [OPTION]... [+FORMAT]</code></strong></li>
<li><strong><code>date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</code></strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian network-scripts]<span class="hljs-comment">#date +"%Y%m%d"</span><br>20200815<br>[root@ashjian network-scripts]<span class="hljs-comment">#date +"%F %T"</span><br>2020-08-15 14:27:01<br></code></pre></td></tr></table></figure>

<p>FORMAT的多种格式，可以通过<code>man date</code>来查看具体格式， 下面列出常用的：</p>
<ul>
<li><code>%F</code> ：年月日全格式，例如2016-06-21</li>
<li><code>%T</code> ：时间全格式，例如13:14:42</li>
<li><code>%Y</code>：年</li>
<li><code>%m</code>：月</li>
<li><code>%d</code>：日</li>
<li><code>%H</code>：小时</li>
<li><code>%M</code> 分</li>
<li><code>-%S</code> 秒</li>
<li><code>%s</code>：从1970年1月1日00:00:00开始的秒数</li>
</ul>
<p><strong>第二种用法是用来更改时间的：</strong></p>
<p>更改的时间格式为<code>MMDDhhmm[[CC]YY][.ss]</code></p>
<ul>
<li>MM:month</li>
<li>DD:day</li>
<li>hh:hour</li>
<li>mm:minute</li>
<li>CC:centery</li>
<li>YY:year</li>
<li>ss:second</li>
</ul>
<p>看可选项我们能明白，必须写月日小时分钟，可以只写年的两位，不写世纪，也可以年和世界都不写（就是不更改年），秒可写可不写。<br>例如设置到2012年12月21日 11:11:11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# date 122111112012.11<br>Fri Dec 21 11:11:11 CST 2012<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-clock硬件时钟（clock-hwclock）"><a href="#2-clock硬件时钟（clock-hwclock）" class="headerlink" title="2. clock硬件时钟（clock==hwclock）"></a>2. <code>clock</code>硬件时钟（<code>clock</code>==<code>hwclock</code>）</h3><p><code>clock</code>又或者<code>hwclock</code>，是一样的命令。</p>
<p>主要用到两个：</p>
<p><code>-s</code> <code>--hctosys</code>：硬件时钟（hardware clock）to 系统时钟（system time），把系统时间调成和硬件时钟一样。<br><code>-w</code>, <code>--systohc</code>：系统时钟（system time） to 硬件时钟（hardware clock），把硬件时钟调成和系统时钟一样。</p>
<hr>
<h3 id="3-ntpdate"><a href="#3-ntpdate" class="headerlink" title="3. ntpdate"></a>3. <code>ntpdate</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ntpdate IP&#96;：如&#96;htpdate 172.17.0.1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：前提是IP所在的那台机器启用了NTP服务，NTP服务后面我们会学，这里先了解下。</p>
</blockquote>
<hr>
<h3 id="4-更改时区"><a href="#4-更改时区" class="headerlink" title="4. 更改时区"></a>4. 更改时区</h3><p><strong>CentOS 6和7都支持的命令：<code>tzselect</code>，是一个交互式的命令。</strong></p>
<p>先让你选择洲，这里我选的<code>5</code> Asia，然后选择国家，这里我选的<code>9</code> China，然后选择时区，这里我选的<code>1</code> Beijing。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# tzselect <br>Please identify a location so that time zone rules can be set correctly.<br>Please select a continent or ocean.<br> 1) Africa<br> 2) Americas<br> 3) Antarctica<br> 4) Arctic Ocean<br> 5) Asia<br> 6) Atlantic Ocean<br> 7) Australia<br> 8) Europe<br> 9) Indian Ocean<br>10) Pacific Ocean<br>11) none - I want to specify the time zone using the Posix TZ format.<br>#? 5<br>Please select a country.<br> 1) Afghanistan		  18) Israel		    35) Palestine<br> 2) Armenia		  19) Japan		    36) Philippines<br> 3) Azerbaijan		  20) Jordan		    37) Qatar<br> 4) Bahrain		  21) Kazakhstan	    38) Russia<br> 5) Bangladesh		  22) Korea (North)	    39) Saudi Arabia<br> 6) Bhutan		  23) Korea (South)	    40) Singapore<br> 7) Brunei		  24) Kuwait		    41) Sri Lanka<br> 8) Cambodia		  25) Kyrgyzstan	    42) Syria<br> 9) China		  26) Laos		    43) Taiwan<br>10) Cyprus		  27) Lebanon		    44) Tajikistan<br>11) East Timor		  28) Macau		    45) Thailand<br>12) Georgia		  29) Malaysia		    46) Turkmenistan<br>13) Hong Kong		  30) Mongolia		    47) United Arab Emirates<br>14) India		  31) Myanmar (Burma)	    48) Uzbekistan<br>15) Indonesia		  32) Nepal		    49) Vietnam<br>16) Iran		  33) Oman		    50) Yemen<br>17) Iraq		  34) Pakistan<br>#? 9<br>Please select one of the following time zone regions.<br>1) Beijing Time<br>2) Xinjiang Time<br>#? 1<br><br>The following information has been given:<br><br>	China<br>	Beijing Time<br><br>Therefore TZ&#x3D;&#39;Asia&#x2F;Shanghai&#39; will be used.<br>Local time is now:	Fri May 19 20:31:30 CST 2017.<br>Universal Time is now:	Fri May 19 12:31:30 UTC 2017.<br>Is the above information OK?<br>1) Yes<br>2) No<br>#? 1<br><br>You can make this change permanent for yourself by appending the line<br>	TZ&#x3D;&#39;Asia&#x2F;Shanghai&#39;; export TZ<br>to the file &#39;.profile&#39; in your home directory; then log out and log in again.<br><br>Here is that TZ value again, this time on standard output so that you<br>can use the &#x2F;usr&#x2F;bin&#x2F;tzselect command in shell scripts:<br>Asia&#x2F;Shanghai<br></code></pre></td></tr></table></figure>

<p><strong>CentOS 7还有一个非交互式的命令：</strong></p>
<ul>
<li><p>时间状态：<code>timedatectl status</code></p>
</li>
<li><p>列出时区<code>timedatectl list-timezones</code></p>
</li>
<li><p>更改时区<code>timedatectl set-timezone 洲/城市</code></p>
<p>RTC是指硬件时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian network-scripts]<span class="hljs-comment">#timedatectl status</span><br>      Local time: Sat 2020-08-15 14:53:33 CST<br>  Universal time: Sat 2020-08-15 06:53:33 UTC<br>        RTC time: Sat 2020-08-15 06:53:32<br>       Time zone: Asia/Shanghai (CST, +0800)<br>     NTP enabled: yes<br>NTP synchronized: yes<br> RTC <span class="hljs-keyword">in</span> <span class="hljs-built_in">local</span> TZ: no<br>      DST active: n/a<br>[root@ashjian network-scripts]<span class="hljs-comment">#timedatectl list-timezones</span><br>Africa/Abidjan<br>Africa/Accra<br>Africa/Addis_Ababa<br><span class="hljs-comment">#省略...</span><br>[root@ashjian network-scripts]<span class="hljs-comment">#timedatectl set-timezone Asia/Shanghai</span><br></code></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>6和7都支持一个非交互式的方法，是直接覆盖文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-cal"><a href="#5-cal" class="headerlink" title="5. cal"></a>5. <code>cal</code></h3><p>显示日历，用法： <code>cal [options] [[[day] month] year]</code></p>
<ul>
<li><code>cal</code>：显示当月</li>
<li><code>cal -y</code>：显示当年日历</li>
<li><code>cal [[[day] month] year]</code>：如<code>cal 21 12 2012</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian ~]# cal 21 12 2012<br>    December 2012   <br>Su Mo Tu We Th Fr Sa<br>                   1<br> 2  3  4  5  6  7  8<br> 9 10 11 12 13 14 15<br>16 17 18 19 20 21 22<br>23 24 25 26 27 28 29<br>30 31<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>07-LAMP介绍</title>
    <url>/07-LAMP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="LAMP："><a href="#LAMP：" class="headerlink" title="LAMP："></a>LAMP：</h2><p>​        a: apache (httpd)<br>​        m: mysql, mariadb<br>​        p: php, perl, python<br>​        </p>
<p>​    WEB资源类型：<br>​        静态资源：原始形式与响应内容一致；<br>​        动态资源：原始形式通常为程序文件，需要在服务器端执行之后，将执行结果返回给客户端；</p>
<p>​        客户端技术： javascript<br>​        服务器端技术：php, jsp<br>​        </p>
<p>CGI：Common Gateway Interface<br>    可以让一个客户端，从网页浏览器向执行在网络服务器上的程序传输数据；CGI描述了客户端和服务器程序之间传输的一种标准；</p>
<p>程序=指令+数据<br>    数据模型：<br>        层次模型<br>        网状模型<br>        关系模型：表（行+列）</p>
<pre><code>关系模型：IngreSQL, Oracle, Sybase, Infomix, DB2, SQL Server, MySQL, PostgreSQL, MariaDB

指令：代码文件
数据：数据存储系统、文件</code></pre><p>请求流程：<br>    Client – (httpd) –&gt; httpd – (cgi) –&gt; application server (program file) – (mysql) –&gt; mysql </p>
<p>php: 脚本编程语言、嵌入到html中的嵌入式web程序开发语言；<br>    基于zend编译成opcode（二进制格式的字节码，重复运行，可省略编译环境）</p>
<h2 id="关于PHP"><a href="#关于PHP" class="headerlink" title="关于PHP"></a>关于PHP</h2><h3 id="一、PHP简介"><a href="#一、PHP简介" class="headerlink" title="一、PHP简介"></a>一、PHP简介</h3><p>​    PHP是通用服务器端脚本编程语言，其主要用于web开发以实现动态web页面，它也是最早实现将脚本嵌入HTML源码文档中的服务器端脚本语言之一。同时，php还提供了一个命令行接口，因此，其也可以在大多数系统上作为一个独立的shell来使用。</p>
<p>​    Rasmus Lerdorf于1994年开始开发PHP，它是初是一组被Rasmus Lerdorf称作“Personal Home Page Tool” 的Perl脚本， 这些脚本可以用于显示作者的简历并记录用户对其网站的访问。后来，Rasmus Lerdorf使用C语言将这些Perl脚本重写为CGI程序，还为其增加了运行Web forms的能力以及与数据库交互的特性，并将其重命名为“Personal Home Page/Forms Interpreter”或“PHP/FI”。此时，PHP/FI已经可以用于开发简单的动态web程序了，这即是PHP 1.0。1995年6月，Rasmus Lerdorf把它的PHP发布于comp.infosystems.<a href="http://www.authoring.cgi" target="_blank" rel="noopener">www.authoring.cgi</a> Usenet讨论组，从此PHP开始走进人们的视野。1997年，其2.0版本发布。</p>
<p>​    1997年，两名以色列程序员Zeev Suraski和Andi Gutmans重写的PHP的分析器(parser)成为PHP发展到3.0的基础，而且从此将PHP重命名为PHP: Hypertext Preprocessor。此后，这两名程序员开始重写整个PHP核心，并于1999年发布了Zend Engine 1.0，这也意味着PHP 4.0的诞生。2004年7月，Zend Engine 2.0发布，由此也将PHP带入了PHP 5时代。PHP5包含了许多重要的新特性，如增强的面向对象编程的支持、支持PDO(PHP Data Objects)扩展机制以及一系列对PHP性能的改进。</p>
<h3 id="二、PHP-Zend-Engine"><a href="#二、PHP-Zend-Engine" class="headerlink" title="二、PHP Zend Engine"></a>二、PHP Zend Engine</h3><p>​    Zend Engine是开源的、PHP脚本语言的解释器，它最早是由以色列理工学院(Technion)的学生Andi Gutmans和Zeev Suraski所开发，Zend也正是此二人名字的合称。后来两人联合创立了Zend Technologies公司。</p>
<p>​    Zend Engine 1.0于1999年随PHP 4发布，由C语言开发且经过高度优化，并能够做为PHP的后端模块使用。Zend Engine为PHP提供了内存和资源管理的功能以及其它的一些标准服务，其高性能、可靠性和可扩展性在促进PHP成为一种流行的语言方面发挥了重要作用。</p>
<p>​    Zend Engine的出现将PHP代码的处理过程分成了两个阶段：首先是分析PHP代码并将其转换为称作Zend opcode的二进制格式(类似Java的字节码)，并将其存储于内存中；第二阶段是使用Zend Engine去执行这些转换后的Opcode。</p>
<h3 id="三、PHP的Opcode"><a href="#三、PHP的Opcode" class="headerlink" title="三、PHP的Opcode"></a>三、PHP的Opcode</h3><p>​    Opcode是一种PHP脚本编译后的中间语言，就像Java的ByteCode,或者.NET的MSL。PHP执行PHP脚本代码一般会经过如下4个步骤(确切的来说，应该是PHP的语言引擎Zend)：<br>​    1、Scanning(Lexing) —— 将PHP代码转换为语言片段(Tokens)<br>​    2、Parsing —— 将Tokens转换成简单而有意义的表达式<br>​    3、Compilation —— 将表达式编译成Opocdes<br>​    4、Execution —— 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能</p>
<p>​        扫描–&gt;分析–&gt;编译–&gt;执行</p>
<h3 id="四、php的加速器"><a href="#四、php的加速器" class="headerlink" title="四、php的加速器"></a>四、php的加速器</h3><p>​    基于PHP的特殊扩展机制如opcode缓存扩展也可以将opcode缓存于php的共享内存中，从而可以让同一段代码的后续重复执行时跳过编译阶段以提高性能。由此也可以看出，这些加速器并非真正提高了opcode的运行速度，而仅是通过分析opcode后并将它们重新排列以达到快速执行的目的。</p>
<p>​    常见的php加速器有：</p>
<p>​    1、APC (Alternative PHP Cache)<br>​    遵循PHP License的开源框架，PHP opcode缓存加速器，目前的版本不适用于PHP 5.4。项目地址，<a href="http://pecl.php.net/package/APC。" target="_blank" rel="noopener">http://pecl.php.net/package/APC。</a></p>
<p>​    2、eAccelerator<br>​    源于Turck MMCache，早期的版本包含了一个PHP encoder和PHP loader，目前encoder已经不在支持。项目地址， <a href="http://eaccelerator.net/。" target="_blank" rel="noopener">http://eaccelerator.net/。</a></p>
<p>​    3、XCache<br>​    快速而且稳定的PHP opcode缓存，经过严格测试且被大量用于生产环境。项目地址，<a href="http://xcache.lighttpd.net/" target="_blank" rel="noopener">http://xcache.lighttpd.net/</a></p>
<p>​    4、Zend Optimizer和Zend Guard Loader<br>​    Zend Optimizer并非一个opcode加速器，它是由Zend Technologies为PHP5.2及以前的版本提供的一个免费、闭源的PHP扩展，其能够运行由Zend Guard生成的加密的PHP代码或模糊代码。 而Zend Guard Loader则是专为PHP5.3提供的类似于Zend Optimizer功能的扩展。项目地址，<a href="http://www.zend.com/en/products/guard/runtime-decoders" target="_blank" rel="noopener">http://www.zend.com/en/products/guard/runtime-decoders</a></p>
<p>​    5、NuSphere PhpExpress<br>​    NuSphere的一款开源PHP加速器，它支持装载通过NuSphere PHP Encoder编码的PHP程序文件，并能够实现对常规PHP文件的执行加速。项目地址，<a href="http://www.nusphere.com/products/phpexpress.htm" target="_blank" rel="noopener">http://www.nusphere.com/products/phpexpress.htm</a></p>
<p>​    五、PHP源码目录结构</p>
<p>​    PHP的源码在结构上非常清晰。其代码根目录中主要包含了一些说明文件以及设计方案，并提供了如下子目录：</p>
<p>​    1、build —— 顾名思义，这里主要放置一些跟源码编译相关的文件，比如开始构建之前的buildconf脚本及一些检查环境的脚本等。<br>​    2、ext —— 官方的扩展目录，包括了绝大多数PHP的函数的定义和实现，如array系列，pdo系列，spl系列等函数的实现。 个人开发的扩展在测试时也可以放到这个目录，以方便测试等。<br>​    3、main —— 这里存放的就是PHP最为核心的文件了，是实现PHP的基础设施，这里和Zend引擎不一样，Zend引擎主要实现语言最核心的语言运行环境。<br>​    4、Zend —— Zend引擎的实现目录，比如脚本的词法语法解析，opcode的执行以及扩展机制的实现等等。<br>​    5、pear —— PHP 扩展与应用仓库，包含PEAR的核心文件。<br>​    6、sapi —— 包含了各种服务器抽象层的代码，例如apache的mod_php，cgi，fastcgi以及fpm等等接口。<br>​    7、TSRM —— PHP的线程安全是构建在TSRM库之上的，PHP实现中常见的<em>G宏通常是对TSRM的封装，TSRM(Thread Safe Resource Manager)线程安全资源管理器。<br>​    8、tests —— PHP的测试脚本集合，包含PHP各项功能的测试文件。<br>​    9、win32 —— 这个目录主要包括Windows平台相关的一些实现，比如sokcet的实现在Windows下和</em>Nix平台就不太一样，同时也包括了Windows下编译PHP相关的脚本。</p>
<p>LAMP：<br>    httpd：接收用户的web请求；静态资源则直接响应；动态资源为php脚本，对此类资源的请求将交由php来运行；<br>    php：运行php程序；<br>    MariaDB：数据管理系统； </p>
<p>http与php结合的方式：<br>    CGI<br>    FastCGI<br>    modules (把php编译成为httpd的模块)<br>        MPM:<br>            prefork: libphp5.so<br>            event, worker: libphp5-zts.so</p>
<p>安装lamp：<br>    CentOS 6: httpd, php, mysql-server, php-mysql</p>
<p>​    service httpd  start</p>
<p>​    service  mysqld  start</p>
<p>​    CentOS 7: httpd, php, php-mysql, mariadb-server</p>
<p>​      systemctl  start  httpd.service</p>
<p>​     systemctl  start  mariadb.service</p>
<p>​        MySQL的命令行客户端程序：mysql<br>​            -u<br>​            -h<br>​            -p<br>​<br>​            支持SQL语句对数据管理：<br>​                DDL，DML<br>​                    DDL： CREATE， ALTER， DROP， SHOW<br>​                    DML： INSERT， DELETE，SELECT， UPDATE<br>​<br>​            授权能远程的连接用户：<br>​                mysql&gt; GRANT  ALL  PRIVILEGES  ON  db_name.tbl_name TO  username@host  IDENTIFIED BY ‘password’;<br>​<br>​        php测试代码<br>​            &lt;php?<br>​                phpinfo();<br>​            ?&gt;<br>​<br>​        php连接mysql的测试代码：<br>​            <?php
​                $conn = mysql_connect('172.16.100.67','testuser','testpass');
​                if ($conn) 
​                    echo "OK";
​                else
​                    echo "Failure";
​            ?><br>​<br>实践作业：部署lamp，以虚拟主机安装wordpress, phpwind, discuz; </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#centos7部署LAMP</span><br>[root@ashjian ~]<span class="hljs-comment">#yum install php php-mysql mariadb-server </span><br><span class="hljs-comment">#之前安装过httpd，我就不再安装了</span><br>Loaded plugins: fastestmirror, langpacks<br>Repository epel is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel-debuginfo is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel-source is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Loading mirror speeds from cached hostfile<br> * base: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.aliyun.com<br>base                                                                                | 3.6 kB  00:00:00     <br>epel                                                                                | 4.7 kB  00:00:00     <br>extras                                                                              | 2.9 kB  00:00:00     <br>updates                                                                             | 2.9 kB  00:00:00     <br>(1/2): epel/7/x86_64/updateinfo                                                     | 1.0 MB  00:00:00     <br>(2/2): epel/7/x86_64/primary_db                                                     | 6.9 MB  00:00:00     <br>Package 1:mariadb-server-5.5.65-1.el7.x86_64 already installed and latest version<br>Resolving Dependencies<br>--&gt; Running transaction check<br>---&gt; Package php.x86_64 0:5.4.16-48.el7 will be installed<br>--&gt; Processing Dependency: php-common(x86-64) = 5.4.16-48.el7 <span class="hljs-keyword">for</span> package: php-5.4.16-48.el7.x86_64<br>--&gt; Processing Dependency: php-cli(x86-64) = 5.4.16-48.el7 <span class="hljs-keyword">for</span> package: php-5.4.16-48.el7.x86_64<br>---&gt; Package php-mysql.x86_64 0:5.4.16-48.el7 will be installed<br>--&gt; Processing Dependency: php-pdo(x86-64) = 5.4.16-48.el7 <span class="hljs-keyword">for</span> package: php-mysql-5.4.16-48.el7.x86_64<br>--&gt; Running transaction check<br>---&gt; Package php-cli.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>---&gt; Package php-cli.x86_64 0:5.4.16-48.el7 will be an update<br>---&gt; Package php-common.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>--&gt; Processing Dependency: php-common(x86-64) = 5.4.16-46.1.el7_7 <span class="hljs-keyword">for</span> package: php-gd-5.4.16-46.1.el7_7.x86_64<br>--&gt; Processing Dependency: php-common(x86-64) = 5.4.16-46.1.el7_7 <span class="hljs-keyword">for</span> package: php-xml-5.4.16-46.1.el7_7.x86_64<br>--&gt; Processing Dependency: php-common(x86-64) = 5.4.16-46.1.el7_7 <span class="hljs-keyword">for</span> package: php-bcmath-5.4.16-46.1.el7_7.x86_64<br>--&gt; Processing Dependency: php-common(x86-64) = 5.4.16-46.1.el7_7 <span class="hljs-keyword">for</span> package: php-mbstring-5.4.16-46.1.el7_7.x86_64<br>---&gt; Package php-common.x86_64 0:5.4.16-48.el7 will be an update<br>---&gt; Package php-pdo.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>---&gt; Package php-pdo.x86_64 0:5.4.16-48.el7 will be an update<br>--&gt; Running transaction check<br>---&gt; Package php-bcmath.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>---&gt; Package php-bcmath.x86_64 0:5.4.16-48.el7 will be an update<br>---&gt; Package php-gd.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>---&gt; Package php-gd.x86_64 0:5.4.16-48.el7 will be an update<br>---&gt; Package php-mbstring.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>---&gt; Package php-mbstring.x86_64 0:5.4.16-48.el7 will be an update<br>---&gt; Package php-xml.x86_64 0:5.4.16-46.1.el7_7 will be updated<br>---&gt; Package php-xml.x86_64 0:5.4.16-48.el7 will be an update<br>--&gt; Finished Dependency Resolution<br><br>Dependencies Resolved<br><br>===========================================================================================================<br> Package                     Arch                  Version                       Repository           Size<br>===========================================================================================================<br>Installing:<br> php                         x86_64                5.4.16-48.el7                 base                1.4 M<br> php-mysql                   x86_64                5.4.16-48.el7                 base                102 k<br>Updating <span class="hljs-keyword">for</span> dependencies:<br> php-bcmath                  x86_64                5.4.16-48.el7                 base                 58 k<br> php-cli                     x86_64                5.4.16-48.el7                 base                2.7 M<br> php-common                  x86_64                5.4.16-48.el7                 base                565 k<br> php-gd                      x86_64                5.4.16-48.el7                 base                128 k<br> php-mbstring                x86_64                5.4.16-48.el7                 base                506 k<br> php-pdo                     x86_64                5.4.16-48.el7                 base                 99 k<br> php-xml                     x86_64                5.4.16-48.el7                 base                126 k<br><br>Transaction Summary<br>===========================================================================================================<br>Install  2 Packages<br>Upgrade             ( 7 Dependent packages)<br><br>Total download size: 5.6 M<br>Is this ok [y/d/N]: y<br>Downloading packages:<br>Delta RPMs disabled because /usr/bin/applydeltarpm not installed.<br>(1/9): php-5.4.16-48.el7.x86_64.rpm                                                 | 1.4 MB  00:00:00     <br>(2/9): php-bcmath-5.4.16-48.el7.x86_64.rpm                                          |  58 kB  00:00:00     <br>(3/9): php-common-5.4.16-48.el7.x86_64.rpm                                          | 565 kB  00:00:00     <br>(4/9): php-gd-5.4.16-48.el7.x86_64.rpm                                              | 128 kB  00:00:00     <br>(5/9): php-mbstring-5.4.16-48.el7.x86_64.rpm                                        | 506 kB  00:00:00     <br>(6/9): php-cli-5.4.16-48.el7.x86_64.rpm                                             | 2.7 MB  00:00:00     <br>(7/9): php-mysql-5.4.16-48.el7.x86_64.rpm                                           | 102 kB  00:00:00     <br>(8/9): php-pdo-5.4.16-48.el7.x86_64.rpm                                             |  99 kB  00:00:00     <br>(9/9): php-xml-5.4.16-48.el7.x86_64.rpm                                             | 126 kB  00:00:00     <br>-----------------------------------------------------------------------------------------------------------<br>Total                                                                       22 MB/s | 5.6 MB  00:00:00     <br>Running transaction check<br>Running transaction <span class="hljs-built_in">test</span><br>Transaction <span class="hljs-built_in">test</span> succeeded<br>Running transaction<br>  Updating   : php-common-5.4.16-48.el7.x86_64                                                        1/16 <br>  Updating   : php-cli-5.4.16-48.el7.x86_64                                                           2/16 <br>  Updating   : php-pdo-5.4.16-48.el7.x86_64                                                           3/16 <br>  Installing : php-mysql-5.4.16-48.el7.x86_64                                                         4/16 <br>  Installing : php-5.4.16-48.el7.x86_64                                                               5/16 <br>  Updating   : php-xml-5.4.16-48.el7.x86_64                                                           6/16 <br>  Updating   : php-mbstring-5.4.16-48.el7.x86_64                                                      7/16 <br>  Updating   : php-gd-5.4.16-48.el7.x86_64                                                            8/16 <br>  Updating   : php-bcmath-5.4.16-48.el7.x86_64                                                        9/16 <br>  Cleanup    : php-pdo-5.4.16-46.1.el7_7.x86_64                                                      10/16 <br>  Cleanup    : php-cli-5.4.16-46.1.el7_7.x86_64                                                      11/16 <br>  Cleanup    : php-bcmath-5.4.16-46.1.el7_7.x86_64                                                   12/16 <br>  Cleanup    : php-gd-5.4.16-46.1.el7_7.x86_64                                                       13/16 <br>  Cleanup    : php-mbstring-5.4.16-46.1.el7_7.x86_64                                                 14/16 <br>  Cleanup    : php-xml-5.4.16-46.1.el7_7.x86_64                                                      15/16 <br>  Cleanup    : php-common-5.4.16-46.1.el7_7.x86_64                                                   16/16 <br>  Verifying  : php-xml-5.4.16-48.el7.x86_64                                                           1/16 <br>  Verifying  : php-mbstring-5.4.16-48.el7.x86_64                                                      2/16 <br>  Verifying  : php-gd-5.4.16-48.el7.x86_64                                                            3/16 <br>  Verifying  : php-bcmath-5.4.16-48.el7.x86_64                                                        4/16 <br>  Verifying  : php-cli-5.4.16-48.el7.x86_64                                                           5/16 <br>  Verifying  : php-pdo-5.4.16-48.el7.x86_64                                                           6/16 <br>  Verifying  : php-mysql-5.4.16-48.el7.x86_64                                                         7/16 <br>  Verifying  : php-common-5.4.16-48.el7.x86_64                                                        8/16 <br>  Verifying  : php-5.4.16-48.el7.x86_64                                                               9/16 <br>  Verifying  : php-cli-5.4.16-46.1.el7_7.x86_64                                                      10/16 <br>  Verifying  : php-xml-5.4.16-46.1.el7_7.x86_64                                                      11/16 <br>  Verifying  : php-common-5.4.16-46.1.el7_7.x86_64                                                   12/16 <br>  Verifying  : php-mbstring-5.4.16-46.1.el7_7.x86_64                                                 13/16 <br>  Verifying  : php-bcmath-5.4.16-46.1.el7_7.x86_64                                                   14/16 <br>  Verifying  : php-gd-5.4.16-46.1.el7_7.x86_64                                                       15/16 <br>  Verifying  : php-pdo-5.4.16-46.1.el7_7.x86_64                                                      16/16 <br><br>Installed:<br>  php.x86_64 0:5.4.16-48.el7                        php-mysql.x86_64 0:5.4.16-48.el7                       <br><br>Dependency Updated:<br>  php-bcmath.x86_64 0:5.4.16-48.el7 php-cli.x86_64 0:5.4.16-48.el7      php-common.x86_64 0:5.4.16-48.el7<br>  php-gd.x86_64 0:5.4.16-48.el7     php-mbstring.x86_64 0:5.4.16-48.el7 php-pdo.x86_64 0:5.4.16-48.el7   <br>  php-xml.x86_64 0:5.4.16-48.el7   <br><br>Complete!<br><br>[root@ashjian ~]<span class="hljs-comment">#rpm -ql php</span><br>/etc/httpd/conf.d/php.conf<br>/etc/httpd/conf.modules.d/10-php.conf<br>/usr/lib64/httpd/modules/libphp5.so <span class="hljs-comment">#php作为httpd的模块</span><br>/usr/share/httpd/icons/php.gif<br>/var/lib/php/session<br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/httpd/conf.d/php.conf</span><br><br><span class="hljs-comment"># Cause the PHP interpreter to handle files with a .php extension.</span><br><span class="hljs-comment">#</span><br>&lt;FilesMatch \.php$&gt; <span class="hljs-comment">#正则表达式，\起到转义作用匹配到.php结尾的文件</span><br>   SetHandler application/x-httpd-php <span class="hljs-comment">#SetHanlder是启动一个内建的处理器，，激活模块libphp5.so处理代码</span><br>&lt;/FilesMatch&gt;<br><br><span class="hljs-comment"># Allow php to handle Multiviews</span><br>AddType text/html .php <span class="hljs-comment">#处理器指定处理的文件类型和文件匹配名</span><br><span class="hljs-comment"># Add index.php to the list of files that will be served as directory</span><br><span class="hljs-comment"># indexes.</span><br><span class="hljs-comment">#</span><br>DirectoryIndex index.php <span class="hljs-comment">#指定一旦启动处理器处理文件，则目录主页变成哪个文件</span><br><br><span class="hljs-comment"># Apache specific PHP configuration options</span><br><span class="hljs-comment"># those can be override in each configured vhost</span><br><span class="hljs-comment">#</span><br>php_value session.save_handler <span class="hljs-string">"files"</span> <span class="hljs-comment">#定义了来存储和获取与会话关联的数据的处理器的名字。默认为 files。</span><br>php_value session.save_path    <span class="hljs-string">"/var/lib/php/session"</span><span class="hljs-comment">#php会话缓存文件的位置</span><br>[root@ashjian ~]<span class="hljs-comment">#httpd -t</span><br>Syntax OK<br>[root@ashjian ~]<span class="hljs-comment">#systemctl restart httpd.service </span><br>[root@ashjian html]<span class="hljs-comment">#systemctl start mariadb</span><br>[root@ashjian html]<span class="hljs-comment">#vim php-mysql-connectTest.php</span><br>&lt;html&gt;<br>    &lt;title&gt;测试mysql&lt;/title&gt;<br>    &lt;?php<br>        <span class="hljs-variable">$con</span> = mysql_connect(<span class="hljs-string">'127.0.0.1'</span>,<span class="hljs-string">'root'</span>,<span class="hljs-string">'m34s2q'</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$con</span>)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">"connect is OK"</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">"connect is failed"</span><br>    ?&gt;                                                                                                <br>&lt;/html&gt;<br><span class="hljs-comment">#访问该网页测试php连接mysql</span><br><br>[root@ashjian html]<span class="hljs-comment">#mysql -uroot -h127.0.0.1 -p</span><br>Enter password: <br>ERROR 1045 (28000): Access denied <span class="hljs-keyword">for</span> user <span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> (using password: YES)<br><span class="hljs-comment">#mysql连接不仅限制用户名密码，还限制主机的ip地址，默认会将ip反向解析为主机名</span><br><br><span class="hljs-comment">#修改配置文件，关闭反向解析ip地址</span><br>[root@ashjian html]<span class="hljs-comment">#vim /etc/my.cnf.d/server.cnf </span><br>[mysqld]<br>datadir=/var/lib/mysql<br>socket=/var/lib/mysql/mysql.sock<br><span class="hljs-comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br>symbolic-links=0<br><br>skip-name=resolve       <span class="hljs-comment">#修改配置文件，关闭反向解析ip地址</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title>07-ngx_http_proxy_module详解</title>
    <url>/07-ngx-http-proxy-module%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ngx_http_proxy_module 里面包含反向代理(Reverse Proxy)相关指令和缓存(Cache)相关指令。</p>
<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><code>proxy_pass</code></h3><p>前端代理服务器Nginx：192.168.10.10<br>后端准备两个被代理的服务器192.168.10.20和192.168.10.30，开启httpd服务</p>
<p><a href="http://www.yulongjun.com/images/15043355411379.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235317.jpg" alt="img"></a><br>192.168.10.20上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install httpd<br><br>cat &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html &lt;&lt;EOF<br>&lt;h1&gt;BLOG Server&lt;&#x2F;h1&gt;<br>&lt;h2&gt;Upsteam Server 1&lt;&#x2F;h2&gt;<br>&lt;h3&gt;IP: 192.168.10.20&lt;&#x2F;h3&gt;<br>EOF<br><br>systemctl start httpd<br></code></pre></td></tr></table></figure>

<p>192.168.10.30上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install httpd<br><br>cat &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html &lt;&lt;EOF<br>&lt;h1&gt;BBS Server&lt;&#x2F;h1&gt;<br>&lt;h2&gt;Upsteam Server 2&lt;&#x2F;h2&gt;<br>&lt;h3&gt;IP: 192.168.10.30&lt;&#x2F;h3&gt;<br>EOF<br><br>systemctl start httpd<br></code></pre></td></tr></table></figure>

<p>192.168.10.10上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;etc&#x2F;nginx&#x2F;confi.d&#x2F;&#123;,.bak&#125;<br>vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;vhost1.conf<br>server_name www.yulongjun.com;<br>listen <br>location &#x2F;blog&#x2F; &#123;<br>    proxy_pass http:&#x2F;&#x2F;192.168.10.20&#x2F;;<br>&#123;<br>location &#x2F;bbs&#x2F; &#123;<br>    proxy_pass http:&#x2F;&#x2F;192.168.10.30&#x2F;;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在proxy_pass 后面的url，加斜线和不加斜线是有区别的：<br>如果加了斜线，如<code>/bbs/ --&gt; http://192.168.10.20/</code> 指的就是访问<code>www.yulongjun.com/bbs/</code>即访问的<code>http://192.167.10.20/</code>。<br>如果不加斜线，如<code>/bbs/ --&gt; http://192.168.10.20</code>，指的就是访问<code>www.yulongjun.com/bbs/</code>即访问的<code>http://192.168.10.20/bbs</code>。<br>如果location定义其uri时使用了正则表达式的模式，或在if语句或limt_execept中使用proxy_pass指令，则proxy_pass之后必须不能使用uri; 用户请求时传递的uri将直接附加代理到的服务的之后:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location ~* \.(jpg|gif|png|jpeg|svg)$ &#123;<br>    proxy_pass http:&#x2F;&#x2F;192.168.10.40;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们访问<code>http://www.yulongjun.com/img/bluesky.jpg</code>即访问<code>http://192.168.0.40/img/sky.jpg</code></p>
<h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a><code>proxy_set_header</code></h3><p><a href="http://www.yulongjun.com/images/15043398328171.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235318.jpg" alt="img"></a></p>
<p>设定发往后端主机的请求报文的请求首部的值。</p>
<p>proxy_set_header X-Real-IP $remote_addr; # 真实client地址<br>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 代理服务器代理的真实地址</p>
<p>定义各个段用的Cache之前，要先在http 上下文定义缓存路径：</p>
<h3 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a><code>proxy_cache_path</code></h3><p><a href="http://www.yulongjun.com/images/15043407981626.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235319.jpg" alt="img"></a></p>
<p>定义的keys_zone的名字，要被嵌套的各个子段所引用，即各子段缓存都定义在这个缓存路径下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">http&#123; <br>    proxy_cache_path &#x2F;data&#x2F;nginx&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;one:10m;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>记得创建目录<code>mkdir -pv /data/nginx/cache</code></p>
</blockquote>
<ul>
<li><code>/data/nginx/cache</code>为缓存路径。</li>
<li><code>levels=1:2</code>的意思是一级目录为hash值的倒数第一个数，二级目录再切两个数字。</li>
<li><code>keys_zone=one:10m</code>：<code>one</code>为缓存的名字,<code>10m</code>为缓存的大小</li>
</ul>
<p>那么，缓存的里的文件名就类似于这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;data&#x2F;nginx&#x2F;cache&#x2F;c&#x2F;29&#x2F;b7f54b2df7773722d382f4809d65029c<br></code></pre></td></tr></table></figure>

<h3 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a><code>proxy_cache</code></h3><p>proxy_cache定义在哪，就在哪生效，在server里写，就对server生效，在location里写，就对location生效。</p>
<p><a href="http://www.yulongjun.com/images/15043417152338.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235320.jpg" alt="img"></a></p>
<h3 id="proxy-cache-valid"><a href="#proxy-cache-valid" class="headerlink" title="proxy_cache_valid"></a><code>proxy_cache_valid</code></h3><p>设置不同的响应码的缓存时间。</p>
<p><a href="http://www.yulongjun.com/images/15043421733635.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235321.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">proxy_cache_valid 200 302 10m;<br>proxy_cache_valid 301      1h;<br>proxy_cache_valid any      1m;<br></code></pre></td></tr></table></figure>

<h3 id="proxy-cache-use-stale"><a href="#proxy-cache-use-stale" class="headerlink" title="proxy_cache_use_stale"></a><code>proxy_cache_use_stale</code></h3><p>stale(腐烂，过时）</p>
<p>在后端服务器出故障或找不到的时候，哪些情况可能会使用过时缓存进行相应。</p>
<p><a href="http://www.yulongjun.com/images/15043447818705.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235322.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">proxy_cache_use_stale error timeout invalid_header;<br></code></pre></td></tr></table></figure>

<h3 id="proxy-cache-methods"><a href="#proxy-cache-methods" class="headerlink" title="proxy_cache_methods"></a><code>proxy_cache_methods</code></h3><p><a href="http://www.yulongjun.com/images/15043452301567.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235323.jpg" alt="img"></a></p>
<h3 id="proxy-hide-header"><a href="#proxy-hide-header" class="headerlink" title="proxy_hide_header"></a><code>proxy_hide_header</code></h3><p>隐藏响应首部的filed，默认隐藏了“Date”，“Server”，“X-Pad”和“X-Accel -…”，如果还想加隐藏项，就可以写在这里。</p>
<p><a href="http://www.yulongjun.com/images/15043453022634.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235324.jpg" alt="img"></a></p>
<h3 id="proxy-pass-header"><a href="#proxy-pass-header" class="headerlink" title="proxy_pass_header"></a><code>proxy_pass_header</code></h3><p>正好相反，想要传递客户端的header里的某些field，可以在这个字段添加。</p>
<p><a href="http://www.yulongjun.com/images/15043455205011.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235325.jpg" alt="img"></a></p>
<h3 id="proxy-set-header-1"><a href="#proxy-set-header-1" class="headerlink" title="proxy_set_header"></a><code>proxy_set_header</code></h3><p>设定发往后端主机的请求header添加某些字段。</p>
<p><a href="http://www.yulongjun.com/images/15043509237120.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235326.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">proxy_set_header X-Real-IP $remote_addr;<br></code></pre></td></tr></table></figure>

<p>修改后端服务器的日志格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined<br></code></pre></td></tr></table></figure>

<p>为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot; %&#123;X-Real-IP&#125;i&quot; combined<br></code></pre></td></tr></table></figure>



<p>或者这样修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>延伸知识，X-forwarded-For可以记录多层代理的信息，如：<br><code>X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3</code><br>而X-Real-IP只能记录单层代理的上一级Client的信息，多级只会记录隔一级的代理。<br>详细区别可见：<a href="http://www.cnblogs.com/mypath/articles/5239687.html" target="_blank" rel="noopener">http://www.cnblogs.com/mypath/articles/5239687.html</a></p>
</blockquote>
<h3 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a><code>proxy_connect_timeout</code></h3><p>代理服务器与后端服务器建立连接的超时时间。应该注意的是，这个超时通常不能超过75秒。</p>
<p><a href="http://www.yulongjun.com/images/15043455694154.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235327.jpg" alt="img"></a></p>
<h3 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a><code>proxy_read_timeout</code></h3><p>代理服务器从后端服务器读取响应的超时时长。超时仅在两个连续读操作之间设置，而不是传输整个响应。如果后端服务器在此时间内没有传输任何内容，则连接被关闭。</p>
<p><a href="http://www.yulongjun.com/images/15043456278028.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235328.jpg" alt="img"></a></p>
<h3 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a><code>proxy_send_timeout</code></h3><p>请求发送给后端服务器的超市是长。超时仅在两个连续写操作之间设置，而不是传输整个响应。如果后端服务器在此时间内没有传输任何内容，则连接被关闭。</p>
<p><a href="http://www.yulongjun.com/images/15043456052255.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235329.jpg" alt="img"></a></p>
<h3 id="proxy-limit-rate"><a href="#proxy-limit-rate" class="headerlink" title="proxy_limit_rate"></a><code>proxy_limit_rate</code></h3><p>限制从后端服务器读取相应的速度。</p>
<p><a href="http://www.yulongjun.com/images/15043519318515.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130235330.jpg" alt="img"></a></p>
<hr>
<h2 id="总的配置实例："><a href="#总的配置实例：" class="headerlink" title="总的配置实例："></a>总的配置实例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir -pv &#x2F;data&#x2F;nginx&#x2F;cache<br>vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br></code></pre></td></tr></table></figure>

<p>在httpd段里添加：<code>proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;</code></p>
<p>全部配置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">user  nginx;<br>worker_processes  1;<br><br>error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;<br>pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;<br><br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br><br>http &#123;<br>    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;<br>    default_type  application&#x2F;octet-stream;<br>    proxy_cache_path &#x2F;data&#x2F;nginx&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;one:10m;<br><br>    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;<br>                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;<br>                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;<br><br>    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    keepalive_timeout  65;<br><br>    #gzip  on;<br><br>    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>移走默认的<code>/etc/nginx/config.d/default.conf</code> ，以免造成干扰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;etc&#x2F;nginx&#x2F;config.d&#x2F;default.conf&#123;,.bak&#125;<br></code></pre></td></tr></table></figure>

<p>添加<code>vhost1.conf</code><br><code>vim /etc/nginx/config.d/vhost1.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &#123;<br>    server_name www.yulongjun.com;<br>    listen 80;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    <br>    location &#x2F; &#123;<br>        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>        index  index.html index.htm;<br>    &#125;<br>    <br>    error_page   500 502 503 504  &#x2F;50x.html;<br>    location &#x3D; &#x2F;50x.html &#123;<br>        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>    &#125;<br><br>    location &#x2F;blog&#x2F; &#123;<br>        proxy_pass http:&#x2F;&#x2F;192.168.10.20&#x2F;;<br>    &#125;<br><br>    location &#x2F;bbs&#x2F; &#123;<br>        proxy_pass http:&#x2F;&#x2F;192.168.10.30&#x2F;;<br>    &#125;<br>    <br>    location ~* \.(jpg|gif|png|jpeg|svg)$ &#123;<br>        proxy_pass http:&#x2F;&#x2F;192.168.10.40;<br>        proxy_cache pgcache;<br>        proxy_cache_key $request_uri<br>        proxy_cache_valid 200 302 10m;<br>        proxy_cache_valid 301 1h;<br>        proxy_cache_valid any 1m;<br>        proxy_cache_use_state error timeout invalid_header;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>07-回显（echo）命令的使用</title>
    <url>/07-%E5%9B%9E%E6%98%BE%EF%BC%88echo%EF%BC%89%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>参数</p>
<ul>
<li><code>-E</code>：禁止对在字符串里的那些转义符进行解释，默认<code>echo</code>命令，就带此参数</li>
<li><code>-n</code>：不自动换行</li>
<li><code>-e</code>：让<code>\</code>转义符（escapes）生效，同时不会自动加回车。<br>下面是常用的几个转义符，如果字符串中出现以下字符，则特别处理，而不会将它当成一般文字输出：</li>
</ul>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’\’</td>
<td>092</td>
</tr>
<tr>
<td>\’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>\”</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\ooo</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<p><strong>打印带颜色的回显：</strong><br>示例：<code>echo -e &#39;\033[43;31;5mFBI Warning!\033[0m&#39;</code></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150511.png" alt="image-20200815155222360"></p>
<p><strong>格式:</strong></p>
<p>echo -e “<strong>控制码</strong>字符串\033[0m”</p>
<ul>
<li>控制码控制显示字体</li>
<li>如果有多个以<code>m</code>结尾的控制码可以使用分号隔开，在最后加<code>m</code>，例如：<code>\033[43;31;5m</code></li>
<li>中间写字符串</li>
<li>最后<code>\033[0m</code>结束属性，这样后面的输入不会变颜色。（可以不加最后的这段自己测试下是什么样子）</li>
</ul>
<p><strong>控制码的说明：</strong></p>
<p><code>\033[0m</code> 关闭所有属性</p>
<p><code>\033[1m</code> 设置高亮度</p>
<p><code>\033[4m</code> 下划线</p>
<p><code>\033[5m</code> 闪烁</p>
<p><code>\033[7m</code> 反显</p>
<p><code>\033[8m</code> 消隐</p>
<p><code>\033[30m -- \033[37m</code> 设置前景色</p>
<p><code>\033[40m -- \033[47m</code> 设置背景色</p>
<p><code>\033[nA</code> 光标上移n行</p>
<p><code>\033[nB</code> 光标下移n行</p>
<p><code>\033[nC</code> 光标右移n行</p>
<p><code>\033[nD</code> 光标左移n行</p>
<p><code>\033[y;xH</code>设置光标位置</p>
<p><code>\033[2J</code> 清屏</p>
<p><code>\033[K</code> 清除从光标到行尾的内容</p>
<p><code>\033[s</code> 保存光标位置</p>
<p><code>\033[u</code> 恢复光标位置</p>
<p><code>\033[?25l</code> 隐藏光标</p>
<p><code>\033[?25h</code> 显示光标</p>
<p><strong>字体背景颜色范围: 40—-49</strong></p>
<p>40: 黑</p>
<p>41: 红</p>
<p>42: 绿</p>
<p>43: 黄</p>
<p>44: 蓝</p>
<p>45: 紫</p>
<p>46: 青</p>
<p>47: 白</p>
<p><strong>字体前景色范围: 30———–39</strong></p>
<p>30: 黑</p>
<p>31: 红</p>
<p>32: 绿</p>
<p>33: 黄</p>
<p>34: 蓝</p>
<p>35: 紫</p>
<p>36: 青</p>
<p>37: 白</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>双引号：<code>&quot;</code></strong>：弱引用，转化变量</p>
<p><strong>单引号：<code>&#39;</code></strong>：强引用不转化，输出原格式</p>
<p><strong>反向单引号：`</strong>：反向单引号里运行的是命令，然后把命令作为前面命令的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment"># echo '$USER'</span><br><span class="hljs-variable">$USER</span><br>[root@ashjian ~]<span class="hljs-comment"># echo $USER</span><br>root<br>[root@ashjian ~]<span class="hljs-comment"># echo "$USER"</span><br>root<br>[root@ashjian ~]<span class="hljs-comment"># echo '$USER'</span><br><span class="hljs-variable">$USER</span><br>[root@ashjian ~]<span class="hljs-comment"># echo `$USER`</span><br>bash: root: 未找到命令...<br><br>[root@ashjian ~]<span class="hljs-comment"># echo echo $USER</span><br><span class="hljs-built_in">echo</span> root<br>[root@centos7 ~]<span class="hljs-comment"># echo "echo $USER"</span><br><span class="hljs-built_in">echo</span> root<br>[root@ashjian ~][root@ashjian ~]<span class="hljs-comment"># echo 'echo $USER'</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$USER</span><br>[root@ashjian ~]<span class="hljs-comment"># echo `echo $USER`</span><br>root<br><br>[root@ashjian ~]]<span class="hljs-comment"># touch oper`date +%F`.log</span><br>[root@ashjian ~]<span class="hljs-comment"># ls</span><br>oper2017-05-20.log<br></code></pre></td></tr></table></figure>

<p><strong>命令行扩展：<code>$( )</code> 或 ``</strong></p>
<p>把一个命令的输出打印给另一个命令的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#echo "This system's name is $(hostname) "</span><br>This system<span class="hljs-string">'s name is ashjian  </span><br><span class="hljs-string">[root@ashjian ~]# echo "i am `whoami` "</span><br><span class="hljs-string">i am root</span><br></code></pre></td></tr></table></figure>

<p><strong>括号扩展：<code>{ }</code></strong></p>
<p>打印重复字符串的简化形式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@centos7 app]<span class="hljs-comment"># echo file&#123;1,3,5&#125;</span><br>file1 file3 file5<br>[root@centos7 app]<span class="hljs-comment"># touch file&#123;1,3,5&#125;</span><br>[root@centos7 app]<span class="hljs-comment"># ls</span><br>file1  file3  file5<br>[root@centos7 app]<span class="hljs-comment"># rm -rf file&#123;1,3,5&#125;</span><br>[root@centos7 app]<span class="hljs-comment"># echo &#123;1..10&#125;</span><br>1 2 3 4 5 6 7 8 9 10<br>[root@centos7 app]<span class="hljs-comment"># echo &#123;a..z&#125;</span><br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>[root@centos7 app]<span class="hljs-comment"># echo &#123;z..a&#125;</span><br>z y x w v u t s r q p o n m l k j i h g f e d c b a<br>[root@centos7 app]<span class="hljs-comment"># echo &#123;A..z&#125;</span><br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [  ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z<br><br>[root@centos7 app]<span class="hljs-comment"># echo &#123;000..20..2&#125;</span><br>000 002 004 006 008 010 012 014 016 018 020<br>/* 三位数字，最大为20，步长为2<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>08-ngx_http_fastcgi_module详解</title>
    <url>/08-ngx-http-fastcgi-module%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有两种Web架构：</p>
<p><strong>LNMP</strong>( Linux+Nginx+MySQL+PHP-FPM+MySQL)：需要FastCGI模块</p>
<p><strong>LNAMP</strong>(Nginx+HTTPD+MySQL+PHP_Module)：需要HTTP相关模块</p>
<p>LNMP是使用的php的fpm功能，而不再是一个依赖httpd的库模块。<br>LNAMP里面，是httpd+php库模块。</p>
<p><strong><code>ngx_http_fastcgi_module</code></strong>和<strong><code>ngx_http_proxy_module</code></strong>很像，在proxy里的用的<code>proxy_pass</code>，在fastcgi里就变成了<code>fastcgi_pass</code>，定义缓存也换成了是<code>fastcgi_cache_path</code>，调用缓存也换成了<code>fastcgi_cache</code>等等。基本用法都差不多。</p>
<p>这里给出一个示例1：</p>
<p>在192.168.10.40上安装<code>php-fpm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y php-fpm<br></code></pre></td></tr></table></figure>

<p>修改<code>/etc/php-fpm.d/www.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">listen &#x3D; 0.0.0.0:9000<br># listen.allowed_clients &#x3D; 127.0.0.1 # 注释掉，让Nginx可以连接到php-fpm<br>pm &#x3D; dynamic # 可以修改为静态<br># 下面的参数生产中都会调大。<br>pm.max_children &#x3D; 50 # 最大子进程数<br>pm.start_servers &#x3D; 5  # 起始子进程数<br>pm.min_spare_servers &#x3D; 5  # 最小空闲子进程数<br>pm.max_spare_servers &#x3D; 35  # 最大空闲子进程数<br></code></pre></td></tr></table></figure>

<p>在Nginx(192.168.10.10)上的<code>/etc/nginx/config.d/</code>里在上一节的基础之上设置<code>vhost1.conf</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &#123;<br>    server_name www.yulongjun.com;<br>    listen 80;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    <br>    location &#x2F; &#123;<br>        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>        # 此处增加php<br>        index  index.php index.html index.htm;<br>    &#125;<br>    <br>    error_page   500 502 503 504  &#x2F;50x.html;<br>    location &#x3D; &#x2F;50x.html &#123;<br>        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>    &#125;<br><br>    location &#x2F;blog&#x2F; &#123;<br>        proxy_pass http:&#x2F;&#x2F;192.168.10.20&#x2F;;<br>    &#125;<br><br>    location &#x2F;bbs&#x2F; &#123;<br>        proxy_pass http:&#x2F;&#x2F;192.168.10.30&#x2F;;<br>    &#125;<br>    <br>    location ~* \.(jpg|gif|png|jpeg|svg)$ &#123;<br>        proxy_pass http:&#x2F;&#x2F;192.168.10.40;<br>        proxy_cache pgcache;<br>        proxy_cache_key $request_uri<br>        proxy_cache_valid 200 302 10m;<br>        proxy_cache_valid 301 1h;<br>        proxy_cache_valid any 1m;<br>        proxy_cache_use_state error timeout invalid_header;<br>    &#125;<br>    location ~* \.php$ &#123;<br>        fastcgi_pass 172.16.0.69:9000;<br>        fastcgi_index index.php;<br>        fastcgi_param SCRIPT_FILENAME &#x2F;data&#x2F;fpm&#x2F;$fastcgi_script_name;<br>        include fastcgi_params;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置示例2：通过/pm_status和/ping来获取fpm server状态信息；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location ~* ^&#x2F;(pm_status|ping)$ &#123;<br>    include        fastcgi_params;<br>    fastcgi_pass 127.0.0.1:9000;<br>    fastcgi_param  SCRIPT_FILENAME  $fastcgi_script_name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>访问下列不同地址，可以看到不同格式和内容的状态信息：</p>
<p><a href="http://www.yulongjun.com/pm_status" target="_blank" rel="noopener">www.yulongjun.com/pm_status</a><br><a href="http://www.yulongjun.com/pm_status?full" target="_blank" rel="noopener">www.yulongjun.com/pm_status?full</a><br><a href="http://www.yulongjun.com/pm_status?json" target="_blank" rel="noopener">www.yulongjun.com/pm_status?json</a><br><a href="http://www.yulongjun.com/pm_status?xml" target="_blank" rel="noopener">www.yulongjun.com/pm_status?xml</a></p>
<h2 id="ngx-http-uwsgi-module"><a href="#ngx-http-uwsgi-module" class="headerlink" title="ngx_http_uwsgi_module"></a>ngx_http_uwsgi_module</h2><p>和fastcgi接口一样，uwsgi也是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如Python的Flask、Django、Tornado等框架写的程序）通信的一种规范。Nginx的ngx_http_uwsgi_module实现了跟uwsgi服务器的通信。</p>
<h2 id="ngx-http-scgi-module"><a href="#ngx-http-scgi-module" class="headerlink" title="ngx_http_scgi_module"></a>ngx_http_scgi_module</h2><p>同上，也是一种Web服务器网关接口，略</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>08-换行（LF）和回车（CR）详解</title>
    <url>/08-%E6%8D%A2%E8%A1%8C%EF%BC%88LF%EF%BC%89%E5%92%8C%E5%9B%9E%E8%BD%A6%EF%BC%88CR%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>sual Studio Code<code>编辑器，可以看到右下角有这个</code>LF`，这是VS Code的默认行尾序列的符号：</p>
<p><a href="http://www.yulongjun.com/images/1495262531051.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150603.png" alt="img"></a></p>
<p>点开后，我们可以到，有两种模式可选，<code>LF</code>，<code>CRLF</code>：</p>
<p><a href="http://www.yulongjun.com/images/1495262315877.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150629.png" alt="img"></a></p>
<p>为什么是这样呢，这两种模式有什么区别呢？</p>
<p>在Linux下，默认换行的话，是<code>LF</code>模式，见下图两个红框部分：</p>
<p>Linux下创建的<code>LinuxFIle</code>文件，用Linux的编辑器在里面写了三行文本。然后我用Python显示出转义符，可以看到是<code>\n</code>，这里的<code>\n</code>就是指的是<strong>换行符（<code>LF</code>）</strong></p>
<p><a href="http://www.yulongjun.com/images/1495263558250.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150638.png" alt="img"></a></p>
<p>然后我们在Windows下用记事本，写一个文件<code>WindowsFile.txt</code>，然后上转到Linux上去同样的方法查看。可以看到是<code>\r\n</code>，<code>\r</code>指的就是<strong>回车（<code>CR</code>）</strong>，<code>\r\n</code>连起来就是<strong>回车换行（<code>CRLF</code>）</strong></p>
<p><a href="http://www.yulongjun.com/images/1495264654813.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150651.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495264614009.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150657.png" alt="img"></a></p>
<p>也就是说：在Linux里编辑文件，一行结束后跟的是<code>\n</code>；在Windows里用自带的记事本编辑文件，一行结束后跟的是<code>\r\n</code></p>
<blockquote>
<p>tips：在Windows下有很多编辑器，是默认支持LF的方式，如<code>Visual Studio Code</code>、<code>Sublime Text</code>、<code>Notepadd++</code>，而且默认的编码格式是<code>UTF-8</code>，所以，大家在Windows下写Linux脚本，或打开Linux下的文件，可以用上面的编辑器，而不要用Windows自带的记事本。</p>
</blockquote>
<p><code>CR</code>和<code>LF</code>是缩写，其实他们的全称分别是：<code>Carriage-Return</code>和<code>Line-Feed</code>。追本溯源的说，<code>CR</code>(<code>Carriage-Return</code>)和<code>LF</code>(<code>Line-Feed</code>)这两个词来源于打字机的发明和使用。</p>
<p>打字机的纸张向下卷动一行，就是<strong>换行(<code>LF</code>, <code>Line-Feed</code>)</strong></p>
<p>将打印头从最右边归位到最左边，就是<strong>回车(<code>CR</code>, <code>Carriage-Return</code>)</strong></p>
<p><a href="http://www.yulongjun.com/images/1495265395191.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150716.png" alt="img"></a></p>
<p>如果把一个Windows记事本建立的文档，放到Linux里用的话，要用<code>dos2unix</code>来转换一下后，再使用。当然最好的方法还是用专门的编辑器，不要用记事本。<br><a href="http://www.yulongjun.com/images/1495266288403.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816150735.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>09-CGI</title>
    <url>/09-CGI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<a href="https://blog.csdn.net/qq_28081081/article/details/80631812###" target="_blank" rel="noopener">https://blog.csdn.net/qq_28081081/article/details/80631812###</a></p>
<h2 id="当我们在谈到cgi的时候，我们在讨论什么"><a href="#当我们在谈到cgi的时候，我们在讨论什么" class="headerlink" title="当我们在谈到cgi的时候，我们在讨论什么"></a>当我们在谈到cgi的时候，我们在讨论什么</h2><p>　　</p>
<p>　　最早的Web服务器简单地响应浏览器发来的HTTP请求，并将存储在服务器上的HTML文件返回给浏览器，也就是静态html。事物总是不断发展，网站也越来越复杂，所以出现动态技术。但是服务器并不能直接运行 php，asp这样的文件，自己不能做，外包给别人吧，但是要与第三做个约定，我给你什么，然后你给我什么，就是握把请求参数发送给你，然后我接收你的处理结果给客户端。那这个约定就是 common gateway interface，简称cgi。这个协议可以用vb，c，php，python 来实现。cgi只是接口协议，根本不是什么语言。下面图可以看到流程             </p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201129172411.gif" alt="img"></p>
<h2 id="WEB服务器与cgi程序交互"><a href="#WEB服务器与cgi程序交互" class="headerlink" title="WEB服务器与cgi程序交互"></a>WEB服务器与cgi程序交互</h2><p> 　WEB服务器将根据CGI程序的类型决定数据向CGI程序的传送方式，一般来讲是通过标准输入/输出流和环境变量来与CGI程序间传递数据。 如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201129172417.gif" alt="img"></p>
<p>　　CGI程序通过标准输入（STDIN）和标准输出（STDOUT）来进行输入输出。此外CGI程序还通过环境变量来得到输入，操作系统提供了许多环境变量，它们定义了程序的执行环境，应用程序可以存取它们。Web服务器和CGI接口又另外设置了一些环境变量，用来向CGI程序传递一些重要的参数。CGI的GET方法还通过环境变量QUERY-STRING向CGI程序传递Form中的数据。 下面是一些常用的CGI环境变量：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONTENT_TYPE</td>
<td>这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。</td>
</tr>
<tr>
<td>CONTENT_LENGTH</td>
<td>如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。</td>
</tr>
<tr>
<td>HTTP_COOKIE</td>
<td>客户机内的 COOKIE 内容。</td>
</tr>
<tr>
<td>HTTP_USER_AGENT</td>
<td>提供包含了版本数或其他专有数据的客户浏览器信息。</td>
</tr>
<tr>
<td>PATH_INFO</td>
<td>这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。</td>
</tr>
<tr>
<td>QUERY_STRING</td>
<td>如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号’?’分隔。</td>
</tr>
<tr>
<td>REMOTE_ADDR</td>
<td>这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。</td>
</tr>
<tr>
<td>REMOTE_HOST</td>
<td>这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。</td>
</tr>
<tr>
<td>REQUEST_METHOD</td>
<td>提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。</td>
</tr>
<tr>
<td>SCRIPT_FILENAME</td>
<td>CGI脚本的完整路径</td>
</tr>
<tr>
<td>SCRIPT_NAME</td>
<td>CGI脚本的的名称</td>
</tr>
<tr>
<td>SERVER_NAME</td>
<td>这是你的 WEB 服务器的主机名、别名或IP地址。</td>
</tr>
<tr>
<td>SERVER_SOFTWARE</td>
<td>这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix)</td>
</tr>
</tbody></table>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>　　说了这么多，你也许感觉烦了，写个小程序可能会更好的理解。 lighttpd + CGI，用c语言写cgi程序 。</p>
<p>   lighttpd 配置 cgi， 打开cgi.conf， cgi.assign = (“.cgi” =&gt; “”) 设置 cgi 模块的扩展名和解释器。就本语句而言，表示cgi模块的扩展名是“.cgi”且该 cgi 模块不需要特别的解释器来执行。因为用c来写的是可执行文件。</p>
<p>   下面是 test.c 代码：</p>
<p>![复制代码](../../../Program Files/Typora)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#include &quot;stdio.h&quot;<br>#include &quot;stdlib.h&quot;<br>#include &lt;string.h&gt;<br><br>int main()<br>&#123;<br>     char *data;<br>     data &#x3D; getenv(&quot;QUERY_STRING&quot;);<br>     puts(data);<br>     printf(&quot;Hello cgi!&quot;);<br><br>     return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>![复制代码](../../../Program Files/Typora)</p>
<p> 生成可执行文件放到你的服务器配置程序的目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">gcc test.c -o test.cgi<br></code></pre></td></tr></table></figure>

<p> 访问：<a href="http://localhost/test.cgi?a=b&amp;c=d" target="_blank" rel="noopener">http://localhost/test.cgi?a=b&amp;c=d</a> 结果为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a&#x3D;b&amp;c&#x3D;d<br>Hello cgi!<br></code></pre></td></tr></table></figure>

<p>　　通过环境变量”QUERY_STRING” 获取get 方式提交的内容，如果想获取post 提交的内容可以通过getenv(“CONTENT-LENGTH”)，Web服务器在调用使用POST方法的CGI程序时设置此环境变量，它的文本值表示Web服务器传送给CGI程序的输入中的字符数目。上面例子展示了cgi 程序与web服务器的交互。</p>
<h2 id="cgi-与-fastcgi"><a href="#cgi-与-fastcgi" class="headerlink" title="cgi 与 fastcgi"></a>cgi 与 fastcgi</h2><p>　　CGI工作原理：每当客户请求CGI的时候，WEB服务器就请求操作系统生成一个新的CGI解释器进程(如php-cgi.exe)，CGI 的一个进程则处理完一个请求后退出，下一个请求来时再创建新进程。当然，这样在访问量很少没有并发的情况也行。可是当访问量增大，并发存在，这种方式就不适合了。于是就有了fastcgi。</p>
<p>　　FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次（这是CGI最为人诟病的fork-and-execute 模式）。</p>
<p>　　<strong>一般情况下，FastCGI的整个工作流程是这样的：</strong></p>
<p>　　<strong>1.Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)</strong></p>
<p>​    <strong><em>\</em>2.\</strong>*<em>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。***</em></p>
<p>​    <strong><em>\</em>3.\</strong>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。**</p>
<p>​    <strong><em>\</em>4\</strong>.FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时， 请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。**</p>
<p>​    <strong><em>\</em>PHP-FPM与Spawn-FCGI**</strong></p>
<p>　　<strong>Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行FastCGI模式下的管理工作。 但是有缺点，于是PHP-fpm就是针对于PHP的，Fastcgi的一种实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP-fpm是内置于PHP的。</strong></p>
<h2 id="apache-模块方式"><a href="#apache-模块方式" class="headerlink" title="apache 模块方式"></a>apache 模块方式</h2><p>　　记得曾在xp 配置 apache + php ，会在apache 配置下面一段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">LoadModule php5_module C:&#x2F;php&#x2F;php5apache2_2.dll<br></code></pre></td></tr></table></figure>

<p>　　当PHP需要在Apache服务器下运行时，一般来说，它可以模块的形式集成， 此时模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求， 然后将处理后的结果返回给Apache。如果我们在Apache启动前在其配置文件中配置好了PHP模块， PHP模块通过注册apache2的ap_hook_post_config挂钩，在Apache启动的时候启动此模块以接受PHP文件的请求。</p>
<p>   Apache 的Hook机制是指：Apache 允许模块(包括内部模块和外部模块，例如mod_php5.so，mod_perl.so等)将自定义的函数注入到请求处理循环中。 换句话说，模块可以在Apache的任何一个处理阶段中挂接(Hook)上自己的处理函数，从而参与Apache的请求处理过程。 mod_php5.so/ php5apache2.dll就是将所包含的自定义函数，通过Hook机制注入到Apache中，在Apache处理流程的各个阶段负责处理php请求。</p>
<p>有人测试nginx+PHP-FPM在高并发情况下可能会达到Apache+mod_php5的5~10倍，现在nginx+PHP-FPM使用的人越来越多。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>CGI</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Screen命令的使用</title>
    <url>/09-Screen%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单使用screen"><a href="#简单使用screen" class="headerlink" title="简单使用screen"></a>简单使用screen</h2><ul>
<li><p>创建新screen会话<br>screen –S [SESSION] </p>
</li>
<li><p>加入screen会话<br>screen –x [SESSION] </p>
</li>
<li><p>退出并关闭screen会话<br>exit </p>
</li>
<li><p>剥离当前screen会话<br>Ctrl+a,d </p>
</li>
<li><p>显示所有已经打开的screen会话<br>screen -ls </p>
</li>
<li><p>恢复某screen会话</p>
<p>screen -r [SESSION]</p>
</li>
</ul>
<p>  以下非本人原创，转载：<a href="https://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html" target="_blank" rel="noopener">https://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html</a></p>
<p><strong>一、背景</strong></p>
<p>系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p>
<p><strong>二、简介</strong></p>
<p><strong>GNU Screen</strong>是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。</p>
<p>GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</p>
<ul>
<li><strong>会话恢复</strong></li>
</ul>
<ul>
<li><strong>多窗口</strong></li>
</ul>
<ul>
<li><strong>会话共享</strong></li>
</ul>
<p>GNU’s Screen 官方站点：<a href="http://www.gnu.org/software/screen/" target="_blank" rel="noopener">http://www.gnu.org/software/screen/</a></p>
<p><strong>三、语法</strong></p>
<p># screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]</p>
<p><strong>参数说明</strong></p>
<p>-A 　将所有的视窗都调整为目前终端机的大小。<br>-d &lt;作业名称&gt; 　将指定的screen作业离线。<br>-h &lt;行数&gt; 　指定视窗的缓冲区行数。<br>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br>-r &lt;作业名称&gt; 　恢复离线的screen作业。<br>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br>-s 　指定建立新视窗时，所要执行的shell。<br>-S &lt;作业名称&gt; 　指定screen作业的名称。<br>-v 　显示版本信息。<br>-x 　恢复之前离线的screen作业。<br>-ls或–list 　显示目前所有的screen作业。<br>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</p>
<p><strong>四、常用screen参数</strong></p>
<p>screen -S yourname -&gt; 新建一个叫yourname的session<br>screen -ls -&gt; 列出当前所有的session<br>screen -r yourname -&gt; 回到yourname这个session<br>screen -d yourname -&gt; 远程detach某个session<br>screen -d -r yourname -&gt; 结束当前session并回到yourname这个session</p>
<p><strong>在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。</strong><br>C-a ? -&gt; 显示所有键绑定信息<br>C-a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口<br>C-a n -&gt; Next，切换到下一个 window<br>C-a p -&gt; Previous，切换到前一个 window<br>C-a 0..9 -&gt; 切换到第 0..9 个 window<br>Ctrl+a [Space] -&gt; 由视窗0循序切换到视窗9<br>C-a C-a -&gt; 在两个最近使用的 window 间切换<br>C-a x -&gt; 锁住当前的 window，需用用户密码解锁<br>C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。<br>C-a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。<br>C-a w -&gt; 显示所有窗口列表<br>C-a t -&gt; Time，显示当前时间，和系统的 load<br>C-a k -&gt; kill window，强行关闭当前的 window<br>C-a [ -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样<br>  C-b Backward，PageUp<br>  C-f Forward，PageDown<br>  H(大写) High，将光标移至左上角<br>  L Low，将光标移至左下角<br>  0 移到行首<br>  $ 行末<br>  w forward one word，以字为单位往前移<br>  b backward one word，以字为单位往后移<br>  Space 第一次按为标记区起点，第二次按为终点<br>  Esc 结束 copy mode<br>C-a ] -&gt; Paste，把刚刚在 copy mode 选定的内容贴上</p>
<p><strong>五、使用 screen</strong></p>
<p><strong>5.1 安装screen</strong></p>
<p>流行的Linux发行版（例如Red Hat Enterprise Linux）通常会自带screen实用程序，如果没有的话，可以从GNU screen的官方网站下载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# yum install screen<br>[root@TS-DEV ~]# rpm -qa|grep screen<br>screen-4.0.3-4.el5<br>[root@TS-DEV ~]#<br></code></pre></td></tr></table></figure>

<p><strong>5.2 创建一个新的窗口</strong></p>
<p>安装完成后，直接敲命令screen就可以启动它。但是这样启动的screen会话没有名字，实践上推荐为每个screen会话取一个名字，方便分辨：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen -S david<br></code></pre></td></tr></table></figure>

<p>screen启动后，会创建第一个窗口，也就是窗口No. 0，并在其中打开一个系统默认的shell，一般都会是bash。所以你敲入命令screen之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入Screen的世界了。当然，也可以在screen命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen vi david.txt<br></code></pre></td></tr></table></figure>

<p>screen创建一个执行vi david.txt的单窗口会话，退出vi 将退出该窗口/会话。</p>
<p><strong>5.3 查看窗口和窗口名称</strong></p>
<p>打开多个窗口后，可以使用快捷键C-a w列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用X环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">0$ bash  1-$ bash  2*$ bash<br></code></pre></td></tr></table></figure>

<p>这个例子中我开启了三个窗口，其中*号表示当前位于窗口2，-号表示上一次切换窗口时位于窗口1。</p>
<p>Screen默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。可以使用快捷键C-a A来为当前窗口重命名，按下快捷键后，Screen会允许你为当前窗口输入新的名字，回车确认。</p>
<p><strong>5.4 会话分离与恢复</strong></p>
<p>你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/david.txt文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen vi &#x2F;tmp&#x2F;david.txt<br></code></pre></td></tr></table></figure>

<p>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入<code>C-a d</code>，Screen会给出detached提示：</p>
<p><strong>暂时中断会话</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816152207.jpg" alt="img"></p>
<p>半个小时之后回来了，找到该screen会话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen -ls<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816153614.jpg" alt="img"></p>
<p>重新连接会话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen -r 12865<br></code></pre></td></tr></table></figure>

<p>一切都在。</p>
<p>当然，如果你在另一台机器上没有分离一个Screen会话，就无从恢复会话了。</p>
<p>这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816153619.jpg" alt="img"></p>
<p><strong>5.5 清除dead 会话</strong></p>
<p>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816153626.jpg" alt="img"></p>
<p><strong>5.6 关闭或杀死窗口</strong></p>
<p>正常情况下，当你退出一个窗口中最后一个程序（通常是bash）后，这个窗口就关闭了。另一个关闭窗口的方法是使用C-a k，这个快捷键杀死当前的窗口，同时也将杀死这个窗口中正在运行的进程。</p>
<p>如果一个Screen会话中最后一个窗口被关闭了，那么整个Screen会话也就退出了，screen进程会被终止。</p>
<p>除了依次退出/杀死当前Screen会话中所有窗口这种方法之外，还可以使用快捷键C-a :，然后输入quit命令退出Screen会话。需要注意的是，这样退出会杀死所有窗口并退出其中运行的所有程序。其实C-a :这个快捷键允许用户直接输入的命令有很多，包括分屏可以输入split等，这也是实现Screen功能的一个途径，不过个人认为还是快捷键比较方便些。</p>
<p><strong>六、screen 高级应用</strong> </p>
<p><strong>6.1 会话共享</strong></p>
<p>还有一种比较好玩的会话恢复，可以实现会话共享。假设你在和朋友在不同地点以相同用户登录一台机器，然后你创建一个screen会话，你朋友可以在他的终端上命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen -x<br></code></pre></td></tr></table></figure>

<p>这个命令会将你朋友的终端Attach到你的Screen会话上，并且你的终端不会被Detach。这样你就可以和朋友共享同一个会话了，如果你们当前又处于同一个窗口，那就相当于坐在同一个显示器前面，你的操作会同步演示给你朋友，你朋友的操作也会同步演示给你。当然，如果你们切换到这个会话的不同窗口中去，那还是可以分别进行不同的操作的。</p>
<p><strong>6.2 会话锁定与解锁</strong></p>
<p>Screen允许使用快捷键C-a s锁定会话。锁定以后，再进行任何输入屏幕都不会再有反应了。但是要注意虽然屏幕上看不到反应，但你的输入都会被Screen中的进程接收到。快捷键C-a q可以解锁一个会话。</p>
<p>也可以使用C-a x锁定会话，不同的是这样锁定之后，会话会被Screen所属用户的密码保护，需要输入密码才能继续访问这个会话。</p>
<p><strong>6.3 发送命令到screen会话</strong></p>
<p>在Screen会话之外，可以通过screen命令操作一个Screen会话，这也为使用Screen作为脚本程序增加了便利。关于Screen在脚本中的应用超出了入门的范围，这里只看一个例子，体会一下在会话之外对Screen的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@TS-DEV ~]# screen -S sandy -X screen ping www.baidu.com<br></code></pre></td></tr></table></figure>

<p>这个命令在一个叫做sandy的screen会话中创建一个新窗口，并在其中运行ping命令。</p>
<p><strong>6.4 屏幕分割</strong></p>
<p>现在显示器那么大，将一个屏幕分割成不同区域显示不同的Screen窗口显然是个很酷的事情。可以使用快捷键C-a S将显示器水平分割，Screen 4.00.03版本以后，也支持垂直分屏，快捷键是C-a |。分屏以后，可以使用C-a <tab>在各个区块间切换，每一区块上都可以创建窗口并在其中运行进程。</p>
<p>可以用C-a X快捷键关闭当前焦点所在的屏幕区块，也可以用C-a Q关闭除当前区块之外其他的所有区块。关闭的区块中的窗口并不会关闭，还可以通过窗口切换找到它。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816153631.jpg" alt="img"></p>
<p><strong>6.5 C/P模式和操作</strong></p>
<p>screen的另一个很强大的功能就是可以在不同窗口之间进行复制粘贴了。使用快捷键C-a <Esc>或者C-a [可以进入copy/paste模式，这个模式下可以像在vi中一样移动光标，并可以使用空格键设置标记。其实在这个模式下有很多类似vi的操作，譬如使用/进行搜索，使用y快速标记一行，使用w快速标记一个单词等。关于C/P模式下的高级操作，其文档的这一部分有比较详细的说明。</p>
<p>一般情况下，可以移动光标到指定位置，按下空格设置一个开头标记，然后移动光标到结尾位置，按下空格设置第二个标记，同时会将两个标记之间的部分储存在copy/paste buffer中，并退出copy/paste模式。在正常模式下，可以使用快捷键C-a ]将储存在buffer中的内容粘贴到当前窗口。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816153639.jpg" alt="img"></p>
<p><strong>6.6 更多screen功能</strong></p>
<p>同大多数UNIX程序一样，GNU Screen提供了丰富强大的定制功能。你可以在Screen的默认两级配置文件/etc/screenrc和$HOME/.screenrc中指定更多，例如设定screen选项，定制绑定键，设定screen会话自启动窗口，启用多用户模式，定制用户访问权限控制等等。如果你愿意的话，也可以自己指定screen配置文件。</p>
<p>以多用户功能为例，screen默认是以单用户模式运行的，你需要在配置文件中指定multiuser on 来打开多用户模式，通过acl*（acladd,acldel,aclchg…）命令，你可以灵活配置其他用户访问你的screen会话。更多配置文件内容请参考screen的man页。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>09-ngx_http_upstream_module详解</title>
    <url>/09-ngx-http-upstream-module%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LB Cluster（负载均衡集群）方案：</p>
<ul>
<li>硬件：<ul>
<li>F5公司：BigIP</li>
<li>Citrix公司：NetScaler</li>
<li>A10公司：A10</li>
</ul>
</li>
<li>软件：<ul>
<li>四层调度：lvs, nginx(stream module), haproxy(mode tcp)</li>
<li>七层调度：nginx(http_upstream module), haproxy(mode http), httpd, ats, …</li>
</ul>
</li>
</ul>
<p>这节我们学习Nginx的七层调度模块<code>ngx_http_upstream_module</code>。</p>
<p>我们可以构建一个后端服务器组(Backend Server Group),里面包含多个相同作用的服务器，通过Nginx的负载均衡功能，可以实现调度。</p>
<p>ngx_http_upstream_module模块用来定义服务器组，这个服务器组可以被proxy_pass、fastcgi_pass、uwsgi_pass、scgi_pass和memcached_pass等指令引用。实现负载均衡的调度功能。</p>
<p>默认算法为randrobin，另外支持least_conn、ip_hash算法，nginx plus还支持更多的调度算法，这里不做讨论。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a><code>upstream</code></h3><p><a href="http://www.yulongjun.com/images/15049669798442.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000420.jpg" alt="img"></a></p>
<p>upstream只能在http上下文里，定义了一组上游服务器组。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a><code>server</code></h3><p><a href="http://www.yulongjun.com/images/15049671014097.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000421.jpg" alt="img"></a></p>
<p>server字段只能在在upstream上下文里，定义一个个的上游服务器，也叫后端服务器（Backend）.</p>
<p>参数有很多：</p>
<ul>
<li><code>weight=number</code>：设置服务器的权重，默认情况下为1。</li>
<li><code>fail_timeout=time</code>：与后端服务器通信失败的超时时间，超过时间，则算一次失败。</li>
<li><code>max_fails=number</code>：设置与服务器通讯的最大失败次数，超过此数将不再调度。</li>
<li><code>backup</code>：将服务器标记为备份服务器。当一个组里所有非备份的服务器都挂了的时候，将会反代备份服务器对外服务。</li>
<li><code>down</code>：将备份服务器标记为不可用；通常在维护服务器的时候使用，比如蓝绿发布的时候。（配置为down，然后reload Nginx服务，维护好了，再去掉down，再reload Nginx服务）</li>
<li><code>resolve</code>：当后端服务器地址写的是域名的时候，如果修改了ip地址，可以自动监控修改</li>
</ul>
<blockquote>
<p>蓝绿发布：<a href="https://www.v2ex.com/t/344341" target="_blank" rel="noopener">https://www.v2ex.com/t/344341</a></p>
</blockquote>
<h3 id="调度算法-默认不写是wrr-least-conn、ip-hash、hash"><a href="#调度算法-默认不写是wrr-least-conn、ip-hash、hash" class="headerlink" title="调度算法(默认不写是wrr)least_conn、ip_hash、hash"></a>调度算法(默认不写是wrr)<code>least_conn</code>、<code>ip_hash</code>、<code>hash</code></h3><p><a href="http://www.yulongjun.com/images/15049695540210.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000422.jpg" alt="img"></a></p>
<p>最少连接算法</p>
<p><a href="http://www.yulongjun.com/images/15049695732922.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000423.jpg" alt="img"></a></p>
<p>源地址哈希算法：同一个ip绑定在一个服务器上</p>
<p><a href="http://www.yulongjun.com/images/15049696488463.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000424.jpg" alt="img"></a></p>
<p>hash自定义的key。该key可以包含文本，变量，以及它们的组合,<code>consistent</code>表示是否启用一致性hash算法。</p>
<p>例如<code>hash $request_uri consistent</code>，就是根据request URI来做调度，即意味着无论哪个客户端，访问同一个资源，都会到固定的后端服务区上去找。如果后端是缓存服务器，可以提高缓存命中率。</p>
<blockquote>
<p>关于一致性hash算法，可以看这里详细了解：<a href="http://www.jianshu.com/p/e8fb89bb3a61" target="_blank" rel="noopener">http://www.jianshu.com/p/e8fb89bb3a61</a></p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="基础虚拟机环境"><a href="#基础虚拟机环境" class="headerlink" title="基础虚拟机环境"></a>基础虚拟机环境</h3><p>一个proxy负责前端调度，后面接两个backend做负载均衡，一个作为backup。</p>
<p><code>proxy</code>反代服务器：192.168.1.200<br><code>backend1</code>后端服务器：192.168.1.101<br><code>backend2</code>后端服务器：192.168.1.102<br><code>backup</code>备份后端服务器：192.168.1.103</p>
<p>Vagrant的<code>Vagrantfile</code>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># -*- mode: ruby -*-<br># vi: set ft&#x3D;ruby :<br><br>Vagrant.configure(&quot;2&quot;) do |config|<br>  # Vagrant Global Config<br>  # &#96;longdream&#x2F;centos7&#96; is a custom centos7 box made by YuLongjun.<br>  config.vm.box &#x3D; &quot;longdream&#x2F;centos7&quot;<br>  # If this box is add online, set true will check update.<br>  # Also set &#96;false&#96; will not update it.<br>  # If this box is added locally, this setting is invalid.<br>  config.vm.box_check_update &#x3D; false<br>  # you need &#96;vagrant plugin install vagrant-vbguest&#96;<br>  # You also need &#96;vagrant plugin install vagrant-hostmanager&#96;<br>  config.hostmanager.enabled &#x3D; true<br>  # Allow update &#96;&#x2F;etc&#x2F;hosts&#96; file in VMs.<br>  config.hostmanager.manage_guest &#x3D; true<br>  # Allow update &#96;&#x2F;etc&#x2F;hosts&#96; file in Hosts.<br>  config.hostmanager.manage_host &#x3D; true<br><br>  # Create VM &#96;proxy&#96;.<br>  config.vm.define &quot;proxy&quot; do |proxy|<br>    proxy.vm.network &quot;private_network&quot;, ip: &quot;192.168.1.200&quot;<br>    proxy.vm.hostname &#x3D;  &quot;proxy&quot;<br>  end<br><br>  # Create VM &#96;backend1&#96;.<br>  config.vm.define &quot;backend1&quot; do |backend1|<br>    backend1.vm.network &quot;private_network&quot;, ip: &quot;192.168.1.101&quot;<br>    backend1.vm.hostname &#x3D;  &quot;backend1&quot;<br>  end<br><br>  # Create VM &#96;backend2&#96;.<br>  config.vm.define &quot;backend2&quot; do |backend2|<br>    backend2.vm.network &quot;private_network&quot;, ip: &quot;192.168.1.102&quot;<br>    backend2.vm.hostname &#x3D;  &quot;backend2&quot;<br>  end<br><br>  # Create VM &#96;backup&#96;.<br>  config.vm.define &quot;backup&quot; do |backup|<br>    backup.vm.network &quot;private_network&quot;, ip: &quot;192.168.1.103&quot;<br>    backup.vm.hostname &#x3D;  &quot;backup&quot;<br>  end<br><br>end<br></code></pre></td></tr></table></figure>

<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>proxy的Nginx程序作为反向代理服务，backend1、backend2、backup的Nginx程序作为HTTP服务。</p>
<p>分别安装Nginx软件：</p>
<p>写一个<code>install_nginx.sh</code>脚本，在四台机器上运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>#<br># set up yum repo.<br>cat &gt;&#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo &lt;&lt;EOF<br>[nginx]<br>name&#x3D;nginx repo<br>baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;\$releasever&#x2F;\$basearch&#x2F;<br>gpgcheck&#x3D;0<br>enabled&#x3D;1<br>EOF<br><br># install<br><br>yum install -y nginx <br>[ $? -eq 0 ]&amp;&amp;echo -e &quot;\033[32;1mInstall nginx successfully.\033[0m&quot;||echo -e &quot;\033[31;1mInstall nginx failed. Please check the Network.\033[0m&quot;<br></code></pre></td></tr></table></figure>

<h3 id="配置各个服务器"><a href="#配置各个服务器" class="headerlink" title="配置各个服务器"></a>配置各个服务器</h3><p>backend1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&#123;,.bak&#125;<br>echo &quot;&lt;h1&gt;Backend Web Server 1&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html<br>systemctl enable nginx<br>systemctl start nginx<br></code></pre></td></tr></table></figure>

<p>backend2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&#123;,.bak&#125;<br>echo &quot;&lt;h1&gt;Backend Web Server 2&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html<br>systemctl enable nginx<br>systemctl start nginx<br></code></pre></td></tr></table></figure>

<p>backup：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html&#123;,.bak&#125;<br>echo &quot;&lt;h1&gt;Backup Server&lt;&#x2F;h1&gt;&quot; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html<br>systemctl enable nginx<br>systemctl start nginx<br></code></pre></td></tr></table></figure>

<p>proxy：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mv &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf&#123;,.bak&#125;<br><br>cat &gt; &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;upstream1.conf &lt;&lt;EOF<br>upstream backend &#123;<br>    server 192.168.1.101; weight&#x3D;2  max_fails&#x3D;2 fail_timeout&#x3D;3;<br>    server 192.168.1.102:80 weight&#x3D;1  max_fails&#x3D;2 fail_timeout&#x3D;3;<br>    server 192.168.1.103 backup;<br>&#125;<br><br>server &#123;<br>    location &#x2F; &#123;<br>        proxy_pass http:&#x2F;&#x2F;backend;<br>    &#125;<br>&#125;<br>EOF<br><br>systemctl enable nginx<br>systemctl start nginx<br></code></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">for i in &#96;seq 10&#96;;do curl 192.168.1.200;done<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15049735810271.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000425.jpg" alt="img"></a></p>
<p>down掉backend1，只能访问到backend2</p>
<p><a href="http://www.yulongjun.com/images/15049736443421.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201000426.jpg" alt="img"></a></p>
<p>down掉backend1和backend2，就负载均衡到backup备份服务器上了：</p>
<p><a href="http://www.yulongjun.com/images/15049737621133.jpg" target="_blank" rel="noopener">
  </a></p>
]]></content>
  </entry>
  <entry>
    <title>10-ngx_stream_modul详解</title>
    <url>/10-ngx-stream-modul%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nginx的<code>ngx_stream_module</code>提供了伪四层代理功能。但是功能不强，用的不多。</p>
<p>捡几个常用的模块说明一下作用，就不做详细展开，想研究的可以详细的去看官方文档。 <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a></p>
<p><a href="http://www.yulongjun.com/images/15049740694578.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201001040.jpg" alt="img"></a></p>
<h2 id="ngx-stream-core-module-：核心模块"><a href="#ngx-stream-core-module-：核心模块" class="headerlink" title="ngx_stream_core_module ：核心模块"></a><code>ngx_stream_core_module</code> ：核心模块</h2><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a><code>listen</code></h3><p><a href="http://www.yulongjun.com/images/15051349117916.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201001041.jpg" alt="img"></a></p>
<p>监听的端口。默认为tcp协议，加上udp就监听udp协议的端口。</p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a><code>stream</code></h3><p><a href="http://www.yulongjun.com/images/15051349740610.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201001042.jpg" alt="img"></a></p>
<p><code>stream</code>段里面定义一个个的server的具体信息。（每个sever监听一个端口）</p>
<h2 id="ngx-stream-proxy-module四层代理功能"><a href="#ngx-stream-proxy-module四层代理功能" class="headerlink" title="ngx_stream_proxy_module四层代理功能"></a><code>ngx_stream_proxy_module</code>四层代理功能</h2><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><code>proxy_pass</code></h3><p>定义的每个端口的server对应的后端主机或主机组。</p>
<h3 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a><code>proxy_connect_timeout</code></h3><p>和被代理的服务器建立连接的超时时间。</p>
<h3 id="proxy-next-upstream"><a href="#proxy-next-upstream" class="headerlink" title="proxy_next_upstream"></a><code>proxy_next_upstream</code></h3><p>当代理服务器和后端服务器不能建立时，是否把客户端连接转移到到下一个后端服务器。默认打开</p>
<h3 id="proxy-next-upstream-timeout"><a href="#proxy-next-upstream-timeout" class="headerlink" title="proxy_next_upstream_timeout"></a><code>proxy_next_upstream_timeout</code></h3><p>转移到下一个服务器的连接的限制时间，如果设置了值，过了这个值，就会再次转移到下一个服务器。如果不设置，那么默认为0，即不限制，一直要求建立连接。</p>
<h3 id="proxy-next-upstream-tries"><a href="#proxy-next-upstream-tries" class="headerlink" title="proxy_next_upstream_tries"></a><code>proxy_next_upstream_tries</code></h3><p>在超时后，尝试的次数，超过这个次数，会转移到下一台。默认为0，无限制尝试。</p>
<h3 id="proxy-timeout"><a href="#proxy-timeout" class="headerlink" title="proxy_timeout"></a><code>proxy_timeout</code></h3><p><a href="http://www.yulongjun.com/images/15051363556211.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201001043.jpg" alt="img"></a></p>
<p>代理服务器处理客户端和后端服务器两次读或写成功的之间的时间内，超过多少时间，就断开连接。默认为10分钟。（即建立连接后，10分钟内没有数据交互，则断开连接）</p>
<h2 id="ngx-stream-upstream-module"><a href="#ngx-stream-upstream-module" class="headerlink" title="ngx_stream_upstream_module"></a><code>ngx_stream_upstream_module</code></h2><h3 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a><code>upstream</code></h3><p><a href="http://www.yulongjun.com/images/15051375631563.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201001044.jpg" alt="img"></a></p>
<p>stream的upstream和http的upstream没什么区别，都可以设置多个后端服务器，也可以设置备份后端服务器，还可以设置权重和算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">upstream backend &#123;<br>        hash $remote_addr consistent;<br>        server backend1.example.com:12345 weight&#x3D;5;<br>        server 127.0.0.1:12345            max_fails&#x3D;3 fail_timeout&#x3D;30s;<br>        server unix:&#x2F;tmp&#x2F;backend3;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ngx-stream-ssl-module"><a href="#ngx-stream-ssl-module" class="headerlink" title="ngx_stream_ssl_module"></a><code>ngx_stream_ssl_module</code></h2><p>和http的ssl相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">worker_processes auto;<br><br>stream &#123;<br><br>    ...<br><br>    server &#123;<br>        listen              12345 ssl;<br><br>        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;<br>        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;<br>        ssl_certificate     &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;cert.pem;<br>        ssl_certificate_key &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;cert.key;<br>        ssl_session_cache   shared:SSL:10m;<br>        ssl_session_timeout 10m;<br><br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ngx-stream-log-module"><a href="#ngx-stream-log-module" class="headerlink" title="ngx_stream_log_module"></a><code>ngx_stream_log_module</code></h2><p>log_format，是日志格式，可以定义多种，写在stream段。<br>access_log可以用在stream和server段（使用log_format）。</p>
<p>如下，定义一个名为basic 的log_format，access_log调用basic的日志格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">log_format basic &#39;$remote_addr [$time_local] &#39;<br>                 &#39;$protocol $status $bytes_sent $bytes_received &#39;<br>                 &#39;$session_time&#39;;<br>access_log &#x2F;spool&#x2F;logs&#x2F;nginx-access.log basic buffer&#x3D;32k;<br></code></pre></td></tr></table></figure>

<h2 id="ngx-stream-access-module"><a href="#ngx-stream-access-module" class="headerlink" title="ngx_stream_access_module"></a><code>ngx_stream_access_module</code></h2><p>同http的访问控制模块。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &#123;<br>    ...<br>    deny  192.168.1.1;<br>    allow 192.168.1.0&#x2F;24;<br>    allow 10.1.1.0&#x2F;16;<br>    allow 2001:0db8::&#x2F;32;<br>    deny  all;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ngx_stream_geo_module</code>：</li>
</ul>
<p>自定义ip地理位置。</p>
<p>用的少，一般用<code>geoip</code>，是有ip地址库的,见下。</p>
<h2 id="ngx-stream-geoip-module"><a href="#ngx-stream-geoip-module" class="headerlink" title="`ngx_stream_geoip_module"></a>`ngx_stream_geoip_module</h2><p><code>yum install yum install GeoIP GeoIP-data</code>geoip是库文件，geoip-data是具体的数据文件。<br>不过不是最新版，要想要最新版还是要到官方网站去下载：官方提供免费版和付费版，官网地址:<a href="http://www.yulongjun.com/lb/20170823-10-ngx_stream_module/www.maxmind.com" target="_blank" rel="noopener">www.maxmind.com</a>。</p>
<p><code>rpm -ql GeoIP-data</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIPASNum-initial.dat<br>&#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIPASNumv6-initial.dat<br>&#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIPCity-initial.dat<br>&#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIPCityv6-initial.dat<br>stream &#123;<br>    geoip_country         &#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIPASNum-initial.dat;<br>    geoip_city            &#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIPCity-initial.dat;<br><br>    map $geoip_city_continent_code $nearest_server &#123;<br>        default        example.com;<br>        EU          eu.example.com;<br>        NA          na.example.com;<br>        AS          as.example.com;<br>    &#125;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>官方的一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">worker_processes auto;<br><br>error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log info;<br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br>stream &#123;<br>    upstream backend &#123;<br>        hash $remote_addr consistent;<br><br>        server backend1.example.com:12345 weight&#x3D;5;<br>        server 127.0.0.1:12345            max_fails&#x3D;3 fail_timeout&#x3D;30s;<br>        server unix:&#x2F;tmp&#x2F;backend3;<br>    &#125;<br><br>    upstream dns &#123;<br>       server 192.168.0.1:53535;<br>       server dns.example.com:53;<br>    &#125;<br><br>    server &#123;<br>        listen 12345;<br>        proxy_connect_timeout 1s;<br>        proxy_timeout 3s;<br>        proxy_pass backend;<br>    &#125;<br><br>    server &#123;<br>        listen 127.0.0.1:53 udp;<br>        proxy_responses 1;<br>        proxy_timeout 20s;<br>        proxy_pass dns; <br>    &#125;<br><br>    server &#123;<br>        listen [::1]:12345;<br>        proxy_pass unix:&#x2F;tmp&#x2F;stream.socket;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>10-历史(history)命令用法</title>
    <url>/10-%E5%8E%86%E5%8F%B2-history-%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="命令行历史"><a href="#命令行历史" class="headerlink" title="命令行历史"></a>命令行历史</h2><ul>
<li>保存你输入的命令历史。可以用它来重复执行命令</li>
<li>登录shell时，会读取命令历史文件中记录下的命令<strong>~/.bash_history</strong></li>
<li>登录进shell后新执行的命令只会记录在<strong>缓存(命令历史列表)</strong>中；这些命令会用户退出时“追加至”<strong>文件系统（命令历史文件）</strong>中</li>
</ul>
<h3 id="history命令："><a href="#history命令：" class="headerlink" title="history命令："></a><strong>history命令：</strong></h3><ul>
<li>直接运行，显示历史命令，默认最多记录1000行</li>
</ul>
<p>新执行的命令存在内存里，正常退出shell后，会写在<code>~/.bash_history</code></p>
<ul>
<li><code>-c</code>清空</li>
<li><code>-a</code>把当前内存里存的历史命令存入<code>~/.bash_history</code>文件。</li>
</ul>
<p>*<code>-p</code> 可以有这种用法，反引号里写命令，可以不保存命令到历史（可以用来做坏事哦）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">history -p &#96;hostname&#96; &#96;ifconfig&#96;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>-s</code>伪造历史命令，其实没执行： <code>history -s &quot;rm -rf /*&quot;</code>（可以用来吓唬人）</li>
</ul>
<blockquote>
<p>tips：printenv可以打印出系统全局变量，可以看到有个HISTSIZE，<code>echo $HISTSIZE</code>可以看到此全局环境变量设置的是1000，这个就是历史命令大小，这个全局环境变量的参数的配置信息存在<code>/etc/profile</code>文件里。</p>
</blockquote>
<hr>
<p><strong>利用历史命令来执行的方法：</strong></p>
<p>常用的几个记住就好：</p>
<ul>
<li><code>!!</code>：重复执行上一个命令</li>
<li><code>! NUM</code>：执行序号为<code>NUM</code>的命令：</li>
<li><code>!-NUM</code>：倒数第几个命令</li>
<li><code>!:NUM</code>：上一个命令的以空格分割的索引</li>
<li><code>Esc .</code>：可以重复上面一个命令的最后的参数<br>比如我们本来要编辑一个文件，发现输入错了，输入的<code>cd</code>，可以再输入<code>vim Esc .</code>就把上一条的参数弄过来了。</li>
</ul>
<hr>
<p><strong>设置<code>HISTTIMEFORMAT</code></strong></p>
<p>这样就可以显示每条命令执行的时间。<br>例如设置 <code>~/.bash_profile</code>里添加用户系统环境变量<code>export HISTTIMEFORMAT=&quot;%F %T</code></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h3><p>history [-c] [-d offset] [n]<br>history -anrw [filename]<br>history -ps arg [arg…]</p>
<ul>
<li>c: 清空命令历史</li>
<li>d  offset: 删除历史中指定的第offset个命令<br>n: 显示最近的n条历史</li>
<li>a: 追加本次会话新执行的命令历史列表至历史文件</li>
<li>r: 读历史文件附加到历史列表</li>
<li>w: 保存历史列表到指定的历史文件</li>
<li>n: 读历史文件中未读过的行到历史列表</li>
<li>p: 展开历史参数成多行，但不存在历史列表中</li>
<li>s: 展开历史参数成一行，附加在历史列表后</li>
</ul>
<h3 id="命令历史相关环境变量"><a href="#命令历史相关环境变量" class="headerlink" title="命令历史相关环境变量"></a>命令历史相关环境变量</h3><p>HISTSIZE：命令历史记录的条数<br>HISTFILE：指定历史文件，默认为~/.bash_history<br>HISTFILESIZE：命令历史文件记录历史的条数<br>HISTTIMEFORMAT=“%F %T “   显示时间<br>HISTIGNORE=“str1:str2*:… “ 忽略str1命令，str2开头的历史<br>控制命令历史的记录方式：<br>    环境变量：HISTCONTROL</p>
<p>​        ignoredups  默认，忽略重复的命令，连续且相同为“重复” </p>
<p>​        ignorespace 忽略所有以空白开头的命令<br>​        ignoreboth  相当于ignoredups, ignorespace的组合 </p>
<p>​        erasedups   删除重复命令 </p>
<h3 id="执行历史命令的快捷方法"><a href="#执行历史命令的快捷方法" class="headerlink" title="执行历史命令的快捷方法"></a>执行历史命令的快捷方法</h3><ul>
<li>重复前一个命令，有4种方法<br>重复前一个命令使用上方向键，并回车执行<br>按 !! 并回车执行<br>输入 !-1 并回车执行<br>按 Ctrl+p 并回车执行</li>
<li>!:0  执行前一条命令（去除参数）</li>
<li>Ctrl + n 显示当前历史中的下一条命令，但不执行</li>
<li>Ctrl + j 执行当前命令</li>
<li>!n  执行history命令输出对应序号n的命令</li>
<li>!-n  执行history历史中倒数第n个命令</li>
<li>!string 重复前一个以“string”开头的命令</li>
<li>!?string 重复前一个包含string的命令</li>
<li>!string:p 仅打印命令历史，而不执行</li>
<li>!$:p 打印输出 !$ （上一条命令的最后一个参数）的内容</li>
<li>!*:p 打印输出 !（上一条命令的所有参数）的内容</li>
<li>^string 删除上一条命令中的第一个string</li>
<li>^string1^string2 将上一条命令中的第一个string1替换为string2</li>
<li>!:gs/string1/string2 将上一条命令中所有的string1都替换为 string2</li>
<li>ctrl-r来在命令历史中搜索命令<br>（reverse-i-search）`’：</li>
<li>Ctrl+g：从历史搜索模式退出</li>
<li>要重新调用前一个命令中最后一个参数<br>!$  表示<br>Esc, .（点击Esc键后松开，然后点击 . 键）<br>Alt+ .（按住Alt键的同时点击 . 键）</li>
</ul>
<h3 id="调用历史参数"><a href="#调用历史参数" class="headerlink" title="调用历史参数"></a>调用历史参数</h3><ul>
<li>command !^   利用上一个命令的第一个参数做cmd的参数</li>
<li>command !$ 利用上一个命令的最后一个参数做cmd的参数</li>
<li>command !*   利用上一个命令的全部参数做cmd的参数</li>
<li>command !:n  利用上一个命令的第n个参数做cmd的参数</li>
<li>command !n:^ 调用第n条命令的第一个参数</li>
<li>command !n:$ 调用第n条命令的最后一个参数</li>
<li>command !n:m 调用第n条命令的第m个参数</li>
<li>command !n:* 调用第n条命令的所有参数</li>
<li>command !string:^ 从命令历史中搜索以 string 开头的命令，并获取它的第一个参数</li>
<li>command !string:$ 从命令历史中搜索以 string 开头的命令,并获取它的最后一个参数</li>
<li>command !string:n 从命令历史中搜索以 string 开头的命令，并获取它的第n个参数</li>
<li>command !string:* 从命令历史中搜索以 string 开头的命令，并获取它的所有参数</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>11-bash的快捷键</title>
    <url>/11-bash%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="bash的快捷键"><a href="#bash的快捷键" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h2><ul>
<li>清屏，相当于clear命令</li>
<li>Ctrl + o 执行当前命令，并重新显示本命令</li>
<li>Ctrl + s 阻止屏幕输出，锁定</li>
<li>Ctrl + q 允许屏幕输出</li>
<li>Ctrl + c 终止命令</li>
<li>Ctrl + z 挂起命令</li>
<li>Ctrl + a 光标移到命令行首，相当于Home</li>
<li>Ctrl + e 光标移到命令行尾，相当于End</li>
<li>Ctrl + f 光标向右移动一个字符</li>
<li>Ctrl + b 光标向左移动一个字符</li>
<li>Alt + f 光标向右移动一个单词尾 </li>
<li>Alt + b 光标向左移动一个单词首</li>
<li>Ctrl + xx 光标在命令行首和光标之间移动</li>
<li>Ctrl + u 从光标处删除至命令行首</li>
<li>Ctrl + k 从光标处删除至命令行尾</li>
<li>Alt + r 删除当前整行</li>
<li>Ctrl + w 从光标处向左删除至单词首</li>
<li>Alt + d 从光标处向右删除至单词尾</li>
<li>Ctrl + d 删除光标处的一个字符</li>
<li>Ctrl + h 删除光标前的一个字符</li>
<li>Ctrl + y 将删除的字符粘贴至光标后</li>
<li>Alt + c 从光标处开始向右更改为首字母大写的单词</li>
<li>Alt + u 从光标处开始，将右边一个单词更改为大写 </li>
<li>Alt + l  从光标处开始，将右边一个单词更改为小写</li>
<li>Ctrl + t 交换光标处和之前的字符位置</li>
<li>Alt + t 交换光标处和之前的单词位置</li>
<li>Alt + N 提示输入指定字符后，重复显示该字符N次<br>注意：Alt组合快捷键经常和其它软件冲突</li>
</ul>
<p><strong>学的快捷组合键越多，软件越多，越冲突，自找麻烦</strong>，<strong>合适自己就好了</strong></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>12-认识Shell</title>
    <url>/12-%E8%AE%A4%E8%AF%86Shell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ul>
<li>Shell 是Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行</li>
<li>shell也被称为LINUX的命令解释器（command interpreter）</li>
<li>shell是一种高级程序设计语言</li>
<li><img src="C:%5CUsers%5Cshixiujian%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814195546675.png" alt="image-20200814195546675"></li>
</ul>
<h3 id="bash-shell"><a href="#bash-shell" class="headerlink" title="bash shell"></a>bash shell</h3><ul>
<li>GNU Bourne-Again Shell(bash)是GNU计划中重要的工具软件之一，目前也是 Linux标准的shell，与sh兼容</li>
<li>CentOS默认使用</li>
<li>​    显示当前使用的shell</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">root@ashjian ~]<span class="hljs-variable">$echo</span> <span class="hljs-variable">$SHELL</span><br>/bin/bash<br>[root@ashjian ~]<span class="hljs-variable">$echo</span> <span class="hljs-variable">$&#123;SHELL&#125;</span>	<span class="hljs-comment">#加中括号&#123;&#125;是严谨写法</span><br>/bin/bash<br></code></pre></td></tr></table></figure>

<ul>
<li>显示当前系统使用的所有shell</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-variable">$cat</span> /etc/shells <br>/bin/sh<br>/bin/bash<br>/sbin/nologin<br>/usr/bin/sh<br>/usr/bin/bash<br>/usr/sbin/nologin<br>/bin/tcsh<br>/bin/csh<br></code></pre></td></tr></table></figure>

<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>输入命令后回车，提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来 </p>
<h3 id="在shell中可执行的命令有两类"><a href="#在shell中可执行的命令有两类" class="headerlink" title="在shell中可执行的命令有两类"></a>在shell中可执行的命令有两类</h3><ul>
<li><p>内部命令：由shell自带的，而且通过某命令形式提供</p>
<p><code>enable</code>或<code>help</code>出来的全是内部命令。<code>help</code>有简单的参数提示。</p>
<p>enable cmd 启用内部命令<br>enable –n cmd 禁用内部命令 enable –n 查看所有禁用的内部命令</p>
<p>上面这两个命令造成的影响，<strong>重登录bash失效</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian /]<span class="hljs-comment">#enable -n type</span><br>[root@ashjian /]<span class="hljs-comment">#tyep who</span><br>-bash: tyep: <span class="hljs-built_in">command</span> not found	<span class="hljs-comment">#禁用命令type后，无法找到type命令</span><br>[root@ashjian /]<span class="hljs-comment">#enable type	#启用内部命令</span><br>[root@ashjian /]<span class="hljs-comment">#type who</span><br>who is hashed (/usr/bin/who)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>外部命令</strong>：非shell内建命令都是外部命令。</p>
<p>查看路径：which  -a |–skip-alias ;  whereis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian /]<span class="hljs-comment">#which who</span><br>/usr/bin/who<br>[root@ashjian /]<span class="hljs-comment">#whereis who #查出命令的所有程序和帮助文档的路径</span><br>who: /usr/bin/who /usr/share/man/man1/who.1.gz<br>[root@ashjian /]<span class="hljs-comment">#which --skip-alias cp	#有别名的命令的查法</span><br>/usr/bin/cp<br></code></pre></td></tr></table></figure>

<p>区别指定的命令是内部或外部命令</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian /]<span class="hljs-comment">#type enable	</span><br><span class="hljs-built_in">enable</span> is a shell <span class="hljs-built_in">builtin</span>	<span class="hljs-comment">#内部命令集合在bash中，不会显示出路径</span><br>[root@ashjian /]<span class="hljs-comment">#type who</span><br>who is hashed (/usr/bin/who)	<span class="hljs-comment">#外部命令则显示出路径</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>内部和外部都有的命令，优先使用内部命令。</strong></p>
</blockquote>
<p>外部命令在hash中不存在该命令时被使用后会被hash，使用时先查看hash，再查看PATH路径（在hash找到，就不再查看PATH）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian /]<span class="hljs-comment">#hash</span><br>hits	<span class="hljs-built_in">command</span><br>   1	/usr/bin/tty<br>   1	/usr/bin/hostname<br>   2	/usr/bin/yes<br>   2	/usr/bin/vim<br></code></pre></td></tr></table></figure>



<ul>
<li><code>type -a COMMAND</code>：可以列出某命令的所有位置（包括内部和外部）</li>
<li><code>type -P COMMAND</code>：可以显示命令的路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-variable">$type</span> httpd<br>httpd is /usr/<span class="hljs-built_in">local</span>/apache/bin/httpd<br>[root@ashjian ~]<span class="hljs-variable">$type</span> -a httpd<br>httpd is /usr/<span class="hljs-built_in">local</span>/apache/bin/httpd<br>httpd is /usr/sbin/httpd<br>[root@ashjian ~]<span class="hljs-variable">$type</span> -p httpd<br>/usr/<span class="hljs-built_in">local</span>/apache/bin/httpd<br></code></pre></td></tr></table></figure>

<h3 id="hash哈希表，缓存表"><a href="#hash哈希表，缓存表" class="headerlink" title="hash哈希表，缓存表"></a><code>hash</code>哈希表，缓存表</h3><p>系统初始hash表为空，当外部命令执行时，默认会从 PATH路径下寻找该命令，找到后会将这条命令的路径记录到 hash表中，当再次使用该命令时，shell解释器首先会查看hash 表，存在将执行之，如果不存在，将会去PATH路径下寻找。利 用hash缓存表可大大提高命令的调用速率。</p>
<p><code>hash</code>：显示命令缓存，还有用了几次（hits）</p>
<p><code>hash -l</code>：列出（list）缓存过的命令</p>
<p><code>hash -p PATH NAME</code>：可以给命令建立缓存（冒充）</p>
<p><code>hash -d COMMAND</code>：删除某个命令的缓存</p>
<p><code>hash -t COMMAND</code>：列出单个别名的路径</p>
<p><code>hash -r</code>：清空hash表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]$ <span class="hljs-built_in">hash</span><br>hits	<span class="hljs-built_in">command</span><br>   1	/usr/bin/who<br>   1	/usr/bin/ls<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -l<br><span class="hljs-built_in">builtin</span> <span class="hljs-built_in">hash</span> -p /usr/bin/who who<br><span class="hljs-built_in">builtin</span> <span class="hljs-built_in">hash</span> -p /usr/bin/ls ls<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -p /ww/aa/ f<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -l<br><span class="hljs-built_in">builtin</span> <span class="hljs-built_in">hash</span> -p /ww/aa/ f<br><span class="hljs-built_in">builtin</span> <span class="hljs-built_in">hash</span> -p /usr/bin/who who<br><span class="hljs-built_in">builtin</span> <span class="hljs-built_in">hash</span> -p /usr/bin/ls ls<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -d f<br>[root@ashjian ~]<span class="hljs-variable">$hash</span><br>hits	<span class="hljs-built_in">command</span><br>   1	/usr/bin/who<br>   1	/usr/bin/ls<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -t ls<br>/usr/bin/ls<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -r<br>[root@ashjian ~]<span class="hljs-variable">$hash</span> -l<br><span class="hljs-built_in">hash</span>: <span class="hljs-built_in">hash</span> table empty<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>13- CentOS 6 安装步骤</title>
    <url>/13-CentOS-6-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14975931251894.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816162238.png" alt="img"></a></p>
<h3 id="1-虚拟机软件"><a href="#1-虚拟机软件" class="headerlink" title="1. 虚拟机软件"></a>1. 虚拟机软件</h3><p><strong>Windows</strong>和<strong>Linux</strong>下推荐使用<a href="http://www.vmware.com/cn/products/workstation/workstation-evaluation.html" target="_blank" rel="noopener"><strong>VMware Workstation</strong></a></p>
<p><a href="http://www.yulongjun.com/images/1495023646887.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816162403.png" alt="img"></a><br><strong>macOS</strong>下推荐使用<a href="http://www.vmware.com/cn/products/fusion/fusion-evaluation.html" target="_blank" rel="noopener"><strong>VMware Fusion</strong></a></p>
<p><a href="http://www.yulongjun.com/images/1495023856188.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816163449.png" alt="img"></a></p>
<p>另外还有Virtual Box也非常好用。</p>
<hr>
<h3 id="2-虚拟机分配的资源"><a href="#2-虚拟机分配的资源" class="headerlink" title="2. 虚拟机分配的资源"></a>2. 虚拟机分配的资源</h3><ul>
<li><code>2CPU</code>/<code>1G内存</code>/<code>200G硬盘</code></li>
<li>去掉打印机等的没用的硬件</li>
<li>光盘开始选择空白光盘，不要在这里选择iso安装，会有一个简易的自动安装，等完成设置后，再手动编辑设置改为iso镜像。同时勾选连接光盘和已连接。</li>
</ul>
<hr>
<h3 id="3-系统安装过程"><a href="#3-系统安装过程" class="headerlink" title="3. 系统安装过程"></a>3. 系统安装过程</h3><p>1、 选择“Install or upgrade an existing system”（安装或升级现存的系统）</p>
<p><a href="http://www.yulongjun.com/images/1495019121334.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816163511.png" alt="img"></a></p>
<p>2、 检测光盘有无问题，这里跳过，不检测</p>
<p><a href="http://www.yulongjun.com/images/1495019207892.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816163946.png" alt="img"></a></p>
<p>3、 下一步</p>
<p><a href="http://www.yulongjun.com/images/1495037111639.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816163953.png" alt="img"></a></p>
<p>4、 在安装过程中使用的语言，这里选英文</p>
<p><a href="http://www.yulongjun.com/images/1495019264600.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816172931.png" alt="img"></a></p>
<p>5、 键盘，选择<code>U.S. English</code></p>
<p><a href="http://www.yulongjun.com/images/1495019319742.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816172913.png" alt="img"></a></p>
<p>6、 磁盘这里，选择基本存储设备（Basic Storage Devices）</p>
<p><a href="http://www.yulongjun.com/images/1495019381516.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173004.png" alt="img"></a></p>
<p>7、 删除磁盘上的分区和文件系统，选<code>Yes, discard any data</code></p>
<p><a href="http://www.yulongjun.com/images/1495019431647.png" target="_blank" rel="noopener">![img](D:\MyMD\linux\CentOS 6 安装步骤.assets\1495019431647.png)</a></p>
<p>8、 hostname主机名填一个自定义的主机名。</p>
<p><a href="http://www.yulongjun.com/images/1495019489056.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173010.png" alt="img"></a></p>
<p>9、 然后点击左下角的配置网络（Configure Network）来配置网卡信息。</p>
<p><a href="http://www.yulongjun.com/images/1495019556425.png" target="_blank" rel="noopener">![img](D:\MyMD\linux\CentOS 6 安装步骤.assets\1495019556425.png)</a></p>
<p>10、 这里我们两个网段都有DHCP，所以可以都自动获取，但是这两个网卡默认都是不启用的，所以要打开自动连接（Connect automatically）</p>
<p><a href="http://www.yulongjun.com/images/1495019814539.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173019.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495019838552.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173031.png" alt="img"></a></p>
<p>11、 都打开后，点击下一步</p>
<p><a href="http://www.yulongjun.com/images/1495019850220.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173337.png" alt="img"></a></p>
<p>12、 这里选择时区，点地图上的点，点到上海，下面会自动变为<code>Asia/Shanghai</code>，然后关闭UTC时间（<code>System clock uses UTC</code>前面的勾去掉）</p>
<p><a href="http://www.yulongjun.com/images/1495019954758.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173345.png" alt="img"></a></p>
<p>13、 设置root用户密码</p>
<p><a href="http://www.yulongjun.com/images/1495019978275.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173351.png" alt="img"></a></p>
<p>14、 安装方式，选择自定义布局<code>Create Custom Layout</code></p>
<p><a href="http://www.yulongjun.com/images/1495020046668.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173419.png" alt="img"></a></p>
<p>15、 点击<code>sda</code>或者<code>free</code>，然后点<code>Create</code>创建分区。</p>
<p><a href="http://www.yulongjun.com/images/1495020150153.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173755.png" alt="img"></a></p>
<p>16、 分区，各分区大小(这里给个参考，可跟据自己机器自由选择)</p>
<table>
<thead>
<tr>
<th align="left">分区</th>
<th align="left">大小（GB）</th>
<th align="left">大小（MB）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/boot</code></td>
<td align="left">1</td>
<td align="left">1024</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">100</td>
<td align="left">102400</td>
</tr>
<tr>
<td align="left"><code>/app</code></td>
<td align="left">50</td>
<td align="left">51200</td>
</tr>
<tr>
<td align="left"><code>swap</code></td>
<td align="left">2</td>
<td align="left">2048</td>
</tr>
</tbody></table>
<p>最后剩下的不用管，后面做<code>lvm</code>等磁盘实验用，先不分。</p>
<p><a href="http://www.yulongjun.com/images/1495020945228.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173802.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495020974606.png" target="_blank" rel="noopener">![img](D:\MyMD\linux\CentOS 6 安装步骤.assets\1495020974606.png)</a></p>
<p><a href="http://www.yulongjun.com/images/1495020981965.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173808.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495020990360.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173817.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495020998231.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816173817.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495021004760.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816174025.png" alt="img"></a></p>
<p>17、 这是让你确认是否开始格式化，点<code>Format</code>格式化</p>
<p><a href="http://www.yulongjun.com/images/1495036670436.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816174844.png" alt="img"></a></p>
<p>18、 是否开始给硬盘分区，点<code>Write change to disk</code></p>
<p><a href="http://www.yulongjun.com/images/1495036786151.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816174855.png" alt="img"></a></p>
<p>19、 这里选择默认的就好。</p>
<blockquote>
<p>tips：生产中有时候用u盘来给服务器装操作系统，这里要看到<code>boot loader</code>（很小的一小段空间，446字节，但很重要）的安装位置是不是<code>/dev/sda</code>，不要不小心把<code>boot loader</code>装到u盘(<code>/dev/sdb)</code>了，这里要手动改一下设备的。如果没注意，很有可能写到u盘里，这样u盘也无法使用了，然后拔掉u盘后，系统也无法启动了。</p>
</blockquote>
<p><a href="http://www.yulongjun.com/images/1495036838195.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816174903.png" alt="img"></a></p>
<p>20、 选择安装包，选择<code>Desktop</code>，然后再自定义选择<code>Customize now</code>。</p>
<p><a href="http://www.yulongjun.com/images/1495021881815.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816174910.png" alt="img"></a></p>
<p>21、 自定义就可以选一些包了，比如选一个中文支持包，选一个<code>KDE</code>桌面包（跟据个人爱好，我还是比较喜欢<code>Gnome</code>）</p>
<p>包里其实有还有些可选包，在包上点右键，可以选择<br><code>Select all optional packages</code>，即选择所有可选包。我们可以看到<code>Chinese Support</code>的包为<code>6 of 7</code>，右键选完后，就变为7 of 7了。</p>
<p><a href="http://www.yulongjun.com/images/1495022043184.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816174918.png" alt="img"></a></p>
<p>22、 然后进入安装界面，开始安装包</p>
<p><a href="http://www.yulongjun.com/images/1495022243618.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816175102.png" alt="img"></a></p>
<p>23、 等待安装，安装完后，点击<code>reboot</code></p>
<p><a href="http://www.yulongjun.com/images/1495022291952.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816175113.png" alt="img"></a></p>
<p>24、 进入一个欢迎界面，还有些设置要设置一下。</p>
<p><a href="http://www.yulongjun.com/images/1495022326616.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816175626.png" alt="img"></a></p>
<p>25、 同意协议</p>
<p><a href="http://www.yulongjun.com/images/1495022397089.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816175555.png" alt="img"></a></p>
<p>26、 创建用户，这里可以自己创建一下，或不填跳过，都可以。</p>
<p><a href="http://www.yulongjun.com/images/1495022409452.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816175637.png" alt="img"></a></p>
<p>27、 设置时间<br><a href="http://www.yulongjun.com/images/1495022467988.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182048.png" alt="img"></a></p>
<p>28、 开启kdump，这里选择No，可以不用重启操作系统，如果按Yes，需要重启操作系统。<br><a href="http://www.yulongjun.com/images/1495022530461.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182058.png" alt="img"></a></p>
<p>29、 安装完毕<br><a href="http://www.yulongjun.com/images/1495022544829.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182105.png" alt="img"></a></p>
<p>30、 <code>ifconfig</code>检查两个网卡是否都起来了，是否有ip地址分配，如果没有，可以<code>cat /etc/sysconfig/network-scripts/ifcfg-网卡名</code>，看看里面有一行<code>ONBOOT=no</code>(这条配置决定了开机是否启动网卡)，如果是<code>no</code>, 可以用<code>nano</code>或<code>gedit</code>或<code>vim</code>等工具来更改为<code>yes</code>，这样下次重启后就永久生效了，然后<code>ifup 网卡名</code>实时启动网卡（避免重启）。</p>
<p>31、 关闭系统，拍一个快照。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>14-CentOS 7 安装步骤</title>
    <url>/14-CentOS-7-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14975931251894.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182146.png" alt="img"></a></p>
<h3 id="1-虚拟机软件"><a href="#1-虚拟机软件" class="headerlink" title="1. 虚拟机软件"></a>1. 虚拟机软件</h3><p><strong>Windows</strong>和<strong>Linux</strong>下推荐使用<a href="http://www.vmware.com/cn/products/workstation/workstation-evaluation.html" target="_blank" rel="noopener"><strong>VMware Workstation</strong></a></p>
<p><a href="http://www.yulongjun.com/images/1495038117087.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182125.png" alt="img"></a></p>
<p><strong>macOS</strong>下推荐使用<a href="http://www.vmware.com/cn/products/fusion/fusion-evaluation.html" target="_blank" rel="noopener"><strong>VMware Fusion</strong></a></p>
<p><a href="http://www.yulongjun.com/images/1495038151299.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182154.png" alt="img"></a></p>
<hr>
<h3 id="2-虚拟机分配的资源"><a href="#2-虚拟机分配的资源" class="headerlink" title="2. 虚拟机分配的资源"></a>2. 虚拟机分配的资源</h3><p>因为用的软件不一样，这里设置方法无法截图，但大至如下：</p>
<ul>
<li><code>2CPU</code>/<code>1G内存</code>/<code>200G硬盘</code></li>
<li>去掉打印机等没用的硬件（macOS要去掉打印机和摄像头）</li>
<li>光盘开始选择空白光盘，不要在这里选择iso安装，会有一个简易的自动安装，等完成设置后，再手动编辑设置改为iso镜像。同时勾选连接光盘和已连接。</li>
</ul>
<hr>
<h3 id="3-系统安装过程"><a href="#3-系统安装过程" class="headerlink" title="3. 系统安装过程"></a>3. 系统安装过程</h3><p>1、 加载光盘后，默认的选项是第二行：Test this media &amp; install CentOS Linux 7(测试媒介&amp;安装CentOS Linux 7)，按键盘<code>↑</code>选择<code>Install CentOS Linux7</code>（安装CentOS 7）</p>
<p><a href="http://www.yulongjun.com/images/1495038288314.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182207.png" alt="img"></a></p>
<p>2、 在安装过程中使用的语言，这里使用默认的英文</p>
<p><a href="http://www.yulongjun.com/images/1495038626655.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182207.png" alt="img"></a></p>
<p>3、 日期和时间<code>DATA &amp; TIME</code></p>
<p><a href="http://www.yulongjun.com/images/1495038829257.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182215.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495038842065.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182224.png" alt="img"></a></p>
<p>4、 软件选择<code>SOFTWARE SELECT</code></p>
<p><a href="http://www.yulongjun.com/images/1495038916632.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182236.png" alt="img"></a></p>
<p>这里选择<code>Sever with GUI</code>或者<code>GNOME Desktop</code></p>
<p><a href="http://www.yulongjun.com/images/1495038927742.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182236.png" alt="img"></a></p>
<p>5、 安装位置</p>
<p><a href="http://www.yulongjun.com/images/1495039087551.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182305.png" alt="img"></a></p>
<p>选择<code>I will configure partitioning</code>（我将会配置分区），然后<code>Done</code>进入分区页面</p>
<p><a href="http://www.yulongjun.com/images/1495039101917.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182328.png" alt="img"></a></p>
<p>默认分区方式为<code>lvm</code>，这里改为<code>Standard Partition</code>标准分区。</p>
<p>然后按<code>+</code>号开始划分分区</p>
<p><a href="http://www.yulongjun.com/images/1495039367994.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182322.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495039381664.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182345.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495039390480.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182350.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495039399903.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182405.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495039408723.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182357.png" alt="img"></a></p>
<p>点Done后，弹出变更摘要<code>Summary of changes</code>，点<code>Accept Changes</code></p>
<p><a href="http://www.yulongjun.com/images/1495039418544.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182431.png" alt="img"></a></p>
<p>6、 NETWORK &amp; HOSTNAME（网络和主机名）</p>
<p><a href="http://www.yulongjun.com/images/1495039626632.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182440.png" alt="img"></a></p>
<p>把网卡都打开</p>
<p><a href="http://www.yulongjun.com/images/1495039633678.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182445.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Host name&#96;自定义一下，然后点&#96;Apply<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/1495039643372.png" target="_blank" rel="noopener">![img](D:\MyMD\linux\CentOS 7 安装步骤.assets\1495039643372.png)</a></p>
<p>7、 设置结束，开始安装</p>
<p><a href="http://www.yulongjun.com/images/1495039857739.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182451.png" alt="img"></a></p>
<p>8、 安装过程中，设置下root密码，然后创建一个用户</p>
<p>设置root密码</p>
<p><a href="http://www.yulongjun.com/images/1495039920713.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182459.png" alt="img"></a></p>
<p>创建用户，勾选下作为管理员<code>Make this user Administrator</code></p>
<p><a href="http://www.yulongjun.com/images/1495039932277.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182508.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495039958670.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182519.png" alt="img"></a></p>
<p>9、 安装完后点重启</p>
<p><a href="http://www.yulongjun.com/images/1495040048433.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182533.png" alt="img"></a></p>
<p>10、 重启后，接受下协议</p>
<p><a href="http://www.yulongjun.com/images/1495040076222.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182541.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495040090888.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182547.png" alt="img"></a></p>
<p>11、 完成设置</p>
<p><a href="http://www.yulongjun.com/images/1495040107184.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182738.png" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/1495040137201.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182724.png" alt="img"></a></p>
<p>12、 <code>ifconfig</code>检查两个网卡是否都起来了，是否有ip地址分配，如果没有，可以<code>cat /etc/sysconfig/network-scripts/ifcfg-网卡名</code>，看看里面有一行<code>ONBOOT=no</code>(这条配置决定了开机是否启动网卡)，如果是<code>no</code>, 可以用<code>nano</code>或<code>gedit</code>或<code>vim</code>等工具来更改为<code>yes</code>，这样下次重启后就永久生效了，然后<code>ifup 网卡名</code>实时启动网卡（避免重启）。</p>
<p>13、关闭系统，拍一个快照。</p>
<p>关机位置在这：</p>
<p><a href="http://www.yulongjun.com/images/1495040200616.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182733.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>15-终端</title>
    <url>/15-%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200816182753.png" alt="image-20200814170010223"  />

<ul>
<li><p>设备终端</p>
<p>键盘、鼠标、显示器</p>
</li>
<li><p>物理终端（ /dev/console ）</p>
<p>控制台console</p>
</li>
<li><p>串行终端（ /dev/ttyS# ）</p>
<p>tty 可有n个，Ctrl+Alt+F#</p>
</li>
<li><p>虚拟终端(tty：teletypewriters， /dev/tty#</p>
<p>ty 可有n个，Ctrl+Alt+F#</p>
</li>
<li><p>图形终端（ /dev/tty7 ） startx, xwindows</p>
<p>CentOS 6: Ctrl + Alt + F7<br>CentOS 7: 在哪个终端启动，即位于哪个虚拟终端</p>
</li>
<li><p>伪终端（ pty：pseudo-tty ， /dev/pts/# ）</p>
<p>pty, SSH远程连接</p>
</li>
</ul>
<p>查看当前终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-variable">$tty</span>	查看当前终端<br>/dev/pts/0<br>[root@ashjian ~]<span class="hljs-variable">$who</span><br>root     pts/0        2020-08-14 17:02 (120.239.139.121)<br>[root@ashjian ~]<span class="hljs-variable">$w</span>	显示谁在登录在做什么事情<br> 17:08:01 up 89 days,  5:48,  1 user,  load average: 0.01, 0.05, 0.05<br>USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT<br>root     pts/0    120.239.139.121  17:02    1.00s  0.04s  0.00s w<br>														<span class="hljs-comment">#WHAT显示在执行的最新命令</span><br>[root@ashjian ~]<span class="hljs-variable">$whoami</span> 查看当前用户名<br>root<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>15美少女漂流記 OVA1</title>
    <url>/15%E7%BE%8E%E5%B0%91%E5%A5%B3%E6%BC%82%E6%B5%81%E8%A8%98%20OVA1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v211/211/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>里番</tag>
      </tags>
  </entry>
  <entry>
    <title>15美少女漂流記 OVA2</title>
    <url>/15%E7%BE%8E%E5%B0%91%E5%A5%B3%E6%BC%82%E6%B5%81%E8%A8%98%20OVA2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v211/212/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>里番</tag>
      </tags>
  </entry>
  <entry>
    <title>15美少女漂流記 OVA3</title>
    <url>/15%E7%BE%8E%E5%B0%91%E5%A5%B3%E6%BC%82%E6%B5%81%E8%A8%98%20OVA3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v211/213/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>里番</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：github的图片链接无法显示</title>
    <url>/BUG%EF%BC%9Agithub%E7%9A%84%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>​    我正在做用github做图床时，发现使用梯子时能正常访问raw.githubusercontent.com域下图片，下了梯子就无法访问该域了，所以怀疑是DNS的域名解析问题，搜索一下“找不到 raw.githubusercontent.com 的服务器 IP 地址”，给出的解决方案都是改hosts，以下是普遍的答案</p>
<blockquote>
<p>修改Hosts临时解决GitHub的raw.githubusercontent.com无法链接</p>
<p>通过IPAddress.com首页,输入raw.githubusercontent.com查询到真实IP地址<br>199.232.28.133<br>C:\Windows\System32\drivers\etc<br>hosts文件<br>添加 以下内容并保存即可恢复<br>199.232.28.133 raw.githubusercontent.com</p>
</blockquote>
<p>​    我按照这方法尝试，结果行不通，通过<a href="https://site.ip138.com/raw.githubusercontent.com/可以查询到raw.githubusercontent.com的美国地址就是199.232.28.133，本机ping该ip大概率会超时丢包，因此该ip是不可用了，要另找ip。" target="_blank" rel="noopener">https://site.ip138.com/raw.githubusercontent.com/可以查询到raw.githubusercontent.com的美国地址就是199.232.28.133，本机ping该ip大概率会超时丢包，因此该ip是不可用了，要另找ip。</a></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>C:\Windows\System32\drivers\etc\hosts</p>
<p>在文件末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># GitHub Start <br>140.82.113.3      github.com<br>140.82.114.20     gist.github.com<br> <br>151.101.184.133    assets-cdn.github.com<br>151.101.184.133    raw.githubusercontent.com<br>151.101.184.133    gist.githubusercontent.com<br>151.101.184.133    cloud.githubusercontent.com<br>151.101.184.133    camo.githubusercontent.com<br>151.101.184.133    avatars0.githubusercontent.com<br>199.232.68.133     avatars0.githubusercontent.com<br>199.232.28.133     avatars1.githubusercontent.com<br>151.101.184.133    avatars1.githubusercontent.com<br>151.101.184.133    avatars2.githubusercontent.com<br>199.232.28.133     avatars2.githubusercontent.com<br>151.101.184.133    avatars3.githubusercontent.com<br>199.232.68.133     avatars3.githubusercontent.com<br>151.101.184.133    avatars4.githubusercontent.com<br>199.232.68.133     avatars4.githubusercontent.com<br>151.101.184.133    avatars5.githubusercontent.com<br>199.232.68.133     avatars5.githubusercontent.com<br>151.101.184.133    avatars6.githubusercontent.com<br>199.232.68.133     avatars6.githubusercontent.com<br>151.101.184.133    avatars7.githubusercontent.com<br>199.232.68.133     avatars7.githubusercontent.com<br>151.101.184.133    avatars8.githubusercontent.com<br>199.232.68.133     avatars8.githubusercontent.com<br> <br># GitHub End<br></code></pre></td></tr></table></figure>

<p>然后保存文件就OK了。</p>
<p>至于无法保存，是因为没有修改权限。鼠标右键hosts文件-属性-安全-修改权限；或将hosts文件复制一份，修改之后，复制到原文件夹替换！</p>
<p>改完后能正常在访问了，但速度依然比不上梯子</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>图库</tag>
        <tag>github</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>CA认证和证书</title>
    <url>/CA%E8%AE%A4%E8%AF%81%E5%92%8C%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一些概念：</p>
<p><strong>PKI</strong>：Public Key Infrastructure</p>
<ul>
<li>签证机构：<strong>CA</strong>（Certificate Authority）</li>
<li>注册机构：<strong>RA</strong>（Register Authority）</li>
<li>证书吊销列表：<strong>CRL</strong>（Certificate Revoke Lists）</li>
<li>证书存取库</li>
</ul>
<p><strong>X.509</strong>：定义了证书的结构和认证协议的标准。包括版本号、序列号、签名算法、颁发者、有效期限、主体名称、主体公钥、CRL分发点、扩展信息、发行者签名等</p>
<p>获取证书的两种方法：</p>
<ul>
<li>使用证书授权机构<ul>
<li>生成签名请求（csr）</li>
<li>将csr发送给CA</li>
<li>从CA处接收签名</li>
</ul>
</li>
<li>自签名的证书<ul>
<li>自已签发自己的公钥</li>
</ul>
</li>
</ul>
<p>重点介绍一下自建CA颁发机构和自签名。</p>
<h2 id="自建CA颁发机构和自签名"><a href="#自建CA颁发机构和自签名" class="headerlink" title="自建CA颁发机构和自签名"></a>自建CA颁发机构和自签名</h2><p>实验用两台服务器，一台做ca颁发证书，一台去请求签名证书。</p>
<p>证书申请及签署步骤：</p>
<ol>
<li>生成申请请求</li>
<li>CA核验</li>
<li>CA签署</li>
<li>获取证书</li>
</ol>
<p>我们先看一下openssl的配置文件：<code>/etc/pki/tls/openssl.cnf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">####################################################################<br>[ ca ]<br>default_ca	&#x3D; CA_default		# The default ca section(默认的CA配置，是CA_default,下面第一个小节就是)<br><br>####################################################################<br>[ CA_default ]<br><br>dir		&#x3D; &#x2F;etc&#x2F;pki&#x2F;CA		# Where everything is kept （dir变量）<br>certs		&#x3D; $dir&#x2F;certs		# Where the issued certs are kept（认证证书目录）<br>crl_dir		&#x3D; $dir&#x2F;crl		# Where the issued crl are kept（注销证书目录）<br>database	&#x3D; $dir&#x2F;index.txt	# database index file.（数据库索引文件）<br>new_certs_dir	&#x3D; $dir&#x2F;newcerts		# default place for new certs.（新证书的默认位置）<br><br>certificate	&#x3D; $dir&#x2F;cacert.pem 	# The CA certificate（CA机构证书）<br>serial		&#x3D; $dir&#x2F;serial 		# The current serial number（当前序号，默认为空，可以指定从01开始）<br>crlnumber	&#x3D; $dir&#x2F;crlnumber	# the current crl number（下一个吊销证书序号）<br>					# must be commented out to leave a V1 CRL<br>crl		&#x3D; $dir&#x2F;crl.pem 		# The current CRL（下一个吊销证书）<br>private_key	&#x3D; $dir&#x2F;private&#x2F;cakey.pem# The private key（CA机构的私钥）<br>RANDFILE	&#x3D; $dir&#x2F;private&#x2F;.rand	# private random number file（随机数文件）<br><br>x509_extensions	&#x3D; usr_cert		# The extentions to add to the cert<br><br># Comment out the following two lines for the &quot;traditional&quot;<br># (and highly broken) format.<br>name_opt 	&#x3D; ca_default		# Subject Name options（被颁发者，订阅者选项）<br>cert_opt 	&#x3D; ca_default		# Certificate field options（认证字段参数）<br><br># Extension copying option: use with caution.<br># copy_extensions &#x3D; copy<br><br># Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs<br># so this is commented out by default to leave a V1 CRL.<br># crlnumber must also be commented out to leave a V1 CRL.<br># crl_extensions	&#x3D; crl_ext<br><br>default_days	&#x3D; 365			# how long to certify for （默认的有效期天数是365）<br>default_crl_days&#x3D; 30			# how long before next CRL<br>default_md	&#x3D; sha256		# use SHA-256 by default<br>preserve	&#x3D; no			# keep passed DN ordering<br><br># A few difference way of specifying how similar the request should look<br># For type CA, the listed attributes must be the same, and the optional<br># and supplied fields are just that :-)<br>policy		&#x3D; policy_match  # 是否匹配规则<br><br># For the CA policy<br>[ policy_match ]<br>countryName		&#x3D; match   # 国家名是否匹配，match为匹配<br>stateOrProvinceName	&#x3D; match  # 州或省名是否需要匹配<br>organizationName	&#x3D; match  # 组织名是否需要匹配<br>organizationalUnitName	&#x3D; optional # 组织的部门名字是否需要匹配<br>commonName		&#x3D; supplied # 注释<br>emailAddress		&#x3D; optional # 邮箱地址<br><br># For the &#39;anything&#39; policy<br># At this point in time, you must list all acceptable &#39;object&#39;<br># types.<br>[ policy_anything ]<br>countryName		&#x3D; optional<br>stateOrProvinceName	&#x3D; optional<br>localityName		&#x3D; optional<br>organizationName	&#x3D; optional<br>organizationalUnitName	&#x3D; optional<br>commonName		&#x3D; supplied<br>emailAddress		&#x3D; optional<br><br>####################################################################<br></code></pre></td></tr></table></figure>

<p>重点关注下面的几个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dir             &#x3D; &#x2F;etc&#x2F;pki&#x2F;CA           # Where everything is kept<br>certs           &#x3D; $dir&#x2F;certs            # Where the issued certs are kept<br>database        &#x3D; $dir&#x2F;index.txt        # database index file.<br><br>new_certs_dir   &#x3D; $dir&#x2F;newcerts         # default place for new certs.<br><br>certificate     &#x3D; $dir&#x2F;cacert.pem       # The CA certificate<br>serial          &#x3D; $dir&#x2F;serial           # The current serial number<br><br>private_key     &#x3D; $dir&#x2F;private&#x2F;cakey.pem# The private key<br></code></pre></td></tr></table></figure>

<h3 id="1、创建所需要的文件"><a href="#1、创建所需要的文件" class="headerlink" title="1、创建所需要的文件"></a>1、创建所需要的文件</h3><p><code>touch /etc/pki/CA/index.txt</code> 生成证书索引数据库文件</p>
<p><code>echo 01 &gt; /etc/pki/CA/serial</code> 指定第一个颁发证书的序列号,16进制数，比如可以从1a开始，一般从01开始。</p>
<h3 id="2、CA自签证书"><a href="#2、CA自签证书" class="headerlink" title="2、CA自签证书"></a>2、CA自签证书</h3><p>在作为CA的服务器上操作：</p>
<ul>
<li>生成私钥</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(umask 066;openssl genrsa -out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;private&#x2F;cakey.pem 4096)<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15001084061870.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827212655.jpg" alt="img"></a></p>
<ul>
<li>生成自签名证书</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl req -new -x509 -key &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;private&#x2F;cakey.pem -days 7300 -out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;cacert.pem<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15001090547814.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827212709.jpg" alt="img"></a></p>
<blockquote>
<p><strong>参数解析：</strong></p>
<ul>
<li><code>-new</code>: 生成新证书签署请求</li>
<li><code>-x509</code>: 专用于CA生成自签证书</li>
<li><code>-key</code>: 生成请求时用到的私钥文件</li>
<li><code>-days n</code>：证书的有效期限</li>
<li><code>-out /PATH/TO/SOMECERTFILE</code>: 证书的保存路径</li>
</ul>
</blockquote>
<h3 id="3、颁发证书"><a href="#3、颁发证书" class="headerlink" title="3、颁发证书"></a>3、颁发证书</h3><ul>
<li>在需要使用证书的主机生成证书请求。</li>
</ul>
<p>比如给一台作为博客web服务的服务器生成私钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(umask 066; openssl genrsa -out &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;private&#x2F;blog.key 4096)<br></code></pre></td></tr></table></figure>

<p>生成证书申请文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl req -new -key &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;private&#x2F;blog.key -days 3560 -out &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;blog.csr<br></code></pre></td></tr></table></figure>

<blockquote>
<p>和CA生成证书的区别是没有<code>-x509</code>参数，加了<code>-x509</code>就是CA自签名证书</p>
</blockquote>
<p><a href="http://www.yulongjun.com/images/15001110657183.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827212809.jpg" alt="img"></a></p>
<ul>
<li>将证书请求文件传输给CA</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">scp &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;blog.csr root@172.16.111.100:&#x2F;tmp&#x2F;<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15001098886969.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827212822.jpg" alt="img"></a></p>
<ul>
<li>CA签署证书，并将证书颁发给请求者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl ca -in &#x2F;tmp&#x2F;blog.csr –out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;certs&#x2F;blog.crt -days 365<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15001111456054.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827212646.jpg" alt="img"></a></p>
<blockquote>
<p>注意：默认国家，省，公司名称三项必须和CA一致</p>
</blockquote>
<ul>
<li>把<code>blog.crt</code>证书回传给申请者，申请者可以使用此证书。</li>
</ul>
<blockquote>
<p>证书可以放在网站里，比如tomacat服务有专门存放证书的地方，还有可能需要转化格式，此处使用方法暂略</p>
</blockquote>
<h3 id="4、吊销证书"><a href="#4、吊销证书" class="headerlink" title="4、吊销证书"></a>4、吊销证书</h3><ul>
<li>在客户端获取要吊销的证书的serial</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl x509 -in &#x2F;PATH&#x2F;FROM&#x2F;CERT_FILE -noout -serial -subject<br></code></pre></td></tr></table></figure>

<ul>
<li>在CA上，根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致，吊销证书：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl ca -revoke &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;newcerts&#x2F;SERIAL.pem<br></code></pre></td></tr></table></figure>

<ul>
<li>指定第一个吊销证书的编号</li>
</ul>
<blockquote>
<p>注意：这里只有在第一次更新证书吊销列表前，才需要执行指定编号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo 01 &gt; &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;crlnumber<br></code></pre></td></tr></table></figure>

<ul>
<li>更新证书吊销列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl ca -gencrl -out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;crl&#x2F;crl.pem<br></code></pre></td></tr></table></figure>

<ul>
<li>查看crl文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">openssl crl -in &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;crl&#x2F;crl.pem -noout -text<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>CA证书</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 6的系统启动流程</title>
    <url>/CentOS-6%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<a href="http://xsllqs.blog.51cto.com/2308669/1762422" target="_blank" rel="noopener">http://xsllqs.blog.51cto.com/2308669/1762422</a></p>
<h2 id="一、POST加电自检"><a href="#一、POST加电自检" class="headerlink" title="一、POST加电自检"></a>一、POST加电自检</h2><p>  按下电源后ROM芯片中的CMOS程序执行并检测CPU、内存等设备是否存在并正常运行，CMOS中的程序叫BIOS，可以设置硬盘接口，网卡声卡开关之类的简单设置。一般PC机主板上有一个纽扣电池，这个电池就是给ROM供电的，可以保证主板断电后BIOS的一些基本设置不会重置。</p>
<p>  下面是一个比较新的主板的BIOS，在老主板上一般只有英文不会有中文界面，老式主板只支持键盘操作不支持鼠标，现在很多新主板已经可以支持鼠标操作了。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827123046.png" alt="img"></p>
<h2 id="二、引导加载次序Boot-Sequence"><a href="#二、引导加载次序Boot-Sequence" class="headerlink" title="二、引导加载次序Boot Sequence"></a>二、引导加载次序Boot Sequence</h2><p>  在系统启动前计算机是不知道你系统在哪里的，需要按照设备启动顺序<strong>一次查找引导加载器器bootloader</strong>，这个查找次序可以自己在BIOS中设定，一般在boot选项中设置，【注意】不同厂商不同版本的主板设置方法是不同的，请以厂商的官方说明为准。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827123059.png" alt="img"></p>
<h2 id="三、引导加载器bootloader"><a href="#三、引导加载器bootloader" class="headerlink" title="三、引导加载器bootloader"></a>三、引导加载器bootloader</h2><p>  前面说了系计算机是不知道系统在哪里的，所以需要程序进行引导，这个引导的程序就叫bootloader，不同操作系统的bootloader是不同的，windows使用的<strong>bootloader程序是ntloader</strong>，只能对windows进行引导不能对其他系统进行引导，而<strong>Linux的bootloader叫GRUB</strong>，可以对其他操作系统进行引导（包括windows），正是因为这样，所以<strong>在装既有Windows又有Linux的双系统的时候，需要先装Windows，再装Linux</strong>。</p>
<p>功能：提供一个菜单，允许用户选择要启动系统或不同的内核版本；把用户选定的内核装载到内存中的特定空间中，解压、展开，并把系统控制权移交给内核。</p>
<p> bootloader的引导程序GRUB放在MBR中。</p>
<h2 id="四、引导加载器程序GRUB"><a href="#四、引导加载器程序GRUB" class="headerlink" title="四、引导加载器程序GRUB"></a>四、引导加载器程序GRUB</h2><h3 id="1、grub-legacy"><a href="#1、grub-legacy" class="headerlink" title="1、grub legacy"></a>1、grub legacy</h3><p>  前面提到GRUB是bootloader阶段的一个程序，这是Centos中最常用的引导程序，CentOS 6安装的是grub legacy</p>
<p>  下面是CentOS 6的grub legacy</p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827131109.png" alt="img"></p>
<p>按e:进入编辑模式，用于编辑菜单；</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827131109.png" alt="img"></p>
<p> 然后按c: 进入命令模式，交互式接口；</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827131121.png" alt="img"></p>
<p>常用的命令有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#help: 获取帮助列表<br>#help KEYWORD: 详细帮助信息<br>#find (hd#,#)&#x2F;PATH&#x2F;TO&#x2F;SOMEFILE：<br>#root (hd#,#)设定grub的根设备<br>#kernel &#x2F;PATH&#x2F;TO&#x2F;KERNEL_FILE: 设定本次启动时用到的内核文件；额外还可以添加许多内核支持使用的cmdline参数；<br>#例如：init&#x3D;&#x2F;path&#x2F;to&#x2F;init, selinux&#x3D;0<br>#initrd &#x2F;PATH&#x2F;TO&#x2F;INITRAMFS_FILE: 设定为选定的内核提供额外文件的ramdisk；<br>#boot: 引导启动选定的内核；<br></code></pre></td></tr></table></figure>

<p>CentOS 6中grub的配置文件保存在/boot/grub/grub.conf中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim grub.conf<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># grub.conf generated by anaconda<br>#<br># Note that you do not have to rerun grub after making changes to this file<br># NOTICE: You have a &#x2F;boot partition. This means that<br>#     all kernel and initrd paths are relative to &#x2F;boot&#x2F;, eg.<br>#     root (hd0,0)<br>#     kernel &#x2F;vmlinuz-version ro root&#x3D;&#x2F;dev&#x2F;mapper&#x2F;VolGroup-lv_root<br>#     initrd &#x2F;initrd-[generic-]version.img<br>#boot&#x3D;&#x2F;dev&#x2F;sda<br>default&#x3D;0<br>timeout&#x3D;5<br>splashimage&#x3D;(hd0,0)&#96;&#96;&#x2F;grub&#x2F;splash&#96;&#96;.xpm.gz<br>hiddenmenu<br>title CentOS (2.6.32-431.el6.x86_64)<br>    &#96;&#96;root (hd0,0)<br>    &#96;&#96;kernel &#96;&#96;&#x2F;vmlinuz-2&#96;&#96;.6.32-431.el6.x86_64 ro root&#x3D;&#96;&#96;&#x2F;dev&#x2F;mapper&#x2F;VolGroup-lv_root&#96; &#96;rd_NO_LUKS rd_NO_MD rd_LVM_LV&#x3D;VolGroup&#96;&#96;&#x2F;lv_swap&#96; &#96;crashkernel&#x3D;auto LANG&#x3D;zh_CN.UTF-8 rd_LVM_LV&#x3D;VolGroup&#96;&#96;&#x2F;lv_root&#96; &#96;KEYBOARDTYPE&#x3D;pc KEYTABLE&#x3D;us rd_NO_DM rhgb quiet<br>    &#96;&#96;initrd &#96;&#96;&#x2F;initramfs-2&#96;&#96;.6.32-431.el6.x86_64.img<br></code></pre></td></tr></table></figure>

<p> 其中常用的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">default&#x3D;&#96;&#96;#: 设定默认启动的菜单项；落单项(title)编号从0开始；<br>timeout&#x3D;&#96;&#96;#：指定菜单项等待选项选择的时长；<br>splashimage&#x3D;(hd&#96;&#96;#,#)&#x2F;PATH&#x2F;TO&#x2F;XPM_PIC_FILE：指明菜单背景图片文件路径；<br>hiddenmenu：隐藏菜单；<br>password [--md5] STRING: 菜单编辑认证；<br>title TITLE：定义菜单项“标题”, 可出现多次；<br>root (hd&#96;&#96;#,#)：grub查找stage2及kernel文件所在设备分区；为grub的“根”; <br>kernel &#96;&#96;&#x2F;PATH&#x2F;TO&#x2F;VMLINUZ_FILE&#96; &#96;[PARAMETERS]：启动的内核<br>initrd &#96;&#96;&#x2F;PATH&#x2F;TO&#x2F;INITRAMFS_FILE&#96;&#96;: 内核匹配的ramfs文件；<br>password --md5 STRING: 启动选定的内核或操作系统时进行认证；<br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2、GRUB2"><a href="#2、GRUB2" class="headerlink" title="2、GRUB2"></a>2、GRUB2</h3><p> CentOS 7上安装的是gurb2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost ~]&#96;&#96;# rpm -q grub2<br>grub2-2.02-0.34.el7.centos.x86_64<br></code></pre></td></tr></table></figure>

<p>下面是centos7的GRUB，如果什么都不选，在3秒后系统会进入默认设置的那一项系统。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827193002.png" alt="img"></p>
<p>按e进入GRUB编辑</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827193013.png" alt="img"></p>
<p>按ctrl+c进入命令行模式</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827193021.png" alt="img"></p>
<p>常用的命令行命令有下面这些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1. help<br>  &#96;&#96;查看命令用法，显示所有可用命令<br>  &#96;&#96;help search <br>  &#96;&#96;search 命令用法<br>2. &#96;&#96;ls<br>  &#96;&#96;列出当前的所有设备。如 (hd0) (hd0,1) (hd0,5) (hd1) (hd1,1) (hd1,2) .......<br>  &#96;&#96;ls&#96; &#96;-l<br>  &#96;&#96;详细列出当前的所有设备。对于分区，会显示其label及uuid。<br>  &#96;&#96;ls&#96; &#96;&#x2F;<br>  &#96;&#96;列出当前设为root的分区下的文件<br>  &#96;&#96;ls&#96; &#96;(hd1,1)&#x2F;<br>  &#96;&#96;列出(hd1,1)分区下文件<br>3. search<br>  &#96;&#96;search -f &#96;&#96;&#x2F;ntldr<br>  &#96;&#96;列出根目录里包含ntldr文件的分区，返回为分区号<br>  &#96;&#96;search -l LINUX<br>  &#96;&#96;搜索label是LINUX的分区。<br>  &#96;&#96;search --&#96;&#96;set&#96; &#96;-f &#96;&#96;&#x2F;ntldr<br>  &#96;&#96;搜索根目录包含ntldr文件的分区并设为root，注意如果多外分区含有ntldr文件，&#96;&#96;set&#96; &#96;失去作用<br>4. loopback<br>  &#96;&#96;loopback命令可用于建立回放设备，如<br>  &#96;&#96;loopback lo0 (hd1,1)&#96;&#96;&#x2F;abc&#96;&#96;.iso<br>  &#96;&#96;可以使用lo0设备来访问abc.iso里的内容，比如说，可以从abc.iso里的软盘映像中启动<br>  &#96;&#96;loopback lo0 (hd1,1)&#96;&#96;&#x2F;aa&#96;&#96;.iso<br>  &#96;&#96;linux (lo0)&#96;&#96;&#x2F;memdisk<br>  &#96;&#96;initrd (lo0)&#96;&#96;&#x2F;abc&#96;&#96;.img<br>  &#96;&#96;要删除某一回放设备，可以使用-d参数：<br>  &#96;&#96;loopback -d lo0<br>5. &#96;&#96;set<br>  &#96;&#96;使用&#96;&#96;set&#96;&#96;可以设置变量的值<br>  &#96;&#96;set&#96; &#96;root&#x3D;<br>  &#96;&#96;set&#96; &#96;timeout&#x3D;<br>  &#96;&#96;需要调用变量的值时，使用$&#123;AA&#125;，如&#96;&#96;set&#96; &#96;root&#x3D;(hd1,1)<br>  &#96;&#96;则$&#123;root&#125;&#x3D;(hd1,1)<br>6. pager<br>  &#96;&#96;分页显示。<br>  &#96;&#96;set&#96; &#96;pager&#x3D;1<br>  &#96;&#96;满页时暂停，按space继续<br>  &#96;&#96;set&#96; &#96;pager&#x3D;0<br>  &#96;&#96;取消分页<br>7. linux<br>  &#96;&#96;linux取代grub中的kernel<br></code></pre></td></tr></table></figure>

<p> CentOS 7的/boot/grub2/grub.conf官方建议是不要随便修改的，一般都是在grub.d文件下生成新的启动目录，再重新生成</p>
<p>默认启动的修改可通过/boot/grub2/grubenv文件修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost grub2]&#96;&#96;# vim grubenv<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># GRUB Environment Block<br>saved_entry&#x3D;CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)<br>#########################################################<br></code></pre></td></tr></table></figure>

<p>可以进入/etc/grub.d下查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost grub.d]&#96;&#96;# ls<br>00_header 01_users 20_linux_xen   30_os-prober 41_custom<br>00_tuned  10_linux 20_ppc_terminfo 40_custom   README<br></code></pre></td></tr></table></figure>

<p>进入README可以查看grub.d中文件的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost grub.d]&#96;&#96;# cat README<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">All executable files &#96;&#96;in&#96; &#96;this directory are processed &#96;&#96;in&#96; &#96;shell expansion order.<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#96;&#96;00_*: Reserved &#96;&#96;for&#96; &#96;00_header.<br>&#96;&#96;10_*: Native boot entries.<br>&#96;&#96;20_*: Third party apps (e.g. memtest86+).<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">The number namespace &#96;&#96;in&#96;&#96;-between is configurable by system installer and&#96;&#96;&#x2F;or<br>administrator. For example, you can add an entry to boot another OS as<br>01_otheros, 11_otheros, etc, depending on the position you want it to occupy &#96;&#96;in<br>the menu; and &#96;&#96;then&#96; &#96;adjust the default setting via &#96;&#96;&#x2F;etc&#x2F;default&#x2F;grub&#96;&#96;.<br>#00 _ *:为00 _header保留<br>#10 _ *:本机引导条目<br>#20 _ *:第三方应用程序(例如memtest86)<br></code></pre></td></tr></table></figure>

<h2 id="五、进入kernel"><a href="#五、进入kernel" class="headerlink" title="五、进入kernel"></a>五、进入kernel</h2><p>  在GRUB中选择对应的kernel进入，然后kernel会对自身进行初始化</p>
<p>  探测可识别到的所有硬件设备。</p>
<p>  加载硬件驱动程序。</p>
<p>  以只读方式挂载根文件系统。</p>
<p>  运行用户空间的第一个应用程序，在CentOS 6上是init，在CentOS 7上是Systemd</p>
<p>  内核组成部分：</p>
<p>​    kernel: 内核核心，一般为bzImage，通常在/boot目录下,名称为vmlinuz-VERSION-RELEASE；</p>
<p>​    kernel object: 内核对象，一般放置于/lib/modules/VERSION-RELEASE/</p>
<h2 id="六、运行init"><a href="#六、运行init" class="headerlink" title="六、运行init"></a>六、运行init</h2><p>  CentOS 6上init所在的位置是在/sbin/init，init共分为7个级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#0：关机<br>#1：单用户模式(root, 无须登录), single, 维护模式；<br>#2: 多用户模式，会启动网络功能，但不会启动NFS；维护模式；<br>#3：多用户模式，正常模式；文本界面；<br>#4：预留级别；可同3级别；<br>#5：多用户模式，正常模式；图形界面；<br>#6：重启<br></code></pre></td></tr></table></figure>

<p>例如你要关机可直接输入init 0进行关机操作</p>
<p>[root@localhost sbin]# init 0</p>
<p>如果要查看当前系统运行的init级别可使用runlevel或者who -r</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost sbin]&#96;&#96;# runlevel <br>N 5<br>[root@localhost sbin]&#96;&#96;# who -r<br>     &#96;&#96;运行级别 5 2016-04-10 18:25<br></code></pre></td></tr></table></figure>

<p>init的配置文件在/etc/inittab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost sbin]&#96;&#96;# vim &#x2F;etc&#x2F;inittab<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># inittab is only used by upstart for the default runlevel.<br>#<br># ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.<br>#<br># System initialization is started by &#x2F;etc&#x2F;init&#x2F;rcS.conf<br>#<br># Individual runlevels are started by &#x2F;etc&#x2F;init&#x2F;rc.conf<br>#<br># Ctrl-Alt-Delete is handled by &#x2F;etc&#x2F;init&#x2F;control-alt-delete.conf<br>#<br># Terminal gettys are handled by &#x2F;etc&#x2F;init&#x2F;tty.conf and &#x2F;etc&#x2F;init&#x2F;serial.conf,<br># with configuration in &#x2F;etc&#x2F;sysconfig&#x2F;init.<br>#<br># For information on how to write upstart event handlers, or how<br># upstart works, see init(5), init(8), and initctl(8).<br>#<br># Default runlevel. The runlevels used are:<br>#  0 - halt (Do NOT set initdefault to this)<br>#  1 - Single user mode<br>#  2 - Multiuser, without NFS (The same as 3, if you do not have networking)<br>#  3 - Full multiuser mode<br>#  4 - unused<br>#  5 - X11<br>#  6 - reboot (Do NOT set initdefault to this)<br># <br>id&#96;&#96;:5:initdefault:<br>#这里定义的默认运行级别为5<br></code></pre></td></tr></table></figure>

<p> 配置文件中的格式是：id:runlevel:action:process</p>
<p>  此配置文件每行定义一个级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">id&#96;&#96;：指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求&#96;&#96;id&#96;&#96;与&#96;&#96;tty&#96;&#96;的编号相同，否则getty程序将不能正常工作。<br>runlevel：init的系统运行级别<br>action：是用来定义后面process的运行方式，常用的有下面几种<br>    &#96;&#96;wait: 切换至此级别运行一次；<br>    &#96;&#96;respawn：此process终止，就重新启动之；<br>    &#96;&#96;initdefault：设定默认运行级别；process省略；<br>    &#96;&#96;sysinit：设定系统初始化方式，此处一般为指定&#96;&#96;&#x2F;etc&#x2F;rc&#96;&#96;.d&#96;&#96;&#x2F;rc&#96;&#96;.sysinit<br>process：为具体的执行程序，<br></code></pre></td></tr></table></figure>

<p> 例如设置为l0:5:wait:/etc/rc.d/rc 5</p>
<p>  /etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc /rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc 启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p>
<p>  /etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#K开头的文件：运行次序是数字越小，越先运行；数字越小的服务，通常为依赖到别的服务；关闭服务。<br>#S开头的文件：运行次序是数字越小，越先运行；数字越小的服务，通常为被依赖到的服务；启动服务。<br>[root@localhost rc5.d]&#96;&#96;# pwd<br>&#x2F;etc&#x2F;rc&#96;&#96;.d&#96;&#96;&#x2F;rc5&#96;&#96;.d<br></code></pre></td></tr></table></figure>

<p>![img](CentOS 6的系统启动流程.assets/854428-20160923172434059-1235638256.png)</p>
<h2 id="七、运行系统初始化脚本"><a href="#七、运行系统初始化脚本" class="headerlink" title="七、运行系统初始化脚本"></a>七、运行系统初始化脚本</h2><p>  系统初始化脚本对应的文件是/etc/rc.d/rc.sysinit</p>
<p>  大概就是这个样子，因为太长，省略了很多</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827194039.png" alt="img"></p>
<h2 id="八、启动系统服务"><a href="#八、启动系统服务" class="headerlink" title="八、启动系统服务"></a>八、启动系统服务</h2><p>  centos6下的系统服务脚本都放在/etc/rc.d/init.d或者/etc/init.d中，可以看到两个文件中的内容是一样的,因为/etc/init.d链接到了/etc/rc.d/init.d中</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827200430.png" alt="img"></p>
<p>通过chkconfig命令可以查看什么系统级别下开启了哪些服务，以及添加服务到系统中并在指定级别下启动</p>
<p>  查看chkconfig –list</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827194525.png" alt="img"></p>
<p>添加chkconfig –add 服务名，在添加的时候需要将对应的服务放入/etc/init.d中，并在服务脚本中加入chkconfig: LLLL nn nn</p>
<p>  写到LLLL的init级别就是S的，没写得就是K的，第一个nn代表S的数字，第二个nn代表K的数字</p>
<p>[root@localhost init.d]# chkconfig –add httpd</p>
<p>删除chkconfig –del 服务名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@localhost init.d]&#96;&#96;# chkconfig --del httpd<br></code></pre></td></tr></table></figure>

<p>【注意】：正常级别下，最后启动一个服务S99local没有链接至/etc/rc.d/init.d一个服务脚本，而是指向了/etc/rc.d/rc.local脚本；因此，不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录，且又想开机时自动运行的命令，可直接放置于/etc/rc.d/rc.local文件中。</p>
<h2 id="九、打印登录提示符"><a href="#九、打印登录提示符" class="headerlink" title="九、打印登录提示符"></a>九、打印登录提示符</h2><p>  系统在启动完服务后会打印登录提示符，然后输入账号密码，进入对应的命令行界面或图形界面。</p>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>  系统的启动流程总的来说分成以下几个步骤：</p>
<p>  1、加电自检</p>
<p>  2、按照BIOS中设置的Boot Sequence查找有bootloader程序的设备</p>
<p>  3、加载MBR中的bootloader程序GRUB</p>
<p>  4、进入GRUB设置的默认kernel</p>
<p>  5、kernel初始化</p>
<p>  6、运行init程序</p>
<p>  7、运行系统初始化脚本</p>
<p>  8、启动对应服务</p>
<p>  9、打印登录提示符</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>启动流程</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6网络命令</title>
    <url>/CentOS6%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/14985786600754.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215548.jpg" alt="img"></a></p>
<ul>
<li>ifconfig</li>
<li>route</li>
<li>netstat</li>
<li>ss</li>
<li>setup</li>
<li>ip {link, addr, route}</li>
</ul>
<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ifconfig  # 查看所有网卡信息<br>ifconfig eth1 #查看eth1的网卡信息<br>ifconfig eth1 172.17.111.100&#x2F;16 # 临时设置ip<br></code></pre></td></tr></table></figure>

<h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">route -n&#96; : 查看路由<br>&#96;route add [-net|-host] target [netmask Nm] [gw Gw][[dev] Interface]<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 主机<br>route add -host 192.168.1.3 gw 172.16.0.1 dev eth0<br># 网段<br>route add -net 192.168.0.0&#x2F;24 gw 172.16.0.1 dev eth0<br></code></pre></td></tr></table></figure>

<p>添加默认路由，默认路由即默认网关：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 第一种写法：<br>route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1<br># 简单写法：<br>route add default gw 172.16.0.1<br></code></pre></td></tr></table></figure>

<p>删除路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">route del -host 192.168.1.3<br>route del -net 192.168.0.0&#x2F;24<br></code></pre></td></tr></table></figure>

<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>常用参数：</p>
<ul>
<li><code>-t</code>: tcp协议相关</li>
<li><code>-u</code>: udp协议相关</li>
<li><code>-a</code>: 所有状态</li>
<li><code>-n</code>: 以数字显示IP和端口</li>
<li><code>-l</code>: 处于监听状态</li>
<li><code>-p</code>: 显示相关进程及PID</li>
</ul>
<p>显示接口统计数据：</p>
<p><code>netstat -i</code>: 显示所有接口统计数据<br><code>netstat –I=IFACE</code>或者<code>netstat -Ixxxx</code>: 显示单个接口的统计数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">watch -n1 netstat -Ieth0<br></code></pre></td></tr></table></figure>

<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>新的ss效率更高，用法和netstat差不多。</p>
<p>有一些高级用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ss -o state established &#39;( dport &#x3D; :ssh or sport &#x3D; :ssh )&#39; # 显示所有已建立的ssh连接<br><br>ss -o state established &#39;( dport &#x3D; :http or sport &#x3D; :http )&#39; # 显示所有已建立的HTTP连接<br></code></pre></td></tr></table></figure>

<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p><code>setup</code>可以打开TUI（Text-based User Interface）基于文本的交互式界面。可以配置网络（Network configuration），配置防火墙(Firewall configuration)，启用关闭系统服务（System services）等等。</p>
<p><a href="http://www.yulongjun.com/images/14985325003094.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215801.jpg" alt="img"></a></p>
<h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>以前用的不多的新命令，很好很强大的命令。主要用到3个子命令 <code>ip link</code>、<code>ip addr</code>、<code>ip route</code></p>
<h3 id="ip-link"><a href="#ip-link" class="headerlink" title="ip link"></a>ip link</h3><p><code>ip link show [IFNAME]</code> ：显示网卡mac信息（link，链路层），不加网卡名就是全部，加上就是显示单个网卡的mac信息。<br><code>ip link set up/down</code>：设置网卡启用或关闭，在物理层禁止。</p>
<h3 id="ip-addr"><a href="#ip-addr" class="headerlink" title="ip addr"></a>ip addr</h3><p><code>ip addr show [IFNAME]</code>：显示网卡ip信息，不加网卡名就是全部，加上就是显示单个网卡的ip信息。<br><code>ip addr add xxx.xxx.xxx.xxx/xx dev IFNAME label IFNAME:LABELNAME</code>：临时添加ip。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip addr add 192.168.100.100&#x2F;24 dev eth1 label eth1:tmp-net<br></code></pre></td></tr></table></figure>

<p><code>ip addr del xxx.xxx.xxx.xxx/xx dev IFNAME</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip addr del 192.168.100.100&#x2F;24 dev eth1<br></code></pre></td></tr></table></figure>

<p><code>ip addr flush IFNAME</code>：清楚网卡上所有ip地址，连非临时的都删掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip addr flush eth1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips: 重启机器或者网络服务，所有临时添加的ip会消失。</p>
</blockquote>
<h2 id="ip-route"><a href="#ip-route" class="headerlink" title="ip route"></a>ip route</h2><p><code>ip route add TARGET via gw</code> 添加路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip route add 192.168.0.0&#x2F;24 via 172.16.0.1<br>ip route add 192.168.1.13 via 172.16.0.1<br></code></pre></td></tr></table></figure>

<p><code>ip route delete TARGET</code> 删除路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip route delete 192.168.0.0&#x2F;24<br>ip route delete 192.168.1.13<br></code></pre></td></tr></table></figure>

<p><code>ip route show|list</code> 显示路由<br><code>ip route flush dev IFACE</code>清空路由表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip route flush dev eth1<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6网络配置</title>
    <url>/CentOS6%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="etc-sysconfig-network-scripts-ifcfg-xxx"><a href="#etc-sysconfig-network-scripts-ifcfg-xxx" class="headerlink" title="/etc/sysconfig/network-scripts/ifcfg-xxx"></a><code>/etc/sysconfig/network-scripts/ifcfg-xxx</code></h2><p>ip、mask、gateway、dns相关配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">NAME&#x3D;xxx<br>DEVICE&#x3D;XXX<br>ONBOOT&#x3D;yes<br>BOOTPROTO&#x3D;dhcp&#x2F;none #dhcp还是静态，不写就是手工指定。<br>IPADDR&#x3D;xx.xx.xx.xx # ip地址<br>PREFIX&#x3D;xx # 掩码，新格式<br># NETMASK&#x3D;xxx.xxx.xxx.xxx # 掩码，旧格式<br>DNS1&#x3D;xxx.xxx.xxx.xxx<br>DNS2&#x3D;xxx.xxx.xxx.xxx<br>HWADDR&#x3D;xx:xx:xx:xx:xx:xx # 硬件MAC地址<br>MACADDR&#x3D;yy:yy:yy:yy:yy:yy # 手动修改MAC地址，要用MACADDR，而不能用HWADDR<br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DEVICE&#x3D;eth0<br>NAME&#x3D;eth0<br>IPADDR&#x3D;192.168.100.100<br>PREFIX&#x3D;24<br>GATEWAY&#x3D;192.168.100.254<br>DNS1&#x3D;223.5.5.5<br></code></pre></td></tr></table></figure>

<p><code>NetworkManager</code>服务会在你修改完文件后，自动生成 <code>/etc/resolv.conf</code>，这个就是DNS地址。</p>
<h2 id="etc-resolv-conf"><a href="#etc-resolv-conf" class="headerlink" title="/etc/resolv.conf"></a><code>/etc/resolv.conf</code></h2><p>DNS和DOMAIN相关的配置文件。通常不用管，会自动生成。</p>
<p>DOMAIN是搜索域<br><code>DOMAIN yulongjun.com</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ping www&#96;就是&#96;ping www.yulongjun.com<br></code></pre></td></tr></table></figure>

<h2 id="etc-sysconfig-network"><a href="#etc-sysconfig-network" class="headerlink" title="/etc/sysconfig/network"></a><code>/etc/sysconfig/network</code></h2><p>主机名配置文件</p>
<h2 id="etc-hosts"><a href="#etc-hosts" class="headerlink" title="/etc/hosts"></a><code>/etc/hosts</code></h2><p>本地的域名解析，优先解析hosts里定义的域名，然后没有才会去DNS里查。</p>
<blockquote>
<p>tips：如果要修改顺序，可以更改<code>/etc/nsswitch</code>文件里的内容：<br><code>hosts: file dns</code> –&gt; <code>hosts: dns file</code><br>可以先使用dns，后使用/etc/hosts文件。</p>
</blockquote>
<h2 id="vim-ifcfg-IFNAME-xxx"><a href="#vim-ifcfg-IFNAME-xxx" class="headerlink" title="vim ifcfg-IFNAME:xxx"></a><code>vim ifcfg-IFNAME:xxx</code></h2><p>给网卡设置另外一个地址，指定label设备名为<code>网卡名:xxx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DEVICE&#x3D;eth1:office<br>BOOTPROTO&#x3D;none<br>IPADDR&#x3D;5.5.5.5<br>PREFIX&#x3D;24<br></code></pre></td></tr></table></figure>

<p>在实现一个网卡获取两个ip地址，一个dhcp自动获取，一个固定ip的时候，要注意，dhcp要先配置，然后新增的设为固定ip。</p>
<p>例如更改ifcfg-eth1里面的参数为dhcp模式，ifcfg-eth1:2里的参数为固定ip模式。</p>
<p>如果顺序反过来，会有问题。</p>
<h2 id="etc-sysconfig-network-scripts-route-IFNAME"><a href="#etc-sysconfig-network-scripts-route-IFNAME" class="headerlink" title="/etc/sysconfig/network-scripts/route-IFNAME"></a><code>/etc/sysconfig/network-scripts/route-IFNAME</code></h2><p>路由配置文件，永久生效。需要重启网络服务后才能生效。</p>
<p>两种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">TARGET via GW&#96;<br>如：&#96;10.0.0.0&#x2F;8 via 172.16.0.1<br></code></pre></td></tr></table></figure>

<p>每三行定义一条路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ADDRESSXXX&#x3D;TARGET<br>NETMASKXXX&#x3D;mask<br>GATEWAYXXX&#x3D;GW<br></code></pre></td></tr></table></figure>

<p><code>XXX</code>是数字，一般从1开始写</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7网络配置</title>
    <url>/CentOS7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>把网卡命名方式改为传统eth方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;boot&#x2F;grub2&#x2F;grub.cfg&#96; linux16那行，最后添加&#96;net.ifnames&#x3D;0<br></code></pre></td></tr></table></figure>

<h2 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h2><p><code>hostnamectl status</code><br><code>hostnamectl set-hostname xxxxx</code>：更改主机名，同时写到<code>/etc/hostname</code>配置文件里。</p>
<blockquote>
<p>tips：记得也改下/etc/hosts里，最后加上新加的主机名</p>
</blockquote>
<h2 id="nmcli"><a href="#nmcli" class="headerlink" title="nmcli"></a>nmcli</h2><p>修改连接名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli connection modify enp0s25 connection.id eth0<br></code></pre></td></tr></table></figure>

<p>添加一条新的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli connection add con-name eth1-lan type ethernet ifname eth1<br>nmcli connection modify eth0 xxxx.xxxx xxxx<br></code></pre></td></tr></table></figure>

<p>xxxx.xxxx xxxx指的是：<br><code>connection.autoconnect yes</code><br><code>ipv4.method manual/auto</code><br><code>ipv4.addresses xxx.xxx.xxx.xxx</code><br><code>ipv4.gateway xxx.xxx.xxx.xxx</code></p>
<p>重启连接：<br><code>nmcli connection reload</code></p>
<p>还有其他的：</p>
<p><a href="http://www.yulongjun.com/images/14986159472266.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826223743.jpg" alt="img"></a></p>
<p>对应关系：</p>
<p><a href="http://www.yulongjun.com/images/14986187124078.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826224225.jpg" alt="img"></a></p>
<p>去掉ip连接，不down设备：<br><code>nmcli dev disconnect</code></p>
<h2 id="nmtui"><a href="#nmtui" class="headerlink" title="nmtui"></a>nmtui</h2><p>字符界面：</p>
<p>编辑连接、激活连接、设置主机名<br><a href="http://www.yulongjun.com/images/14986188370055.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826224216.jpg" alt="img"></a></p>
<h2 id="bond"><a href="#bond" class="headerlink" title="bond"></a>bond</h2><p>bond也可以用bond来作</p>
<ul>
<li>添加bonding接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con add type bond con-name mybond0 ifname mybond0 mode active-backup<br></code></pre></td></tr></table></figure>

<ul>
<li>添加从属接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con add type bond-slave ifname ens7 master mybond0<br><br>nmcli con add type bond-slave ifname ens3 master mybond0<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：如无为从属接口提供连接名，则该名称是接口名称加类型构成</p>
</blockquote>
<ul>
<li>要启动绑定，则必须首先启动从属接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con up bond-slave-ens7<br><br>nmcli con up bond-slave-ens3<br></code></pre></td></tr></table></figure>

<ul>
<li>启动绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con up mybond0<br></code></pre></td></tr></table></figure>

<ul>
<li>down掉,并删除bond</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli connect down mybond0<br>nmcli connect del mybond0<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobbler——无人值守安装多种版本多种配置操作系统</title>
    <url>/Cobbler%E2%80%94%E2%80%94%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E5%A4%9A%E7%A7%8D%E7%89%88%E6%9C%AC%E5%A4%9A%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Cobbler官网地址：<a href="http://www.yulongjun.com/linux/20170722-cobbler/cobbler.github.io" target="_blank" rel="noopener">cobbler.github.io</a></p>
<p>Cobbler是一个Linux安装服务器，它能实现网络安装环境下的快速安装。</p>
<p>Cobbler是基于Python研发的。</p>
<p>我们可能经常遇到这种情况，需要大规模的安装Linux操作系统（几百上千台），不同版本的操作系统，同一版本又有不同配置，用Cobbler就可以搞定。</p>
<p>Cobber基于DHCP、PXE、TFTP、HTTP、Kickstart的技术，来提供统一的对外服务，另外还有Cobbler Web界面，不过Cobbler CLI已经满足大部分人需求，本节Cobbler Web不做研究，下节有个简单的Web实际用法。</p>
<p>另外Cobbler还可以作为一个本地yum仓库，利用reposync</p>
<h2 id="一、配置Cobbler"><a href="#一、配置Cobbler" class="headerlink" title="一、配置Cobbler"></a>一、配置Cobbler</h2><h3 id="1-主机信息"><a href="#1-主机信息" class="headerlink" title="1. 主机信息"></a>1. 主机信息</h3><p>虚拟机安装CentOS7，配置两个网卡。一个仅主机模式，关闭仅主机模式的dhcp服务（仅主机模式不影响其他网段的机器，做实验比较安全）；一个桥接模式，主要用来连外网下载Cobbler和Cobbler-Web安装包。</p>
<p>仅主机模式配置静态ip为<code>192.168.111.1</code>；桥接模式的ip用dhcp获取即可。</p>
<h3 id="2-配置阿里云的CentOS7和epel的yum源（比较快）"><a href="#2-配置阿里云的CentOS7和epel的yum源（比较快）" class="headerlink" title="2. 配置阿里云的CentOS7和epel的yum源（比较快）"></a>2. 配置阿里云的CentOS7和epel的yum源（比较快）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cd &#x2F;etc&#x2F;yum.repos.d&#x2F;<br>mkdir backup<br>mv *.repo backup<br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo<br>wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo<br></code></pre></td></tr></table></figure>

<h3 id="3-关闭SELinux和iptables"><a href="#3-关闭SELinux和iptables" class="headerlink" title="3. 关闭SELinux和iptables"></a>3. 关闭SELinux和iptables</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">setenforce 0<br>sed -i.bak &#39;s&#x2F;SELINUX&#x3D;enforcing&#x2F;SELINUX&#x3D;disabled&#x2F;g&#39; &#x2F;etc&#x2F;selinux&#x2F;config<br>systemctl stop firewalld<br>systemctl disable firewalld<br></code></pre></td></tr></table></figure>

<h3 id="4-安装dhcp、tftp、cobbler、cobbler-web-启动和启用服务"><a href="#4-安装dhcp、tftp、cobbler、cobbler-web-启动和启用服务" class="headerlink" title="4. 安装dhcp、tftp、cobbler、cobbler-web, 启动和启用服务"></a>4. 安装dhcp、tftp、cobbler、cobbler-web, 启动和启用服务</h3><p>yum安装cobbler的时候，除了<code>dhcp</code>和，其他依赖如<code>tftp-server</code>、<code>httpd</code>、<code>syslinux</code>(里面有<code>pxelinux.0</code>文件）等会自动安装，所以只要装<code>dhcp、cobbler、cobbler-web</code>就好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install cobbler cobbler-web  tftp-server dhcp<br>systemctl enable  httpd  cobblerd  dhcpd <br>systemctl start httpd cobblerd  dhcpd<br></code></pre></td></tr></table></figure>

<p>这里启动dhcpd会报错，是因为配置还没配置，不用管，忽略就行。</p>
<h3 id="5-更改配置文件"><a href="#5-更改配置文件" class="headerlink" title="5. 更改配置文件"></a>5. 更改配置文件</h3><p>配置文件路径：<code>/etc/cobbler/settings</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;etc&#x2F;cobbler&#x2F;settings&#123;,.bak&#125;<br>vim &#x2F;etc&#x2F;cobbler&#x2F;settings<br></code></pre></td></tr></table></figure>

<p>要更改的内容：</p>
<p><strong>(1) Default Encrypted Password</strong></p>
<p>默认为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">default_password_crypted: &quot;$1$bfI7WLZz$PxXetL97LkScqJFxnW7KS1&quot;<br></code></pre></td></tr></table></figure>

<p>但这个密码必须要更改，否则cobbler check会报错。</p>
<p>用<code>openssl passwd -1</code>命令来生成新的sha1sum加密密码，这里设置的密码是<code>cobbler1024</code>，加密后变成<code>$1$mq2YqFBn$um6u0ScNqnDHltdWGQSIj0</code>，把生成的密码覆盖原来的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># openssl passwd -1<br><br>Password: <br>Verifying - Password: <br>$1$mq2YqFBn$um6u0ScNqnDHltdWGQSIj0<br></code></pre></td></tr></table></figure>

<p><strong>(2) Server 和 Next_Server</strong></p>
<p><code>server</code>选项是指cobbler server的ip地址，这里要指定一个网卡的ip，实验环境里指的是仅主机模式的<code>192.168.111.1</code>。</p>
<p><code>next_server</code>选项被用在DHCP/PXE上，用来作为DHCP Server和TFTP Server的IP地址，一般和Cobbler服务地址使用一个IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># default, localhost<br>server: 192.168.111.1<br># default, localhost<br>next_server: 192.168.111.1<br></code></pre></td></tr></table></figure>

<p><strong>(3) DHCP Management 和 DHCP Server Template（模板）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">manage_dhcp&#96;，&#96;0&#96;更改为&#96;1<br># default, don&#39;t manage<br>manage_dhcp: 1<br></code></pre></td></tr></table></figure>

<h3 id="6-更改dhcp模板"><a href="#6-更改dhcp模板" class="headerlink" title="6. 更改dhcp模板"></a>6. 更改dhcp模板</h3><p>由于上一节更改<code>settings</code>里的<code>manage_dhcp</code>为<code>1</code>了，所以，<code>dhcpd</code>变成<code>cobblerd</code>来管理了。我们通过更改<code>/etc/cobbler/dhcp.template</code>，然后sync同步到<code>/etc/dhcp/dhcpd.conf</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;etc&#x2F;cobbler&#x2F;dhcp.template&#123;,.bak&#125;<br>vim &#x2F;etc&#x2F;cobbler&#x2F;dhcp.template<br></code></pre></td></tr></table></figure>

<p>修改模板里的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">subnet 192.168.111.0 netmask 255.255.255.0 &#123;<br>     option subnet-mask         255.255.255.0;<br>     range dynamic-bootp        192.168.111.100 192.168.111.200;<br>     default-lease-time         21600;<br>     max-lease-time             43200;<br>     next-server                $next_server;<br></code></pre></td></tr></table></figure>

<p>备份原来的<code>dhcpd.config</code>,然后用<code>cobbler sync</code>一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf&#123;,.bak&#125;<br>systemctl restart cobblerd<br>cobbler sync<br></code></pre></td></tr></table></figure>

<p>同步完后，这时候去查看一下<code>/etc/dhcp/dhcpd.conf</code>，内容已经被覆盖了,我们也可以看到注释里写的是被Cobbler管理的dhcpd.conf：<code>Cobbler managed dhcpd.conf file</code></p>
<p><a href="http://www.yulongjun.com/images/15007491663767.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160412.jpg" alt="img"></a></p>
<blockquote>
<p>警告：千万不要修改<code>next-server $next_server;</code>这行，不用改。配置是写在<code>#for dhcp_tag in $dhcp_tags.keys():</code>这行之前，不要写在最后。<br>如果想了解更多关于<code>dhcpd.conf</code>的信息，可以<code>man dhcpd.conf</code></p>
</blockquote>
<h3 id="7-同步配置，重启相关服务"><a href="#7-同步配置，重启相关服务" class="headerlink" title="7. 同步配置，重启相关服务"></a>7. 同步配置，重启相关服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cobbler sync<br></code></pre></td></tr></table></figure>

<h2 id="8-下载bootloader的加载程序"><a href="#8-下载bootloader的加载程序" class="headerlink" title="8. 下载bootloader的加载程序"></a>8. 下载bootloader的加载程序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cobbler get-loaders<br>cobbler sync<br></code></pre></td></tr></table></figure>

<h2 id="9-配置cobbler-web"><a href="#9-配置cobbler-web" class="headerlink" title="9. 配置cobbler-web"></a>9. 配置cobbler-web</h2><p>配置文件是<code>/etc/cobbler/modules.conf</code>。</p>
<p>修改cobbler web登录时候的的用户名和密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">htdigest &#x2F;etc&#x2F;cobbler&#x2F;users.digest &quot;Cobbler&quot; cobbler<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15007433651819.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160413.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl restart cobblerd<br>cobbler sync<br>systemctl restart httpd<br></code></pre></td></tr></table></figure>

<p>用修改过用户名密码登录测试：</p>
<p><a href="https://192.168.111.1/cobbler_web" target="_blank" rel="noopener">https://192.168.111.1/cobbler_web</a></p>
<p><a href="http://www.yulongjun.com/images/15007910699725.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160414.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/15007913591680.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160415.jpg" alt="img"></a></p>
<h2 id="二、cobbler使用指南"><a href="#二、cobbler使用指南" class="headerlink" title="二、cobbler使用指南"></a>二、cobbler使用指南</h2><h3 id="1-导入光盘"><a href="#1-导入光盘" class="headerlink" title="1. 导入光盘"></a>1. 导入光盘</h3><p><strong>(1)挂载光盘</strong><br>给虚拟机配置两个光盘，分别挂载CentOS6和CentOS7的光盘。<br>挂载光盘到目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir &#x2F;mnt&#x2F;centos6<br>mkdir &#x2F;mnt&#x2F;centos7<br>mount &#x2F;dev&#x2F;sr0 &#x2F;mnt&#x2F;centos6<br>mount &#x2F;dev&#x2F;sr1 &#x2F;mnt&#x2F;centos7<br></code></pre></td></tr></table></figure>

<p>如果是拷贝的iso文件到服务器，可以mount iso到目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir &#x2F;mnt&#x2F;centos6<br>mkdir &#x2F;mnt&#x2F;centos7<br>mount CentOS-6.9-x86_64-bin-DVD1.iso &#x2F;mnt&#x2F;centos6<br>mount CentOS-7-x86_64-Everything-1611.iso &#x2F;mnt&#x2F;centos7<br></code></pre></td></tr></table></figure>

<p><strong>(2)<code>cobbler import</code>导入光盘</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cobbler import --name&#x3D;CentOS6.9 --path&#x3D;&#x2F;mnt&#x2F;centos6 &amp;&amp; cobbler import --name&#x3D;CentOS7.3 --path&#x3D;&#x2F;mnt&#x2F;centos7<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15007962357847.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160416.jpg" alt="img"></a></p>
<p>如图我们可以看到，我们添加了两个发行版本到<code>distros</code>,也创建了两个<code>profile</code>(使用的是sample的ks文件），名字都是<code>CentOSx.x-x86_64</code>，是cobblerd自动侦测了是x86_64的版本，自动添加到上面<code>import</code>命令的<code>name</code>后面。</p>
<p>查看<code>distro/profile</code>对，这两个list目前显示应该是一样的。（后期增加不同配置的ks文件，生成不同的profile，就不一样了，还需要把profile默认的两个例子删掉）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cobbler distro list<br><br>cobbler profile list<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15007967696986.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160417.jpg" alt="img"></a></p>
<p>查看导入的发行版操作系统信息(<code>distro</code>)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 导入的发行版操作系统信息<br>cobbler distro report  # 全部<br>cobbler distro report --name&#x3D;CentOS6.9-x86_64 # 单独一个<br></code></pre></td></tr></table></figure>

<p>我们看到有两行信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Kickstart Metadata             : &#123;&#39;tree&#39;: &#39;http:&#x2F;&#x2F;@@http_server@@&#x2F;cblr&#x2F;links&#x2F;CentOS7.3-x86_64&#39;&#125;<br><br>Kickstart Metadata             : &#123;&#39;tree&#39;: &#39;http:&#x2F;&#x2F;@@http_server@@&#x2F;cblr&#x2F;links&#x2F;CentOS6.9-x86_64&#39;&#125;<br></code></pre></td></tr></table></figure>

<p>这两行就是你将来ks文件里写的安装url，后续在ks文件就采用这个地址作为源的地址。</p>
<p>ks文件如果原来是cdrom安装方式，把<code>cdrom</code>换成<code>url --url=http://xxxx</code>：</p>
<p>CentOS 6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">url --url&#x3D;http:&#x2F;&#x2F;192.168.111.1&#x2F;cblr&#x2F;links&#x2F;CentOS6.9-x86_64&#x2F;<br></code></pre></td></tr></table></figure>

<p>CentOS 7:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">url --url&#x3D;http:&#x2F;&#x2F;192.168.111.1&#x2F;cblr&#x2F;links&#x2F;CentOS7.3-x86_64&#x2F;<br></code></pre></td></tr></table></figure>

<h3 id="导入ks文件"><a href="#导入ks文件" class="headerlink" title="导入ks文件"></a>导入ks文件</h3><p>如果要自己制作，详见博文<a href="http://www.yulongjun.com/linux/20170720-kickstart-iso/" target="_blank" rel="noopener">自制kickstart光盘</a> 。</p>
<p>然后记得修改<code>cdrom</code>安装方式为<code>url --url=http://192.168.111.1/cblr/links/CentOSx.x-x86_64/</code>，x.x为你的上面写的系统版本。</p>
<blockquote>
<p>本人自制的cobbler的ks文件链接: <a href="http://pan.baidu.com/s/1i4BGeUh" target="_blank" rel="noopener">http://pan.baidu.com/s/1i4BGeUh</a><br>密码:0kfe</p>
</blockquote>
<p>如果有网友拿过来，记得更改url地址为自己cobbler的地址。</p>
<p>cobbler文件夹就是存放cobbler用的ks文件,分别对应6和7的最小化安装和开发包安装（其中手选了一些必要的包），包的话可以根据个人喜好自行更改:</p>
<p><a href="http://www.yulongjun.com/images/15007984000235.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160418.jpg" alt="img"></a></p>
<p>把这四个文件copy到cobbler服务器的<code>/var/lib/cobbler/kickstarts/</code>目录下</p>
<p><a href="http://www.yulongjun.com/images/15007988165162.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160419.jpg" alt="img"></a></p>
<p>这时候我们只是拷贝到目录里了，但是cobbler并没有对系统和ks文件做对应关系，我们用<code>cobbler profile report</code>（和<code>distro</code>命令一样，加<code>--name=xxx</code>可以查看具体单个的属性信息）可以看到kickstart的那一条属性只是一个例子而已：</p>
<p><a href="http://www.yulongjun.com/images/15007992070168.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160420.jpg" alt="img"></a></p>
<p>我们删掉例子，来重新添加新的kickstart文件对应关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cobbler profile remove --name&#x3D;&quot;CentOS6.9-x86_64&quot;<br>cobbler profile remove --name&#x3D;&quot;CentOS7.3-x86_64&quot;<br>cobbler profile add --name&#x3D;CentOS6.9-Devel--x86_64 --kickstart&#x3D;&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;kickstarts&#x2F;ks-centos6-devel.cfg --distro&#x3D;CentOS6.9-x86_64<br>cobbler profile add --name&#x3D;CentOS6.9-Mini-x86_64 --kickstart&#x3D;&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;kickstarts&#x2F;ks-centos6-mini.cfg --distro&#x3D;CentOS6.9-x86_64<br>cobbler profile add --name&#x3D;CentOS7.3-Devel-x86_64 --kickstart&#x3D;&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;kickstarts&#x2F;ks-centos7-devel.cfg --distro&#x3D;CentOS7.3-x86_64<br>cobbler profile add --name&#x3D;CentOS7.3-Mini-x86_64 --kickstart&#x3D;&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;kickstarts&#x2F;ks-centos7-mini.cfg --distro&#x3D;CentOS7.3-x86_64<br></code></pre></td></tr></table></figure>

<p>这时候我们去查看<code>pxelinux.cfg/default</code>文件就能看到菜单选项也跟着变了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@center tftpboot]# locate pxelinux.cfg&#x2F;default<br>&#x2F;var&#x2F;lib&#x2F;tftpboot&#x2F;pxelinux.cfg&#x2F;default<br>[root@center tftpboot]# cat &#x2F;var&#x2F;lib&#x2F;tftpboot&#x2F;pxelinux.cfg&#x2F;default<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15008005969755.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160421.jpg" alt="img"></a></p>
<p>重启cobblerd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl restart cobblerd<br>cobblerd sync<br></code></pre></td></tr></table></figure>

<h2 id="Cobbler自动化安装图示"><a href="#Cobbler自动化安装图示" class="headerlink" title="Cobbler自动化安装图示"></a>Cobbler自动化安装图示</h2><p>新增加一台虚机，和cobbler服务器在一个网段，打开运行，就会出现如下界面：</p>
<p><a href="http://www.yulongjun.com/images/15008129193050.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160422.jpg" alt="img"></a></p>
<p>好了，可以尽情的使用了，如果要添加新的版本，按照上面步骤添加就可以了。</p>
<h2 id="Cobbler-Web"><a href="#Cobbler-Web" class="headerlink" title="Cobbler Web"></a>Cobbler Web</h2><p>图形界面也能实现类似的导入功能，可以参见下一节举了一个Cobbler Web的用法：</p>
<p><a href="http://www.yulongjun.com/linux/20170722-cobbler-web/" target="_blank" rel="noopener">cobbler 添加网络同步仓库（Reposync用法)</a></p>
]]></content>
  </entry>
  <entry>
    <title>DHCP详解</title>
    <url>/DHCP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：</p>
<ul>
<li>用于内部网络或网络服务供应商自动分配IP地址给用户。</li>
<li>用于内部网络管理员作为对所有电脑作中央管理的手段。</li>
</ul>
<p>DHCP使用<strong>UDP</strong>协议，服务端的端口为<code>67</code>，客户端的端口为<code>68</code>。</p>
<h2 id="DHCP的服务过程"><a href="#DHCP的服务过程" class="headerlink" title="DHCP的服务过程"></a>DHCP的服务过程</h2><p>DHCP相关消息：</p>
<ul>
<li><strong>DHCP DISCOVER</strong>：客户端到服务器</li>
<li><strong>DHCP OFFER</strong> ：服务器到客户端</li>
<li><strong>DHCP REQUES</strong>：客户端到服务器</li>
<li><strong>DHCP ACK</strong> ：服务器到客户端</li>
<li><strong>DHCP NACK</strong>：服务器到客户端指示客户 端的网络地址的概念是不正确的</li>
<li><strong>DHCP DECLINE</strong> ：客户端到服务器，指 示地址已被使用</li>
<li><strong>DHCP RELEASE</strong>：客户端到服务器，放弃 网络地址和取消剩余的租约时间</li>
<li><strong>DHCP INFORM</strong>：客户端到服务器,只要 求本地配置参数，客户端已经具有外部配 置的网络地址</li>
</ul>
<p>主要用到前四个：</p>
<p><a href="http://www.yulongjun.com/images/DHCP_session.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203152515.svg" alt="img"></a></p>
<p>DHCP正常的运行分为四个基本过程，分别为：</p>
<ul>
<li><strong>DHCP发现（DISCOVER）</strong></li>
<li><strong>DHCP提供（OFFER）</strong></li>
<li><strong>DHCP请求（REQUEST）</strong></li>
<li><strong>DHCP确认（Acknowledge，ACK）</strong></li>
</ul>
<h2 id="租期"><a href="#租期" class="headerlink" title="租期"></a>租期</h2><p>DHCP使用了租约的概念，或称为计算机IP地址的有效期。租用时间是不定的，主要取决于用户在某地连接Internet需要多久。通过较短的租期，DHCP能够在一个计算机比可用IP地址多的环境中动态地重新配置网络。DHCP支持为计算机分配静态地址，可以自行手动指定。</p>
<p>客户在获得了一个IP地址以后，就可以发送一个ARP请求来避免由于DHCP服务器地址池重叠而引发的IP冲突。</p>
<p>租期一般为<strong>10分钟</strong>，在配置文件里可以更改。</p>
<ul>
<li><strong>50%</strong>：租赁时间达到50%时来续租，刚向DHCP服务器发向新的DHCPREQUEST请求。如果DHCP服务没有拒绝的理 由，则回应DHCPACK信息。当DHCP客户端收到该应答信 息后，就重新开始新的租用周期。</li>
<li><strong>87.5%</strong>：如果之前DHCP Server没有回应续租请求，等到 租约期的7/8时，主机会再发送一次广播请求</li>
</ul>
<h2 id="DHCP实现程序"><a href="#DHCP实现程序" class="headerlink" title="DHCP实现程序"></a>DHCP实现程序</h2><p>dhcpd服务，主要用到<code>dhcp</code>这个包(也有轻量级的的DNS+DHCP的包，叫<code>dnsmasq</code>。）</p>
<p>Client方面，系统默认安装了<code>dhclient</code>。</p>
<p><code>yum info dhcp</code>我们可以看到dhcp这个包是<a href="http://www.yulongjun.com/linux/20170722-01-dhcp/isc.org" target="_blank" rel="noopener">isc.org</a>这个组织开发的。</p>
<p>这个组织是开发<strong>DHCP</strong>和<strong>BIND</strong>（DNS软件）开源项目的组织。</p>
<h2 id="dhcpd主要配置"><a href="#dhcpd主要配置" class="headerlink" title="dhcpd主要配置"></a>dhcpd主要配置</h2><p>虚机配置仅主机模式，不对外服务，同时在网络编辑器里设置仅主机网络不提供dhcp服务（会跟配置的dhcp服务器冲突）。</p>
<p>安装dhcpd服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install dhcp<br></code></pre></td></tr></table></figure>

<p>我们需要先行配置dhcpd的配置文件，如果不配置，服务使起不来的。</p>
<p>dhcpd服务的配置文件<code>/etc/dhcp/dhcpd.conf</code></p>
<p>我们查看dhcpd.conf文件，发现只有这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#<br># DHCP Server Configuration file.<br>#   see &#x2F;usr&#x2F;share&#x2F;doc&#x2F;dhcp*&#x2F;dhcpd.conf.example<br>#   see dhcpd.conf(5) man page<br>#<br></code></pre></td></tr></table></figure>

<p>让我们去查看示例：<code>/usr/share/doc/dhcp*/dhcpd.conf.example</code><br>或者<code>man 5 dhcpd.conf</code>。</p>
<p>我们复制一份示例到配置下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cp &#x2F;usr&#x2F;share&#x2F;doc&#x2F;dhcp*&#x2F;dhcpd.conf.example &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf<br></code></pre></td></tr></table></figure>

<p>我们来看下面几个配置选项(更改过的），分别注释下意义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">## 全局网络的选项定义<br>option domain-name &quot;yulongjun.com&quot;;  <br>option domain-name-servers  223.5.5.5, 223.6.6.6;<br>option routers 192.168.111.1;<br>default-lease-time 600;<br>max-lease-time 7200;<br>## 局部网络的选项定义<br>subnet 192.168.111.0 netmask 255.255.255.0 &#123;<br>  range  192.168.111.100 192.168.111.200;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>`option domain-name “yulongjun.com”</strong><code>：搜索域，即search domain,网络中获取dhcp的服务器默认被设置的搜索域名。有什么作用呢？在我们ping的时候，</code>ping www<code>即是</code>ping <a href="http://www.yulongjun.com`，`ping" target="_blank" rel="noopener">www.yulongjun.com`，`ping</a> blog<code>即是</code>ping blog.yulongjun.com`。</li>
<li><strong><code>option routers 192.168.111.1</code></strong>：网关<br><code>option domain-name-servers 223.5.5.5, 223.6.6.6;</code>：DNS服务器，这里设置的<code>223.5.5.5，223.6.6.6</code>，阿里的dns服务器。</li>
<li><strong><code>default-lease-time 600;</code></strong>：默认租期时间。单位为秒。</li>
<li><strong><code>max-lease-time 7200;</code></strong>：最大租期时间。指的是客户端有请求长租期的时候，默认分配的时间。单位为秒。</li>
<li><strong><code>subnet</code></strong> 写网段的参数，包括range范围之类的，也可以自定义上述全局的那些参数（如domain-name、domain-name-server，router等），就变成这个网段的局部参数，只对这个网段生效。</li>
</ul>
<p>启动dhcpd服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start dhcpd<br></code></pre></td></tr></table></figure>

<p>另一台在同一个网段的服务器，如果网络是dhcp获取的，就可以获取range范围内的ip地址。</p>
<p>可以通过查看<code>/var/lib/dhclient/xxx-网卡名.lease</code>看到租期信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">lease &#123;<br>  interface &quot;ens192&quot;;<br>  fixed-address 192.168.111.100;<br>  option subnet-mask 255.255.255.0;<br>  option dhcp-lease-time 600;<br>  option dhcp-message-type 5;<br>  option dhcp-servers 223.5.5.5,223.6.6.6;<br>  option dhcp-server-identifier 192.168.111.1;<br>  renew 6 2017&#x2F;07&#x2F;22 01:46:30;<br>  rebind 6 2017&#x2F;07&#x2F;22 01:50:46;<br>  expire 6 2017&#x2F;07&#x2F;22 01:52:01;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>renew：续租时间（50%）<br>rebind：7/8时间，再询问的时间（87.5%）<br>expire：过期时间（100%）</p>
<p><code>dhclient -d</code>可以重新发个广播，来请求dhcpd服务。</p>
<p>我们发现还会使用旧的地址，除非你关机了，地址被回收了，那么就会使用新地址。</p>
<p>如果给多个网段提供服务，网关可以写到各个子网段里，而不是写到全局配置里。还有domain-name、domain-name-server，router等参数，也可以写到子网段里。如果全局和局部都有，优先使用局部的，如果没有定义，则使用全局的。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">## 全局网络的选项定义<br>option domain-name &quot;yulongjun.com&quot;;  <br>option domain-name-servers  223.5.5.5, 223.6.6.6;<br>option routers 192.168.111.1;<br>default-lease-time 600;<br>max-lease-time 7200;<br>## 局部网络的选项定义<br>subnet 192.168.111.0 netmask 255.255.255.0 &#123;<br>  range  192.168.111.100 192.168.111.200;<br>&#125;<br>subnet 192.168.222.0 netmask 255.255.255.0 &#123;<br>  range  192.168.222.100 192.168.222.200;<br>  option routers 192.168.222.1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>111网段没有定义局部的routers，所以使用全局的routers ，222网段由于定义了局部的routers，就使用局部的routers</p>
<h2 id="dhcpd其他配置"><a href="#dhcpd其他配置" class="headerlink" title="dhcpd其他配置"></a>dhcpd其他配置</h2><p><code>filename</code>: 指明引导文件名称<br><code>next-server</code>: 指明引导文件的服务器ip地址</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">subnet 192.168.111.0 netmask 255.255.255.0 &#123;<br>  range  192.168.111.100 192.168.111.200;<br>  filename &quot;pxelinux.0&quot;<br>  next-server 192.168.111.1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们制定了这两个文件，一个网络引导的有pxe服务的dhcp客户端，就可以通过tftp去拉取next-server上的filename指定的pxelinux.0文件。</p>
]]></content>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：出处：<a href="https://www.cnblogs.com/convict/p/10795320.html" target="_blank" rel="noopener">https://www.cnblogs.com/convict/p/10795320.html</a></p>
<p><strong>一、本地操作：</strong></p>
<p><strong>1.其它</strong></p>
<p>git init：初始化本地库</p>
<p>git status：查看工作区、暂存区的状态</p>
<p>git add <file name>：将工作区的“新建/修改”添加到暂存区</p>
<p>git rm –cached <file name>：移除暂存区的修改</p>
<p>git commit <file name>：将暂存区的内容提交到本地库</p>
<p>　　tip：需要再编辑提交日志，比较麻烦，建议用下面带参数的提交方法</p>
<p>git commit -m “提交日志” <file name>：文件从暂存区到本地库</p>
<p><strong>2.日志</strong></p>
<p>git log：查看历史提交</p>
<p>　　tip：空格向下翻页，b向上翻页，q退出</p>
<p>git log –pretty=oneline：以漂亮的一行显示，包含全部哈希索引值</p>
<p>git log –oneline：以简洁的一行显示，包含简洁哈希索引值</p>
<p>git reflog：以简洁的一行显示，包含简洁哈希索引值，同时显示移动到某个历史版本所需的步数</p>
<p><strong>3.版本控制</strong></p>
<p>git reset –hard 简洁/完整哈希索引值：回到指定哈希值所对应的版本</p>
<p>git reset –hard HEAD：强制工作区、暂存区、本地库为当前HEAD指针所在的版本</p>
<p>git reset –hard HEAD^：后退一个版本　　</p>
<p>　　tip：一个^表示回退一个版本</p>
<p>git reset –hard HEAD~1：后退一个版本</p>
<p>　　tip：波浪线~后面的数字表示后退几个版本</p>
<p><strong>4.比较差异</strong></p>
<p>git diff：比较工作区和暂存区的<strong>所有文件</strong>差异</p>
<p>git diff <file name>：比较工作区和暂存区的<strong>指定文件</strong>的差异</p>
<p>git diff HEAD|HEAD^|HEAD~|哈希索引值 <file name>：比较工作区跟本地库的某个版本的<strong>指定文件</strong>的差异</p>
<p><strong>5.分支操作</strong></p>
<p>git branch -v：查看所有分支</p>
<p>git branch -d &lt;分支名&gt;：删除本地分支</p>
<p>git branch &lt;分支名&gt;：新建分支</p>
<p>git checkout &lt;分支名&gt;：切换分支</p>
<p>git merge &lt;被合并分支名&gt;：合并分支</p>
<p>　　tip：如master分支合并 hot_fix分支，那么当前必须处于master分支上，然后执行 git merge hot_fix 命令</p>
<p>　　tip2：合并出现冲突</p>
<p>　　　　①删除git自动标记符号，如&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD、&gt;&gt;&gt;&gt;&gt;&gt;&gt;等</p>
<p>　　　　②修改到满意后，保存退出</p>
<p>　　　　③git add <file name></p>
<p>　　　　④git commit -m “日志信息”，此时后面不要带文件名</p>
<p><strong>二、本地库跟远程库交互：</strong></p>
<p>git clone &lt;远程库地址&gt;：克隆远程库</p>
<p>　　功能：①完整的克隆远程库为本地库，②为本地库新建origin别名，③初始化本地库</p>
<p>git remote -v：查看远程库地址别名</p>
<p>git remote add &lt;别名&gt; &lt;远程库地址&gt;：新建远程库地址别名</p>
<p>git remote rm &lt;别名&gt;：删除本地中远程库别名</p>
<p>git push &lt;别名&gt; &lt;分支名&gt;：本地库某个分支推送到远程库，分支必须指定</p>
<p>git pull &lt;别名&gt; &lt;分支名&gt;：把远程库的修改拉取到本地</p>
<p>　　tip：该命令包括git fetch，git merge</p>
<p>git fetch &lt;远程库别名&gt; &lt;远程库分支名&gt;：抓取远程库的指定分支到本地，但没有合并</p>
<p>git merge &lt;远程库别名/远程库分支名&gt;：将抓取下来的远程的分支，跟当前所在分支进行合并</p>
<p>git fork：复制远程库</p>
<p>　　tip：一般是外面团队的开发人员fork本团队项目，然后进行开发，之后外面团队发起pull request，然后本团队进行审核，如无问题本团队进行merge（合并）到团队自己的远程库，整个流程就是本团队跟外面团队的协同开发流程，Linux的团队开发成员即为这种工作方式。</p>
<p>借用网上的图</p>
<p><a href="https://img2018.cnblogs.com/blog/1301757/201904/1301757-20190430122157827-1697022748.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/1301757/201904/1301757-20190430122157827-1697022748.png" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>IO重定向和管道练习题</title>
    <url>/IO%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、将<code>/etc/issue</code>文件中的内容转换为大写后保存至<code>/tmp/issue.out</code>文件中</p>
<p><strong>答案</strong>（两种方法）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tr &#39;a-z&#39; &#39;A-Z&#39; &lt;  &#x2F;etc&#x2F;issue &gt; &#x2F;tmp&#x2F;issue<br><br>cat &#x2F;etc&#x2F;issue | tr &#39;a-z&#39; &#39;A-Z&#39;  &gt; &#x2F;tmp&#x2F;issue<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>第一种方法用的输入输出重定向，是把/<code>etc/issue</code>文件作为tr命令的输入，然后输出到<code>/tmp/issue</code>; 第二种方法是用的管道和输出重定向，把<code>cat</code>命令的输出，作为tr命令的输入，然后结果输出到<code>/tmp/issue</code></p>
</blockquote>
<hr>
<p>2、将当前系统登录用户的信息转换为大写后保存至<code>/tmp/who.out</code>文件中</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">who |tr &#39;a-z&#39; &#39;A-Z&#39; &gt; &#x2F;tmp&#x2F;who.out<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p><code>who</code>输出的登录信息，作为<code>tr</code>命令的输入，然后<code>tr</code>命令的输出重定向到<code>/tmp/who.txt</code>文件</p>
</blockquote>
<hr>
<p>3、一个linux用户给<code>root</code>发邮件，要求邮件标题为<code>”help”</code>，邮件正文如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Hello, I am 用户名,The system version is here,please help me to check it ,thanks!&#96;<br>&#96;操作系统版本信息<br></code></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat &lt;&lt;EOF | mail -s help root<br>&gt;Hello, I am $USER,The system version is here,please help me to check it ,thanks! <br>&gt;My OS is &#96;cat &#x2F;etc&#x2F;centos-release&#96;<br>&gt;My OS&#39;s Kernel is &#96;uname -a&#96;<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>先用<code>cat &lt;&lt;EOF</code>来把下面行的输入信息 输出出来，作为后面mail命令的输入。</p>
</blockquote>
<hr>
<p>4、将<code>/root/</code>下文件列表，显示成一行，并文件名之间用空格隔开</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls -1 |tr &#39;\n&#39; &#39; &#39;<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p><code>ls</code>显示所有文件行，用tr命令把尾部的<code>\n</code>替换成空格</p>
</blockquote>
<hr>
<p>5、计算<code>1+2+3+..+99+100</code>的总和</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo &#123;1..100&#125; |tr &#39; &#39; &#39;+&#39; |bc<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>echo输出100个数，然后把中间的空格转化为加号，然后再传给bc计算</p>
</blockquote>
<hr>
<p>6、删除Windows文本文件中的<code>‘^M’</code>字符</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat windows.txt |tr -d &quot;\r&quot;<br></code></pre></td></tr></table></figure>

<hr>
<p>7、处理字符串“<code>xt.,l 1 jr#!$mn 2 c*/fe 3 uz 4</code>”，只保留其中的数字 和空格</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo “xt.,l 1 jr#!$mn 2 c*&#x2F;fe 3 uz 4” | tr -d &quot;^0-9 &quot;<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>-d选项是delete的意思，^是非的意思，0=9是数字，后面跟一个空格，组合起来就是非数字和空格，然后-d删除</p>
</blockquote>
<hr>
<p>8、将<code>PATH</code>变量每个目录显示在独立的一行</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo $PATH | tr &quot;:&quot; &quot;\n&quot;<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>冒号转化为换行</p>
</blockquote>
<hr>
<p>9、将指定文件中<code>0-9</code>分别替代成<code>a-j</code></p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tr &quot;0-9&quot; &quot;a-j&quot; file<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>略</p>
</blockquote>
<hr>
<p>10、将文件中每个单词（由字母组成）显示在独立的一行，并无空行</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat 1.log |tr -c &#39;a-zA-Z&#39; &#39;\n&#39;<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<blockquote>
<p>cat命令的输出，作为tr命令的输入，-c选项是选择补集，即不是字母的单词</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>IO重定向</tag>
        <tag>管道</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS DR实验</title>
    <url>/LVS-DR%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/lvs-dr-wlc.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185823.svg" alt="img"></a></p>
<p>LVS/DR模式,数据流来的时候走VS，回去的时候调度到RS上，然后用VIP的作为源地址返回回去。</p>
<p>实验采用Vagrant配置网络和主机信息。Vagrant的用法可参考<a href="http://www.yulongjun.com/linux/20170811-vagrant/" target="_blank" rel="noopener">Vagrant–快速搭建实验环境利器</a>。</p>
<p><code>Vagrantfile</code>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Vagrant.configure(&quot;2&quot;) do |config|<br>  # config为全局配置文件<br>  config.vm.box &#x3D; &quot;longdream&#x2F;centos7&quot;     # 这里是我自定义的centos7模板<br>  config.hostmanager.enabled &#x3D; true       # 启用hostmanager插件<br>  config.hostmanager.manage_guest &#x3D; true  # 允许更新虚拟机上的hosts文件<br>  config.hostmanager.manage_host &#x3D; true   # 允许更新主机上的hosts文件<br><br>  # 定义Client<br>  config.vm.define &quot;client&quot; do |client|<br>    client.vm.network &quot;private_network&quot;, ip: &quot;172.16.111.123&quot;<br>    client.vm.hostname &#x3D; &quot;client&quot;<br>    client.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;client.sh&quot;<br>  end<br><br>  # 定义Router<br>  config.vm.define &quot;router&quot; do |router|<br>    router.vm.network &quot;private_network&quot;, ip: &quot;172.16.111.222&quot;<br>    router.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.222&quot;<br>    router.vm.hostname &#x3D; &quot;router&quot;<br>    router.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;router.sh&quot;<br>  end<br><br>  # 定义VS<br>  config.vm.define &quot;vs&quot; do |vs|<br>    vs.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.100&quot;<br>    vs.vm.hostname &#x3D; &quot;vs&quot;<br>    vs.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;vs.sh&quot;<br>  end<br><br>  # 定义RS1<br>  config.vm.define &quot;rs1&quot; do |rs1|<br>    rs1.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.101&quot;<br>    rs1.vm.hostname &#x3D; &quot;rs1&quot;<br>    rs1.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;rs1.sh&quot;<br>  end<br><br>  # 定义RS2<br>  config.vm.define &quot;rs2&quot; do |rs2|<br>    rs2.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.102&quot;<br>    rs2.vm.hostname &#x3D; &quot;rs2&quot;<br>    rs2.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;rs2.sh&quot;<br>  end<br><br>end<br></code></pre></td></tr></table></figure>

<p>Vagrantfile里每一台机器都运行了相应的脚本。</p>
<p><strong>Client</strong>:</p>
<p><strong><code>client.sh</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;GATEWAY&#x3D;172.16.111.222&quot; &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1<br>ifdown eth1 &amp;&amp; ifup eth1<br></code></pre></td></tr></table></figure>

<p><strong>Router</strong>:</p>
<p><strong><code>router.sh</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;net.ipv4.ip_forward&#x3D;1&quot; &gt;&gt;&#x2F;etc&#x2F;sysctl.conf<br>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br></code></pre></td></tr></table></figure>

<p><strong>VS</strong>:</p>
<p><strong><code>vs.sh</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;GATEWAY&#x3D;192.168.111.222&quot; &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1<br>ifdown eth1 &amp;&amp; ifup eth1<br>yum install -y ipvsadm<br>bash &#x2F;vagrant&#x2F;vs-dr-wlc.sh start<br></code></pre></td></tr></table></figure>

<p><code>vs.sh</code>引用的<code>vs-dr-wlc.sh</code>来启动VS。</p>
<p><strong><code>vs-dr-wlc.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>vip&#x3D;192.168.111.200<br>mode&#x3D;g  # m为NAT模式，g为DR模式，i为tun模式<br>schdule&#x3D;wlc<br>rip1&#x3D;192.168.111.101<br>rip2&#x3D;192.168.111.102<br>dev&#x3D;lo:1<br><br>case $1 in<br>start)<br>    ifconfig $dev $vip netmask 255.255.255.255 broadcast $vip up<br>    ipvsadm -A -t $vip:80 -s $schdule<br>    ipvsadm -a -t $vip:80 -r $rip1 -$mode -w 3<br>    ipvsadm -a -t $vip:80 -r $rip2 -$mode -w 1<br>    ;;<br>stop)<br>    ipvsadm -C<br>    ifconfig $dev down<br>    ;;<br>*)<br>    echo &quot;Usage: &#96;basename $0&#96; start|stop&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<p><strong>RS1</strong></p>
<p><strong><code>rs1.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;GATEWAY&#x3D;192.168.111.222&quot; &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1<br>ifdown eth1 &amp;&amp; ifup eth1<br><br>yum install -y httpd<br><br>cat &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html&lt;&lt;EOF<br>Real Server 1<br>EOF<br><br>systemctl enable httpd<br>systemctl start httpd<br><br>bash &#x2F;vagrant&#x2F;rs-config.sh start<br></code></pre></td></tr></table></figure>

<p><strong>RS2</strong></p>
<p><strong><code>rs2.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;GATEWAY&#x3D;192.168.111.222&quot; &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1<br>ifdown eth1 &amp;&amp; ifup eth1<br><br>yum install -y httpd<br><br>cat &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html&lt;&lt;EOF<br>Real Server 2<br>EOF<br><br>systemctl enable httpd<br>systemctl start httpd<br><br>bash &#x2F;vagrant&#x2F;rs-config.sh start<br></code></pre></td></tr></table></figure>

<p><strong>两个RS都调用的一个脚本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rs-config.sh<br>#!&#x2F;bin&#x2F;bash<br>vip&#x3D;192.168.111.200<br>dev&#x3D;lo:1<br>case $1 in<br>start)<br>    echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore<br>    echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore<br>    echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce<br>    echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce<br>    ifconfig $dev $vip netmask 255.255.255.255 broadcast $vip up<br>    echo &quot;VS Server is Ready!&quot;<br>    ;;<br>stop)<br>    ifconfig $dev down<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce<br>    echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce<br>    echo &quot;VS Server is Cancel!&quot;<br>    ;;<br>*)<br>    echo &quot;Usage &#96;basename $0&#96; start|stop&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<hr>
<p><code>vagrant up</code>启动所有机器后，在Virtualbox里关掉所有虚机的eth0（vagrant创建虚机时候，默认的一个NAT网络，默认在eth0上，关闭它以防止对实验造成影响）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ifdown eth0<br></code></pre></td></tr></table></figure>

<p>然后从Client虚机里运行：</p>
<p><code>bash /vagrant/client-test.sh</code>进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin.bash<br># 测试LVS<br>vip&#x3D;192.168.111.200<br>for i in &#96;seq 100&#96;;do<br>    curl --connect-timeout 1 $vip<br>    sleep 1<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS-Ip Tunnel模式应用</title>
    <url>/LVS-Ip-Tunnel%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是Ip-Tunnel模式"><a href="#一、什么是Ip-Tunnel模式" class="headerlink" title="一、什么是Ip Tunnel模式"></a>一、什么是Ip Tunnel模式</h1><p> Ip Tunnel，又叫IP隧道，顾名思义，LVS通过在IP数据包外面再封装了一层Ip Tunnel 头部，将数据包的源地址改写为LVS自身的物理地址，目的地址改写为RS的物理地址，从而实现跨网段访问RS。整个过程看起来好像LVS和RS之间有一条隧道，数据包通过这条虚拟的隧道进行传输。<br> 如下图所示：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-0ec591745507277a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488/format/webp" alt="img"></p>
<p>Ip Tunnel封装</p>
<p> Ip Tunnel模式下，客户端的请求包到达负载均衡器的虚拟服务IP端口后，负载均衡器不会改写请求包的IP和端口，但是会在数据包IP层外面再封装一个IP层，然后将数据包转发；真实服务器收到请求后，会先将外面封装的Ip Tunnel头去掉，然后处理里面实际的请求报文；与DR模式类似，响应包也不再经过LVS，而是直接返回给客户端。所以Ip Tunnel模式的转发效率虽然弱于DR，但是强于NAT。</p>
<h1 id="二、为什么要用Ip-Tunnel模式"><a href="#二、为什么要用Ip-Tunnel模式" class="headerlink" title="二、为什么要用Ip Tunnel模式"></a>二、为什么要用Ip Tunnel模式</h1><p> 既然Ip Tunnel模式的性能比不上DR，那为什么还要用它呢？ 因为它可以跨网段转发！<br> Ip Tunnel模式最大的优点就在于它可以跨网段转发，没有DR和NAT模式的组网限制。这在部署上带来的很大的灵活性，甚至还可以跨机房转发，不过不建议这样使用，一是会带来跨机房间的流量，提高了成本；二是跨机房转发必然会要在RS机房上绑定LVS机房的VIP，这有可能会被运营商的防火墙认为是IP伪造请求而拦截。</p>
<h1 id="三、如何配置Ip-Tunnel模式"><a href="#三、如何配置Ip-Tunnel模式" class="headerlink" title="三、如何配置Ip Tunnel模式"></a>三、如何配置Ip Tunnel模式</h1><h2 id="【LVS配置】"><a href="#【LVS配置】" class="headerlink" title="【LVS配置】"></a>【LVS配置】</h2><ol>
<li>使用ipvsadm配置</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ipvsadm</span> <span class="hljs-selector-tag">-A</span> <span class="hljs-selector-tag">-t</span> <span class="hljs-selector-tag">vip</span><span class="hljs-selector-pseudo">:port</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">rr</span><br><span class="hljs-selector-tag">ipvsadm</span> <span class="hljs-selector-tag">-a</span> <span class="hljs-selector-tag">-t</span> <span class="hljs-selector-tag">vip</span><span class="hljs-selector-pseudo">:port</span> <span class="hljs-selector-tag">-r</span> <span class="hljs-selector-tag">rip</span> <span class="hljs-selector-tag">-i</span><br></code></pre></td></tr></table></figure>

<ol>
<li>使用Keepalived配置<br>推荐使用Keepalived管理LVS。Keepalived提供配置文件keepalived.conf，可以很方便的配置LVS，并且提供了健康检查功能。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">virtual_server vip port &#123;<br>    delay_loop <span class="hljs-number">6</span><br>    lb_algo rr<br>    lb_kind <span class="hljs-type">TUN</span>          <span class="hljs-comment">//与DR模式唯一的区别就是这里配置为TUN</span><br>#    persistence_timeout <span class="hljs-number">50</span><br>    <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TCP</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">    <span class="hljs-title">real_server</span> <span class="hljs-title">rip</span> <span class="hljs-title">port</span> </span>&#123;<br>        weight <span class="hljs-number">100</span><br>        <span class="hljs-type">TCP_CHECK</span> &#123;<br>            connect_timeout <span class="hljs-number">3</span><br>            retry <span class="hljs-number">3</span><br>            delay_before_retry <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 注意这里只写了与DR模式配置不一样的地方，lvs上配置vip之类的就没写了。</p>
<h2 id="【RS配置】"><a href="#【RS配置】" class="headerlink" title="【RS配置】"></a>【RS配置】</h2><ol>
<li>加载ipip模块。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs undefined">modprobe ipip<br></code></pre></td></tr></table></figure>

<ol>
<li>启动tunl0虚拟网卡</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs undefined">ifconfig tunl0 up<br></code></pre></td></tr></table></figure>

<ol>
<li>将vip绑定在tunl0网卡上。（注意这里也是与DR模式不同的地方，DR模式是将vip绑在LO网卡）</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">ip addr <span class="hljs-keyword">add</span> vip dev tunl0<br></code></pre></td></tr></table></figure>

<ol>
<li>设置内核参数</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">echo <span class="hljs-string">"0"</span> &gt; <span class="hljs-regexp">/proc/sys</span><span class="hljs-regexp">/net/ipv</span>4/ip_forward<br>echo <span class="hljs-string">"2"</span> &gt; <span class="hljs-regexp">/proc/sys</span><span class="hljs-regexp">/net/ipv</span>4/conf/all/arp_announce<br>echo <span class="hljs-string">"1"</span> &gt; <span class="hljs-regexp">/proc/sys</span><span class="hljs-regexp">/net/ipv</span>4/conf/all/arp_ignore<br>echo <span class="hljs-string">"0"</span> &gt; <span class="hljs-regexp">/proc/sys</span><span class="hljs-regexp">/net/ipv</span>4/conf/all/rp_filter<br>echo <span class="hljs-string">"0"</span> &gt; <span class="hljs-regexp">/proc/sys</span><span class="hljs-regexp">/net/ipv</span>4/conf/tunl<span class="hljs-number">0</span>/rp_filter<br></code></pre></td></tr></table></figure>

<p> 注意Ip Tunnel模式下需要将RS上的rp_filter参数配为0，否则无法正常工作，因为RS是在物理网卡收到请求，但是VIP是绑在虚拟网卡tunl0上的。</p>
<h1 id="四、Ip-Tunnel模式需要注意的地方"><a href="#四、Ip-Tunnel模式需要注意的地方" class="headerlink" title="四、Ip Tunnel模式需要注意的地方"></a>四、Ip Tunnel模式需要注意的地方</h1><h2 id="【Ip-Tunnel模式存在的问题】"><a href="#【Ip-Tunnel模式存在的问题】" class="headerlink" title="【Ip Tunnel模式存在的问题】"></a>【Ip Tunnel模式存在的问题】</h2><p> Ip Tunnel模式下，LVS会在数据报文原有的IP头部上再封装一层IP头，封装层IP头的源IP是LVS节点的物理IP，目的IP是RS的物理IP，相当于原有的数据报文是在一层封装的隧道中传输。<br> 这样可以解决跨网段转发的问题，但是会带来一个新的问题：<br> 每个数据包都要封装一个新的20字节的IP头，如果LVS上收到的数据包就已经达到了Ethernet帧的最大值1514（MTU1500+帧头14），这时候封装层的IP头就无法加进去。如果数据报文IP头中设置了DF标志位（Don’t Fragment），这时候LVS就无法正常转发该报文。而是会返回一个Type=3，Code=4的ICMP报文给客户端，通知客户端目的地不可达，需要分片，并且在通知报文中指定了本端的MTU为1480。如果客户端支持PMTUD协议，那么客户端会根据ICMP中通知的MTU值重新计算合适的MSS，对要发送的数据进行分片后再重传给LVS节点。<br> 下图是TUN模式下LVS上的抓包，可以看到一开始LVS收到的数据包的data长度为1460，加上20字节TCP头，加上20字节IP头，已经达到MTU1500了（抓包大小为1514是算上了14字节的Ethernet帧头）。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-a2ea5341d079b8b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/918/format/webp" alt="img"></p>
<p>数据长度为1460</p>
<p> 这时候LVS无法转发，通过ICMP报文通知客户端分片后重传。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-8222a8edc57415c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>ICMP通知重传</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-a30e98a77ac1859f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/809/format/webp" alt="img"></p>
<p>告知本端MTU为1480</p>
<p> 下图可以看到重传后的数据报文中data长度变成了1440，剩余的data位于另外的分片中。1440加上20字节TCP头，加上20字节IP头刚好等于ICMP报文中通知的MTU值1480。此时LVS在1480的基础上再插入20字节的封装层的IP头，刚好等于物理网卡的MTU值1500。这时候IP TUNNEL模式就可以正常转发了。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-e39a353885c27857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/916/format/webp" alt="img"></p>
<p>数据长度为1440</p>
<p> 出现这个问题的原因在于IP TUNNEL模式下，LVS需要在源数据报文中再插入20字节的封装层IP头，所以它将自身的MTU值降到了1480。 这个情况下，LVS对每个大包（超过1480）的包都通过ICMP消息通知客户端分片。这依赖于客户端支持PMTUD，并且还依赖于ICMP通知能正常返回到客户端。因为在实际情况下，ICMP消息在返回客户端的过程中需要经过多跳公网路由，在中间很可能会被拦截过滤掉，这时客户端无法收到LVS返回的ICMP通知，就无法正常的分片重传了，导致LVS转发失败。</p>
<h2 id="【解决方法】"><a href="#【解决方法】" class="headerlink" title="【解决方法】"></a>【解决方法】</h2><p> 可以通过减少RS侧的MSS值，比如调到1400。这样客户端在和RS三次握手协商MSS的时候，就会使用修改后的MSS值。这样客户端网卡在对数据包进行分片时就会减小单个请求中的data大小，确保LVS上收到的请求大小不会超过1480，从而不会触发到上述的问题。<br> iptables配置方法如下，实际情况中可以根据需求指定规则所要匹配的ip地址，这样可以减小配置修改的影响范围。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">iptables -A OUTPUT -s xxx -p tcp --tcp-flags ALL SYN,ACK -j TCPMSS --<span class="hljs-built_in">set</span>-mss 1400<br></code></pre></td></tr></table></figure>

<p> 下面是修改后的客户端上的抓包结果：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-36818d06f31e9a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>MSS修改为1400</p>
<p> 从上图可以看到客户端在三次握手过程中收到的RS沟通的MSS值为修改后的值1400。<br> （注意wireshark中之所以能抓到超过1514字节的包，是因为目前大部分机器上都是开启了TSO/GSO的，TCP分片的工作下放给了网卡驱动去做；而wireshark抓到的是网卡缓冲区中的数据，还没有进行分片，所以有可能会看到大于1514的包；但是在真正发送出去的时候网卡驱动会根据MSS对TCP报文进行分片；可以对比服务端收到的抓包，服务端上收到的包就不会超过1514字节了）<br> 下面是LVS上的抓包结果：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-8d24a17365aba761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/903/format/webp" alt="img"></p>
<p>MSS=1400</p>
<p> LVS上收到来自客户端的数据包分片中的data长度也变成了1400，这样LVS就可以正常插入封装层IP头进行转发了。<br> 下图可以看到插入封装头后，数据包里面有两层IP头。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-94cd48125cc33139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/904/format/webp" alt="img"></p>
<p>两层IP头</p>
<p> 下图展示的就是LVS收到No. 1442的请求包，大小为1454字节；插入20字节的封装头后，数据包变为1474字节，然后转发给RS。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/3329890-80875f5181e29540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>Ip Tunnel转发</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS NAT实验</title>
    <url>/LVS-NAT%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/lvs-nat-rr.svg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185531.svg" alt="img"></a></p>
<p>LVS/NAT模式，在VS和RS之间有路由。</p>
<p>上图中，假设172.16.111.0网段都是外网。</p>
<p>实验采用Vagrant配置网络和主机信息。Vagrant的用法可参考<a href="http://www.yulongjun.com/linux/20170811-vagrant/" target="_blank" rel="noopener">Vagrant–快速搭建实验环境利器</a>。</p>
<table>
<thead>
<tr>
<th align="left">服务器</th>
<th align="left">IP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">client</td>
<td align="left">172.16.111.123（假装是外网）</td>
</tr>
<tr>
<td align="left">vs</td>
<td align="left">172.16.111.200（假装是外网）/192.168.111.200（内网）</td>
</tr>
<tr>
<td align="left">rs1</td>
<td align="left">192.168.111.101（内网，网关指向vs）</td>
</tr>
<tr>
<td align="left">rs2</td>
<td align="left">192.168.111.102（内网，网关指向vs）</td>
</tr>
</tbody></table>
<p><code>Vagrantfile</code>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Vagrant.configure(&quot;2&quot;) do |config|<br>  # config为全局配置文件<br>  config.vm.box &#x3D; &quot;longdream&#x2F;centos7&quot;     # 这里是我自定义的centos7模板<br>  config.hostmanager.enabled &#x3D; true       # 启用hostmanager插件<br>  config.hostmanager.manage_guest &#x3D; true  # 允许更新虚拟机上的hosts文件<br>  config.hostmanager.manage_host &#x3D; true   # 允许更新主机上的hosts文件<br><br>  # 定义Client<br>  config.vm.define &quot;client&quot; do |client|<br>    client.vm.network &quot;private_network&quot;, ip: &quot;172.16.111.123&quot;<br>    client.vm.hostname &#x3D; &quot;client&quot;<br>    client.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;client.sh&quot;<br>  end<br><br>  # 定义VS<br>  config.vm.define &quot;vs&quot; do |vs|<br>    vs.vm.network &quot;private_network&quot;, ip: &quot;172.16.111.200&quot;<br>    vs.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.200&quot;<br>    vs.vm.hostname &#x3D; &quot;vs&quot;<br>    vs.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;vs.sh&quot;<br>  end<br><br>  # 定义RS1<br>  config.vm.define &quot;rs1&quot; do |rs1|<br>    rs1.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.101&quot;<br>    rs1.vm.hostname &#x3D; &quot;rs1&quot;<br>    rs1.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;rs1.sh&quot;<br>  end<br><br>  # 定义RS2<br>  config.vm.define &quot;rs2&quot; do |rs2|<br>    rs2.vm.network &quot;private_network&quot;, ip: &quot;192.168.111.102&quot;<br>    rs2.vm.hostname &#x3D; &quot;rs2&quot;<br>    rs2.vm.provision &quot;shell&quot;, inline: &quot;sudo bash &#x2F;vagrant&#x2F;rs2.sh&quot;<br>  end<br><br>end<br></code></pre></td></tr></table></figure>

<p>Vagrantfile里每一台机器都运行了相应的脚本。</p>
<p><strong>Client</strong>:</p>
<p><strong><code>client.sh</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifconfig-eth1 &lt;&lt;EOF<br>GATEWAY&#x3D;172.16.111.200<br>EOF<br></code></pre></td></tr></table></figure>

<p><strong>VS</strong>:</p>
<p><strong><code>vs.sh</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &quot;net.ipv4.ip_forward&#x3D;1&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf<br>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward<br>yum install -y ipvsadm<br>bash &#x2F;vagrant&#x2F;vs-nat-rr.sh start<br></code></pre></td></tr></table></figure>

<p><code>vs.sh</code>引用的<code>vs-nat-rr.sh</code>来启动VS。</p>
<p><strong><code>vs-nat-rr.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>vip&#x3D;172.16.111.200<br>mode&#x3D;m  # m为NAT模式，g为DR模式，i为tun模式<br>schdule&#x3D;rr<br>rip1&#x3D;192.168.111.101<br>rip2&#x3D;192.168.111.102<br><br>case $1 in<br>start)<br>    ipvsadm -A -t $vip:80 -s $schdule<br>    ipvsadm -a -t $vip:80 -r $rip1 -$mode<br>    ipvsadm -a -t $vip:80 -r $rip2 -$mode<br>    ;;<br>stop)<br>    ipvsadm -C<br>    ;;<br>*)<br>    echo &quot;Usage: &#96;basename $0&#96; start|stop&quot;<br>    exit 1<br>    ;;<br>esac<br></code></pre></td></tr></table></figure>

<p><strong>RS1</strong></p>
<p><strong><code>rs1.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &#39;GATEWAY&#x3D;192.168.111.200&#39; &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1<br>ifdown eth1 &amp;&amp; ifup eth1<br><br>yum install -y httpd<br><br>cat &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html&lt;&lt;EOF<br>Real Server 1<br>EOF<br><br>systemctl enable httpd<br>systemctl start httpd<br></code></pre></td></tr></table></figure>

<p><strong>RS2</strong></p>
<p><strong><code>rs2.sh</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br>echo &#39;GATEWAY&#x3D;192.168.111.200&#39; &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth1<br>ifdown eth1 &amp;&amp; ifup eth1<br><br>yum install -y httpd<br><br>cat &gt;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.html&lt;&lt;EOF<br>Real Server 2<br>EOF<br><br>systemctl enable httpd<br>systemctl start httpd<br></code></pre></td></tr></table></figure>

<hr>
<p><code>vagrant up</code>启动所有机器后，在Virtualbox里关掉所有虚机的eth0（vagrant创建虚机时候，默认的一个NAT网络，默认在eth0上，关闭它以防止对实验造成影响）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ifdown eth0<br></code></pre></td></tr></table></figure>

<p>然后从Client虚机里运行：</p>
<p><code>bash /vagrant/client-test.sh</code>进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin.bash<br># 测试LVS<br>vip&#x3D;172.16.111.200<br>for i in &#96;seq 100&#96;;do<br>    curl --connect-timeout 1 $vip<br>    sleep 1<br>done<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS-四种工作模式( dr tunnel nat fullnat )原理简介</title>
    <url>/LVS-%E5%9B%9B%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F-dr-tunnel-nat-fullnat-%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130190013" alt="img"></p>
<p>  LVS-DR模式：   </p>
<p>1.客户端将访问vip报文发送给LVS服务器；<br>2.LVS服务器将请求报文的mac地址改为后端真实服务器的mac地址；<br>3.后端真实服务器得到访问报文后进行ip查看，再确认自己有vip之后进行请求处理；<br>4.后端真实服务器在处理完数据请求后，直接响应客户端。   </p>
<p>要求：   </p>
<p>1.LVS服务器和后端真实的服务器要处在同一vlan中。<br>2.LVS和后端服务器上都要有vip，并且后端真实服务器上的vip不能对外进行广播。   </p>
<p>优点：   </p>
<p>1.LVS服务器只是修改了mac地址，所以非常快速，并且LVS不会成为瓶颈。   </p>
<p>缺点：   </p>
<p>1.要求较高，LVS服务器必须和后端真实服务器处于同一vlan中；<br>2.后端真实服务器直接响应客户端，对于后端真实服务器来说，并不安全。   </p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130190018" alt="img">    </p>
<p>LVS-TUNNEL模式：     </p>
<p>1.客户端将访问vip报文发送给LVS服务器；<br>2.LVS服务器将请求报文重新封装，发送给后端真实服务器；<br>3.后端真实服务器将请求报文解封，在确认自身有vip之后进行请求处理；<br>4.后端真实服务器在处理完数据请求后，直接响应客户端。     </p>
<p>要求：     </p>
<p>1.lvs和后端真实服务器上都要有vip。<br>2.不会成为瓶颈。<br>3.请求的报文不能太大。     </p>
<p>优点：     </p>
<p>1.快速<br>2.不安全，不能抵抗DOS攻击     </p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130190024" alt="img"></p>
<p>LVS-NAT模式：       </p>
<p>1.客户端将访问vip报文发送给LVS服务器；<br>2.LVS服务器将请求报文的目的地址修改为后端真实服务器(DNAT)，发送给后端真实服务器；<br>3.后端服务器在处理完之后要将响应的报文返回给客户端，但是却不在同一网段；<br>4.LVS根据自己的追踪技术将后端真实服务响应客户端的报文原地址改为自己的ip地址(SNAT)，发送给客户端。       </p>
<p>要求：<br>1.LVS服务器需要有不同的网段。<br>2.真实服务器的网关必须设置为LVS的ip地址。       </p>
<p>优点：       </p>
<p>1.安全<br>2.可以实现不同网段的数据请求。       </p>
<p>缺点：       </p>
<p>因为在 VS/NAT 中请求和响应报文都需要通过负载调度器，伸缩能力有限, 当服务器结点数目升到 20 时,调度器本身<br>有可能成为系统的新瓶颈。       </p>
<p>LVS-fullnat模式：       </p>
<p>1.客户端将访问vip报文发送给LVS服务器；<br>2.LVS服务器将请求报文的目的地址修改为后端真实服务器(DNAT)，源地址改为自己的ip地址(SNAT)，发送给后端真实服务器；<br>3.后端服务器在处理完之后要将响应的报文返回给lvs；<br>4.LVS将返回的数据包源地址改为自己(SNAT)，目的地址改为客户端(DNAT)，发送给客户端。       </p>
<p>fullnat模式和nat模式相似，但是与nat不同的是nat模式只做了两次地址转换，fullnat模式却做了四次。       </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS原理、模式、调度算法</title>
    <url>/LVS%E5%8E%9F%E7%90%86%E3%80%81%E6%A8%A1%E5%BC%8F%E3%80%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、集群和负载均衡"><a href="#一、集群和负载均衡" class="headerlink" title="一、集群和负载均衡"></a>一、集群和负载均衡</h2><h3 id="1-scale-up和scale-out"><a href="#1-scale-up和scale-out" class="headerlink" title="1. scale up和scale out"></a>1. scale up和scale out</h3><p>当业务量越来越大的时候，我们就要对系统进行扩展，扩展有两种方式：</p>
<ul>
<li>scale up: 纵向扩展，即增强服务器的性能。买买买！但是性能越好的服务器价格成几何倍数增长……</li>
<li>scale out: 线性扩展，即增加服务器的数量，然后用调度来解决分配资源，这就是集群（Cluster）的由来。</li>
</ul>
<h3 id="2-集群和分布式"><a href="#2-集群和分布式" class="headerlink" title="2. 集群和分布式"></a>2. 集群和分布式</h3><p><strong>集群</strong>（Cluster）定义：为解决某个特定问题将多台计算机组合起来形成的单个系统</p>
<p>Cluster类型：</p>
<ul>
<li><strong>LB</strong>：Load Balancing，负载均衡。</li>
<li><strong>HA</strong>：High Availiablity，高可用。</li>
<li><strong>HPC</strong>：High-Performance Computing，高性能计算。（<a href="http://www.top500.org）" target="_blank" rel="noopener">www.top500.org）</a></li>
</ul>
<p>与集群相对应的是分布式系统（distributed system）。</p>
<p>集群和分布式的区别，简单来说就是：</p>
<ul>
<li><strong>集群</strong>：同一个业务，部署在多个服务器上。</li>
<li><strong>分布式</strong>：一个业务分拆多个子业务，部署在不同的服务器上。</li>
</ul>
<p><strong>举个例子</strong>大家更能明白：</p>
<blockquote>
<p>一个小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是集群链接。<br>–本段文字<a href="https://www.zhihu.com/question/20004877/answer/112124929" target="_blank" rel="noopener">来源</a>。</p>
</blockquote>
<h3 id="3-负载均衡集群"><a href="#3-负载均衡集群" class="headerlink" title="3. 负载均衡集群"></a>3. 负载均衡集群</h3><p>负载均衡集群的实现：</p>
<ul>
<li><p>硬件：</p>
<ul>
<li>F5: BIG-IP</li>
<li>Citrix: NetScaler</li>
<li>A10: A10</li>
</ul>
</li>
<li><p>软件：</p>
<ul>
<li>LVS</li>
<li>HAproxy</li>
<li>Nginx</li>
<li>ats(apache traffic server)</li>
<li>perlbal</li>
</ul>
<p>软件中，LVS, HAproxy, Nginx用的比较多，重点学习就是这3个。</p>
<p>我们重点学习头3种：<strong>LVS</strong>, <strong>HAproxy</strong> ,<strong>Nginx</strong></p>
<p>关于这三种的优缺点可以看这篇文章：<a href="https://yq.aliyun.com/articles/87257" target="_blank" rel="noopener">Nginx/LVS/HAProxy负载均衡软件的优缺点详解</a></p>
</li>
</ul>
<p>本文主要讲集群中的负载均衡中的一个：lvs（Linux Virtual Server）,LVS基于ISO七层模型中的4层传输层。</p>
<hr>
<h2 id="二、LVS基本术语和组成"><a href="#二、LVS基本术语和组成" class="headerlink" title="二、LVS基本术语和组成"></a>二、LVS基本术语和组成</h2><h3 id="1-LVS基本术语"><a href="#1-LVS基本术语" class="headerlink" title="1. LVS基本术语"></a>1. LVS基本术语</h3><p>LVS集群类型中的术语：</p>
<p><strong>VS</strong>：<code>Virtual Server</code>，<code>Director</code>，<code>Dispatcher</code>(调度器)，<code>Load Balancer</code></p>
<p><strong>RS</strong>：<code>Real Server</code>(lvs里)， <code>upstream server</code>(nginx里)，<code>backend server</code>(haproxy里)、<code>Replica（副本）</code></p>
<p><strong>CIP</strong>：<code>Client IP</code> 客户端ip</p>
<p><strong>VIP</strong>: <code>Virtual server IP</code> VS外网的IP</p>
<p><strong>DIP</strong>: <code>Director IP</code> VS内网的IP</p>
<p><strong>RIP</strong>: <code>Real server IP</code></p>
<h3 id="2-LVS软件组成"><a href="#2-LVS软件组成" class="headerlink" title="2. LVS软件组成"></a>2. LVS软件组成</h3><p>LVS 由2部分程序组成，包括 <code>ipvs</code> 和 <code>ipvsadm</code>。</p>
<ol>
<li><strong><code>ipvs</code></strong>(ip virtual server)：一段代码工作在内核空间，叫ipvs，是真正生效实现调度的代码。</li>
<li><strong><code>ipvsadm</code></strong>：另外一段是工作在用户空间，叫ipvsadm，负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)。</li>
</ol>
<hr>
<h2 id="LVS基本工作原理"><a href="#LVS基本工作原理" class="headerlink" title="LVS基本工作原理"></a>LVS基本工作原理</h2><p><a href="http://www.yulongjun.com/images/15030616224922.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185240.jpg" alt="img"></a></p>
<ol>
<li>当用户向<strong>负载均衡调度器</strong>（VS或者叫LB）发起请求，调度器将请求发往至内核空间。</li>
<li><code>PREROUTING</code>链首先会接收到用户请求，判断目标IP确定是本机IP，将数据包发往<strong>INPUT</strong>链。</li>
<li><strong>IPVS是工作在INPUT链上的</strong>，当用户请求到达INPUT时，IPVS会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时IPVS会强行修改数据包里的目标IP地址及端口，并将新的数据包发往<strong>POSTROUTING</strong>链。</li>
<li>POSTROUTING链接收数据包后发现目标IP地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器。</li>
</ol>
<hr>
<h2 id="LVS各种模式原理"><a href="#LVS各种模式原理" class="headerlink" title="LVS各种模式原理"></a>LVS各种模式原理</h2><p>lvs集群的类型：</p>
<p><strong><code>LVS/NAT</code></strong>： NAT模式。修改请求报文的目标IP,多目标IP的DNAT。</p>
<p><strong><code>LVS/DR</code></strong>：DirectRouting（直接路由）。操纵封装新的MAC地址。</p>
<p><strong><code>LVS/TUN</code></strong>：Tunneling（隧道）。在原请求IP报文之外新加一个IP首部。</p>
<p><strong><code>LVS/FULLNAT</code></strong>：Full NAT。修改请求报文的源和目标IP。</p>
<h3 id="1-LVS-NAT"><a href="#1-LVS-NAT" class="headerlink" title="1. LVS/NAT"></a>1. LVS/NAT</h3><p>LVS/NAT 最基本的LVS策略</p>
<p>如图: 客户端(Client) -&gt; LB（VS） -&gt; replica1(RS1),replica2(RS2),replica3(RS3)</p>
<p><a href="http://www.yulongjun.com/images/15030594983026.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185251.png" alt="img"></a></p>
<p>详细的数据包的流转图：</p>
<p><a href="http://www.yulongjun.com/images/15030619475143.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185259.jpg" alt="img"></a></p>
<p>(a). 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP<br>(b). PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链<br>(c). IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP，然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP<br>(d). POSTROUTING链通过选路，将数据包发送给Real Server<br>(e). Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP<br>(f). Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP</p>
<h3 id="2-LVS-DR"><a href="#2-LVS-DR" class="headerlink" title="2. LVS/DR"></a>2. LVS/DR</h3><p>很多时候，相应流是比请求流大的，如下图：</p>
<p><a href="http://www.yulongjun.com/images/15030596373205.png" target="_blank" rel="noopener"><img src="LVS%E5%8E%9F%E7%90%86%E3%80%81%E6%A8%A1%E5%BC%8F%E3%80%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.assets/15030596373205.png" alt="img"></a></p>
<p>所以有第二种方案，响应流不走LB，这就是<strong>LVS/DR</strong>模式：</p>
<p><a href="http://www.yulongjun.com/images/15030601457957.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185345.png" alt="img"></a></p>
<p>详细的数据包的流转图：</p>
<p><a href="http://www.yulongjun.com/images/15030623128164.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185353.jpg" alt="img"></a></p>
<p>(a) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP<br>(b) PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链<br>(c) IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址<br>(d) 由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。<br>(e) RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文。处理完成之后，将响应报文通过lo接口传送给eth0网卡然后向外发出。 此时的源IP地址为VIP，目标IP为CIP<br>(f) 响应报文最终送达至客户端</p>
<p><strong>LVS-DR模型的特性</strong></p>
<ul>
<li><strong>特点1</strong>：保证前端路由将目标地址为VIP报文统统发给Director Server，而不是RS。</li>
<li>RS可以使用私有地址；也可以是公网地址，如果使用公网地址，此时可以通过互联网对RIP进行直接访问。</li>
<li>RS跟Director Server必须在同一个物理网络中。</li>
<li>所有的请求报文经由Director Server，但响应报文必须不能进过Director Server。</li>
<li>不支持地址转换，也不支持端口映射。</li>
<li>RS可以是大多数常见的操作系统。</li>
<li>RS的网关绝不允许指向DIP(因为我们不允许他经过director)。</li>
<li>RS上的lo接口配置VIP的IP地址。</li>
<li>缺陷：RS和DS必须在同一机房中。</li>
</ul>
<p><strong>特点1的解决方案：</strong></p>
<ul>
<li>在前端路由器做静态地址路由绑定，将对于VIP的地址仅路由到Director Server。</li>
<li>存在问题：用户未必有路由操作权限，因为有可能是运营商提供的，所以这个方法未必实用。</li>
<li>arptables：在arp的层次上实现在ARP解析时做防火墙规则，过滤RS响应ARP请求。这是由iptables提供的</li>
<li>修改RS上内核参数（arp_ignore和arp_announce）将RS上的VIP配置在lo接口的别名上，并限制其不能响应对VIP地址解析请求。</li>
</ul>
<h3 id="3-LVS-TUN"><a href="#3-LVS-TUN" class="headerlink" title="3. LVS/TUN"></a>3. LVS/TUN</h3><p>在原有的IP报文外再次封装多一层IP首部，内部IP首部(源地址为CIP，目标IIP为VIP)，外层IP首部(源地址为DIP，目标IP为RIP)</p>
<p><a href="http://www.yulongjun.com/images/15030625216631.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185406.jpg" alt="img"></a></p>
<p>(a) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP 。<br>(b) PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链。<br>(c) IPVS比对数据包请求的服务是否为集群服务，若是，在请求报文的首部再次封装一层IP报文，封装源IP为为DIP，目标IP为RIP。然后发至POSTROUTING链。 此时源IP为DIP，目标IP为RIP 。<br>(d) POSTROUTING链根据最新封装的IP报文，将数据包发至RS（因为在外层封装多了一层IP首部，所以可以理解为此时通过隧道传输）。 此时源IP为DIP，目标IP为RIP。<br>(e) RS接收到报文后发现是自己的IP地址，就将报文接收下来，拆除掉最外层的IP后，会发现里面还有一层IP首部，而且目标是自己的lo接口VIP，那么此时RS开始处理此请求，处理完成之后，通过lo接口送给eth0网卡，然后向外传递。 此时的源IP地址为VIP，目标IP为CIP。<br>(f) 响应报文最终送达至客户端。</p>
<p><strong>LVS-TUN模型特性</strong></p>
<ul>
<li>RIP、VIP、DIP全是公网地址。</li>
<li>RS的网关不会也不可能指向DIP。</li>
<li>所有的请求报文经由Director Server，但响应报文必须不能进过Director Server。</li>
<li>不支持端口映射。</li>
<li>RS的系统必须支持隧道。</li>
</ul>
<h3 id="4-LVS-FULLNAT"><a href="#4-LVS-FULLNAT" class="headerlink" title="4. LVS/FULLNAT"></a>4. LVS/FULLNAT</h3><p>lvs-fullnat：通过同时修改请求报文的源IP地址和目标IP地址进行转发:</p>
<ul>
<li>CIP –&gt; DIP</li>
<li>VIP –&gt; RIP</li>
</ul>
<p>(1) VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关一般不会指向DIP。</p>
<p>(2) RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client。</p>
<p>(3) 请求和响应报文都经由Director。</p>
<p>(4) 支持端口映射。</p>
<blockquote>
<p>注意：此类型kernel默认不支持。</p>
</blockquote>
<h3 id="LVS工作模式总结"><a href="#LVS工作模式总结" class="headerlink" title="LVS工作模式总结"></a>LVS工作模式总结</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">VS/NAT</th>
<th align="left">VS/TUN</th>
<th align="left">VS/DR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">server</td>
<td align="left">any</td>
<td align="left">tunneling</td>
<td align="left">non-arp device</td>
</tr>
<tr>
<td align="left">server network</td>
<td align="left">private</td>
<td align="left">LAN/WAN</td>
<td align="left">LAN</td>
</tr>
<tr>
<td align="left">server number</td>
<td align="left">low (10~20)</td>
<td align="left">high</td>
<td align="left">high</td>
</tr>
<tr>
<td align="left">server gateway</td>
<td align="left">load balancer</td>
<td align="left">own router</td>
<td align="left">own router</td>
</tr>
</tbody></table>
<ul>
<li>LVS/NAT, LVS/FULLNAT：请求和响应报文都经由VS<ul>
<li>LVS/NAT：RIP的网关要指向DIP</li>
<li>LVS/FULLNAT：RIP和DIP未必在同一IP网络，但要能通信</li>
</ul>
</li>
<li>LVS/DR, LVS/TUN：请求报文要经由VS，但响应报文由RS直接发往Client<ul>
<li>LVS/DR：通过封装新的MAC首部实现，通过MAC网络转发</li>
<li>LVS/TUN：通过在原IP报文之外封装新的IP报文实现转发，支持远距离通信</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>其实企业中最常用的是 DR 实现方式，而 NAT 配置上比较简单和方便，后边实践中会总结 DR 和 NAT 具体使用配置过程。</strong></p>
</blockquote>
<hr>
<h2 id="LVS调度算法"><a href="#LVS调度算法" class="headerlink" title="LVS调度算法"></a>LVS调度算法</h2><p>根据其调度时是否考虑各RS当前的负载状态，分为静态方法和动态方法。</p>
<p><strong>静态方法</strong>：仅根据算法本身进行调度</p>
<ol>
<li><strong>RR</strong>：<code>roundrobin</code>，轮询。</li>
<li><strong>WRR</strong>：<code>Weighted RR</code>，加权轮询。</li>
<li><strong>SH</strong>：<code>Source Hashing</code>，实现session sticky，源IP地址hash；将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定。</li>
<li><strong>DH</strong>：<code>Destination Hashing</code>；目标地址哈希，将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡，如：宽带运营商。</li>
</ol>
<p>动态方法：主要根据每RS当前的负载状态及调度算法进行调度，<code>Overhead=value</code>较小的RS将被调度。</p>
<ol>
<li><strong>LC</strong>：<code>least connections</code>，最少连接，适用于长连接应用。<code>Overhead=activeconns*256+inactiveconns</code></li>
<li><strong>WLC</strong>：<code>Weighted LC</code>，加权最少连接，默认调度方法。<code>Overhead=(activeconns*256+inactiveconns)/weight</code></li>
<li><strong>SED</strong>：<code>Shortest Expection Delay</code>,初始连接高权重优先。<code>Overhead=(activeconns+1)*256/weight</code></li>
<li><strong>NQ</strong>：<code>Never Queue</code>，第一轮均匀分配，后续SED。</li>
<li><strong>LBLC</strong>：<code>Locality-Based LC</code>，动态的DH算法，使用场景： 根据负载状态实现正向代理。</li>
<li><strong>LBLCR</strong>：<code>LBLC with Replication</code>，带复制功能的LBLC，解决LBLC负载不均衡问题，从负载重的复制到负载轻的RS。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>LVS的原理-工作模式</title>
    <url>/LVS%E7%9A%84%E5%8E%9F%E7%90%86-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="LVS简介"><a href="#LVS简介" class="headerlink" title="LVS简介"></a>LVS简介</h2><h3 id="什么是LVS"><a href="#什么是LVS" class="headerlink" title="什么是LVS:"></a>什么是LVS:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一.<br></code></pre></td></tr></table></figure>

<h3 id="LVS的作用："><a href="#LVS的作用：" class="headerlink" title="LVS的作用："></a>LVS的作用：</h3><p>LVS的原理很简单，当用户的请求过来时，会直接分发到LVS机器（director server）上，然后它把用户的请求根据设置好的调度算法，智能均衡地分发到后端真正服务器(real server)上。<br>简单的讲，LVS就是一种负载均衡服务器。</p>
<h3 id="LVS的角色："><a href="#LVS的角色：" class="headerlink" title="LVS的角色："></a>LVS的角色：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DS：director server，即负载均衡器，根据一定的负载均衡算法将流量分发到后端的真实服务器上.<br>RS：real server 真实的提供服务的server，可被DS划分到一个或多个负载均衡组.<br>BDS：backup director server，为了保证负载均衡器的高可用衍生出的备份.<br>VS：vitual server，负载均衡集群对外提供的IP+Port.<br>VIP：VS的IP，client请求服务的DIP（destination IP address），定义在DS上，client或其网关需要有其路由<br></code></pre></td></tr></table></figure>

<h3 id="LVS组成："><a href="#LVS组成：" class="headerlink" title="LVS组成："></a>LVS组成：</h3><p>LVS 由2部分程序组成，包括ipvs和ipvsadm。<br>ipvs工作在内核空间，是真正生效实现调度的代码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ipvs基于netfilter框架，netfilter的架构就是在整个网络流程的若干位置放置一些检测点（HOOK）.<br>在每个检测点上登记一些处理函数进行处理（如包过滤，NAT等，甚至可以是用户自定义的功能）。<br>IPVS就是定义了一系列的“钩子函数”，在INPUT链和Forward上放置一些HOOK点.<br>如匹配了ipvs的规则，就会通过函数来对数据包进行操作，比如修改目的IP为realserver的接口IP（NAT），对MAC进行修改（DR）等等。<br></code></pre></td></tr></table></figure>



<p>ipvsadm工作在用户空间，负责为ipvs内核框架编写规则, 它是一个工具，通过调用ipvs的接口去定义调度规则，定义虚拟服务（VS）。</p>
<h3 id="LVS请求的流程"><a href="#LVS请求的流程" class="headerlink" title="LVS请求的流程"></a>LVS请求的流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1、客户端（Client）访问请求发送到调度器（Director Server）。<br>2、调度器的PREROUTING链会接收到用户请求，判断目标IP确定是本机IP，将数据包发往INPUT链。<br>3、INPUT链的IPVS会根据ipvsadm定义的规则（调度模式和调度算法等等）进行对比判断。<br>4、如果用户请求就是所定义的虚拟服务（vitual server），那么IPVS会修改请求包的ip、mac、端口号等信息，并将请求发送到FORWARD链，再经由POSTROUTING链发送到后端的真实提供服务的主机（Real Server）<br></code></pre></td></tr></table></figure>

<p>下面我主要记录一下LVS调度的方式和原理。</p>
<h2 id="LVS的调度"><a href="#LVS的调度" class="headerlink" title="LVS的调度"></a>LVS的调度</h2><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>调度算法也就是指负载均衡算法，注意LVS只负责负载均衡，不负责探活和保证RS的高可用。</p>
<h4 id="静态算法"><a href="#静态算法" class="headerlink" title="静态算法"></a>静态算法</h4><p>不考虑Real Server实时的活动连接和非活动连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rr：轮询<br>wrr：Weight，加权轮询<br>dh：destination hash，功能类似于sh，但应用场景不同<br>sh：source hash，源地址hash；根据hash表将来自同一IP请求发送至同一Real Server，这样在一定程度上破坏了负载均衡的效果；主要使用在电商网站，实现session affinity（会话绑定）<br></code></pre></td></tr></table></figure>



<h4 id="动态算法"><a href="#动态算法" class="headerlink" title="动态算法"></a>动态算法</h4><p>ipvs默认的调度算法是下面的wlc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">lc：最少连接数调度（least-connection）,IPVS表存储了所有活动的连接。LB会比较将连接请求发送到当前连接最少的RS. （active*256+inactive）<br>wlc：加权最少连接数调度，（active*256+inactive）&#x2F;weighed，权重越大连接数越少，则连接至此rs<br>sed：最短期望延迟 （active+1）&#x2F;权重，不考虑inactive，解决了如果只有一个请求，就给性能强的那台服务器<br>nq：never queue 在每台rs都有连接之前不排队，保证每台rs至少有一个链接 ，不考虑inactive，解决了性能高的忙死，性能低没有连接<br>lblc：基于本地的最少连接数调度（locality-based least-connection）：将来自同一个目的地址的请求分配给同一台RS，此时这台服务器是尚未满负荷的。否则就将这个请求分配给连接数最小的RS，并以它作为下一次分配的首先考虑。<br>lblcr：基于本地带复制功能的最少连接；对于已建立的请求，分配到同一台服务器；对于新请求，分配到连接数少的server<br></code></pre></td></tr></table></figure>



<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><h4 id="NAT方式"><a href="#NAT方式" class="headerlink" title="NAT方式"></a>NAT方式</h4><p>NAT(Network Address Translation),类似于防火墙的私有网络结构，Director Server作为所有服务器节点的网关，即作为客户端的访问入口，也是各节点回应客户端的访问出口，其外网地址作为整个群集的VIP地址，其内网地址与后端服务器Real Server在同一个物理网络，Real Server必须使用私有IP地址。<br><a href="https://yizhi.ren/linkimage/lvs/natflow.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185929.png" alt="nat flow"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1. 参考上面LVS请求的流程，修改数据包的目标IP地址为后端服务器IP，重新封装数据包（源IP为CIP，目标IP为RIP），然后选路将数据包发送给Real Server。<br>2. Real Server比对发现目标IP是本机的IP，处理请求后正常发送响应报文（源IP为RIP，目标IP为CIP）发回给Director Server。<br>3. Director Server重新封装数据包，将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP。<br></code></pre></td></tr></table></figure>

<p>由此可总结特点如下：<br>从上面第一点分析，DS修改了网络层的IP和传输层的端口，所以NAT支持端口映射，VIP的PORT可以不同于RS的PORT。<br>从上面第二点分析，为了让RS的响应经过DS，我们必须把RS的网关设置为DS。<br>从上面第三点分析，响应的过程DS修改源IP并转发数据包，所以DS必须开启IP-Forward.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IP-Forward即当主机拥有多于一块的网卡时，其中一块收到数据包，<br>根据数据包的目的ip地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。<br></code></pre></td></tr></table></figure>



<p>从流程上看，NAT方式的数据进出都经过DS，DS容易成为性能瓶颈；RS和DS必须在同一个VLAN，即处于同一个局域网。</p>
<h4 id="DR方式"><a href="#DR方式" class="headerlink" title="DR方式"></a>DR方式</h4><p>DR(Direct Routing),Director Server作为群集的访问入口，但不作为网关使用，后端服务器池中的Real Server与Director Server在同一个物理网络中，发送给客户机的数据包不需要经过Director Server。即input经过DR，output不经过DR。为了响应对整个群集的访问，DS与RS都需要配置有VIP地址。<br><a href="https://yizhi.ren/linkimage/lvs/drflow.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185937.png" alt="dr flow"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1. 参考上面LVS请求的流程，修改数据包的源MAC地址为DS的MAC，目标MAC地址为RS的MAC，重新封装数据包然后选路将数据包发送给Real Server。<br>2. RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文，处理请求后正常发送响应报文(源MAC地址为RS出口网卡（eth0）的MAC，目标MAC为CIP的MAC),将响应报文通过lo接口传送给eth0网卡然后向外发出。<br>RS直接将响应报文传送到客户端，不经过DS。<br></code></pre></td></tr></table></figure>



<p>由此可总结特点如下：<br>从上面第一点分析，DS只修改了数据链路层的MAC，没有修改传输层的数据，所以NAT不支持端口映射。<br>从上面第二点分析，DS没有修改IP，数据包的IP还是VIP，所以为了让RS认为数据包是发给他的，必须给RS绑定一个VIP，通常就绑定到lo上面去，所以RS的lo都需要绑定VIP。<br>同时DS必须能通过ARP请求查到RS的MAC，如果不在同一网段则会隔离arp，所以DS和RS必须在同一个VLAN。<br>此时网络中就同时存在DS和RS的多个IP为VIP的机器，所以这里需要抑制RS的arp响应，否则DS和RS就都会回应自己是VIP，造成混乱。所以设置arp_ignore=1或者2，见下面arp_ignore的解释。<br>再从上面第二点分析，RS响应数据包的源MAC是eth0而不是VIP所在的lo，因为如果是用的lo的MAC就造成其他网络设备的缓存中存在DS_MAC-VIP和RS_LO_MAC-VIP这样多个不同的MAC-IP映射对，造成混乱。这里就需要设置arg_annouce=2，设置方法见下面的解释。<br>同时可知该模式下响应不经过DS，因此其性能会优于NAT方式。<br>同时可知DS不需要承担数据转发的工作，因此不需要开启Ip-Forward.</p>
<p>这里补充对ARP的设置方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">我们知道仰制arp帧需要在server上执行以下命令，如下:<br><br>echo &quot;1&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignore<br>echo &quot;2&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announce<br>echo &quot;1&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore<br>echo &quot;2&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce<br>因为arp对逻辑口没有意义。实际上起作用的只有以下两条:<br><br>echo &quot;1&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore<br>echo &quot;2&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce<br></code></pre></td></tr></table></figure>



<p>arp_ignore的意义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">0（默认）<br>只要查询的目的IP在我的某个网卡中，我就响应。<br>1<br>本网卡的查询包，必须是查询本网卡的IP，否则不回应，所以eth0的数据包不会响应对lo的IP的查询。<br>2<br>本网卡的查询包，必须是查询本网卡的IP，同时查询者的IP必须在本网卡所在网段（这个条件正常情况应该都满足吧？？除非特意构造的），否则不回应，所以同参数1，eth0的数据包不会响应对lo的IP的查询。<br></code></pre></td></tr></table></figure>



<p>arp_annouce的意义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">arp_annouce用来设置当lo的数据包通过eth0发送ARP查询时（lo和eth0指的任意两个网卡）,数据包的源ip是用lo的ip还是eth0的ip。<br>0（默认）用的lo的ip<br>1 用eth0的ip，除非eth0和lo是同一网段的，则使用lo的ip。<br>2 用eth0的ip。<br></code></pre></td></tr></table></figure>



<p>可以看到，DR方法虽然效率更高，但是RS的设置比较麻烦，要设置lo绑定VIP，还要设置arp_ignore和arp_annouce。</p>
<p>这里暂停一下，不知道你发现没有，NAT和DR两种方式，都存在一个严重的问题，DS和RS都必须在同一个网段，那异地部署怎么办呢？<br>所以后面列举一下解决跨网段问题的转发方式，TUN/FUNNNAT。NAT/DR/TUN/FULLNAT加在一起就是全部LVS的转发方式了。</p>
<h4 id="TUN方式"><a href="#TUN方式" class="headerlink" title="TUN方式"></a>TUN方式</h4><p>我们回忆下，在DR方式下，DS只修改数据包中数据链路层的MAC信息，IP信息不修改。于是DS通过MAC来定位RS，由此限制了DS和RS要处于同一网段。<br>那么如果DS可以不通过MAC就可以定位到RS的话，也就不用限制RS和DS处于同一网段了。<br>而IP Tunnel正好可以解决这一问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ip隧道简单解释一下，ip隧道可以理解为IP in IP, 即发送方在IP头的外部再包装一个IP头，接收方先解出第一层IP头，然后再按照正常流程处理剩下的的IP数据包。<br>比如下面的数据是10.10.1.10发往20.20.1.20<br>src ip      |  dst ip<br>10.10.1.10  |  20.20.1.20<br>数据经过tunl网络设备后变成<br>src ip      |  dst ip     | src ip      |  dst ip<br>30.30.1.30  |  40.40.1.40 | 10.10.1.10  |  20.20.1.20<br>数据包可以通过网络链路到达40.40.1.40，IP层处理函数把数据交给ip隧道程序解析，解出第一层IP头，并把解出的原始数据包放入接收队列，接下来如果20.20.1.20匹配了另一个网卡的IP，则数据包就被完整接受和处理。<br></code></pre></td></tr></table></figure>



<p>有了ip tunnel技术，我们就可以把RS分布到不同的机房下，如下图<br><a href="https://yizhi.ren/linkimage/lvs/tunflow.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185944.png" alt="tun flow"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1. 参考上面LVS请求的流程，给数据包添加新的IP头，重新封装数据包然后选路将数据包发送给Real Server。<br>2. RS发现请求报文的IP地址是自己的eth0的IP地址，就剥掉IP隧道包头。<br>3. RS发现请求报文的IP地址是自己的lo的IP地址，就接收此报文，处理请求后正常发送响应报文(源IP是VIP，目的IP是ClientIP),将响应报文通过lo接口传送给eth0网卡然后向外发出。<br>RS直接将响应报文传送到客户端，不经过DS。<br></code></pre></td></tr></table></figure>



<p>由此可总结特点如下：<br>从第一点分析，DS添加了IP头，但是不修改传输层数据，所以TUN不支持端口映射。<br>从第二点分析，只要IP可达，RS完全可以分布到不同的机房和网段。同时可知DS这里不需要两张网卡，所以也不需要开启IP-forward。<br>从第三点分析，RS需要绑定VIP到lo，同时这里没有提到arp抑制，那是因为tun方式下，DS和RS常不在同一网段，也就不会引起DS和RS的ARP混乱。一旦DS和RS部署在一个网段，那么跟DR一样，需要配置ARP抑制。对于同一网段下的RS之间也会引起ARP映射混乱，不过没什么影响。</p>
<p>注意tun方案下会存在MTU的问题，如果一个数据包已经达到了mtu的大小，ip隧道添加一个ip头之后，包的大小就会超过MTU。这个时候有两个方案来解决。<br>支持<a href="http://www.cnpaf.net/rfc/rfc1191.txt" target="_blank" rel="noopener">PMTUD</a>协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">每个数据包都要封装一个新的20字节的IP头，如果LVS上收到的数据包就已经达到了Ethernet帧的最大值1514（MTU1500+帧头14），这时候封装层的IP头就无法加进去。<br>如果数据报文IP头中设置了DF标志位（Don&#39;t Fragment），这时候LVS就无法正常转发该报文。<br>而是会返回一个Type&#x3D;3，Code&#x3D;4的ICMP报文给客户端，通知客户端目的地不可达，需要分片，并且在通知报文中指定了本端的MTU为1480。<br>如果客户端支持PMTUD，那么客户端会根据ICMP中通知的MTU值重新计算合适的MSS，对要发送的数据进行分片后再重传给LVS节点。<br></code></pre></td></tr></table></figure>



<p>减小RS的MSS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">可以通过减少RS侧的MSS值，比如调到1480。<br>这样客户端在和RS三次握手协商MSS的时候，就会使用修改后的MSS值。<br>这样客户端网卡在对数据包进行分片时就会减小单个请求中的data大小，确保LVS上收到的请求大小不会超过1480，从而不会触发到上述的问题。<br></code></pre></td></tr></table></figure>



<p>TUN方式确实解决了RS的部署和扩展问题，但是DS的扩展问题还是无法解决，我们能做的顶多是对DS实行主备高可用，想要扩展DS还是没法做到。所以就有了FULLNAT方式。</p>
<h4 id="FULLNAT方式"><a href="#FULLNAT方式" class="headerlink" title="FULLNAT方式"></a>FULLNAT方式</h4><p>上面三种调度方法都只能适用于一定规模的集群，对于大企业的大规模集群，上面那几个都被DS的扩展能力约束住了。<br>FULLNAT是由淘宝最先实现的一种调度方式，重点解决DS的扩展能力，以及其他一些优化。目前业界的大厂都是基于这个方案来做的。<br>FULLNAT试图消除前面几个方案的不便之处：DR和NAT都需要在同一网段，TUN需要配置ipip模块。<br>下图是基于NAT的流程图做的修改：<br><a href="https://yizhi.ren/linkimage/lvs/fullnatflow.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130185950.png" alt="fullnat flow"></a></p>
<p>可以看到两个明显的差别，一个是DS进行了横向扩展，DS之前增加了一个交换机。一个是RS返回数据不是靠的配置默认网关，而是明确的把数据发往DS。流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1. DS前面的交换机选择一台DS，把请求发送到该DS。<br>2. 参考上面LVS请求的流程，DS修改数据包，源IP改为DS，目的IP改为RS，也修改端口（如果需要），重新封装数据包然后选路将数据包发送给Real Server。<br>3. RS发现请求报文的IP地址是自己的IP地址，就接收此报文，处理请求后正常发送响应报文(源IP是RS，目的IP是DS),将响应报文发给DS。<br>4. DS修改此报文，把源IP给成VIP，目的IP给成CIP。<br></code></pre></td></tr></table></figure>



<p>由此可总结特点如下：<br>从第一点分析，可知需要一个让交换机选择DS的策略，答案就是OSPF。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">OSPF路由协议用于在单一自治系统内决策路由。<br>而OSPF协议支持一个特性叫ECMP,即存在多条到达同一个目的地址的相同开销的路径时，<br>那么发往目的IP的转发流量就可以通过不同路径分担，实现负载均衡。<br></code></pre></td></tr></table></figure>



<p>从第二点分析，DS按照常规流程修改ip和端口，所以支持端口映射。<br>从第三点分析，RS不需要配置默认网关，所以RS可以跨机房跨网段部署。<br>从第四点分析，返回数据需要进行转发，所以需要开启DS的ip_forward.</p>
<p>这个流程其实偏复杂了，因此带来了一些问题，比如</p>
<h5 id="如何透传CIP"><a href="#如何透传CIP" class="headerlink" title="如何透传CIP"></a>如何透传CIP</h5><p>RS这时候是看不到CIP的，只能看到DS的IP，解决办法是DS发给RS的数据包中通过TCP option携带CIP，RS通过toa模块hook获取ip的函数，使返回TCP option中的IP。</p>
<h5 id="DS动态增减"><a href="#DS动态增减" class="headerlink" title="DS动态增减"></a>DS动态增减</h5><p>DS在增减节点的时候，会引起路由改变，某个连接的数据会被发送到不存在该连接session信息的DS上，造成异常，结果就是该连接下线或者重连。解决方法是使用支持一致性hash的交换机（支持的交换机较少所以不太考虑），或者使用session同步，即DS之间互相同步session信息，每个DS都保留一份全量的session表。这样DS节点下线时别的DS也有session信息，所以连接不受影响。新节点上线时，则首先全量同步session信息再把自己加到交换机的下游去。</p>
<h5 id="RS动态增减"><a href="#RS动态增减" class="headerlink" title="RS动态增减"></a>RS动态增减</h5><p>RS在增减节点的时候，可能导致某个客户端新建的连接落不到同一个RS上，这可能会影响某些业务。所以这就要求DS使用一致性算法来调度客户端的连接，同时要求每个DS拥有同样的调度算法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="left">调度方式</th>
<th align="left">端口映射</th>
<th align="left">ip转发</th>
<th align="left">性能</th>
<th align="left">部署</th>
<th align="left">扩展性</th>
<th align="left">其他注意点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NAT</td>
<td align="left">支持</td>
<td align="left">需要</td>
<td align="left">较低</td>
<td align="left">同网段</td>
<td align="left">一般</td>
<td align="left">配默认网关</td>
</tr>
<tr>
<td align="left">DR</td>
<td align="left">不支持</td>
<td align="left">不需要</td>
<td align="left">最高</td>
<td align="left">同网段</td>
<td align="left">一般</td>
<td align="left">arp抑制，绑定VIP</td>
</tr>
<tr>
<td align="left">TUN</td>
<td align="left">不支持</td>
<td align="left">不需要</td>
<td align="left">较高</td>
<td align="left">跨网段</td>
<td align="left">较好</td>
<td align="left">绑定VIP; ipip模块；MSS调整</td>
</tr>
<tr>
<td align="left">FULLNAT</td>
<td align="left">支持</td>
<td align="left">需要</td>
<td align="left">最低</td>
<td align="left">跨网段</td>
<td align="left">最好</td>
<td align="left">OSPF&amp;ECMP；CIP透传；session同步</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]<a href="http://zhxfei.com/2016/08/04/lvs/" target="_blank" rel="noopener">LVS负载均衡集群架设</a><br>[2]<a href="https://www.kancloud.cn/hiyang/linux/360095" target="_blank" rel="noopener">LVS调度方法</a><br>[3]<a href="https://www.linuxidc.com/Linux/2018-11/155542.htm" target="_blank" rel="noopener">LVS负载均衡之LVS-NAT与LVS-DR模式原理详解</a><br>[4]<a href="https://blog.51cto.com/blief/1745134" target="_blank" rel="noopener">LVS负载均衡之工作原理说明（原理篇）</a><br>[5]<a href="https://www.jianshu.com/p/11ee89c54449" target="_blank" rel="noopener">LVS-Ip Tunnel模式应用</a><br>[6]<a href="https://blog.51cto.com/13683137989/1880744" target="_blank" rel="noopener">ip_forward与路由转发</a><br>[7]<a href="https://www.wandouip.com/t5i18683/" target="_blank" rel="noopener">LVS-Ip Tunnel模式应用</a><br>[8]<a href="https://tech.meituan.com/2017/01/05/mgw.html" target="_blank" rel="noopener">美团点评高性能四层负载均衡</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux防火墙REJECT与DROP的区别</title>
    <url>/Linux%E9%98%B2%E7%81%AB%E5%A2%99REJECT%E4%B8%8EDROP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux防火墙内的策略动作有REJECT和DROP两种，区别如下：</p>
<p><strong>1.、REJECT动作会返回一个拒绝(终止)数据包(TCP FIN或UDP-ICMP-PORT-UNREACHABLE)，明确的拒绝对方的连接动作。</strong></p>
<p>连接马上断开，Client会认为访问的主机不存在。</p>
<p>REJECT在IPTABLES里面有一些返回参数，参数如下：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>
<p><strong>2、DROP动作只是简单的直接丢弃数据，并不反馈任何回应。需要Client等待超时，Client容易发现自己被防火墙所阻挡。</strong></p>
<p> 至于使用DROP还是REJECT更合适一直未有定论，因为的确二者都有适用的场合：</p>
<p>1、REJECT是一种更符合规范的处理方式，并且在可控的网络环境中，更易于诊断和调试网络/防火墙所产生的问题；</p>
<p>2、DROP则提供了更高的防火墙安全性和稍许的效率提高，但是由于DROP不很规范(不很符合TCP连接规范)的处理方式，可能<br> 会对你的网络造成一些不可预期或难以诊断的问题。</p>
<p> 因为DROP虽然单方面的中断了连接，但是并不返回任何拒绝信息，因此连接客户端将被动的等到tcp session超时才能判断连接是否成功，这样早企业内部网络中会有一些问题，例如某些客户端程序或应用需要IDENT协议支持(TCP Port 113, RFC 1413)，如果防<br> 火墙未经通知的应用了DROP规则的话，所有的同类连接都会失败，并且由于超时时间，将导致难以判断是<br> 由于防火墙引起的问题还是网络设备/线路故障。 </p>
<p> 注：在部署防火墙时，如果是面向企业内部(或部分可信任网络)，那么最好使用更绅士REJECT<br>方法，对于需要经常变更或调试规则的网络也是如此；而对于面向危险的Internet/Extranet的防火墙，<br> 则有必要使用更为粗暴但是安全的DROP方法，可以在一定程度上延缓黑客攻击的进度(和难度，至少，DROP<br>可以使他们进行TCP-Connect方式端口扫描时间更长)。 </p>
]]></content>
  </entry>
  <entry>
    <title>MMD</title>
    <url>/MMD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MMD"><a href="#MMD" class="headerlink" title="MMD"></a>MMD</h2><iframe width="901" height="507" src="https://www.youtube.com/embed/j54pxZiuZhU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="901" height="507" src="https://www.youtube.com/embed/wbml8gvr5Pk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



<iframe width="901" height="507" src="https://www.youtube.com/embed/jduM9ysWXnw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="901" height="507" src="https://www.youtube.com/embed/L-ZHD7fQM5k" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="901" height="507" src="https://www.youtube.com/embed/Mam2jwox45I" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="927" height="507" src="https://www.youtube.com/embed/vyywOEvD3Xg?list=WL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="901" height="507" src="https://www.youtube.com/embed/r1mhfrC1xjw?list=WL" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
  </entry>
  <entry>
    <title>Nginx 配置之性能篇</title>
    <url>/Nginx-%E9%85%8D%E7%BD%AE%E4%B9%8B%E6%80%A7%E8%83%BD%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在介绍完我博客（imququ.com）的 Nginx 配置中<a href="https://imququ.com/post/my-nginx-conf-for-security.html" target="_blank" rel="noopener">与安全有关的一些配置</a>后，这篇文章继续介绍与性能有关的一些配置。WEB 性能优化是一个系统工程，涵盖很多方面，做好其中某个环节并不意味性能就能变好，但可以肯定地说，如果某个环节做得很糟糕，那么结果一定会变差。</p>
<p>首先说明下，本文提到的一些 Nginx 配置，需要较高版本 Linux 内核才支持。在实际生产环境中，升级服务器内核并不是一件容易的事，但为了获得最好的性能，有些升级还是必须的。很多公司服务器运维和项目开发并不在一个团队，一方追求稳定不出事故，另一方希望提升性能，本来就是矛盾的。好在我们折腾自己 VPS 时，可以无视这些限制。</p>
<h3 id="TCP-优化"><a href="#TCP-优化" class="headerlink" title="TCP 优化"></a>TCP 优化</h3><p>Nginx 关于 TCP 的优化基本都是修改系统内核提供的配置项，所以跟具体的 Linux 版本和系统配置有关，我对这一块还不是非常熟悉，这里只能简单介绍下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">NGINXhttp</span> &#123;<br>    <span class="hljs-attribute">sendfile</span>           <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nopush</span>         <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nodelay</span>        <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">60</span>;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一行的 <code>sendfile</code> 配置可以提高 Nginx 静态资源托管效率。sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。</p>
<p>TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 <code>tcp_nopush</code> 来控制它，并且只有在启用了 sendfile 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。</p>
<p>TCP_NODELAY 也是一个 socket 选项，启用后会禁用 Nagle 算法，尽快发送数据，某些情况下可以节约 200ms（Nagle 算法原理是：在发出去的数据还未被确认之前，新生成的小数据先存起来，凑满一个 MSS 或者等到收到确认后再发送）。Nginx 只会针对处于 keep-alive 状态的 TCP 连接才会启用 <code>tcp_nodelay</code>。</p>
<p>可以看到 TCP_NOPUSH 是要等数据包累积到一定大小才发送，TCP_NODELAY 是要尽快发送，二者相互矛盾。实际上，它们确实可以一起用，最终的效果是先填满包，再尽快发送。</p>
<p>关于这部分内容的更多介绍可以看这篇文章：<a href="https://t37.net/nginx-optimization-understanding-sendfile-tcp_nodelay-and-tcp_nopush.html" target="_blank" rel="noopener">NGINX OPTIMIZATION: UNDERSTANDING SENDFILE, TCP_NODELAY AND TCP_NOPUSH</a>。</p>
<p>配置最后一行用来指定服务端为每个 TCP 连接最多可以保持多长时间。Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒，所以我统一设置为 60。</p>
<p>另外，还有一个 TCP 优化策略叫 TCP Fast Open（TFO），这里先介绍下，配置在后面贴出。TFO 的作用是用来优化 TCP 握手过程。客户端第一次建立连接还是要走三次握手，所不同的是客户端在第一个 SYN 会设置一个 Fast Open 标识，服务端会生成 Fast Open Cookie 并放在 SYN-ACK 里，然后客户端就可以把这个 Cookie 存起来供之后的 SYN 用。下面这个图形象地描述了这个过程：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003249.webp" alt="tcp fast open"></p>
<p>关于 TCP Fast Open 的更多信息，可以查看 <a href="https://www.rfc-editor.org/rfc/rfc7413.txt" target="_blank" rel="noopener">RFC7413</a>，或者这篇文章：<a href="https://bradleyf.id.au/nix/shaving-your-rtt-wth-tfo/" target="_blank" rel="noopener">Shaving your RTT with TCP Fast Open</a>。需要注意的是，现阶段只有 Linux、ChromeOS 和 Android 5.0 的 Chrome / Chromium 才支持 TFO，所以实际用途并不大。</p>
<p>5 月 26 日发布的 Nginx 1.9.1，增加了 <code>reuseport</code> 功能，意味着 Nginx 也开始支持 TCP 的 SO_REUSEPORT 选项了。这里也先简单介绍下，具体配置方法后面统一介绍。启用这个功能后，Nginx 会在指定的端口上监听多个 socket，每个 Worker 都能分到一个。请求过来时，系统内核会自动通过不同的 socket 分配给对应的 Worker，相比之前的单 socket 多 Worker 的模式，提高了分发效率。下面这个图形象地描述了这个过程：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003259.webp" alt="tcp reuseport"></p>
<p>有关这部分内容的更多信息，可以查看 Nginx 的官方博客：<a href="http://nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">Socket Sharding in NGINX Release 1.9.1</a>。</p>
<h3 id="开启-Gzip"><a href="#开启-Gzip" class="headerlink" title="开启 Gzip"></a>开启 Gzip</h3><p>我们在上线前，代码（JS、CSS 和 HTML）会做压缩，图片也会做压缩（PNGOUT、Pngcrush、JpegOptim、Gifsicle 等）。对于文本文件，在服务端发送响应之前进行 GZip 压缩也很重要，通常压缩后的文本大小会减小到原来的 1/4 - 1/3。下面是我的配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">NGINXhttp</span> &#123;<br>    <span class="hljs-attribute">gzip</span>               <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">gzip_vary</span>          <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-attribute">gzip_comp_level</span>    <span class="hljs-number">6</span>;<br>    <span class="hljs-attribute">gzip_buffers</span>       <span class="hljs-number">16</span> <span class="hljs-number">8k</span>;<br><br>    <span class="hljs-attribute">gzip_min_length</span>    <span class="hljs-number">1000</span>;<br>    <span class="hljs-attribute">gzip_proxied</span>       any;<br>    <span class="hljs-attribute">gzip_disable</span>       <span class="hljs-string">"msie6"</span>;<br><br>    <span class="hljs-attribute">gzip_http_version</span>  <span class="hljs-number">1</span>.<span class="hljs-number">0</span>;<br><br>    <span class="hljs-attribute">gzip_types</span>         text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这部分内容比较简单，只有两个地方需要解释下：</p>
<p><code>gzip_vary</code> 用来输出 Vary 响应头，用来解决某些缓存服务的一个问题，详情请看我之前的博客：<a href="https://imququ.com/post/vary-header-in-http.html" target="_blank" rel="noopener">HTTP 协议中 Vary 的一些研究</a>。</p>
<p><code>gzip_disable</code> 指令接受一个正则表达式，当请求头中的 UserAgent 字段满足这个正则时，响应不会启用 GZip，这是为了解决在某些浏览器启用 GZip 带来的问题。特别地，指令值 <code>msie6</code> 等价于 <code>MSIE [4-6]\.</code>，但性能更好一些。另外，Nginx 0.8.11 后，<code>msie6</code> 并不会匹配 UA 包含 <code>SV1</code> 的 IE6（例如 Windows XP SP2 上的 IE6），因为这个版本的 IE6 已经修复了关于 GZip 的若干 Bug。</p>
<p>默认 Nginx 只会针对 HTTP/1.1 及以上的请求才会启用 GZip，因为部分早期的 HTTP/1.0 客户端在处理 GZip 时有 Bug。现在基本上可以忽略这种情况，于是可以指定 <code>gzip_http_version 1.0</code> 来针对 HTTP/1.0 及以上的请求开启 GZip。</p>
<h3 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h3><p>优化代码逻辑的极限是移除所有逻辑；优化请求的极限是不发送任何请求。这两点通过缓存都可以实现。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>我的博客更新并不频繁，评论部分也早就换成了 Disqus，所以完全可以将页面静态化，这样就省掉了所有代码逻辑和数据库开销。实现静态化有很多种方案，我直接用的是 Nginx 的 proxy_cache（注：本博客为了做更精细的静态化，已经将缓存逻辑挪到 Web 应用里实现了）：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">NGINXproxy_cache_path</span>  /home/jerry/cache/nginx/proxy_cache_path levels=<span class="hljs-number">1</span>:<span class="hljs-number">2</span> keys_zone=pnc:<span class="hljs-number">300m</span> inactive=<span class="hljs-number">7d</span> max_size=<span class="hljs-number">10g</span>;<br><span class="hljs-attribute">proxy_temp_path</span>   /home/jerry/cache/nginx/proxy_temp_path;<br><span class="hljs-attribute">proxy_cache_key</span>   <span class="hljs-variable">$host</span><span class="hljs-variable">$uri</span><span class="hljs-variable">$is_args</span><span class="hljs-variable">$args</span>;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">resolver</span>                  <span class="hljs-number">127.0.0.1</span>;  <br>        <span class="hljs-attribute">proxy_cache</span>               pnc;<br>        <span class="hljs-attribute">proxy_cache_valid</span>         <span class="hljs-number">200</span> <span class="hljs-number">304</span> <span class="hljs-number">2h</span>;<br>        <span class="hljs-attribute">proxy_cache_lock</span>          <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">proxy_cache_lock_timeout</span>  <span class="hljs-number">5s</span>;<br>        <span class="hljs-attribute">proxy_cache_use_stale</span>     updating <span class="hljs-literal">error</span> timeout invalid_header http_500 http_502;<br><br>        <span class="hljs-attribute">proxy_http_version</span>        <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br><br>        <span class="hljs-attribute">proxy_ignore_headers</span>      Set-Cookie;<br>        ... ...<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，在配置最外层定义一个缓存目录，并指定名称（keys_zone）和其他属性，这样在配置 proxy_pass 时，就可以使用这个缓存了。这里我对状态值等于 200 和 304 的响应缓存了 2 小时。</p>
<p>默认情况下，如果响应头里有 Set-Cookie 字段，Nginx 并不会缓存这次响应，因为它认为这次响应的内容是因人而异的。我的博客中，这个 Set-Cookie 对于用户来说没有用，也不会影响输出内容，所以我通过配置 <code>proxy_ignore_header</code> 移除了它。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>服务端在输出响应时，可以通过响应头输出一些与缓存有关的信息，从而达到少发或不发请求的目的。HTTP/1.1 的缓存机制稍微有点复杂，这里简单介绍下：</p>
<p>首先，服务端可以通过响应头里的 <code>Last-Modified</code>（最后修改时间） 或者 <code>ETag</code>（内容特征） 标记实体。浏览器会存下这些标记，并在下次请求时带上 <code>If-Modified-Since: 上次 Last-Modified 的内容</code> 或 <code>If-None-Match: 上次 ETag 的内容</code>，询问服务端资源是否过期。如果服务端发现并没有过期，直接返回一个状态码为 304、正文为空的响应，告知浏览器使用本地缓存；如果资源有更新，服务端返回状态码 200、新的 Last-Modified、Etag 和正文。这个过程被称之为 HTTP 的协商缓存，通常也叫做弱缓存。</p>
<p>可以看到协商缓存并不会节省连接数，但是在缓存生效时，会大幅减小传输内容（304 响应没有正文，一般只有几百字节）。另外为什么有两个响应头都可以用来实现协商缓存呢？这是因为一开始用的 <code>Last-Modified</code> 有两个问题：1）只能精确到秒，1 秒内的多次变化反映不出来；2）<del>时间采用绝对值，如果服务端 / 客户端时间不对都可能导致缓存失效</del>在轮询的负载均衡算法中，如果各机器读到的文件修改时间不一致，有缓存无故失效和缓存不更新的风险。HTTP/1.1 并没有规定 <code>ETag</code> 的生成规则，而一般实现者都是对资源内容做摘要，能解决前面两个问题。</p>
<p>另外一种缓存机制是服务端通过响应头告诉浏览器，在什么时间之前（Expires）或在多长时间之内（Cache-Control: Max-age=xxx），不要再请求服务器了。这个机制我们通常称之为 HTTP 的强缓存。</p>
<p>一旦资源命中强缓存规则后，再次访问完全没有 HTTP 请求（Chrome 开发者工具的 Network 面板依然会显示请求，但是会注明 from cache；Firefox 的 firebug 也类似，会注明 BFCache），这会大幅提升性能。所以我们一般会对 CSS、JS、图片等资源使用强缓存，而入口文件（HTML）一般使用协商缓存或不缓存，这样可以通过修改入口文件中对强缓存资源的引入 URL 来达到即时更新的目的。</p>
<p>这里也解释下为什么有了 <code>Expires</code>，还要有 <code>Cache-Control</code>。也有两个原因：1）Cache-Control 功能更强大，对缓存的控制能力更强；2）Cache-Control 采用的 max-age 是相对时间，不受服务端 / 客户端时间不对的影响。</p>
<p>另外关于浏览器的刷新（F5 / cmd + r）和强刷（Ctrl + F5 / shift + cmd +r）：普通刷新会使用协商缓存，忽略强缓存；强刷会忽略浏览器所有缓存（并且请求头会携带 Cache-Control:no-cache 和 Pragma:no-cache，用来通知所有中间节点忽略缓存）。只有从地址栏或收藏夹输入网址、点击链接等情况下，浏览器才会使用强缓存。</p>
<p>默认情况下，Nginx 对于静态资源都会输出 <code>Last-Modified</code>，而 <code>ETag</code>、<code>Expires</code> 和 <code>Cache-Control</code> 则需要自己配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">NGINXlocation</span> <span class="hljs-regexp">~ ^/static/</span> &#123;<br>    <span class="hljs-attribute">root</span>      /home/jerry/www/blog/www;<br>    <span class="hljs-attribute">etag</span>      <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">expires</span>   max;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>expires</code> 指令可以指定具体的 max-age，例如 <code>10y</code> 代表 10 年，如果指定为 <code>max</code>，最终输出的 <code>Expires</code> 会是 2037 年最后一天，<code>Cache-Control</code> 的 <code>max-age</code> 会是 10 年（准确说是 3650 天，315360000 秒）。</p>
<h3 id="使用-SPDY（HTTP-2）"><a href="#使用-SPDY（HTTP-2）" class="headerlink" title="使用 SPDY（HTTP/2）"></a>使用 SPDY（HTTP/2）</h3><p>我的博客之前多次讲到过 HTTP/2（SPDY），现阶段 Nginx 只支持 SPDY/3.1，这样配置就可以启用了（编译 Nginx 时需要加上 –with-http_spdy_module 和 –with-http_ssl_module）：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">NGINXserver</span> &#123;<br>    <span class="hljs-attribute">listen</span>             <span class="hljs-number">443</span> ssl spdy fastopen=<span class="hljs-number">3</span> reuseport;<br>    <span class="hljs-attribute">spdy_headers_comp</span>  <span class="hljs-number">6</span>;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那个 <code>fastopen=3</code> 用来开启前面介绍过的 TCP Fast Open 功能。3 代表最多只能有 3 个未经三次握手的 TCP 链接在排队。超过这个限制，服务端会退化到采用普通的 TCP 握手流程。这是为了减少资源耗尽攻击：TFO 可以在第一次 SYN 的时候发送 HTTP 请求，而服务端会校验 Fast Open Cookie（FOC），如果通过就开始处理请求。如果不加限制，恶意客户端可以利用合法的 FOC 发送大量请求耗光服务端资源。</p>
<p><code>reuseport</code> 就是用来启用前面介绍过的 TCP SO_REUSEPORT 选项的配置。</p>
<h3 id="HTTPS-优化"><a href="#HTTPS-优化" class="headerlink" title="HTTPS 优化"></a>HTTPS 优化</h3><p>建立 HTTPS 连接本身就慢（多了获取证书、校验证书、TLS 握手等等步骤），如果没有优化好只能是慢上加慢。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">NGINXserver</span> &#123;<br>    <span class="hljs-attribute">ssl_session_cache</span>        shared:SSL:<span class="hljs-number">10m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span>      <span class="hljs-number">60m</span>;<br><br>    <span class="hljs-attribute">ssl_session_tickets</span>      <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-attribute">ssl_stapling</span>             <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">ssl_stapling_verify</span>      <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">ssl_trusted_certificate</span>  /xxx/full_chain.crt;<br><br>    <span class="hljs-attribute">resolver</span>                 <span class="hljs-number">8.8.4.4</span> <span class="hljs-number">8.8.8.8</span>  valid=<span class="hljs-number">300s</span>;<br>    <span class="hljs-attribute">resolver_timeout</span>         <span class="hljs-number">10s</span>;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我的这部分配置就两部分内容：TLS 会话恢复和 OCSP stapling。</p>
<p>TLS 会话恢复的目的是为了简化 TLS 握手，有两种方案：Session Cache 和 Session Ticket。他们都是将之前握手的 Session 存起来供后续连接使用，所不同是 Cache 存在服务端，占用服务端资源；Ticket 存在客户端，不占用服务端资源。另外目前主流浏览器都支持 Session Cache，而 Session Ticket 的支持度一般。</p>
<p><code>ssl_stapling</code> 开始的几行用来配置 OCSP stapling 策略。浏览器可能会在建立 TLS 连接时在线验证证书有效性，从而阻塞 TLS 握手，拖慢整体速度。OCSP stapling 是一种优化措施，服务端通过它可以在证书链中封装证书颁发机构的 OCSP（Online Certificate Status Protocol）响应，从而让浏览器跳过在线查询。服务端获取 OCSP 一方面更快（因为服务端一般有更好的网络环境），另一方面可以更好地缓存。有关 OCSP stapling 的详细介绍，可以<a href="https://raymii.org/s/tutorials/OCSP_Stapling_on_nginx.html" target="_blank" rel="noopener">看这里</a>。</p>
<p>这些策略设置好之后，可以通过 <a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">Qualys SSL Server Test</a> 这个工具来验证是否生效，例如下图就是本博客的测试结果（<a href="https://www.ssllabs.com/ssltest/analyze.html?d=imququ.com" target="_blank" rel="noopener">via</a>）：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003300.webp" alt="Qualys server ssl test"></p>
<p>在给 Nginx 指定证书时，需要选择合适的证书链。因为浏览器在验证证书信任链时，会从站点证书开始，递归验证父证书，直至信任的根证书。这里涉及到两个问题：1）服务器证书是在握手期间发送的，由于 TCP 初始拥塞窗口的存在，如果证书太长很可能会产生额外的往返开销；2）如果服务端证书没包含中间证书，大部分浏览器可以正常工作，但会暂停验证并根据子证书指定的父证书 URL 自己获取中间证书。这个过程会产生额外的 DNS 解析、建立 TCP 连接等开销。配置服务端证书链的最佳实践是包含<strong>站点证书</strong>和<strong>中间证书</strong>两部分。有的证书提供商签出来的证书级别比较多，这会导致证书链变长，选择的时候需要特别注意。</p>
<p>好了，我的博客关于安全和性能两部分 Nginx 配置终于都写完了。实际上很多策略没办法严格区分是为了安全还是性能，比如 HSTS 和 CHACHA20_POLY1305，两方面都有考虑，所以写的时候比较纠结，早知道就合成一篇来写了。</p>
<p>本文链接：<a href="https://imququ.com/post/my-nginx-conf-for-wpo.html，[参与评论" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-wpo.html，[参与评论</a> »](<a href="https://imququ.com/post/my-nginx-conf-for-wpo.html#comments" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-wpo.html#comments</a>)</p>
<p>–EOF–</p>
]]></content>
  </entry>
  <entry>
    <title>Nginx操作记录</title>
    <url>/Nginx%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#yum info libevent</span><br>[root@ashjian ~]<span class="hljs-comment">#yum info nginx</span><br>Name        : nginx<br>Arch        : x86_64<br>Epoch       : 1<br>Version     : 1.16.1<br>Release     : 1.el7<br>Size        : 562 k<br>Repo        : epel/7/x86_64<br>Summary     : A high performance web server and reverse proxy server<br>URL         : http://nginx.org/<br>License     : BSD<br>Description : Nginx is a web server and a reverse proxy server <span class="hljs-keyword">for</span> HTTP, SMTP, POP3 and<br>            : IMAP protocols, with a strong focus on high concurrency, performance and low<br>            : memory usage.<br><br><span class="hljs-comment">#yum安装</span><br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/yum.repos.d/nginx.repo #如果使用最新的，可以使用官方的yum仓库</span><br>[nginx]<br>name=nginx repository<br>baseurl=http://nginx.org/packages/centos/7/x86_64/<br>gpgcheck=0<br>[root@ashjian ~]<span class="hljs-comment">#yum repolist</span><br>Loaded plugins: fastestmirror, langpacks<br>Repository epel is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel-debuginfo is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Repository epel-source is listed more than once <span class="hljs-keyword">in</span> the configuration<br>Loading mirror speeds from cached hostfile<br> * base: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.aliyun.com<br>base                                                                               | 3.6 kB  00:00:00     <br>epel                                                                               | 4.7 kB  00:00:00     <br>extras                                                                             | 2.9 kB  00:00:00     <br>nginx                                                                              | 2.9 kB  00:00:00     <br>updates                                                                            | 2.9 kB  00:00:00     <br>(1/3): epel/7/x86_64/updateinfo                                                    | 1.0 MB  00:00:00     <br>(2/3): epel/7/x86_64/primary_db                                                    | 6.9 MB  00:00:00     <br>(3/3): nginx/primary_db                                                            |  56 kB  00:00:04     <br>repo id                               repo name                                                     status<br>base/7/x86_64                         CentOS-7 - Base - mirrors.aliyun.com                          10,070<br>epel/7/x86_64                         EPEL <span class="hljs-keyword">for</span> redhat/centos 7 - x86_64                             13,452<br>extras/7/x86_64                       CentOS-7 - Extras - mirrors.aliyun.com                           413<br>nginx                                 nginx repository                                                 194<br>updates/7/x86_64                      CentOS-7 - Updates - mirrors.aliyun.com                        1,134<br>repolist: 25,263<br> <br>[root@ashjian ~]<span class="hljs-comment">#yum info nginx </span><br>Name        : nginx<br>Arch        : x86_64<br>Epoch       : 1<br>Version     : 1.18.0    <span class="hljs-comment">#再次查看，版本已经更新，查了最新版本两三个服版本号</span><br>Release     : 1.el7.ngx<br>Size        : 772 k<br>Repo        : nginx<br>Summary     : High performance web server<br>URL         : http://nginx.org/<br>License     : 2-clause BSD-like license<br>Description : nginx [engine x] is an HTTP and reverse proxy server, as well as<br>            : a mail proxy server.<br>[root@ashjian ~]<span class="hljs-comment">#yum install nginx </span><br><br><span class="hljs-comment">#手动安装# yum groupinstall "Development Tools" "Server Platform Development"</span><br><span class="hljs-comment"># yum install pcre-devel openssl-devel zlib-devel #pcre用来正则表达式，zlib用于支持传输压缩格式</span><br><span class="hljs-comment"># useradd -r nginx</span><br><span class="hljs-comment">#  ./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_dav_module --with-http_stub_status_module --with-threads --with-file-aio</span><br><span class="hljs-comment">#make &amp;&amp; make install</span><br>[root@ashjian ~]<span class="hljs-comment">#cat /usr/lib/systemd/system/nginx.service  #参考yum install 的Unit启动服务文件，写一个文件，即可开机自启</span><br>[Unit]<br>Description=nginx - high performance web server<br>Documentation=http://nginx.org/en/docs/<br>After=network-online.target remote-fs.target nss-lookup.target<br>Wants=network-online.target<br><br>[Service]<br>Type=forking<br>PIDFile=/var/run/nginx.pid<br>ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf<br>ExecReload=/bin/<span class="hljs-built_in">kill</span> -s HUP <span class="hljs-variable">$MAINPID</span><br>ExecStop=/bin/<span class="hljs-built_in">kill</span> -s TERM <span class="hljs-variable">$MAINPID</span><br><br>[Install]<br>WantedBy=multi-user.target<br><br><br>[root@ashjian ~]<span class="hljs-comment">#rpm -ql nginx</span><br>/etc/logrotate.d/nginx<br>/etc/nginx<br>/etc/nginx/conf.d <span class="hljs-comment">#好像只有官方yum安装的有模块化配置，使用系统yum安装的也可以手动创建</span><br>/etc/nginx/conf.d/default.conf<br>/etc/nginx/fastcgi_params<br>/etc/nginx/koi-utf<br>/etc/nginx/koi-win<br>/etc/nginx/mime.types<br>/etc/nginx/modules<br>/etc/nginx/nginx.conf <span class="hljs-comment">#主配置文件</span><br>/etc/nginx/scgi_params<br>/etc/nginx/uwsgi_params<br>/etc/nginx/win-utf<br>/etc/sysconfig/nginx<br>/etc/sysconfig/nginx-debug<br>/usr/lib/systemd/system/nginx-debug.service<br>/usr/lib/systemd/system/nginx.service<br>/usr/lib64/nginx<br>/usr/lib64/nginx/modules<br>/usr/libexec/initscripts/legacy-actions/nginx<br>/usr/libexec/initscripts/legacy-actions/nginx/check-reload<br>/usr/libexec/initscripts/legacy-actions/nginx/upgrade<br>/usr/sbin/nginx<br>/usr/sbin/nginx-debug<br>/usr/share/doc/nginx-1.18.0<br>/usr/share/doc/nginx-1.18.0/COPYRIGHT<br>/usr/share/man/man8/nginx.8.gz<br>/usr/share/nginx<br>/usr/share/nginx/html<br>/usr/share/nginx/html/50x.html<br>/usr/share/nginx/html/index.html<br>/var/cache/nginx<br>/var/<span class="hljs-built_in">log</span>/nginx<br><br><br>user  nginx;<br>worker_processes  1;<br><br>error_log  /var/<span class="hljs-built_in">log</span>/nginx/error.log warn;<br>pid        /var/run/nginx.pid;<br><br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br>http &#123; <span class="hljs-comment">#注意操作系统版本这里为server</span><br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  <span class="hljs-string">'$remote_addr - $remote_user [$time_local] "$request" '</span><br>                      <span class="hljs-string">'$status $body_bytes_sent "$http_referer" '</span><br>                      <span class="hljs-string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;<br><span class="hljs-comment">#http_x_forwarded_for是代理客户的真正ip地址</span><br>    access_log  /var/<span class="hljs-built_in">log</span>/nginx/access.log  main; <span class="hljs-comment">#访问日志文件</span><br><br>    sendfile            on;<span class="hljs-comment">#由内核负责分发响应报文，提高性能</span><br>    tcp_nopush          on;<span class="hljs-comment">#在sendfile开启才有效。将响应头和正文的开始部分一起发送，一次性发送整个文件。</span><br>    tcp_nodelay         on;<span class="hljs-comment">#禁止tcp的nagle算法。小数据包能立即发送。只对长连接有效</span><br>    keepalive_timeout   65;<span class="hljs-comment">#长连接超时时间65秒</span><br>    types_hash_max_size 2048;<span class="hljs-comment">#nignx的哈希值表占用内存大小的最大值。。单位是项</span><br><br>    include             /etc/nginx/mime.types;<span class="hljs-comment">#支持mime类型</span><br>    default_type        application/octet-stream;<br><br>     include /etc/nginx/conf.d/*.conf;<span class="hljs-comment">#可以自定义自己的虚拟主机.conf配置</span><br>     server &#123;<br>        listen       80 default_server; <span class="hljs-comment">#default_server意味默认的虚拟主机</span><br>        listen       [::]:80 default_server;<br>        server_name  _; <span class="hljs-comment">#主机名，_代表能匹配所有其他有名字的主机不能匹配，则由我来匹配</span><br>        root         /usr/share/nginx/html; <span class="hljs-comment">#目录根路径</span><br><br>        <span class="hljs-comment"># Load configuration files for the default server block.</span><br>        include /etc/nginx/default.d/*.conf;<br><br>        location / &#123; <span class="hljs-comment">#location 用来定义各种设置</span><br>        &#125;<br><br>        error_page 404 /404.html;<br>            location = /40x.html &#123;<br>        &#125;<br><br>        error_page 500 502 503 504 /50x.html;<br>            location = /50x.html &#123;<br>        &#125;<br>    &#125;<br><br>&#125;  <br><br>[root@ashjian ~]<span class="hljs-comment">#systemctl stop httpd.service </span><br>[root@ashjian ~]<span class="hljs-comment">#systemctl start nginx.service #niginx默认安装后即可启动，有一个默认网页</span><br><br>[root@ashjian ~]<span class="hljs-comment">#ps aunx</span><br>       0 31415  0.0  0.0  46460   964 ?        Ss   19:30   0:00 nginx: master process /usr/sbin/nginx -c <br>     994 31416  0.0  0.1  48936  2248 ?        S    19:30   0:00 nginx: worker process <span class="hljs-comment">#丫的，居然买的云主机只有一个cpu核，默认只有一个worker进程</span><br><br><br><span class="hljs-comment">#看了老师的操作是用操作系统epel的nginx，发现和我用的nginx官方的主配置文件有点区别，而且官方安装只有一个包，而操作系统的epel有多个模块包的依赖安装，我学习用还是用回了操作系统epel提供的nginx了</span><br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/nginx/nginx.conf</span><br>user nginx;<br>worker_processes auto; <span class="hljs-comment">#指定worker的进程数，auto代表启动后，会根据自动扫描主机有多少个物理CPU核数，然后产生多少个worker进程数，听老师说worker进程数不宜超过物理CPU核数，性能提升不大。而官方版这里默认为1，建议改为auto。</span><br>error_log /var/<span class="hljs-built_in">log</span>/nginx/error.log;<br>pid /run/nginx.pid;<br><br>events &#123;<br>    worker_connections 1024; <span class="hljs-comment">#单进程最多响应1024个请求。要想增加处理请求数最大值，增加worker_processes进程数意义不大，所以建议增加worker_connections最大请求数值，比如改成10240</span><br>&#125;<br><br><br>[root@ashjian ~]<span class="hljs-comment">#nginx -t #语法检查</span><br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok<br>nginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful<br><br>[root@ashjian ~]<span class="hljs-comment">#nginx -h</span><br>nginx version: nginx/1.16.1<br>Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]<br><br>Options:<br>  -?,-h         : this <span class="hljs-built_in">help</span><br>  -v            : show version and <span class="hljs-built_in">exit</span><br>  -V            : show version and configure options <span class="hljs-keyword">then</span> <span class="hljs-built_in">exit</span><br>  -t            : <span class="hljs-built_in">test</span> configuration and <span class="hljs-built_in">exit</span><br>  -T            : <span class="hljs-built_in">test</span> configuration, dump it and <span class="hljs-built_in">exit</span><br>  -q            : suppress non-error messages during configuration testing<br>  -s signal     : send signal to a master process: stop, quit, reopen, reload<br>  -p prefix     : <span class="hljs-built_in">set</span> prefix path (default: /usr/share/nginx/)<br>  -c filename   : <span class="hljs-built_in">set</span> configuration file (default: /etc/nginx/nginx.conf)<br>  -g directives : <span class="hljs-built_in">set</span> global directives out of configuration file<br> <br> [root@ashjian ~]<span class="hljs-comment">#nginx -s reload #如果进程还在，用信号reload</span><br><br>[root@ashjian ~]<span class="hljs-comment">#lscpu</span><br>CPU(s):                1 <span class="hljs-comment">#我的主机只有一个核心</span><br><br>[root@ashjian ~]<span class="hljs-comment">#ll /usr/share/nginx/modules/</span><br>total 20<br>-rw-r--r--. 1 root root 72 Oct  3  2019 mod-http-image-filter.conf<br>-rw-r--r--. 1 root root 64 Oct  3  2019 mod-http-perl.conf<br>-rw-r--r--. 1 root root 71 Oct  3  2019 mod-http-xslt-filter.conf<br>-rw-r--r--. 1 root root 59 Oct  3  2019 mod-mail.conf<br>-rw-r--r--. 1 root root 61 Oct  3  2019 mod-stream.conf<br><br><span class="hljs-comment">#创建虚拟机</span><br>[root@ashjian ~]<span class="hljs-comment">#mkdir -pv /data/nginx/vhost1</span><br>[root@ashjian ~]<span class="hljs-comment">#vim /data/nginx/vhost1/index.html</span><br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/nginx/conf.d/vhost1.conf</span><br>server &#123;<br>        listen 80;<br>        server_name www.ashjian.xyz;<br>        root /data/nginx/vhost1;<br>&#125;<br>[root@ashjian ~]<span class="hljs-comment">#nginx -t</span><br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok<br>nginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful<br>[root@ashjian ~]<span class="hljs-comment">#nginx -s reload</span><br>~   <br>[root@ashjian ~]<span class="hljs-comment">#ps axo comm,pid,psr | grep nginx #查看nginx的进程运行在那颗cpu核心上，cpu核心从0开始编号</span><br>nginx            2351   0<br>nginx           17208   0<br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/nginx/nginx.conf</span><br>worker_cpu_affinity 1000 0100 0010 0001;  <span class="hljs-comment">#假如有4颗cpu，依次3210的顺序绑定worker进程</span><br>[root@ashjian ~]<span class="hljs-comment">#yum info httpd-tools #下载包含ab压测命令的包</span><br>[root@ashjian ~]<span class="hljs-comment">#ab -n 100000 -c 100 www.ashjian.xyz</span><br>[root@ashjian ~]<span class="hljs-comment">#watch -n.5 'ps axo comm,pid,psr | grep nginx'</span><br><br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/nginx/nginx.conf</span><br>worker_priority -5;<span class="hljs-comment">#要调整调整优先级nice-5</span><br>worker_rlimit_nofile 65536;<span class="hljs-comment">#所有worker进程能打开的文件数量最大值,。因为处理并发连接需要套接字文件，所以必须大于（woker进程数*单个worker进程最大并发处理请求数）</span><br><br><span class="hljs-comment">#省略一下其他模块配置了，有空才补回来</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#nginx部署hexo的静态网页</span><br>[root@ashjian conf.d]<span class="hljs-comment">#mkdir /etc/nginx/ssl</span><br>[root@ashjian conf.d]<span class="hljs-comment">#ll /etc/nginx/ssl</span><br>total 8<br>-rw-r--r--. 1 root root 3769 Sep  7 10:43 1_www.ashjian.xyz_bundle.crt<br>-rw-r--r--. 1 root root 1700 Sep  7 10:43 2_www.ashjian.xyz.key<br>[root@ashjian conf.d]<span class="hljs-comment">#vim /etc/nginx/conf.d/hexoBlog.conf </span><br>server &#123;<br>        listen 443 ssl;<br>        server_name www.ashjian.xyz;<br>        root /ashjian/blog/public/;<br>        <span class="hljs-comment">#root /var/www/html/;</span><br>        charset utf-8; <span class="hljs-comment">#避免url里面的中文乱码</span><br>        autoindex on;  <span class="hljs-comment">#类似httpd 的option的Indexes选项，允许查看网页目录                                                                                    </span><br>        ssl_protocols   TLSv1 TLSv1.1 TLSv1.2;<br>        ssl_certificate /etc/nginx/ssl/1_www.ashjian.xyz_bundle.crt;<br>        ssl_certificate_key /etc/nginx/ssl/2_www.ashjian.xyz.key;<br>        ssl_session_cache shared:SSLcache:20m;<br>        ssl_session_timeout 10m;<br>        gzip on;<br>        gzip_comp_level 6;<br>        gzip_min_length 64;<br>        gzip_proxied any;<br>        gzip_types text/tml text/css application/javascript videos/mp4;<br>        location /self &#123;<br>        <span class="hljs-built_in">alias</span> /var/www/html/;<br>&#125;<br>&#125;<br>server &#123;<br>        listen 80;<br>        server_name www.ashjian.xyz;<br>        <span class="hljs-comment">#root /ashjian/blog/public/;</span><br>        root /var/www/html;<br>        rewrite /(.*)$ https://www.ashjian.xyz/<span class="hljs-variable">$1</span>;<br>        rewrite http:www.ashjian.xyz https://www.ashjian.xyz;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Nginx缓存原理及机制</title>
    <url>/Nginx%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上篇文章介绍了Nginx一个较为重要的知识点：Nginx实现接口限流。本篇文章将介绍Nginx另一个重要知识点：Nginx缓存原理。其实说到缓存技术大家应该都不会很陌生，缓存技术的基本思想其实是对用户已经访问过的内容在Nginx建立副本，如果在一段时间内(缓存尚未过期)再次访问该数据，则不需要重新发起请求获取数据，可以直接从缓存中读取到该数据，好处在于减少了Nginx与后端服务之间的网络交互，减轻了网络的压力，而且在减少数据传输的延迟时同时可以提升用户访问速度。而且如果碰上后端服务出现异常时，还可以通过缓存进行相应用户请求，提高了后端服务的稳定性。</p>
<p><strong>什么是Nginx缓存？</strong></p>
<p>Nginx基于Proxy Store实现，使用Nginx的http_proxy模块可以实现类似于squid的缓存功能。当启用缓存时，Nginx会将相应数据保存在磁盘缓存中，只要缓存数据尚未过期，就会使用缓存数据来响应客户端的请求。</p>
<p><strong>如何启用缓存？</strong></p>
<p>Nginx启用缓存需要在最顶层的http节点下配置proxy_cache_path命令。我们先看看proxy_cache_path命令的语法结构：</p>
<ul>
<li>proxy_cache_path /data/cache keys_zone=niyueling:10m;</li>
</ul>
<p>可以看到proxy_cache_path命令一共包含两个参数，第一个参数指定缓存保存的本地路径，第二个参数定义缓存数据的共享内存区域的名称和内存区大小。Nginx启动后，缓存加载程序只进行加载一次，加载时会将缓存的元数据加载到共享内存区域，但是如果一次加载整个缓存全部内容可能会使Nginx刚启动的前几分钟性能消耗严重，大幅度降低Nginx的性能。所以可以在proxy_cache_path命令中配置缓存迭代加载。缓存迭代加载一共可以设置三个参数：</p>
<ul>
<li>loader_threshold - 迭代的持续时间，以毫秒为单位(默认为200)</li>
<li>loader_files - 在一次迭代期间加载的最大项目数(默认为100)</li>
<li>loader_sleeps - 迭代之间的延迟(以毫秒为单位)(默认为50)</li>
</ul>
<p>我们可以看下一个小例子：</p>
<ul>
<li>proxy_cache_path /data/cache keys_zone=niyueling:10m loader_threshold=300 loader_files=200;</li>
</ul>
<p>在这个例子中缓存迭代加载可以持续300毫秒或者直到加载满200个项目。在http节点下设置完proxy_cache_path命令，下一步在虚拟服务器配置中配置proxy_cache命令，我们可以看看proxy_cache命令的语法结构：</p>
<ul>
<li>proxy_cache niyueling;</li>
</ul>
<p>可以看到proxy_cache命令很简单，就是指定了我们刚才配置的内存区。但是这里有一点需要额外注意的是：我们刚才通过配置proxy_cache_path命令的keys_zone参数配置内存区大小为10m，这并不会限制缓存数据的大小，实际上缓存数据是存储在文件系统中的特定文件的元数据副本。如果想要限制缓存数据的上限，则需要在proxy_cache_path命令中添加max_size参数设置缓存数据上限。说完了proxy_cache命令。我们接着看看下一个命令：proxy_cache_methods，我们看下该命令语法结构：</p>
<ul>
<li>proxy_cache_methods[GET HEAD POST];</li>
</ul>
<p>在虚拟服务器下配置proxy_cache_methods命令可以指定该虚拟服务器下什么类型的HTTP方法可以被缓存。默认情况下GET请求及HEAD请求会被缓存，而POST请求不会被缓存。接下来看看另外一个常见的命令：proxy_cache_valid，先贴下该命令语法结构：</p>
<ul>
<li>proxy_cache_valid reply_code [reply_code…] time;</li>
</ul>
<p>这个命令很有意思，在虚拟服务器下设置该命令，它可以针对不同状态码的响应数据设置不同的缓存时间，我们可以看个简单的小例子：</p>
<ul>
<li>proxy_cache_valid 200 10m ;</li>
<li>proxy_cache_valid 404 1m ;</li>
<li>proxy_cache_valid 302 5m ;</li>
</ul>
<p>我们通过上面的命令就可以设置200状态码的缓存时间为10分钟，302重定向的缓存时间为5分钟，404的缓存时间为1分钟。如果想为所有状态码定义相同缓存时间，就可以使用any作为第一个参数：</p>
<ul>
<li>proxy_cache_valid any 5m;</li>
</ul>
<p>接下来看看下一个命令：proxy_cache_bypass。一样先看下语法结构：</p>
<ul>
<li>proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;</li>
</ul>
<p>这个命令可以配置不会向客户端响应缓存，而是直接将请求转发给后端服务进行请求数据。可以通过上述命令配置需要绕过缓存的请求URL，也就是说URL中包含该配置的值，则这次请求会直接跳过缓存直接请求后端服务去获取数据。接下来还有最后一个比较常用的命令：proxy_cache_min_uses。先贴下语法结构：</p>
<ul>
<li>proxy_cache_min_uses 2;</li>
</ul>
<p>这个命令可以设置当某请求最少响应几次后会被缓存。若我设置为2则表示每个请求最少被请求2次后会加入到缓存中。</p>
<p><strong>Nginx清除缓存</strong><br>如果缓存过期则需要从缓存中删除过期的缓存文件，防止新旧缓存出现交错出错，当Nginx接收到自定义HTTP头或者PURGE请求时，缓存将会被清除。</p>
<p><strong>配置缓存清除</strong><br>我们在HTTP节点下创建一个新变量$purge_method来标识使用PURGE方法的请求并删除匹配的URL。</p>
<blockquote>
<p>http {<br>map $request_method $purge_method {<br>PURGE 1;<br>default 0;<br>}<br>}</p>
</blockquote>
<p>进入虚拟服务器配置，在location中配置高速缓存，并且指定缓存清除请求命令proxy_cache_purge。</p>
<blockquote>
<p>server {<br>listen 80;<br>server_name <a href="http://www.niyueling.cn" target="_blank" rel="noopener">www.niyueling.cn</a>;<br>location / {<br>proxy_cache niyueling;<br>proxy_cache_purge $purge_method;<br>}<br>}</p>
</blockquote>
<p><strong>发送清除命令</strong></p>
<p>配置proxy_cache_purge指令后需要发送PURGE请求来清除缓存。例如我们使用PURGE方式请求url:</p>
<ul>
<li>PURGE <a href="http://www.niyueling.cn/getArticle" target="_blank" rel="noopener">www.niyueling.cn/getArticle</a></li>
</ul>
<p>则getArticle对应的缓存中的数据将被删除。但是，这些高速缓存数据不会从缓存中完全删除，它们将保留在磁盘上，直到它们被删除为非活动状态，或由缓存清除进程处理。</p>
<p><strong>限制IP访问清除命令</strong></p>
<p>清除缓存这种命令一般需要权限才可进行操作，所以我们一般需要配置允许发送缓存清除请求的IP地址：</p>
<blockquote>
<p>geo $purge_allowed {<br>default 0;<br>49.235.28.88 1;<br>192.168.1.100/24 1;<br>}<br>map $request_method $purge_method {<br>PURGE $purge_allowed;<br>default 0;<br>}<br>当Nginx接收到清除缓存请求时，Nginx检查客户端IP地址，若IP地址已经获得清除缓存权限，则$purge_method设置为$purge_allowed，值为1表示允许清除缓存，值为0表示表示IP地址未获得权限。</p>
</blockquote>
<p><strong>从缓存中完全删除文件</strong></p>
<p>刚才说过了高速缓存数据不会从缓存中完全删除，它们将保留在磁盘上，直到它们被删除为非活动状态，或由缓存清除进程处理。要完全删除与getArticle相匹配的缓存数据，需要在proxy_cache_path添加参数purger，该参数表示永久的遍历所有缓存条目，并删除与通配符相匹配的条目。</p>
<ul>
<li>proxy_cache_path /data/cache keys_zone=niyueling:10m purger=on;</li>
</ul>
<p><strong>字节缓存</strong><br>当我们请求一个大文件时，因为请求比较耗时，当有下一个请求来临时将不得不等待整个大文件被下载并放入高速缓存。Nginx用缓存片模块填充高速缓存。可以将大文件分为较小的切片，每个范围请求选择将覆盖所请求范围的特定切片，并且如果此范围切片仍未缓存，就将其放入缓存中。启用字节范围缓存需要注意两个条件是否满足：</p>
<ul>
<li>确保Nginx是使用模块编译的。</li>
<li>使用slice指令指定切片的大小。</li>
</ul>
<p><strong>可以使用slice命令指定切片大小：</strong></p>
<blockquote>
<p>location / {<br>slice 1m;<br>}</p>
</blockquote>
<p>使用slice指令指定切片大小时应注意切片大小应适当调整，使切片快速下载。因为切片大小指定太小可能会导致内存使用量过多和大量打开的文件描述符，切片大小指定太大的值可能会导致请求延迟。</p>
<p><strong>接着将$slice_range变量加入到缓存键中：</strong></p>
<ul>
<li>proxy_cache_key $uri$is_args$args$slice_range;</li>
</ul>
<p><strong>使用206状态代码缓存响应，缓存有效期30m：</strong></p>
<ul>
<li>proxy_cache_valid 206 30m;</li>
</ul>
<p><strong>然后设置Range头传递$slice_range变量来将传递范围请求：</strong></p>
<ul>
<li>proxy_set_header Range $slice_range;</li>
</ul>
<p><strong>字节缓存小案例：</strong></p>
<blockquote>
<p>location / {<br>slice 1m;<br>proxy_cache niyueling;<br>proxy_cache_key $uri$is_args$args$slice_range;<br>proxy_set_header Range $slice_range;<br>proxy_cache_valid 206 30m;<br>}</p>
</blockquote>
<p><strong>缓存清除小案例</strong></p>
<blockquote>
<p>http {<br>proxy_cache_path /data/cache keys_zone=niyueling:10m purger=on;<br>map $request_method $purge_method {<br>PURGE 1;<br>default 0;<br>}</p>
<p>server {<br>listen 80;<br>server_name <a href="http://www.niyueling.cn" target="_blank" rel="noopener">www.niyueling.cn</a>;<br>location / {<br>proxy_cache niyueling;<br>proxy_cache_purge $purge_method;<br>}<br>}</p>
<p>geo $purge_allowed {<br>default 0;<br>49.235.28.88 1;<br>192.168.1.100/24 1;<br>}</p>
<p>map $request_method $purge_method {<br>PURGE $purge_allowed;<br>default 0;<br>}<br>}</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>SSH客户端命令</title>
    <url>/SSH%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos73 ~]# rpm -qa &quot;openssh*&quot;<br>openssh-6.6.1p1-31.el7.x86_64  # 两者通用设置<br>openssh-server-6.6.1p1-31.el7.x86_64  # 服务端<br>openssh-clients-6.6.1p1-31.el7.x86_64  # 客户端<br></code></pre></td></tr></table></figure>

<p>server的服务都是<code>sshd*</code>,client的服务都是<code>ssh*</code>ls</p>
<h2 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h2><p>ssh命令参数：<br><code>-p PORT</code>：指定对端端口<br><code>-X</code>: 支持x11转发<br><code>-t</code>: 强制伪tty分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -t remoteserver1 ssh remoteserver2<br></code></pre></td></tr></table></figure>

<blockquote>
<p>可以以remoteserver1作为跳板，然后登陆remoteserver2</p>
</blockquote>
<h2 id="ssh-keygen、ssh-copy-id命令–基于key的验证-免密登录）"><a href="#ssh-keygen、ssh-copy-id命令–基于key的验证-免密登录）" class="headerlink" title="ssh-keygen、ssh-copy-id命令–基于key的验证(免密登录）"></a><code>ssh-keygen</code>、<code>ssh-copy-id</code>命令–基于key的验证(免密登录）</h2><p><code>ssh-keygen</code> 生成密钥对儿。</p>
<p><code>ssh-copy-id REMOTESERVER</code> 拷贝公钥到对端服务器（实际是拷贝到.ssh/authorized_keys文件里）。</p>
<p><code>ssh-keygen -p</code> 更改秘钥的密码（passphrase），如果有旧密码，需要输入旧密码。</p>
<p><code>ssh root@ADDRESS &#39;cat /etc/shadow&#39;</code> 登录远程机器执行命令，然后退出。</p>
<p>实际应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh-keygen  # 生成秘钥<br>ssh-copy-id root@172.16.111.200  # 把秘钥copy到远程服务器上<br>ssh root@172.16.111.200  # 此时就可以基于key登录了<br></code></pre></td></tr></table></figure>

<p>在<em>Ansible权威指南</em>有见过一个例子，用了一些参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh-keygen -N &quot;&quot; -t rsa -b 4096 -C &quot;me@yulongjun.com&quot; -f &#x2F;root&#x2F;.ssh&#x2F;yulongjun.rsa<br>ssh-copy-id  -i &#x2F;root&#x2F;.ssh&#x2F;yulongjun.rsa.pub root@romate_host<br></code></pre></td></tr></table></figure>

<p>这个例子里，第一个<code>ssh-keygen</code>命令里，<code>-N</code>参数指的是秘钥的密码，这里是空，<code>-t</code>是指的秘钥类型，<code>-b</code>指的是位数，默认2048，<code>-C</code>可以自定义一个邮箱 <code>-f</code>是指定一个自定义的秘钥文件（包括名字）。<br>由于是自定义的秘钥，所以<code>ssh-copy-id</code>需要手动<code>-i</code>指定公钥路径（私钥路径也可以，会自动去匹配公钥发送）</p>
<h2 id="ssh-agent-bash、ssh-add命令–免重复输入key的密码（passphrase）"><a href="#ssh-agent-bash、ssh-add命令–免重复输入key的密码（passphrase）" class="headerlink" title="ssh-agent bash、ssh-add命令–免重复输入key的密码（passphrase）"></a><code>ssh-agent bash</code>、<code>ssh-add</code>命令–免重复输入key的密码（passphrase）</h2><p>如果密钥设置了密码，每次输入都很麻烦，这时候可以用ssh-agent代理，只要输入一次口令，之后都可以用。退出会话之后就失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh-agent bash<br>ssh-add ~&#x2F;.ssh&#x2F;id_rsa  # 此时只后，需要id_rsa的passphrase密码的话，只要输入一次就够了。<br></code></pre></td></tr></table></figure>

<h2 id="scp命令–走ssh端口的远程复制命令"><a href="#scp命令–走ssh端口的远程复制命令" class="headerlink" title="scp命令–走ssh端口的远程复制命令"></a><code>scp</code>命令–走ssh端口的远程复制命令</h2><p><code>scp [options] SRC... DEST/</code><br>源可以有多个。</p>
<p>主要两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">scp [options] [user@]host:&#x2F;sourcefile &#x2F;destpath<br>scp [options] &#x2F;sourcefile [user@]host:&#x2F;destpath<br></code></pre></td></tr></table></figure>

<blockquote>
<p>常用选项：</p>
<ul>
<li><code>-C</code>: 压缩数据流(compress)</li>
<li><code>-r</code>: 递归复制(recursive)</li>
<li><code>-p</code>: 保持原文件的属性信息(preserve)</li>
<li><code>-q</code>: 静默模式(quiet)</li>
<li><code>-P PORT</code>: 指明remote host的监听的端口(port)</li>
</ul>
</blockquote>
<h2 id="rsync命令–更聪明的复制"><a href="#rsync命令–更聪明的复制" class="headerlink" title="rsync命令–更聪明的复制"></a><code>rsync</code>命令–更聪明的复制</h2><p>基于ssh和rsh服务实现高效率的远程系统之间复制文件，使用安全的shell连接做为传输方式。</p>
<p>如果重复的文件可以不copy,比scp更快。</p>
<blockquote>
<p>选项：</p>
<ul>
<li><code>-n</code> 模拟复制过程</li>
<li><code>-v</code> 显示详细过程</li>
<li><code>-r</code> 递归复制目录树</li>
<li><code>-p</code> 保留权限</li>
<li><code>-t</code> 保留时间戳</li>
<li><code>-g</code> 保留组信息</li>
<li><code>-o</code> 保留所有者信息</li>
<li><code>-l</code> 将软链接文件本身进行复制（默认）</li>
<li><code>-L</code> 将软链接文件指向的文件复制</li>
<li><code>-a</code> 存档，相当于<code>–rlptgoD</code>，但不保留ACL（<code>-A</code>）和SELinux属性（<code>-X</code>）</li>
</ul>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">rsync –av &#x2F;etc server1:&#x2F;tmp  # 复制目录和目录下文件<br>rsync –av &#x2F;etc&#x2F; server1:&#x2F;tmp  # 只复制目录下文件<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH服务端</title>
    <url>/SSH%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="系统自带的ssh服务端"><a href="#系统自带的ssh服务端" class="headerlink" title="系统自带的ssh服务端"></a>系统自带的ssh服务端</h2><p>配置文件：<code>/etc/ssh/sshd_config</code></p>
<p>常用配置（包含默认配置）：</p>
<blockquote>
<p><code>Port 22</code>：端口号，可以改为其他的端口号<br><code>ListenAddress 0.0.0.0</code>：可以设置监听的网段，默认为全网段<br>限制登录(遵循最严权限，如果同时在禁止和允许的名单里，就禁止）：</p>
<ul>
<li><code>AllowUsers</code></li>
<li><code>DenyUsers</code></li>
<li><code>AllowGroups</code></li>
<li><code>DenyGroups</code></li>
</ul>
</blockquote>
<h2 id="dropbear-第三方ssh服务端"><a href="#dropbear-第三方ssh服务端" class="headerlink" title="dropbear 第三方ssh服务端"></a>dropbear 第三方ssh服务端</h2><p>安装准备：</p>
<p>• 1、安装开发包组:</p>
<p>• 2、<a href="https://matt.ucc.asn.au/dropbear/" target="_blank" rel="noopener">https://matt.ucc.asn.au/dropbear/</a><br>下载<code>dropbear-xxx.tar.bz2</code></p>
<p>安装：</p>
<p>• 3、<code>tar xf dropbear-xxx.tar.bz2</code></p>
<p>• 4、<code>less INSTALL</code> 查看安装过程，按照安装过程安装</p>
<p>• 5、<code>./configure</code></p>
<p>• 6、<code>make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot;</code></p>
<p>• 7、<code>make PROGRAMS=&quot;dropbear dbclient dropbearkey dropbearconvert scp&quot; install</code></p>
<p>查看安装的程序：<br><a href="http://www.yulongjun.com/images/15004481293317.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827214711.jpg" alt="img"></a></p>
<p>查看使用帮助<code>dropbear -h</code> 默认打开需要key，如果没有指定的话，会去默认位置找，所以要在默认位置创建key<br><a href="http://www.yulongjun.com/images/15004482502139.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827214711.jpg" alt="img"></a></p>
<p>查看安装包里的<code>README</code>和<code>dropbearkey -h</code>里写的，来创建key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dropbearkey -t rsa -f &#x2F;etc&#x2F;dropbear&#x2F;dropbear_rsa_host_key -s 2048   # -s 2048可以不写，默认就是2048，可以指定更大的数,最大支持4096<br>或者是<br>dropbearkey -t dss -f &#x2F;etc&#x2F;dropbear&#x2F;dropbear_dsa_host_key  # 固定值，1024<br></code></pre></td></tr></table></figure>

<p>启用dropbear的ssh服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dropbear -p :2222 -F -E  # 前台运行<br>dropbear -p :2222  # 后台运行<br></code></pre></td></tr></table></figure>

<p>客户端访问，可以用系统的ssh，也可以用dropbear的客户端<code>dbclient</code>，使用方法是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -p 2222 root@127.0.0.1<br>dbclient -p 2222 root@127.0.0.1<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH转发</title>
    <url>/SSH%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SH端口转发"><a href="#SH端口转发" class="headerlink" title="SH端口转发"></a>SH端口转发</h2><p>SSH的端口转发（port forwarding via SSH),又叫做SSH隧道（SSH tunneling) ，是一种在本地计算机和远程计算机之间建立一个安全的连接，使远程计算机还可以作为中继服务。因为连接是加密的，所以SSH隧道对于传输使用未加密协议的信息（如IMAP，VNC或IRC）很有用。</p>
<p>SSH有3种类型的端口转发：</p>
<ul>
<li><strong>本地端口转发（Local port forwarding）</strong>: 连接是从SSH客户端经由SSH服务端转发，然后传递到目标服务器</li>
<li><strong>远程端口转发（Remote port forwarding）</strong>: 连接是从SSH服务器经由ssh client转发，然后传递到目标服务器。</li>
<li><strong>动态端口转发（Dynamic port forwarding）</strong>: 连接是从各种应用经由ssh客户端转发，然后经过SSH服务器，最终到达目标服务器。</li>
</ul>
<h3 id="1-本地端口转发："><a href="#1-本地端口转发：" class="headerlink" title="1. 本地端口转发："></a>1. 本地端口转发：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -L [bind_local_address:]local_port:remote_host_address:remote_host_port remote_sshd_jumpserver<br></code></pre></td></tr></table></figure>

<ul>
<li><code>bind_local_address</code>指的是本机有多个ip地址，可以指定一个ip作为出口,可选项，可以不写，不写默认就是</li>
<li><code>local_port</code>是指指定一个本地端口，作为连接sshd跳板机的端口</li>
<li><code>remote_host_address</code>指的是要登录的远程主机地址</li>
<li><code>remote_host_port</code>指的是要登录的远程主机的端口</li>
<li><code>remote_ssh_jumpserver</code> 是指开启了sshd服务的跳板机(跟<code>remote_host</code>网络是通的）</li>
</ul>
<p>选项：</p>
<ul>
<li><code>-f</code> 后台启用</li>
<li><code>-N</code> 不打开远程shell，处于等待状态</li>
<li><code>-g</code> 启用网关功能，跟本地这台机器在同一个网段的，都可以通过这台机器进行转发。</li>
</ul>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh –L 9527:telnetsrv:23 -fN sshsrv<br></code></pre></td></tr></table></figure>

<p>当访问本机的9527的端口时，被加密后转发到sshsrv的ssh服务， 再解密被转发到telnetsrv:23</p>
<p>data &lt;–&gt; localhost:9527 &lt;–&gt; localhost:XXXXX &lt;–&gt; sshsrv:22 &lt;–&gt; sshsrv:YYYYY &lt;–&gt; telnetsrv:23</p>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -fNL 8080:www.ubuntuforums.org:443 -L 12345:www.ubuntu.com:443 172.16.111.200<br></code></pre></td></tr></table></figure>

<h3 id="2-远程端口转发"><a href="#2-远程端口转发" class="headerlink" title="2. 远程端口转发:"></a>2. 远程端口转发:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -R [bind_local_address:]local_sshd_server_port:remotehost:remote_host_port sshserver<br></code></pre></td></tr></table></figure>

<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh –R 9527:telnetsrv:23 –fN sshssrv<br></code></pre></td></tr></table></figure>

<p>让sshsrv侦听9527端口的访问，如有访问，就加密后通过ssh 服务转发请求到本机ssh客户端，再由本机解密后转发到telnetsrv:23</p>
<p>Data &lt;–&gt; sshsrv:9527 &lt;–&gt; sshsrv:22 &lt;–&gt; localhost:XXXXX &lt;–&gt; localhost:YYYYY &lt;–&gt; telnetsrv:23</p>
<h3 id="3-动态端口转发："><a href="#3-动态端口转发：" class="headerlink" title="3. 动态端口转发："></a>3. 动态端口转发：</h3><p>当用firefox访问internet时，本机的1080端口做为代理服务 器，firefox的访问请求被转发到sshserver上，由sshserver 替之访问internet</p>
<p>在本机firefox设置代理socket proxy:127.0.0.1:1080</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -C -D 1080 root@sshserver<br></code></pre></td></tr></table></figure>

<h2 id="X协议转发"><a href="#X协议转发" class="headerlink" title="X协议转发"></a>X协议转发</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh -X user@remotehost gedit<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Sudo</title>
    <url>/Sudo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们之前接触过su（Switch User）命令</p>
<p>我们用过曾经用过这种用法：<code>su - LongDream -c &#39;ll -a ~/&#39;</code>，即临时的切换呢用户并执行命令然后回来。</p>
<p>我们通常用某个用户来执行一些其他用户才能运行的命令，这时候我们用su的话，会用`su - root -c ‘COMMAND’”。这样有个缺点，就是权限不好控制，root的权限太大，有时候不想给root权限和密码给某些用户。</p>
<p>Sudo机制：可以让某些用户像root用户一样运行一些命令，而不需要root密码。</p>
<p>命令格式：<code>sudo COMMAND</code></p>
<p>sudo权限配置文件：<code>/etc/sudoers</code></p>
<p>默认有这两项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root	ALL&#x3D;(ALL) 	ALL<br>%wheel	ALL&#x3D;(ALL)	ALL<br></code></pre></td></tr></table></figure>

<p>一个是<code>root</code>用户可以执行所有命令，一个是<code>wheel</code>用户可以执行所有命令</p>
<p>如果不知道管理员密码，一个有wheel组的用户，也可以切换到root，可以这样：<code>sudo su - root</code>（只要输入用户自己的密码就可以了，可以简写为<code>sudo su -</code>）。</p>
<p>我们看到<code>/etc/sudoers</code>文件有这样一句话：”This file must be edited with the ‘visudo’ command.”(这个文件最好是用visudo命令来编辑）。所以我们尽量用<code>visudo</code>命令来配置，有语法错误会报错：</p>
<p><a href="http://www.yulongjun.com/images/15026340690348.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827215213.jpg" alt="img"></a></p>
<p>我们继续来分析参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root	ALL&#x3D;(ALL) 	ALL<br>%wheel	ALL&#x3D;(ALL)	ALL<br></code></pre></td></tr></table></figure>

<p>参数分为几块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Users Hosts&#x3D;(Runas_users) Commands<br></code></pre></td></tr></table></figure>

<p>也就是<strong>运行命令的用户或用户组</strong>，在<strong>哪些主机</strong>上，以<strong>哪些用户</strong>的身份，来执行<strong>哪些命令</strong>。</p>
<p>详解：</p>
<ul>
<li>Users<ul>
<li><code>username</code> ：用户名</li>
<li><code>#uid</code>：用户UID</li>
<li><code>%groupname</code>：用户组</li>
<li><code>%#gid</code>：用户组GID</li>
<li><code>User_Alias</code>：用户别名(sudoers文件中单独定义的)</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>User_Alias</code>用法：<code>User_Alias ADMINS = jsmith, mikem</code>，ADMINS为别名，必须为大写；<code>jsmith, mikem</code>为用户名。</p>
</blockquote>
<ul>
<li>Hosts<ul>
<li><code>hostname</code>：主机名</li>
<li><code>ip_addr</code>：ip地址</li>
<li>network(/netmask)：网段</li>
<li><code>Host_Alias</code>：主机别名(sudoers文件中单独定义的)</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Host_Alias&#96;定义方法：&#96;Host_Alias FILESERVERS &#x3D; fs1, fs2<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>Runas_users<ul>
<li><code>username</code> ：用户名</li>
<li><code>#uid</code>：用户UID</li>
<li><code>%groupname</code>：用户组</li>
<li><code>%#gid</code>：用户组GID</li>
<li><code>Runas_Alias</code>：用户别名(sudoers文件中单独定义的)</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Runas_Alias</code>定义方法：同<code>Users</code>里<code>User_Alias</code>用法。</p>
</blockquote>
<ul>
<li>Commands<ul>
<li><code>command_name</code>：实际的命令，写绝对路径</li>
<li><code>directory</code>：目录，目录下所有命令</li>
<li><code>sudoedit</code>：有编辑<code>sudoers</code>文件的权限，相当于有授权权限。</li>
<li><code>Cmnd_Alias</code>：一组命令的别名</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Cmnd_Alias</code>定义方法：<code>Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum</code> SOFTWARE为别名，必须为大写；<code>j/bin/rpm, /usr/bin/up2date, /usr/bin/yum</code>为命令名。</p>
</blockquote>
<p>可以不输入用户密码,在<code>Commands</code>前可以加<code>NOPASSWD：</code>(如果有同学接触过Vagrant，就知道默认创建的vagrant用户执行sudo命令不用输入密码)，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">root ALL&#x3D;(ALL) NOPASSWD: ALL<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>tips:</strong>通常，我们一般也不编辑sudoers文件，一般编辑<code>/etc/sudoers.d/xxx</code>xxx为你自定义的文件，一般以用户名或者组名来命名文件。例如：<br><code>vim /etc/sudoers.d/vagrant</code><br><code>%vagrant ALL=(ALL) NOPASSWD: ALL</code><br>这样一个用户或一个用户组一个文件，便于后期管理。</p>
</blockquote>
<hr>
<h2 id="Sudo示例"><a href="#Sudo示例" class="headerlink" title="Sudo示例"></a>Sudo示例</h2><p>示例1：(ALL全权限）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Student ALL&#x3D;(ALL) ALL<br>%wheel ALL&#x3D;(ALL) ALL<br></code></pre></td></tr></table></figure>

<p>示例2：（单独命令和NOPASSWD）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">student ALL&#x3D;(root) &#x2F;sbin&#x2F;pidof,&#x2F;sbin&#x2F;ifconfig<br>%wheel ALL&#x3D;(ALL) NOPASSWD: ALL<br></code></pre></td></tr></table></figure>

<p>示例3：（使用Alias的示例）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">User_Alias NETADMIN&#x3D; netuser1,netuser2<br>Cmnd_Alias NETCMD &#x3D; &#x2F;usr&#x2F;sbin&#x2F;ip<br>NETADMIN ALL&#x3D;（root） NETCMD<br></code></pre></td></tr></table></figure>

<p>示例4：（使用多Alias的示例，其中SERS没写表示任何人）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">User_Alias SYSADER&#x3D;wang,mage,%admins<br>User_Alias DISKADER&#x3D;tom<br>Host_Alias SERS&#x3D;www.magedu.com,172.16.0.0&#x2F;24<br>Runas_Alias OP&#x3D;root<br>Cmnd_Alias SYDCMD&#x3D;&#x2F;bin&#x2F;chown,&#x2F;bin&#x2F;chmod<br>Cmnd_Alias DSKCMD&#x3D;&#x2F;sbin&#x2F;parted,&#x2F;sbin&#x2F;fdisk<br>SYSADER SERS&#x3D; SYDCMD,DSKCMD<br>DISKADER ALL&#x3D;(OP) DSKCMD<br></code></pre></td></tr></table></figure>

<p>示例5：（使用正则表达式、NOPASSWD和PASSWD并存的示例，！排除）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">User_Alias ADMINUSER &#x3D; adminuser1,adminuser2<br>Cmnd_Alias ADMINCMD &#x3D; &#x2F;usr&#x2F;sbin&#x2F;useradd, &#x2F;usr&#x2F;sbin&#x2F;usermod, &#x2F;usr&#x2F;bin&#x2F;passwd [a-zA-Z]*, !&#x2F;usr&#x2F;bin&#x2F;passwd root<br>ADMINUSER ALL&#x3D;(root) NOPASSWD:ADMINCMD， PASSWD:&#x2F;usr&#x2F;sbin&#x2F;userdel<br></code></pre></td></tr></table></figure>

<p>示例6：（Defaults表示默认用户，表示如果sudo不指定用户名时，默认使用的用户，在下面，指的是如果wang使用<code>sudo</code>不<code>-u</code>指定用户名，默认是tom）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Defaults:wang runas_default&#x3D;tom<br>wang ALL&#x3D;(tom,jerry) ALL<br></code></pre></td></tr></table></figure>

<p>示例7：（指定了文件夹，但是排除了文件夹下面的useradd命令）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">wang 192.168.175.136,192.168.175.138&#x3D;(root) &#x2F;usr&#x2F;sbin&#x2F;,!&#x2F;usr&#x2F;sbin&#x2F;useradd<br></code></pre></td></tr></table></figure>

<p>示例8：（命令限定哪些文件，但是用*很不安全，比如我用wang用户 <code>sudo cat /var/log/messages /etc/shadow</code>也是可以的,这里不安全，不要这么使用。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">wang ALL&#x3D;(ALL) &#x2F;bin&#x2F;cat &#x2F;var&#x2F;log&#x2F;messages*<br></code></pre></td></tr></table></figure>

<h2 id="sudo-常用命令参数"><a href="#sudo-常用命令参数" class="headerlink" title="sudo 常用命令参数"></a>sudo 常用命令参数</h2><p><code>sudo -l</code> 列出（list）当前用户可以运行的sudo命令。</p>
<p><code>sudo -b</code> 将要执行的命令放在后台(background)执行。</p>
<p><code>sudo -u username/#uid</code> 指定以另外一个用户(user)的身份运行命令，不加<code>-u</code>默认是root</p>
<p>默认5分钟内不用输入密码，如果<code>sudo -k</code>，则下次需要输入密码</p>
<h2 id="sudo的好处"><a href="#sudo的好处" class="headerlink" title="sudo的好处"></a>sudo的好处</h2><p>不给用户root权限，便于日志审计，只要给他sudo权限就好。</p>
<p>如果大家都用root登录，就不知道是谁操作的，用sudo权限来分配，可以直接审计单个用户的操作。</p>
<p>还有一个好处是，便于权限控制。有些用户不能给他太多的权限，就可以用sudo来控制他的权限范围。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Sudo</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP_Wrappers应用层防火墙</title>
    <url>/TCP-Wrappers%E5%BA%94%E7%94%A8%E5%B1%82%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TCP_Wrappers是一个工作在应用层的安全工具，它只能针对某些具体的应用或者服务起到一定的防护作用。比如说ssh、telnet、FTP等服务的请求，都会先受到TCP_Wrappers的拦截。</p>
<p>TCP_Wrappers是基于库调用实现的。</p>
<p>包名为<code>tcp_wrappers-libs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@blog ~]# rpm -ql tcp_wrappers-libs<br>&#x2F;usr&#x2F;lib64&#x2F;libwrap.so.0<br>&#x2F;usr&#x2F;lib64&#x2F;libwrap.so.0.7.6<br><br>[root@blog ~]# ll &#x2F;usr&#x2F;lib64&#x2F;libwrap.so.0*<br>lrwxrwxrwx. 1 root root    16 Jul 10 20:22 &#x2F;usr&#x2F;lib64&#x2F;libwrap.so.0 -&gt; libwrap.so.0.7.6<br>-rwxr-xr-x. 1 root root 42520 Jun 10  2014 &#x2F;usr&#x2F;lib64&#x2F;libwrap.so.0.7.6<br></code></pre></td></tr></table></figure>

<p>我们可以查询到好多服务都是调用的这个库文件,如<code>sshd</code>、<code>vsftpd</code>、<code>xinetd</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@blog ~]# ldd &#96;which sshd&#96; |grep libwrap.so.0<br>	libwrap.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libwrap.so.0 (0x00007fc777586000)<br>[root@blog ~]# ldd &#96;which vsftpd&#96; |grep libwrap.so.0<br>	libwrap.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libwrap.so.0 (0x00007fdb8d276000)<br>[root@blog ~]# ldd &#96;which xinetd&#96; |grep libwrap.so.0<br>	libwrap.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libwrap.so.0 (0x00007f4ae8036000)<br></code></pre></td></tr></table></figure>

<h2 id="TCP-Wrappers访问控制实现"><a href="#TCP-Wrappers访问控制实现" class="headerlink" title="TCP_Wrappers访问控制实现"></a>TCP_Wrappers访问控制实现</h2><p>TCP_Wrappers访问控制实现，是靠两个文件实现的：<code>/etc/hosts.allow</code>和<code>/etc/hosts.deny</code> .<code>man hosts.allow</code>或者 <code>man hosts.deny</code>可以查看规则和用法。</p>
<p><code>/usr/sbin/tcpd</code>进程会根据这两个文件判断是否对访问请求提供服务。</p>
<p>/usr/sbin/tcpd进程先检查文件/etc/hosts.allow，如果请求访问的主机名或IP包含在此文件中，则允许访问。<br>如果请求访问的主机名或IP不包含在/etc/hosts.allow中，那么tcpd进程就检查/etc/hosts.deny。看请求访问的主机名或IP有没有包含在hosts.deny文件中。如果包含，那么访问就被拒绝；如果既不包含在/etc/hosts.allow中，又不包含在/etc/hosts.deny中，那么此访问也被允许。</p>
<p><a href="http://www.yulongjun.com/images/15026986812731.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200827215158.jpg" alt="img"></a></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">daemon_list: client_list1 [EXCEPT client_list2][:options]<br></code></pre></td></tr></table></figure>

<p><strong><code>deamon_list</code></strong></p>
<ul>
<li><code>应用程序文件名称</code> 而非服务名</li>
<li><code>应用程序文件名称列表</code> 彼此间使用逗号或空格分隔</li>
<li><code>All</code> 表示所有服务</li>
</ul>
<p><strong><code>client_list1</code></strong></p>
<ul>
<li><code>IP地址</code></li>
<li><code>主机名</code></li>
<li><code>域名段</code> ,例如<code>.yulongjun.com</code>,即可以匹配<code>db1.yulongjun.com``node1.web.yulongjun.com</code>等。</li>
<li><code>网络段</code>CentOS6必须使用完整格式的掩码<code>net/mask</code>，如<code>127.16.111.0/255.255.255.0</code>，不能使用<code>net/prefix</code>,如<code>127.16.111.0/24</code>,从CentOS7开始，支持使用<code>net/prefix</code></li>
<li><code>短格式的网络段</code>（如 <code>172.16.</code>，相当于<code>172.16.0.0/255.255.0.0</code>）</li>
<li><code>ALL</code> 所有来源主机</li>
<li><code>KNOW</code> 所有能解析到的主机</li>
<li><code>UNKNOW</code> 所有未解析到的主机</li>
<li><code>LOCAL</code> 主机名中不带<code>.</code>的</li>
<li><code>PARANOID</code> 正反解析不匹配的地址</li>
</ul>
<p><strong><code>EXCEPT client_list2</code></strong></p>
<p>除了client_list2的主机之外，client_list1的都匹配。</p>
<p><strong><code>options</code></strong></p>
<ul>
<li><code>deny</code> 拒绝，主要用于<code>hosts.allow</code>文件中，实现deny功能</li>
<li><code>allow</code> 允许，主要用在<code>hosts.deny</code>文件中，实现allow功能</li>
<li><code>spawn</code> 启动额外应用程序,用的不多</li>
<li><code>twist</code> 无论写在<code>hosts.allow</code>还是<code>hosts.deny</code>都是拒绝，并提示<br>例子1：不允许<code>172.16.111.100</code>的ftp访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;hosts.deny<br>vsftpd : 172.16.111.100<br></code></pre></td></tr></table></figure>

<p>例子2：仅允许<code>172.16.111.</code>网段的ftp访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;hosts.allow<br>vsftpd : 172.16.111.<br>vim &#x2F;etc&#x2F;hosts.deny<br>vsftpd : ALL<br></code></pre></td></tr></table></figure>

<p>例子3：仅允许<code>172.16.111.</code>网段的ftp访问，除了172.16.111.100外</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;hosts.allow<br>vsftpd : 172.16.111. EXCEPT 172.16。111.100<br>vim &#x2F;etc&#x2F;hosts.deny<br>vsftpd : ALL<br></code></pre></td></tr></table></figure>

<p>例子3：不允许<code>172.16.111.</code>网段访问ftp，写在<code>hosts.allow</code>里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;hosts.allow<br>vsftpd : 172.16.111. : deny<br></code></pre></td></tr></table></figure>

<p>例子4，不允许<code>192.168.111.</code>网段ssh来访问，尝试的访问记录在<code>/var/log/sshd.deny.log</code>里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;hosts.deny<br>sshd: 192.168.111. :spawn echo &quot;&#96;date&#96; login attempt from %c to %s,%d&quot; &gt;&gt;&#x2F;var&#x2F;log&#x2F;sshd.deny.log<br></code></pre></td></tr></table></figure>

<p>我们用一台<code>192.168.111.</code>网段的机器ssh访问，可以看到下面结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@center ~]# cat &#x2F;var&#x2F;log&#x2F;sshd.deny.log <br>Mon Aug 14 17:25:08 CST 2017 login attempt from 192.168.111.100 to sshd@192.168.111.254,sshd<br></code></pre></td></tr></table></figure>



<p>拒绝<code>192.168.111.</code>网段的ftp访问，并输出提示符。<br><code>vim /etc/hosts.deny</code> 或者 <code>vim /etc/hosts.allow</code>均可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vsftpd: 192.168.111. :twist &#x2F;bin&#x2F;echo &quot;connection refused!!!&quot;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>TFTP和PXE</title>
    <url>/TFTP%E5%92%8CPXE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/15009109935925.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160305.jpg" alt="img"></a></p>
<h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><p><strong>TFTP</strong>（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69，基于UDP协议。</p>
<p><code>yum info tftp-server</code>或<code>rpm -qi tftp-server</code>可以查看描述：</p>
<p><a href="http://www.yulongjun.com/images/15009133215597.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160306.jpg" alt="img"></a></p>
<p>看到描述我们可以知道，TFTP通常用来作为无盘工作站的启动。允许用户从远程机器上传输文件。</p>
<p>tftp服务可以用来做pxe的启动拉取pxelinux.0文件和启动菜单文件。</p>
<p>一般存放pxe相关文件的位置为<code>/var/lib/tftpboot/</code>下面。</p>
<p><a href="http://www.yulongjun.com/images/15009133953558.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203160307.jpg" alt="img"></a></p>
<h2 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h2><p>PXE：Preboot Excution Environment, Intel公司研发，没有任何操作系统的主机，能够基于网络完成系统的安装工作。</p>
<p><strong>PXE工作原理：</strong></p>
<ul>
<li>Client向PXE Server上的DHCP发送IP地址请求消息，DHCP检测Client是否合法（主要是检测Client的网卡MAC 地址），如果合法则返回Client的IP地址，同时将启动文件 pxelinux.0的位置信息一并传送给Client</li>
<li>Client向PXE Server上的TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0</li>
<li>Client执行接收到的pxelinux.0文件</li>
<li>Client向TFTP Server发送针对本机的配置信息文件（在 TFTP 服务的pxelinux.cfg目录下），TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。</li>
<li>Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给Client</li>
<li>Client向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统</li>
<li>Client启动Linux内核</li>
<li>Client下载安装源文件，读取自动化安装脚本。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Tomcat主配置详解</title>
    <url>/Tomcat%E4%B8%BB%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="etc-tomcat-server-xml"><a href="#etc-tomcat-server-xml" class="headerlink" title="/etc/tomcat/server.xml"></a><code>/etc/tomcat/server.xml</code></h2><p>server.xml是Tomcat的主配置文件。我们来看一下配置文件里各个条目的意义：</p>
<h3 id="lt-Server-port-quot-8005-quot-shutdown-quot-SHUTDOWN-quot-gt"><a href="#lt-Server-port-quot-8005-quot-shutdown-quot-SHUTDOWN-quot-gt" class="headerlink" title="&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;"></a><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></h3><p>一个Server代表tomcat instance，即表现出的一个java进程；监听在8005端口，只接收“SHUTDOWN”。各server监听的端口不能相同，因此，在同一物理主机启动多个实例时，需要修改其监听端口为不同的端口。</p>
<p>通常我们把这个关闭：<code>&lt;Server port=&quot;-1&quot; shutdown=&quot;480f5eca50a06b1e063165c5e30ab0c3415dd5e0&quot;&gt;</code></p>
<blockquote>
<p>tips：那串字符串是通过<code>openssl rand -hex 20</code>生成的。</p>
</blockquote>
<h3 id="lt-listener-className-quot-xxxxx-quot-gt"><a href="#lt-listener-className-quot-xxxxx-quot-gt" class="headerlink" title="&lt;listener className=&quot;xxxxx&quot;&gt;"></a><code>&lt;listener className=&quot;xxxxx&quot;&gt;</code></h3><p>侦听器，监视资源的改变，并做相应的操作，多数情况不需要改变。</p>
<h3 id="lt-GlobalNamingResources-gt"><a href="#lt-GlobalNamingResources-gt" class="headerlink" title="&lt;GlobalNamingResources&gt;"></a><code>&lt;GlobalNamingResources&gt;</code></h3><p>全局命名资源。</p>
<p>子项<code>&lt;Resource&gt;</code>就是一个个的资源信息。指向了资源的路径(<code>pathname</code>)。</p>
<p>系统默认提供了一个认证用的资源信息,名为<code>UserDatabase</code>, 后面的<strong>Realm</strong>会调用这个资源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Resource name&#x3D;&quot;UserDatabase&quot; auth&#x3D;&quot;Container&quot;<br>          type&#x3D;&quot;org.apache.catalina.UserDatabase&quot;<br>          description&#x3D;&quot;User database that can be updated and saved&quot;<br>          factory&#x3D;&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;<br>          pathname&#x3D;&quot;conf&#x2F;tomcat-users.xml&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<h3 id="lt-Service-name-quot-Catalina-quot-gt"><a href="#lt-Service-name-quot-Catalina-quot-gt" class="headerlink" title="&lt;Service name=&quot;Catalina&quot;&gt;"></a><code>&lt;Service name=&quot;Catalina&quot;&gt;</code></h3><p>提供的服务名，默认为Catalina。可以用来实现一个或多个Connector关联至一个engine组件。</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a><code>Connector</code></h3><p>负责接收客户端请求。<br>常见有3类：HTTP连接器，HTTPs连接器，AJP连接器。</p>
<p>进入tomcat的请求可分为两类：<br>(1) standalone : 请求来自于客户端浏览器；<br>(2) 由其它的web server反代：来自前端的反代服务器。前端反代又分为以下几种模式：</p>
<ul>
<li>nginx –&gt; http connector –&gt; tomcat</li>
<li>httpd(proxy_http_module) –&gt; http connector –&gt; tomcat</li>
<li>httpd(proxy_ajp_module) –&gt; ajp connector –&gt; tomcat</li>
<li>httpd(mod_jk) –&gt; ajp connector –&gt; tomcat</li>
</ul>
<p>默认配置里有几项示例：</p>
<p><strong><code>HTTP connector</code></strong>：</p>
<p>普通HTTP连接器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;<br>           connectionTimeout&#x3D;&quot;20000&quot;<br>           redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p>使用共享线程池的http连接器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Connector executor&#x3D;&quot;tomcatThreadPool&quot;<br>           port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;<br>           connectionTimeout&#x3D;&quot;20000&quot;<br>           redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p><strong><code>HTTPs connector</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;<br>           maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot;<br>           clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p><strong><code>AJP connector</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p>上述例子没有的几项属性参数：</p>
<ul>
<li>address：监听的IP地址；默认为本机所有可用地址。</li>
<li>maxThreads：最大并发连接数，默认为200。</li>
<li>enableLookups：是否启用DNS查询功能。</li>
<li>acceptCount：等待队列的最大长度。</li>
</ul>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a><code>Engine</code></h3><p>Servlet实例，即servlet引擎，其内部可以一个或多个host组件来定义站点； 通常需要通过defaultHost来定义默认的虚拟主机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;<br></code></pre></td></tr></table></figure>

<p>内部有个相应的Host是localhost</p>
<p>如果要设置负载均衡，要加一个jvmRoute</p>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><code>Realm</code></h3><p>认证模块，这里调用的<code>GlobalNamingResources</code>里名为<code>UserDatabase</code>的<code>Resourse</code>。用来给Manager和Host-Manager提供认证服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;<br>   &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;<br>          resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;<br>&lt;&#x2F;Realm&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a><code>Host</code></h3><p>位于engine内部用于接收请求并进行相应处理的主机或虚拟主机。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;<br>    unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;<br>&lt;&#x2F;Host&gt;<br></code></pre></td></tr></table></figure>

<p>常用属性说明：</p>
<p>(1) <code>appBase</code>：此Host的webapps的默认存放目录，指存放非归档的web应用程序的目录或归档的WAR文件目录路径；可以使用基于$CATALINA_BASE变量所定义的路径的相对路径；<br>(2) <code>autoDeploy</code>：在Tomcat处于运行状态时，将某webapp放置于appBase所定义的目录中时，是否自动将其部署至tomcat；</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 事先创建好目录<br># mkdir -pv &#x2F;appdata&#x2F;webapps<br># mkdir -pv &#x2F;appdata&#x2F;webapps&#x2F;ROOT&#x2F;&#123;lib,classes,WEB-INF&#125;<br># touch &#x2F;appdata&#x2F;webapps&#x2F;ROOT&#x2F;index.jsp<br># 添加测试内容<br></code></pre></td></tr></table></figure>

<p><code>index.jsp</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;%@ page language&#x3D;&quot;java&quot; %&gt;<br>&lt;html&gt;<br>	&lt;head&gt;&lt;title&gt;TomcatA&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;<br>	&lt;body&gt;<br>		&lt;h1&gt;&lt;font color&#x3D;&quot;red&quot;&gt;TomcatA.yulongjun.com&lt;&#x2F;font&gt;&lt;&#x2F;h1&gt;<br>		&lt;table align&#x3D;&quot;centre&quot; border&#x3D;&quot;1&quot;&gt;<br>			&lt;tr&gt;<br>				&lt;td&gt;Session ID&lt;&#x2F;td&gt;<br>			&lt;% session.setAttribute(&quot;yulongjun.com&quot;,&quot;yulongjun.com&quot;); %&gt;<br>				&lt;td&gt;&lt;%&#x3D; session.getId() %&gt;&lt;&#x2F;td&gt;<br>			&lt;&#x2F;tr&gt;<br>			&lt;tr&gt;<br>				&lt;td&gt;Created on&lt;&#x2F;td&gt;<br>				&lt;td&gt;&lt;%&#x3D; session.getCreationTime() %&gt;&lt;&#x2F;td&gt;<br>			&lt;&#x2F;tr&gt;<br>		&lt;&#x2F;table&gt;<br>	&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;<br></code></pre></td></tr></table></figure>

<p>修改server.xml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Host name&#x3D;&quot;tc1.yulongjun.com&quot; appBase&#x3D;&quot;&#x2F;appdata&#x2F;webapps&quot; <br>      unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;<br>&lt;&#x2F;Host&gt;<br></code></pre></td></tr></table></figure>

<p>浏览器访问tc1.yulongjun.com:8080即可访问到这个页面（记得hosts文件里要添加对应的ip，要么部署dns服务）</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>包含在Host标签里。</p>
<p>如果在一个主机上部署多个app的话，Context就可以用来定义不同app对应的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Context path&#x3D;&quot;&#x2F;PATH&quot; docBase&#x3D;&quot;&#x2F;PATH&#x2F;TO&#x2F;SOMEDIR&quot; reloadable&#x3D;&quot;&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p>把<code>/PATH/TO/SOMEDIR</code>映射到 request URI <code>/PATH</code></p>
<ul>
<li>如果<code>/PATH/TO/SOMEDIR</code>不带<code>/</code>，则是相对路径，相对的是Host的appBase。</li>
<li>如果<code>/PATH/TO/SOMEDIR</code>带<code>/</code>，则是操作系统的绝对路径。</li>
</ul>
<p><code>reloadable</code>：是否支持主机装载。</p>
<blockquote>
<p>关于reloadable：<a href="http://blog.csdn.net/blueheart20/article/details/40074115" target="_blank" rel="noopener">http://blog.csdn.net/blueheart20/article/details/40074115</a></p>
</blockquote>
<p>如果在上面Host tc1.yulongjun.com 内部加入一个Context：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Host name&#x3D;&quot;tc1.yulongjun.com&quot; appBase&#x3D;&quot;&#x2F;appdata&#x2F;webapps&quot; <br>      unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;<br>      &lt;Context path&#x3D;&quot;&#x2F;test1&quot; docBase&#x3D;&quot;test1&quot; reloadable&#x3D;&quot;&quot;&#x2F;&gt;<br>      &lt;Context path&#x3D;&quot;&#x2F;app1&quot; docBase&#x3D;&quot;&#x2F;app&#x2F;app1&quot; reloadable&#x3D;&quot;&quot;&#x2F;&gt;<br>&lt;&#x2F;Host&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>Valve存在多种类型：</p>
<ul>
<li>定义访问日志：<code>org.apache.catalina.valves.AccessLogValve</code></li>
<li>定义访问控制：<code>org.apache.catalina.valves.RemoteAddrValve</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;<br>       prefix&#x3D;&quot;localhost_access_log.&quot; suffix&#x3D;&quot;.txt&quot;<br>       pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>&quot;%h %l %u %t &quot;%r&quot; %s %b&quot;</code>为日志格式，<code>&amp;quot</code>表示的是引号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.RemoteAddrValve&quot; deny&#x3D;&quot;172\.16\.100\.<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Tomcat基础知识</title>
    <url>/Tomcat%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>介绍Tomcat之前先介绍下Java相关的知识。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h3><p>Java代码的运行：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">*.java&#96;(source code) –&gt; **javac** –&gt; &#96;*.class&#96;(bytecode) –&gt; &#96;JVM<br></code></pre></td></tr></table></figure>
</blockquote>
<p><code>*.java</code>源代码经过<strong>javac</strong>编译之后，生成字节码<code>*.class</code>，然后发送给<strong>JVM</strong>来运行。</p>
<p><strong>JVM</strong>（Java Virtual Machine）：class loader，加载程序的类文件，及程序的类文件依赖到的其它的类文件而后运行； 整个运行表现为一个jvm进程。</p>
<h3 id="Java-Applet-、Java-Servlet、"><a href="#Java-Applet-、Java-Servlet、" class="headerlink" title="Java Applet 、Java Servlet、"></a>Java Applet 、Java Servlet、</h3><p>在浏览器或客户端运行的Java程序就叫：<strong>Java Applet</strong></p>
<p>在服务端运行的的Java程序就叫：<strong>Java Servlet</strong></p>
<p>Applet和Servlet都不是独立的程序，都需要Java运行环境。</p>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p><strong>Java Server Pages(JSP)</strong>是一种实现普通静态HTML和动态HTML混合编码的技术，JSP并没有增加任何本质上不能用Servlet实现的功能。但是，在 JSP中编写静态HTML更加方便，不必再用println语句来输出每一行HTML代码。更重要的是，借助内容和外观的分离，页面制作中不同性质的任务可以方便地分开：比如，由页面设计者进行HTML设计，同时留出供Servlet程序员插入动态内容的空间。</p>
<blockquote>
<p>此段转载自：<a href="http://blog.csdn.net/yasi_xi/article/details/22071099" target="_blank" rel="noopener">http://blog.csdn.net/yasi_xi/article/details/22071099</a><br>如果想要详细了解，可以阅读原文。</p>
</blockquote>
<h3 id="jasper"><a href="#jasper" class="headerlink" title="jasper"></a>jasper</h3><p>jasper程序的功能，就是把JVM不认识的JSP文件解析成java文件，然后由javac程序编译成class文件提供使用。目前有很多的JSP解析引擎，Tomcat中使用的是Jasper。如下：</p>
<blockquote>
<p><code>*.jsp</code> –&gt; <strong>jasper</strong> –&gt; <code>*.java</code> –&gt; <strong>javac</strong> –&gt; <code>*.class</code> –&gt; <strong>JVM</strong></p>
</blockquote>
<hr>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK（Java Development Kits）：Java 开发套件，一共分为两种：</p>
<ul>
<li>OpenJDK</li>
<li>Oracle JDK</li>
</ul>
<h3 id="安装-OpenJDK-1-8"><a href="#安装-OpenJDK-1-8" class="headerlink" title="安装 OpenJDK 1.8"></a>安装 <code>OpenJDK 1.8</code></h3><p><code>yum list|grep openjdk</code>发现包含1.6、1.7、1.8，我们可以过滤一下，只看1.8的x86_64版本的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum list|grep java-1.8.0-openjdk.*x86_64<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15041002491252.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141646.jpg" alt="img"></a></p>
<p><code>openjdk</code>是<strong>The OpenJDK runtime environment</strong>，只有运行环境; <code>openjdk-devel</code>是<strong>The OpenJDK development tools</strong>,是开发工具包组。所以我们来安装<code>openjdk-devel</code>，这样有一系列的开发工具包组可供使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install -y java-1.8.0-openjdk-devel<br></code></pre></td></tr></table></figure>

<p>这条命令会安装<code>java-1.8.0</code>、<code>java-1.8.0-poenjdk-devel</code>、<code>java-1.8.0-openjdk-headless</code>以及其他相关依赖。</p>
<p><code>java -version</code>可以看到java版本：</p>
<p><a href="http://www.yulongjun.com/images/15041013087323.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141647.jpg" alt="img"></a></p>
<h2 id="安装-Oracle-的-JDK-8"><a href="#安装-Oracle-的-JDK-8" class="headerlink" title="安装 Oracle 的 JDK 8"></a>安装 Oracle 的 <code>JDK 8</code></h2><p>Oracle 官方也有对应的JRE和JDK。可以去官网下载安装：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p><a href="http://www.yulongjun.com/images/15041016765645.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141648.jpg" alt="img"></a></p>
<p>包含3个版本，这里选择JDK版本下载，包格式选择rpm</p>
<p><a href="http://www.yulongjun.com/images/15041017641763.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141649.jpg" alt="img"></a></p>
<p>用rpm命令进行安装：</p>
<p><a href="http://www.yulongjun.com/images/15041022444526.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141650.jpg" alt="img"></a></p>
<p>这里单独下载安装的JDK的rpm，是无法用<code>rpm -ql</code>查询的，我们可以在<code>/usr/java</code>下找到：</p>
<p><a href="http://www.yulongjun.com/images/15041023540213.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141651.jpg" alt="img"></a></p>
<p>默认latest指向jdk的版本的文件夹，default指向latest文件夹，如果后来升级了，可以把指向自行更换。</p>
<p>我们还需要写一下环境变量，让系统可以找到java程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 写到环境变量里，下次启动生效。<br>cat &gt; &#x2F;etc&#x2F;profile.d&#x2F;java.sh &lt;&lt;EOF<br>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;latest<br>export PATH&#x3D;\$JAVA_HOME&#x2F;bin:\$PATH<br>EOF<br># source一下，在当前环境下立即生效。<br>source &#x2F;etc&#x2F;profile.d&#x2F;java.sh<br></code></pre></td></tr></table></figure>



<blockquote>
<p>这里推荐用<code>OpenJDK</code>，免去了配置环境变量的操作。而且<code>JDK</code>属于Oracle公司未开源产品，万一你公司做大了，Oracle像告谷歌一样告你呢？:-D</p>
</blockquote>
<hr>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h3><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目：<a href="http://www.yulongjun.com/linux/20170830-01-tomcat-basic/tomcat.apache.org" target="_blank" rel="noopener">tomcat.apache.org</a>，它的项目名称为<strong>catalina</strong>，后来由Apache、Sun 和其他一些公司及个人共同开发而成，因为在O’Reilly家出的书的封面是一只汤姆猫，所以软件更名为<strong>Tomcat</strong>。Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选，因为Tomcat 技术先进、性能稳定，成为目前比较流行的Web 应用服务器。Tomcat是应用（java）服务器，它只是一个servlet容器，是Apache的扩展，但它是独立运行的。</p>
<h3 id="Tomcat架构"><a href="#Tomcat架构" class="headerlink" title="Tomcat架构"></a>Tomcat架构</h3><p><a href="http://www.yulongjun.com/images/15040982600418.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141652.jpg" alt="img"></a></p>
<blockquote>
<p>图片来自于：<a href="http://www.blogjava.net/honzeland/archive/2010/05/10/320458.html" target="_blank" rel="noopener">http://www.blogjava.net/honzeland/archive/2010/05/10/320458.html</a></p>
</blockquote>
<p>它由一组嵌套的层次和组件组成，一般可分为以下四类：</p>
<ul>
<li><strong>顶级组件</strong>：位于配置层次的顶级，并且彼此间有着严格的对应关系。<code>Server</code></li>
<li><strong>服务类组件</strong>：位于Server的下一级。<code>Service</code></li>
<li><strong>连接器组件</strong>：连接客户端（可以是浏览器或Web服务器）请求至Servlet容器。<code>http</code>，<code>https</code>， <code>ajp</code></li>
<li><strong>容器类组件</strong>：包含一组其它组件。<code>Engine</code>，<code>Host</code>，<code>Context</code></li>
<li><strong>被嵌套的组件</strong>：位于一个容器当中，但不能包含其它组件。<code>valve</code>，<code>loger</code>，<code>realm</code>，<code>loader</code>，<code>manager</code>，…</li>
<li><strong>集群类组件</strong>： <code>listener</code>，<code>cluster</code>，…</li>
</ul>
<p><strong>各常见组件：</strong></p>
<p>1、<strong>服务器(server)</strong>：Tomcat的一个实例，通常一个JVM只能包含一个Tomcat实例；因此，一台物理服务器上可以在启动多个JVM的情况下在每一个JVM中启动一个Tomcat实例，每个实例分属于一个独立的管理端口。这是一个<strong>顶级组件</strong>。</p>
<p>2、<strong>服务(service)</strong>：一个服务组件通常包含一个引擎和与此引擎相关联的一个或多个连接器。给服务命名可以方便管理员在日志文件中识别不同服务产生的日志。一个server可以包含多个service组件，但通常情下只为一个service指派一个server。<br>连接器类组件：</p>
<p>3、<strong>连接器(connectors)</strong>：负责连接客户端（可以是浏览器或Web服务器）请求至Servlet容器内的Web应用程序，通常指的是接收客户发来请求的位置及服务器端分配的端口。默认端口通常是HTTP协议的8080，管理员也可以根据自己的需要改变此端口。还可以支持HTTPS ，默认HTTPS端口为8443。同时也支持AJP，即（A）一个引擎可以配置多个连接器，但这些连接器必须使用不同的端口。默认的连接器是基于HTTP/1.1的Coyote。同时，Tomcat也支持<strong>AJP</strong>、JServ和JK2连接器。</p>
<p><strong>容器类组件：</strong></p>
<p>4、<strong>引擎(Engine)</strong>：引擎通是指处理请求的Servlet引擎组件，即<strong>Catalina Servlet</strong>引擎，它检查每一个请求的HTTP首部信息以辨别此请求应该发往哪个host或context，并将请求处理后的结果返回的相应的客户端。严格意义上来说，容器不必非得通过引擎来实现，它也可以是只是一个容器。如果Tomcat被配置成为独立服务器，默认引擎就是已经定义好的引擎。而如果Tomcat被配置为Apache Web服务器的提供Servlet功能的后端，默认引擎将被忽略，因为Web服务器自身就能确定将用户请求发往何处。一个引擎可以包含多个host组件。</p>
<p>5、<strong>主机(Host)</strong>：主机组件类似于Apache中的虚拟主机，但在Tomcat中只支持基于FQDN的“虚拟主机”。一个引擎至少要包含一个主机组件。</p>
<p>6、<strong>上下文(Context)</strong>：Context组件是最内层次的组件，它表示Web应用程序本身。配置一个Context最主要的是指定Web应用程序的根目录，以便Servlet容器能够将用户请求发往正确的位置。Context组件也可包含自定义的错误页，以实现在用户访问发生错误时提供友好的提示信息。</p>
<p><strong>被嵌套类(nested)组件</strong>：</p>
<p>这类组件通常包含于容器类组件中以提供具有管理功能的服务，它们不能包含其它组件，但有些却可以由不同层次的容器各自配置。</p>
<p>7、<strong>阀门(Valve)</strong>：用来拦截请求并在将其转至目标之前进行某种处理操作，类似于Servlet规范中定义的过滤器。Valve可以定义在任何容器类的组件中。Valve常被用来记录客户端请求、客户端IP地址和服务器等信息，这种处理技术通常被称作请求转储(request dumping)。请求转储valve记录请求客户端请求数据包中的HTTP首部信息和cookie信息文件中，响应转储valve则记录响应数据包首部信息和cookie信息至文件中。</p>
<p>8、<strong>日志记录器(Logger)</strong>：用于记录组件内部的状态信息，可被用于除Context之外的任何容器中。日志记录的功能可被继承，因此，一个引擎级别的Logger将会记录引擎内部所有组件相关的信息，除非某内部组件定义了自己的Logger组件。</p>
<p>9、<strong>领域(Realm)</strong>：用于用户的认证和授权；在配置一个应用程序时，管理员可以为每个资源或资源组定义角色及权限，而这些访问控制功能的生效需要通过Realm来实现。Realm的认证可以基于文本文件、数据库表、LDAP服务等来实现。Realm的效用会遍及整个引擎或顶级容器，因此，一个容器内的所有应用程序将共享用户资源。同时，Realm可以被其所在组件的子组件继承，也可以被子组件中定义的Realm所覆盖。</p>
<blockquote>
<p>此段来自于：<a href="http://www.ttlsa.com/tomcat/tomcat-install-and-configure/" target="_blank" rel="noopener">http://www.ttlsa.com/tomcat/tomcat-install-and-configure/</a></p>
</blockquote>
<hr>
<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>安装好OpenJDK或JDK之后，就可以安装tomcat了。</p>
<h3 id="yum-安装方式"><a href="#yum-安装方式" class="headerlink" title="yum 安装方式"></a>yum 安装方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum install tomcat-lib tomcat tomcat-admin-webapps tomcat-webapps tomcat-docs-webapp tomcat-webapps<br></code></pre></td></tr></table></figure>

<p>依赖的tomcat-libs、tomcat api和其他组件会自动安装上。</p>
<p>CentOS7 默认安装的tomcat版本是7：</p>
<p><a href="http://www.yulongjun.com/images/15041470375724.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141653.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl start tomcat<br></code></pre></td></tr></table></figure>

<p>浏览器打开<code>http://tomcat_ip:8080</code>，这里的<code>tomcat_ip</code>换成你tomcat服务器的ip</p>
<p><a href="http://www.yulongjun.com/images/15041476190485.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141654.jpg" alt="img"></a></p>
<h3 id="手动安装过程"><a href="#手动安装过程" class="headerlink" title="手动安装过程"></a>手动安装过程</h3><p>看官方版本图：<a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">http://tomcat.apache.org/whichversion.html</a></p>
<p><a href="http://www.yulongjun.com/images/15041477769444.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141655.jpg" alt="img"></a></p>
<p>我们可以看到，在目前来说，8.0.x属于superseded(废弃）状态，9.0.x属于alpha版，不考虑,8.5.x是目前的主流版本，故下载8.5.x版本，目前版本是8.5.20，笔者到清华镜像下载的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.20&#x2F;bin&#x2F;&#123;apache-tomcat-8.5.20.tar.gz,apache-tomcat-8.5.20-fulldocs.tar.gz,apache-tomcat-8.5.20-deployer.tar.gz&#125;<br><br>tar -xvf apache-tomcat-8.5.20.tar.gz -C &#x2F;usr&#x2F;local<br>cd &#x2F;usr&#x2F;local<br>link -sv apache-tomcat-8.5.20 tomcat<br><br>cat &gt; &#x2F;etc&#x2F;profile.d&#x2F;tomcat.sh &lt;&lt; EOF<br>export CATALINA_BASE&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat<br>export PATH&#x3D;\$CATALINA_BASE&#x2F;bin:\$PATH<br>EOF<br>. &#x2F;etc&#x2F;profile.d&#x2F;tomcat.sh<br><br>useradd -r tomcat<br>chown -R tomcat:tomcat &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;<br>su - tomcat -c &#39;catalina.sh start&#39;<br></code></pre></td></tr></table></figure>

<p>手动安装的话，设置完环境变量后，手动安装的版本可以使用<code>catlina.sh</code>来进行各种操作。</p>
<p><code>catalina.sh start</code> 后，浏览器打开<code>http://tomcat_ip:8080</code>，这里的<code>tomcat_ip</code>换成你tomcat服务器的ip:</p>
<p><a href="http://www.yulongjun.com/images/15041630263553.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203141656.jpg" alt="img"></a></p>
<h3 id="Tomcat-目录结构"><a href="#Tomcat-目录结构" class="headerlink" title="Tomcat 目录结构"></a>Tomcat 目录结构</h3><p><strong>tomcat的目录结构：</strong></p>
<ul>
<li><code>bin</code>：脚本，及启动时用到的类。</li>
<li><code>conf</code>：配置文件目录。</li>
<li><code>lib</code>：库文件，Java类库，jar。</li>
<li><code>logs</code>：日志文件目录。</li>
<li><code>temp</code>：临时文件目录。</li>
<li><code>webapps</code>：webapp的默认目录。</li>
<li><code>work</code>：工作目录。存放编译后的字节码文件。</li>
</ul>
<p><strong>tomcat的配置目录文件构成：</strong></p>
<ul>
<li><code>server.xml</code>：主配置文件；</li>
<li><code>web.xml</code>：每个webapp只有“部署”后才能被访问，它的部署方式通常由web.xml进行定义，其存放位置为WEB-INF/目录中；此文件为所有的webapps提供默认部署相关的配置；</li>
<li><code>context.xml</code>：每个webapp都可以专用的配置文件，它通常由专用的配置文件context.xml来定义，其存放位置为WEB-INF/目录中；此文件为所有的webapps提供默认配置；</li>
<li><code>tomcat-users.xml</code>：用户认证的账号和密码文件；</li>
<li><code>catalina.policy</code>：当使用-security选项启动tomcat时，用于为tomcat设置安全策略；</li>
<li><code>catalina.properties</code>：Java属性的定义文件，用于设定类加载器路径，以及一些与JVM调优相关参数；</li>
<li><code>logging.properties</code>：日志系统相关的配置。</li>
</ul>
<p><strong>JSP Webapp的组织结构：</strong></p>
<p><strong>webapps的根目录：</strong></p>
<ul>
<li><code>index.jsp</code>：主页；</li>
<li><code>WEB-INF/</code>：当前webapp的私有资源路径；通常用于存储当前webapp的web.xml和context.xml配置文件；</li>
<li><code>META-INF/</code>：类似于WEB-INF/；</li>
<li><code>classes/</code>：类文件，当前webapp所提供的类；</li>
<li><code>lib/</code>：类文件，当前webapp所提供的类，被打包为jar格式；</li>
</ul>
<p><strong>webapp归档格式：</strong></p>
<ul>
<li><code>.war</code>：webapp</li>
<li><code>.jar</code>：EJB的类打包文件；</li>
<li><code>.rar</code>：资源适配器类打包文件；</li>
<li><code>.ear</code>：企业级webapp；</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Tomcat管理页面</title>
    <url>/Tomcat%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.yulongjun.com/images/15041803800341.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203144908.jpg" alt="img"></a></p>
<p>在<code>http:tomcat_ip:8080</code>页面，我们可以看到3个按钮，分别的功用为：</p>
<p>Server Status：tomcat服务器状态，包括内存信息，进程信息等等。<br>manager App：Web App的管理页面，可以开、关、重载、部署、卸载 Web App<br>Host Manager：虚拟主机的管理页面，可以对虚拟主机进行添加删除修改操作。</p>
<h2 id="Tomcat-Web-Application-Manager-（简称-manager）"><a href="#Tomcat-Web-Application-Manager-（简称-manager）" class="headerlink" title="Tomcat Web Application Manager （简称 manager）"></a>Tomcat Web Application Manager （简称 manager）</h2><p>这个工具Tomcat里一个启动（Start）\关闭(Stop)\重载(Reload)\部署(Deploy)\卸载(Undeploy) Web App的一个非常好用的工具，可以实现热部署。</p>
<p>但是点开会提示权限禁止，需要配置：<br><a href="http://www.yulongjun.com/images/15041803591413.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203144909.jpg" alt="img"></a></p>
<ul>
<li>manager-gui - allows access to the HTML GUI and the status pages</li>
<li>manager-script - allows access to the text interface and the status pages</li>
<li>manager-jmx - allows access to the JMX proxy and the status pages</li>
<li>manager-status - allows access to the status pages only</li>
</ul>
<p>我们可以看到，要增加页面的manger权限，需要manager-gui角色，然后赋予相应的用户这个角色，这个角色同事也支持状态页，也就是页面上的<code>Server status</code>。</p>
<p><code>vim $CATALINA_BASE/conf/tomcat-users.xml</code>,在<code>tomcat-users</code>tag里写如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;<br>&lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;LongDream&quot; roles&#x3D;&quot;manager-gui&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tomcat 7里不需要再修改任何东西就可以访问，tocmat 8 做了权限控制，只有tomcat本机才能访问，所以还需要去相应的manager的context.xml中的valve的权限选项：<br><code>vim $CATALINA_HOME/webapps/manager/META-INF/context.xml</code><br>修改其中的<code>Valve</code>阀门中的<code>allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot;</code>为<code>allow=&quot;192\.168+\.111+\.\d+|::1|0:0:0:0:0:0:0:1&quot;</code><br><code>context.xml</code>修改完之后的全部的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;Context antiResourceLocking&#x3D;&quot;false&quot; privileged&#x3D;&quot;true&quot; &gt;<br>  &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.RemoteAddrValve&quot;<br>         allow&#x3D;&quot;192\.168+\.111+\.\d+|::1|0:0:0:0:0:0:0:1&quot; &#x2F;&gt;<br>  &lt;Manager sessionAttributeValueClassNameFilter&#x3D;&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;&#x2F;&gt;<br>&lt;&#x2F;Context&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>重启tomcat，systemd管理的tomcat 7 ，重启用<code>systemctl restart tomcat</code></p>
<p>手动安装的tomcat 8.5.x，可以<code>catalina.sh stop</code> 然后 <code>catalina.sh start</code>来重启。</p>
<p>下面就是 Manager的界面：</p>
<p><a href="http://www.yulongjun.com/images/15041830240367.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203144910.jpg" alt="img"></a></p>
<h2 id="Tomcat-Virtual-Host-Manager-（简称-host-manager）"><a href="#Tomcat-Virtual-Host-Manager-（简称-host-manager）" class="headerlink" title="Tomcat Virtual Host Manager （简称 host manager）"></a>Tomcat Virtual Host Manager （简称 host manager）</h2><p>可以实现虚拟主机的热管理。</p>
<p><code>vim $CATALINA_BASE/conf/tomcat-users.xml</code>,在<code>tomcat-users</code>tag里再添加一条，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;<br>&lt;role rolename&#x3D;&quot;admin-gui&quot;<br>&lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;LongDream&quot; roles&#x3D;&quot;manager-gui,admin&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>

<p><a href="http://www.yulongjun.com/images/15041839192351.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203144911.jpg" alt="img"></a></p>
<h2 id="Server-Status"><a href="#Server-Status" class="headerlink" title="Server Status"></a>Server Status</h2><p>上面个两个配置任意一个配置好了后，都可以启用Server Status的GUI界面：</p>
<p><a href="http://www.yulongjun.com/images/15041855429754.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201203144912.jpg" alt="img"></a></p>
<h2 id="JVM-Memory-Status"><a href="#JVM-Memory-Status" class="headerlink" title="JVM Memory Status"></a>JVM Memory Status</h2><p><strong>MAX memory</strong>：大约为服务器最大内存的四分之一左右。可以自定义，最大不超过32G。</p>
<p>Heap 内存区分为：<code>Eden Space</code>（伊甸园）、<code>Survivor Space</code>(幸存者区)、<code>Tenured Gen</code>（老年代-养老区）。</p>
<p>非Heap 内存区分为：Code Cache（代码缓存区）、Compressed Class Space（压缩的类区）、Metaspace（源数据区）</p>
<h2 id="AJP-服务-和HTTP服务（默认HTTPS服务没有启用）"><a href="#AJP-服务-和HTTP服务（默认HTTPS服务没有启用）" class="headerlink" title="AJP 服务 和HTTP服务（默认HTTPS服务没有启用）"></a>AJP 服务 和HTTP服务（默认HTTPS服务没有启用）</h2><p>AJP(默认监听在<strong>8009</strong>端口）、HTTP（默认监听在<strong>8080</strong>端口）</p>
<p>服务阶段（Stage）<br><code>P</code>: Parse and prepare request （解析和准备请求）<br><code>S</code>: Service （服务中）<br><code>F</code>: Finishing （完成服务）<br><code>R</code>: Ready （准备好）<br><code>K</code>: Keepalive（保持连接）</p>
]]></content>
  </entry>
  <entry>
    <title>github加jsDelivr做图床测试</title>
    <url>/github%E5%8A%A0jsDelivr%E5%81%9A%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://cdn.jsdelivr.net/gh/ashjian/jsDelivr@1.0/img/%E3%80%90FGO%E3%80%91%E3%83%87%E3%82%AB%E4%B9%B3%E5%A9%A6%E9%95%B7%E3%81%A7Yeah_Oh_Ahhh_Oh!_photo.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>hexo的next主题博客添加网易云音乐</title>
    <url>/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>打开网易云客户端，打开<code>公开</code>的音乐菜单（私有的菜单是无分享按键的，所以我的羞耻图也暴露出去，祈求别举报，为了让图过审，都封号几次）</p>
<p>点用击分享中的的复制连接</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204125547.png" alt="image-20201204124310823"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204123442.png" alt="image-20201204123437920"></p>
<p>用浏览器打开该连接</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204123744.png" alt="image-20201204123740102"></p>
<p>点击生<code>成外链接播放器</code>，个人遇到小问题，因为有部分音乐的版权问题，导致全部都无法通过。但有法子。</p>
<p>它只是前端禁止而已，点击该按钮的连接依然生成了，是有效的。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204124107.png" alt="image-20201204123806665"></p>
<p>右键点击“检查”</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204124104.png" alt="image-20201204124059800"></p>
<p>红色框的那数字串是我们需要的</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204125546.png" alt="image-20201204122928305"></p>
<p>.输入网址：<a href="https://music.163.com/#/outchain/0/5281251057" target="_blank" rel="noopener">https://music.163.com/#/outchain/0/5281251057</a></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204125548.png" alt="image-20201204124541521"></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204125549.png" alt="image-20201204124706090"></p>
<p>我个人是使用ifranme插件生成外链接播放器,选择了310*90的尺寸，再调整height为66，得出该代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;110 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;5281251057&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt; #修改90为60<br></code></pre></td></tr></table></figure>



<h3 id="修改-themes-next-layout-macro-sidebar-swig-文件"><a href="#修改-themes-next-layout-macro-sidebar-swig-文件" class="headerlink" title="修改 themes/next/layout/_macro/sidebar.swig 文件"></a>修改 <code>themes/next/layout/_macro/sidebar.swig</code> 文件</h3><p>添加音乐播放器内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;% if theme.background_music %&#125;<br>           &lt;div id&#x3D;&quot;music163player&quot;&gt;<br>              &lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;&quot;210&quot; height&#x3D;&quot;110&quot; src&#x3D;&quot;&#123;&#123; theme.background_music &#125;&#125;&quot;&gt;&lt;&#x2F;iframe&gt;<br>           &lt;&#x2F;div&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure>

<h3 id="在-themes-next-config-yml-配置文件中添加歌单地址配置"><a href="#在-themes-next-config-yml-配置文件中添加歌单地址配置" class="headerlink" title="在 themes/next/_config.yml 配置文件中添加歌单地址配置"></a>在 <code>themes/next/_config.yml</code> 配置文件中添加歌单地址配置</h3><p>tip：_config.yml中可以定义theme的各变量。现在就是将生成的音乐外部连接赋值给一个变量，在sidebar.swig中引用它，方便管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">background_music: &#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;5281251057&amp;auto&#x3D;1&amp;height&#x3D;66<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hexo clean<br>hexo g<br></code></pre></td></tr></table></figure>

<p>预览查看</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201204125550.png" alt="image-20201204125351899"></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>网易云音乐</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables的使用以及NAT的原理</title>
    <url>/iptables%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8ANAT%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本节我们来讲一讲防火墙的知识。所谓防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障.是一种获取安全性方法的形象说法，它是一种计算机硬件和软件的结合，使Internet与Intranet之间建立起一个安全网关（Security Gateway），从而保护内部网免受非法用户的侵入。防火墙按照工作在不同TCP/IP层又可以分为网络层防火墙和应用层网关防火墙，二本节我们要讲的内容为网络层防火墙，即iptables，组件为netfilter/iptables。</p>
<p>   netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</p>
<p>  iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
<p>  那么下面我们就来讲讲netfilter的组成部分以及iptables命令的使用方法。</p>
<p><strong>netfilter</strong></p>
<p>netfilter由4表5链组成。</p>
<p>5条链即为5个hook function（钩子函数），可以理解为数据包传送到该计算机时的5个检查点。分别为：</p>
<p><strong>PREROUTING：路由前</strong></p>
<p><strong>INPUT：到达本机内部的报文必经之路</strong></p>
<p><strong>FORWARD：由本机转发的报文必经之路</strong></p>
<p><strong>OUTPUT：由本机发出的报文的必经之路</strong></p>
<p><strong>POSTROUTING：路由后</strong></p>
<p><a href="https://s3.51cto.com/wyfs02/M02/46/B9/wKiom1P0FxmD7AQbAACe5OxAR-8195.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150824.jpg" alt="wKiom1P0FxmD7AQbAACe5OxAR-8195.jpg"></a></p>
<p>而4张表（即功能）分别为：raw, mangle, nat, filter。</p>
<p><strong>raw:</strong> 目标是关闭nat表上启用的连接追踪功能；</p>
<p><strong>mangle:</strong>包重构，把包拆开来打上某些标记再送走</p>
<p><strong>nat:</strong> 地址转换，启用connection_track;</p>
<p>SNAT</p>
<p>DNAT</p>
<p>PNAT</p>
<p><strong>filter:</strong> 过滤，定义是否允许通过防火墙</p>
<p><strong>注意这4张表是有优先级的概念的，这里我是按照优先级排的。</strong></p>
<p>表和链之间的对应关系。</p>
<p><strong>filter: INPUT, FORWARD, OUTPUT</strong></p>
<p><strong>nat: PREROUTING（DNAT），POSTROUTING（SNAT），OUTPUT</strong></p>
<p><strong>mangle: PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING</strong></p>
<p><strong>raw: PREROUTING, OUTPUT</strong></p>
<p>数据报文流程：如下图所示</p>
<p>跟本机内部进程通信：</p>
<p>进入：PREROUTING, INPUT</p>
<p>出去：OUTPUT, POSTROUTING</p>
<p>由本机转发：</p>
<p>PREROUTING, FORWARD, POSTROUTING</p>
<p>数据报文的流向：</p>
<p>源IP和目标IP由流向决定；</p>
<p><a href="https://s3.51cto.com/wyfs02/M02/46/B8/wKiom1P0EpLw5_9sAALLkdGkAPE897.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150830.jpg" alt="wKiom1P0EpLw5_9sAALLkdGkAPE897.jpg"></a></p>
<p><strong>iptables</strong></p>
<p>当你要写规则时，应该先确定功能（表），确定报文流向，确定要实现的目标，确定匹配件。</p>
<p><strong>iptables规则定义原则：</strong></p>
<p><strong>1、同一类规则，尽量优化条目数量；</strong></p>
<p><strong>2、彼此不相关的规则匹配量大的规则，放在前面，匹配机会较多放在上面；</strong></p>
<p><strong>3、同一类规则，匹配规则更严格放在上面。</strong></p>
<p><strong>必须要注意的是：规则立即生效，所以当你使用iptables时需要先添加放行自己会话的规则，避免自己的会话被拒绝。</strong></p>
<p>规则文件：/etc/sysconfig/iptables</p>
<p><strong>保存启用中的规则于规则文件中：</strong></p>
<p>1、# iptables-save &gt; /etc/sysconfig/iptables</p>
<p>2、# service iptables save</p>
<p><strong>生效规则文件中的规则：</strong></p>
<p>1、# iptables-restore &lt; /etc/sysconfig/iptables</p>
<p>2、# service iptables restart</p>
<p><strong>执行的操作：清空现有规则，读取并生效规则文件中的规则</strong></p>
<p><strong>基本语法：</strong></p>
<p><strong>iptables [-t TABLE] COMMAND CHAIN  CRETIRIA -j TARGET</strong></p>
<p>下面对每一项进行解释：</p>
<p>-t TABLE: 选择哪个表</p>
<p>  nat, mangle, raw, filter</p>
<p>  默认为filter</p>
<p><strong>COMMAND:</strong></p>
<p>链：</p>
<p>-F：flush, 清空规则链；</p>
<p>-N：new, 自建一条链</p>
<p>-X: delete, 删除一条自定义的空链</p>
<p>-Z：zero，计数器归零</p>
<p>-P：policy，设置默认策略，对filter表来讲，默认规则为ACCEPT或DROP；</p>
<p>-E：重命名自定义链</p>
<p>链中的规则：</p>
<p>-A 添加规则</p>
<p>-I 插入规则</p>
<p>-D 删除规则</p>
<p>-R 修改规则</p>
<p>查询：</p>
<p>-L</p>
<p>  -n: 数字格式显示主机地址和端口；</p>
<p>  -v: 详细格式，-vv, -vvv</p>
<p>  -x: exactly，不要对计数器的计数结果做单位换算，而显示其精确值  </p>
<p>  –line-numbers: 显示规则编号</p>
<p>查看后得到的</p>
<p><a href="https://s3.51cto.com/wyfs02/M00/46/BB/wKioL1P0HIDAYoOsAACJkGyHUog513.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150845.jpg" alt="wKioL1P0HIDAYoOsAACJkGyHUog513.jpg"></a></p>
<p>pkts bytes  target   prot opt in     out     source        destination</p>
<p>包数 字节数 目标    协议  流入的接口  流出的接口  源地址        目标地址</p>
<p><strong>CHAIN：选定哪个链</strong></p>
<p><strong>添加规则</strong></p>
<p>iptables [-t TABLE] -A 链名 <strong>匹配条件</strong> -j <strong>处理目标</strong></p>
<p><strong>匹配条件</strong>：</p>
<p><strong>通用匹配</strong></p>
<p>-s 地址：指定报文源IP地址匹配的范围；可以是IP，也可以是网络地址；可使用<strong>!取反；</strong></p>
<p>  –src, –source</p>
<p>-d 地址：指定报文目标IP地址匹配的范围；</p>
<p>  –dst, –destination</p>
<p>-p 协议：指定匹配报文的协议类型，一般有三种tcp, udp和icmp;</p>
<p>-i INTERFACE: 数据报文流入的接口；PREROUTING, INPUT, FORWARD</p>
<p>-o INTERFACE: 数据报文流出的接口；OUTPUT, FORWARD, POSTROUITING</p>
<p><strong>扩展匹配：</strong>调用netfilter额外模块实现特殊检查机制，（使用到相关功能，要使用iptables命令的-m选项来指定调用哪个模块）</p>
<p>**<br>**</p>
<p><strong>隐式扩展</strong>：当使用-p {tcp|udp|icmp}中的一种时，可以直接使用扩展专用选项；</p>
<p><strong>-p tcp:</strong></p>
<p> –sport PORT[-PORT]: 指定源端口</p>
<p> –dport PORT[-PORT]: 指定目标端口</p>
<p> –tcp-flags</p>
<p> 要检查标志位列表（用逗号分隔）  必须为1的标志位列表（逗号分隔）</p>
<p> –syn</p>
<p><strong>-p udp:</strong></p>
<p> –sport </p>
<p> –dport</p>
<p><strong>-p icmp [-m icmp]</strong></p>
<p> –icmp-type</p>
<p> 0: echo-reply, ping响应</p>
<p> 8: echo-request, ping请求</p>
<p><strong>显式扩展</strong>：必须明确说明使用哪个模块进行扩展，而后才能使用其扩展专用选项；</p>
<p>-m 扩展模块名称</p>
<p><strong>multiport: 多端口匹配</strong></p>
<p>可用于匹配非连续或连续端口；最多指定15个端口；</p>
<p>专用选项：</p>
<p>–source-ports, –sports port[,port,port:port]</p>
<p>–destination-ports, –dports</p>
<p>–ports</p>
<p>例子：开放22,80端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables -I INPUT -d 172.16.100.7 -p tcp -m multiport --dports 22,80 -j ACCEPT</span><br><span class="hljs-comment"># iptables -I OUTPUT -s 172.16.100.7 -p tcp -m multiport --sports 22,80 -j ACCEPT</span><br></code></pre></td></tr></table></figure>



<p><strong>iprange: 匹配指定范围内的地址；</strong></p>
<p>匹配一段连续的地址而非整个网络时有用；</p>
<p>专用选项：</p>
<p>[!] –src-ragne IP[-IP]</p>
<p>[!] –dst-range</p>
<p>例子：限定一段连续地址可以通过telnet连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables -A INPUT -d 172.16.100.7 -p tcp --dport 23 -m iprange --src-range 172.16.100.1-172.16.100.100 -j ACCEPT</span><br><span class="hljs-comment"># iptables -A OUTPUT -s 172.16.100.7 -p tcp --sport 23 -m iprange --dst-range 172.16.100.1-172.16.100.100 -j ACCEPT</span><br></code></pre></td></tr></table></figure>



<p><strong>string: 字符串匹配，能够检测报文应用层中的字符串</strong></p>
<p>专用选项：</p>
<p>–algo {kmp|bm} 2种不同的算法，选一种</p>
<p>–string “STRING”    STRING为你想要匹配的字符串</p>
<p>–hex-string “HEX_STRING”: HEX_STRING为编码成16进制格式的字串；</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables -I OUTPUT -m string --algo kmp --string "sex" -j DROP</span><br></code></pre></td></tr></table></figure>



<p><strong>time: 基于时间做访问控制</strong></p>
<p>专用选项：</p>
<p>–datestart YYYY[-MM][-DD[Thh[:mm[:ss]]]]</p>
<p>–datestop </p>
<p>–timestart hh:mm[:ss]</p>
<p>–timestop hh:mm[:ss]</p>
<p>–weekdays day[,day]</p>
<p>Mon, Tue,…..   中间用逗号隔开 </p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables -I INPUT -d 172.16.100.7 -p tcp --dport 80 -m time --timestart 08:20 --timestop 18:40 --weekdays Mon,Tue  -j ACCEPT</span><br></code></pre></td></tr></table></figure>



<p><strong>connlimit: 连接数限制，对每IP所能够发起并发连接数做限制</strong>；</p>
<p>专用选项：</p>
<p>[!] –connlimit-above [n] </p>
<p>例子：限制同一IP ssh远程连接数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#iptables -A INPUT -d 172.16.100.7 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j DROP</span><br></code></pre></td></tr></table></figure>



<p><strong>limit: 速率限制</strong></p>
<p>专用选项：</p>
<p>–limit n[/second|/minute|/hour|/day]</p>
<p>–limit-burst n  </p>
<p>例子：限制每分钟只能ping20次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables -A INPUT -d 172.16.100.7 -p icmp --icmp-type 8 -m limit --limit 20/minute --limit-burst 5 -j ACCEPT</span><br></code></pre></td></tr></table></figure>



<p><strong>state: 状态检查</strong></p>
<p>专用选项：</p>
<p>–state </p>
<p>连接追踪中的状态：</p>
<p><strong>NEW: 新建立一个会话</strong></p>
<p><strong>ESTABLISHED：已建立的连接</strong></p>
<p><strong>RELATED: 有关联关系的连接</strong></p>
<p><strong>INVALID: 无法识别的连接</strong></p>
<p>例子：放行所有已建立连接的数据包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</span><br></code></pre></td></tr></table></figure>

<p>**<br>**</p>
<p><strong>处理目标：</strong></p>
<p>1、DROP :  丢弃</p>
<p>2、REJECT: 拒绝</p>
<p>3、ACCEPT: 放行</p>
<p>4、自定义的链 :  根据自定义链中的规则进行匹配</p>
<p>  创建自定义链：</p>
<p>iptables [-t table] -N chain</p>
<p>  删除自定义且0引用的空链</p>
<p>iptables [-t table] -X chain</p>
<p>  重命名自定义链：</p>
<p>iptables [-t table] -E old_name new_name</p>
<p>5、DNAT：明确申明要做的是目的地地址转换操作  </p>
<p>6、SNAT：明确申明要做的是源地址转换操作</p>
<p>7、REDIRECT：重定向：主要用于实现端口重定向</p>
<p>8、MARK：打防火墙标记的</p>
<p>9、RETURN：在自义链中无法匹配报文时，将其返回主链</p>
<p>调整连接追踪功能所能容纳的连接的最大数目：</p>
<p>/proc/sys/net/nf_conntrack_max</p>
<p>  当前追踪的所有连接</p>
<p>/proc/net/nf_conntrack</p>
<p>  不同协议或连接类型追踪时的属性：</p>
<p>/proc/sys/net/netfilter目录：</p>
<p><strong>下面我们以ftp服务为例：</strong></p>
<p> 放行被动模式下的FTP服务：</p>
<p>1、<strong>装载模块</strong>/lib/modules/KERNEL_VERSION/kernel/net/netfilter/</p>
<p>模块：nf_conntrack_ftp</p>
<p>​     装载命令：modprobe nf_conntrack_ftp</p>
<p>​     卸载：modprobe -r nf_conntrack_ftp</p>
<p>2、<strong>放行请求报文</strong>：</p>
<p>​     (1) 放行NEW状态对21端口请求的报文；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># iptables -A INPUT -d 172.16.106.1 -p tcp --dport 21 -m state --NEW -j ACCEPT</span><br></code></pre></td></tr></table></figure>

<p>(2) 放行ESTABLISHED以及RELATED状态的报文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></code></pre></td></tr></table></figure>

<p>3、<strong>放行响应报文</strong>：</p>
<p>放行ESTABLISHED以及RELATED状态的报文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></code></pre></td></tr></table></figure>

<p>这样FTP服务就可以运行了。</p>
<p>iptables的路由转发功能</p>
<p>所谓的转发功能就是启用forward功能，并且结合地址转换功能，使得2个属于不同网络的主机或者服务器之间可以进行连接通信。（这里默认INPUT,OUTPUT链的策略为drop）</p>
<p>首先必须在配置文件中将路由转发功能开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#vim /etc/sysctl.conf</span><br>net.ipv4.ip_forward = 1<br><span class="hljs-comment">#sysctl -p   重读配置文件</span><br></code></pre></td></tr></table></figure>

<p>上面的启用之后就可以通过iptables命令来进行添加规则了。</p>
<p>下面我们通过下图来解释一下转发时的地址转换原理。</p>
<p><strong>SNAT</strong></p>
<p><a href="https://s3.51cto.com/wyfs02/M02/46/C1/wKiom1P0TWXAqqkbAAEhyrbZvJE837.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150858.jpg" alt="wKiom1P0TWXAqqkbAAEhyrbZvJE837.jpg"></a></p>
<p>假设中间的网关主机为B：由2个地址，一个是内网地址172.16.0.1，一个外网地址192.168.1.1<br>当私网中的主机A想访问公网中的WEB主机时，由于不能直接访问，于是A就通过网关主机的路由发送请求，</p>
<p>假设不进行地址转换,则网关主机允许路由转发，于是请求到达了web主机，然而当web收到请求后，于是返回响应报文，但是WEB发现该请求的源地址是一个私网地址，因此WEB无法将响应报文送回到网关主机B；</p>
<p>因此在网关主机B中必须进行地址转换，在报文将要离开主机B的之前将源地址改为1.1.1.1<strong>（注意：在转换完成之后，主机B会自动生成一张表，记录了内网中的那个主机发起哪个请求，因此当该请求的响应报文从远程主机返回之后，主机B会自动根据该表将响应报文中的IP地址改为请求主机的IP）</strong>，然后再将报文发送给WEB；当WEB收到报文后做出响应，发出响应报文，源地址为2.2.2.2,目标地址问1.1.1.1，因此响应报文发送给了主机B，经过地址转换之后，主机B又将响应报文送回给A，这样才完成了整个通信过程。</p>
<p>由于上述完成的是一个<strong>SNAT</strong>的过程，<strong>即在请求的过程中目标地址始终没变，变的只是源地址</strong>，因此在写规则是，写在POSTROUTING链中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#iptables -t nat -A POSTROUTING -s 172.16.6.2   -j SNAT --to-source 1.1.1.1</span><br></code></pre></td></tr></table></figure>

<p>**<br>**</p>
<p><strong>DNAT</strong></p>
<p>如果是一个<strong>DNAT</strong>的过程的话，写规则时的链就不同，应该写在PREROUTING链中：</p>
<p>该过程就可以看成是公网中的主机C来访问B中的web的服务，然而B只是一台代理服务器，它的web服务是他内网中的www服务器提供的，如下图。</p>
<p><a href="https://s3.51cto.com/wyfs02/M00/46/C2/wKiom1P0VbmCHrM2AAEu2ifj3yw920.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150903.jpg" alt="wKiom1P0VbmCHrM2AAEu2ifj3yw920.jpg"></a></p>
<p>根据C发出的请求报文应该是，源地址为2.2.2.2,目标地址为1.1.1.1，而到了B主机之后呢？他收到请求之后发现目标地址为自己，然而他请求的是web服务，应该将请求的目标地址改为WWW主机的IP（172.16.6.2），那么在哪个地方改呢？对，他只能在路由决策之前修改，不然的话请求就送给B主机本身处理了，而非转发给内网中的WWW主机。因此，该规则只能在PREROUTING链中写，IP修改完之后才能进行转发（<strong>当然和上面一样，修改完之后也会生成一张表，记**</strong>录相关信息，当该请求的响应返回时，主机B将会自动根据该表将响应报文中的源IP地址改为1.1.1.1）**，然后再将报文发送给WWW,WWW收到请求后返回响应报文，源地址为172.16.6.2，目标地址为2.2.2.2，当B收到报文后自动将源地址改为1.1.1.1，然后再返回给C主机。这样通信过程才算完成了。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#iptables -t nat -A PREROUTING -d 1.1.1.1   -j DNAT --to-destination 172.16.6.2</span><br></code></pre></td></tr></table></figure>

<p>  本节相关的内容就讲到这里，欢迎大家一起交流，讲的不好不对的请批评指正，谢谢！</p>
]]></content>
  </entry>
  <entry>
    <title>ip数据包经由路由转发的时候源ip，目的ip是否改变</title>
    <url>/ip%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%8F%E7%94%B1%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%E6%BA%90ip%EF%BC%8C%E7%9B%AE%E7%9A%84ip%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>ip数据包经由路由转发的时候源ip，目的ip是否改变？</strong></p>
<p>最近面试网络方面的经常问到这个问题，答案是不能改变的，*<em>除非做了nat转换才能改变</em>。</p>
<p>不过mac地址是变化的，因为发送端开始不知道目的主机的mac地址，所以每经过一个路由器mac地址是变化的。</p>
<p><strong>目的mac地址是如何得到的？</strong></p>
<p>TCP/IP里面是用的ARP协议。比如新建了一个内网，如果一台机器A找机器B，封装FRAME时（OSI的第二层用的数据格式），要封装对方的MAC，开始时A不知道B的MAC，只知道IP，它就发一个ARP包，源IP是自己的，目的IP是B的，源MAC是自己的，目的MAC是广播的。然后这个请求包在内网内被广播，当其他机器接到这个包时，用目的IP和自己的IP比较，不是的话就丢弃。B接到时，发现IP与自己的一样，就答应这个包的请求，把自己的MAC送给A。如果B是其他子网的机器，那么路由器会判断出B是其他子网，然后路由器把自己的MAC返回给A，A以后再给B发包时，目的MAC封装的是路由器的。</p>
<p><strong>路由转发过程：</strong></p>
<p>当主机A发向主机B的数据流在网络层封装成IP数据包，IP数据包的首部包含了源地址和目标地址。<strong>主机A会用本机配置的24位IP网络掩码255.255.255.0与目标地址进行与运算，得出目标网络地址与本机的网络地址是不是在同一个网段中。</strong>如果不是将IP数据包转发到网关。</p>
<p>在发往网关前主机A还会通过ARP的请求获得默认网关的MAC地址。在主机A数据链路层IP数据包封装成以太网数据帧，然后才发住到网关……也就是路由器上的一个端口。</p>
<p>当网关路由器接收到以太网数据帧时，发现数据帧中的目标MAC地址是自己的某一个端口的物理地址，这时路由器会把以太网数据帧的封装去掉。路由器认为这个IP数据包是要通过自己进行转发，接着它就在匹配路由表。匹配到路由项后，它就将包发往下一条地址。</p>
<p>路由器转发数据包就是这样，所以它始终是不会改IP地址的。只会改MAC.</p>
<p>当有数据包传到路由器时，路由器首先将其的目的地址与路由表进行对比，如果是本地网络，将不会进行转发到外网络，而是直接转发给本地网内的目的主机；<strong>但是如果目的地址经路由表对比，发现不是在本网中，有nat就将改变源地址的IP（原源地址的Ip地址改为了路由器的IP地址），</strong>路由器将数据包转发到相应的端口，进行通信。</p>
<p>比如：<br> 如：A访问B，<br> 首先对比是否同一子网，如果是,检查ARP表,有B的MAC就直接发送,没有就发送ARP请求.如果否，发送到默认网关C，源IP为A，源MAC为A，目的IP为B，目的MAC地址为C，<br>C接收到这个包，检查路由表，发送到下一跳D，源IP为A，源MAC为C，目的IP为B，目的MAC为D…..<br>如此循环,直到发送到B.</p>
<p><strong>NAT为特殊应用，会修改源IP为网关自己外网IP。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>lvs</title>
    <url>/lvs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux Cluster：</p>
<p>Cluster：计算机集合，为解决某个特定问题组合起来形成的单个系统；</p>
<p>Linux Cluster类型：<br>    LB：Load Balancing，负载均衡；<br>    HA：High Availiablity，高可用；<br>        A=MTBF/（MTBF+MTTR）<br>            (0,1)：90%, 95%, 99%, 99.5%,  99.9%, 99.99%, 99.999%, 99.9999%<br>    HP：High Performance，高性能；</p>
<p>​    <a href="http://www.top500.org" target="_blank" rel="noopener">www.top500.org</a><br>​<br>分布式系统：<br>​    分布式存储<br>​    分布式计算</p>
<p>系统扩展方式：<br>    Scale UP：向上扩展<br>    Scale Out：向外扩展<br>        Cluster</p>
<p>​<br>​<br>LB    Cluster：<br>​    </p>
<p>LB Cluster的实现：<br>    硬件：<br>        F5 Big-IP<br>        Citrix Netscaler<br>        A10 A10<br>    软件：<br>        lvs：Linux Virtual Server<br>        nginx<br>        haproxy<br>        ats：apache traffic server<br>        perlbal<br>        pound</p>
<p>基于工作的协议层次划分：<br>    传输层（通用）：（DPORT）<br>        lvs：<br>        nginx：（stream）<br>        haproxy：（mode tcp）<br>    应用层（专用）：（自定义的请求模型分类）<br>        proxy server：<br>            http：nginx(http), httpd, haproxy(mode http), …<br>            fastcgi：nginx, httpd, …<br>            mysql：ProxySQL,  …<br>            …</p>
<p>站点指标：<br>    PV：Page View<br>    UV：Unique Vistor<br>    IP：</p>
<p>​    会话保持：<br>​        (1) session sticky<br>​            Source IP<br>​            Cookie<br>​        (2) session replication;<br>​            session cluster<br>​        (3) session server<br>​<br>lvs：Linux Virtual Server<br>​    VS: Virtual Server<br>​    RS: Real Server<br>​<br>​    作者：章文嵩；alibaba –&gt; didi<br>​<br>​    l4：四层路由器，四层交换机；<br>​        VS：根据请求报文的目标IP和目标协议及端口将其调度转发至某RealServer，根据调度算法来挑选RS；<br>​<br>​    iptables/netfilter：<br>​        iptables：用户空间的管理工具；<br>​        netfilter：内核空间上的框架；<br>​            流入：PREROUTING –&gt; INPUT<br>​            流出：OUTPUT –&gt; POSTROUTING<br>​            转发：PREROUTING –&gt; FORWARD –&gt; POSTROUTING<br>​<br>​        DNAT：目标地址转换； PREROUTING；<br>​        SNAT：源地址转换；POSTROUTING；<br>​<br>​    lvs: ipvsadm/ipvs<br>​        ipvsadm：用户空间的命令行工具，规则管理器，用于管理集群服务及相关的RealServer；<br>​        ipvs：工作于内核空间的netfilter的INPUT钩子之上的框架；<br>​<br>​    lvs集群类型中的术语：<br>​        vs：Virtual Server, Director, Dispatcher, Balancer<br>​        rs：Real Server, upstream server, backend server<br>​<br>​        CIP：Client IP, VIP: Virtual serve IP, RIP: Real server IP, DIP: Director IP<br>​<br>​        CIP &lt;–&gt; VIP == DIP &lt;–&gt; RIP<br>​<br>​    lvs集群的类型：<br>​        lvs-nat：修改请求报文的目标IP；多目标IP的DNAT；<br>​        lvs-dr：操纵封装新的MAC地址；<br>​        lvs-tun：在原请求IP报文之外新加一个IP首部；<br>​        lvs-fullnat：修改请求报文的源和目标IP；</p>
<p>​<br>​            lvs-nat：<br>​                多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发；<br>​                </p>
<p>​            （1）RIP和DIP必须在同一个IP网络，且应该使用私网地址；RS的网关要指向DIP；<br>​            （2）请求报文和响应报文都必须经由Director转发；Director易于成为系统瓶颈；<br>​            （3）支持端口映射，可修改请求报文的目标PORT；<br>​            （4）vs必须是Linux系统，rs可以是任意系统；<br>​<br>​        lvs-dr：<br>​            Direct Routing，直接路由；<br>​<br>​            通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变；<br>​<br>​            <strong>Director和各RS都得配置使用VIP</strong>；<br>​<br>​            (1) 确保前端路由器将目标IP为VIP的请求报文发往Director：<br>​                (a) 在前端网关做静态绑定；<br>​                (b) 在RS上使用arptables；<br>​                (c) 在RS上修改内核参数以限制arp通告及应答级别；<br>​                    arp_announce<br>​                    arp_ignore<br>​            (2) RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director；<br>​            (3) RS跟Director要在同一个物理网络；<br>​            (4) 请求报文要经由Director，但响应不能经由Director，而是由RS直接发往Client；<br>​            (5) 不支持端口映射；</p>
<p>回顾：<br>    Linux Cluster：<br>        LB/HA/HP<br>        分布式系统：存储/计算<br>    LB Cluster：<br>        硬件：F5-BigIP/Netscaler/A10<br>        软件：<br>            四层：lvs/nginx(stream)/haproxy(mode tcp)<br>            七层：<br>                http：nginx(http)/httpd/haproxy(mode http)/ats/perlbal/pound<br>                mysql: ProxySQL, …</p>
<p>lvs：Linux Virutal Server<br>    vs/rs; cip/vip/dip/rip</p>
<p>lvs type：<br>    nat/dr/tun/fullnat</p>
<p>nat类型：多目标IP的DNAT，通过修改请求报文的目标IP和PORT来实现调度；<br>dr类型：通过为请求报文重新封装一个MAC首部进行转发：源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；</p>
<p>LVS(2)</p>
<p>​        lvs-tun：<br>​            转发方式：不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而是在原IP报文之外再封装一个IP首部（源IP是DIP，目标IP是RIP），将报文发往挑选出的目标RS；RS直接响应给客户端（源IP是VIP，目标IP是CIP）；<br>​<br>​            (1) DIP, VIP, RIP都应该是公网地址；<br>​            (2) RS的网关不能，也不可能指向DIP；<br>​            (3) 请求报文要经由Director，但响应不能经由Director；<br>​            (4) 不支持端口映射；<br>​            (5) RS的OS得支持隧道功能；<br>​<br>​        lvs-fullnat：<br>​            通过同时修改请求报文的源IP地址和目标IP地址进行转发；<br>​                CIP &lt;–&gt; DIP<br>​                VIP &lt;–&gt; RIP<br>​<br>​            (1) VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关一般不会指向DIP；<br>​            (2) RS收到的请求报文源地址是DIP，因此，只能响应给DIP；但Director还要将其发往Client；<br>​            (3) 请求和响应报文都经由Director；<br>​            (4) 支持端口映射；<br>​<br>​            注意：此类型默认不支持；</p>
<p>​        总结：<br>​            lvs-nat, lvs-fullnat：请求和响应报文都经由Director；<br>​                lvs-nat：RIP的网关要指向DIP；<br>​                lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信；<br>​            lvs-dr, lvs-tun：请求报文要经由Director，但响应报文由RS直接发往Client；<br>​                lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发；<br>​                lvs-tun：通过在原IP报文之外封装新的IP首部实现转发，支持远距离通信；<br>​<br>​    ipvs scheduler：<br>​        根据其调度时是否考虑各RS当前的负载状态，可分为静态方法和动态方法两种：<br>​            </p>
<pre><code>        静态方法：仅根据算法本身进行调度；
            RR：roundrobin，轮询；
            WRR：Weighted RR，加权轮询；
            SH：Source Hashing，实现session sticky，源IP地址hash；将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定；
            DH：Destination Hashing；目标地址哈希，将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡；

        动态方法：主要根据每RS当前的负载状态及调度算法进行调度；
            Overhead=

            LC：least connections
                Overhead=activeconns*256+inactiveconns
            WLC：Weighted LC
                Overhead=(activeconns*256+inactiveconns)/weight
            SED：Shortest Expection Delay
                Overhead=(activeconns+1)*256/weight
            NQ：Never Queue

            LBLC：Locality-Based LC，动态的DH算法；
            LBLCR：LBLC with Replication，带复制功能的LBLC；

ipvsadm/ipvs：
    集群和集群之上的各RS是分开管理的；
        集群定义
        RS定义

    ipvs：
        ~]# grep -i -C 10 &quot;ipvs&quot; /boot/config-VERSION-RELEASE.x86_64

            支持的协议：TCP， UDP， AH， ESP， AH_ESP,  SCTP；

        ipvs集群：
            集群服务
            服务上的RS

    ipvsadm：
        程序包：ipvsadm
            Unit File: ipvsadm.service
            主程序：/usr/sbin/ipvsadm
            规则保存工具：/usr/sbin/ipvsadm-save
            规则重载工具：/usr/sbin/ipvsadm-restore
            配置文件：/etc/sysconfig/ipvsadm-config</code></pre><p>​<br>​            ipvsadm命令：<br>​                核心功能：<br>​                    集群服务管理：增、删、改；<br>​                    集群服务的RS管理：增、删、改；<br>​                    查看：<br>​<br>​                ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [–pe persistence_engine] [-b sched-flags]<br>​                ipvsadm -D -t|u|f service-address<br>​                ipvsadm -C<br>​                ipvsadm -R<br>​                ipvsadm -S [-n]<br>​                ipvsadm -a|e -t|u|f service-address -r server-address [options]<br>​                ipvsadm -d -t|u|f service-address -r server-address<br>​                ipvsadm -L|l [options]<br>​                ipvsadm -Z [-t|u|f service-address]<br>​<br>​                管理集群服务：增、改、删；<br>​                    增、改：<br>​                        ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]<br>​<br>​                    删：<br>​                        ipvsadm -D -t|u|f service-address<br>​<br>                    service-address：<br>                        -t|u|f：<br>                            -t: TCP协议的端口，VIP:TCP_PORT<br>                            -u: UDP协议的端口，VIP:UDP_PORT<br>                            -f：firewall MARK，是一个数字；</p>
<pre><code>                [-s scheduler]：指定集群的调度算法，默认为wlc；

            管理集群上的RS：增、改、删；
                增、改：
                    ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight]

                删：
                    ipvsadm -d -t|u|f service-address -r server-address

                server-address：
                    rip[:port]

                选项：
                    lvs类型：
                        -g: gateway, dr类型
                        -i: ipip, tun类型
                        -m: masquerade, nat类型

                    -w weight：权重；

            清空定义的所有内容：
                ipvsadm -C

            查看：
                ipvsadm -L|l [options]
                    --numeric, -n：numeric output of addresses and ports 
                    --exact：expand numbers (display exact values)

                    --connection， -c：output of current IPVS connections
                    --stats：output of statistics information
                    --rate ：output of rate information

            保存和重载：
                ipvsadm -S = ipvsadm-save
                ipvsadm -R = ipvsadm-restore 

负载均衡集群设计时要注意的问题：
    (1) 是否需要会话保持；
    (2) 是否需要共享存储；
        共享存储：NAS， SAN， DS（分布式存储）
        数据同步：
            课外作业：rsync+inotify实现数据同步 

    lvs-nat：

        设计要点：
            (1) RIP与DIP在同一IP网络, RIP的网关要指向DIP；
            (2) 支持端口映射；
            (3) Director要打开核心转发功能；

        实践作业（博客）：负载均衡两个php应用（wordpress，discuzx）；
            测试：(1) 是否需要会话保持；(2) 是否需要共享存储；


    lvs-dr：

        dr模型中，各主机上均需要配置VIP，解决地址冲突的方式有三种：
            (1) 在前端网关做静态绑定；
            (2) 在各RS使用arptables；
            (3) 在各RS修改内核参数，来限制arp响应和通告的级别；
                限制响应级别：arp_ignore
                    0：默认值，表示可使用本地任意接口上配置的任意地址进行响应；
                    1: 仅在请求的目标IP配置在本地主机的接收到请求报文接口上时，才给予响应；
                限制通告级别：arp_announce
                    0：默认值，把本机上的所有接口的所有信息向每个接口上的网络进行通告；
                    1：尽量避免向非直接连接网络进行通告；
                    2：必须避免向非本网络通告；

        实践作业（博客）：负载均衡两个php应用（wordpress，discuzx）；
            测试：(1) 是否需要会话保持；(2) 是否需要共享存储；

        RS的预配置脚本：
            #!/bin/bash
            #
            vip=10.1.0.5
            mask=&apos;255.255.255.255&apos;

            case $1 in
            start)
                echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
                echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
                echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
                echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce

                ifconfig lo:0 $vip netmask $mask broadcast $vip up
                route add -host $vip dev lo:0
                ;;
            stop)
                ifconfig lo:0 down

                echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
                echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
                echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
                echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce

                ;;
            *) 
                echo &quot;Usage $(basename $0) start|stop&quot;
                exit 1
                ;;
            esac                    

        VS的配置脚本：
            #!/bin/bash
            #
            vip=&apos;10.1.0.5&apos;
            iface=&apos;eno16777736:0&apos;
            mask=&apos;255.255.255.255&apos;
            port=&apos;80&apos;
            rs1=&apos;10.1.0.7&apos;
            rs2=&apos;10.1.0.8&apos;
            scheduler=&apos;wrr&apos;
            type=&apos;-g&apos;

            case $1 in
            start)
                ifconfig $iface $vip netmask $mask broadcast $vip up
                iptables -F

                ipvsadm -A -t ${vip}:${port} -s $scheduler
                ipvsadm -a -t ${vip}:${port} -r ${rs1} $type -w 1
                ipvsadm -a -t ${vip}:${port} -r ${rs2} $type -w 1
                ;;
            stop)
                ipvsadm -C
                ifconfig $iface down
                ;;
            *)
                echo &quot;Usage $(basename $0) start|stop&quot;
                exit 1
                ;;
            esac                

        课外扩展作业：vip与dip/rip不在同一网段的实验环境设计及配置实现； 

        博客作业：lvs的详细应用
            讲清楚类型、调度方法；并且给出nat和dr类型的设计拓扑及具体实现；

FWM：FireWall Mark 
    netfilter：
        target: MARK, This  target  is  used  to set the Netfilter mark value associated with the packet.

            --set-mark value

    借助于防火墙标记来分类报文，而后基于标记定义集群服务；可将多个不同的应用使用同一个集群服务进行调度；

    打标记方法（在Director主机）：
        # iptables -t mangle -A PREROUTING -d $vip -p $proto --dport $port -j MARK --set-mark NUMBER 

    基于标记定义集群服务：
        # ipvsadm -A -f NUMBER [options]

lvs persistence：持久连接

    持久连接模板：实现无论使用任何调度算法，在一段时间内，能够实现将来自同一个地址的请求始终发往同一个RS；

        ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]

    port Affinity：
        每端口持久：每个端口对应定义为一个集群服务，每集群服务单独调度；
        每防火墙标记持久：基于防火墙标记定义集群服务；可实现将多个端口上的应用统一调度，即所谓的port Affinity；
        每客户端持久：基于0端口定义集群服务，即将客户端对所有应用的请求统统调度至后端主机，必须定义为持久模式；

保存及重载规则：
    保存：建议保存至/etc/sysconfig/ipvsadm
        ipvsadm-save &gt; /PATH/TO/IPVSADM_FILE
        ipvsadm -S &gt; /PATH/TO/IPVSADM_FILE
        systemctl stop ipvsadm.service 

    重载：    
        ipvsadm-restore &lt; /PATH/FROM/IPVSADM_FILE
        ipvsadm -R &lt; /PATH/FROM/IPVSADM_FILE
        systemctl restart ipvsadm.service 

考虑：
    (1) Director不可用，整个系统将不可用；SPoF
        解决方案：高可用 
            keepalived 
            heartbeat/corosync
    (2) 某RS不可用时，Director依然会调度请求至此RS；
        解决方案：对各RS的健康状态做检查，失败时禁用，成功时启用；
            keepalived
            heartbeat/corosync, ldirectord
        检测方式：
            (a) 网络层检测；
            (b) 传输层检测，端口探测；
            (c) 应用层检测，请求某关键资源；

            ok --&gt; failure
            failure --&gt; ok

ldirectord：
    Daemon to monitor remote services and control Linux Virtual Server. ldirectord is a daemon to monitor and administer real servers in a cluster of load balanced virtual servers. ldirectord typically is started from heartbeat but can also be run from the command line.

    配置示例：
        checktimeout=3
        checkinterval=1
        fallback=127.0.0.1:80
        autoreload=yes
        logfile=&quot;/var/log/ldirectord.log&quot;
        quiescent=no
        virtual=5
            real=172.16.0.7:80 gate 2
            real=172.16.0.8:80 gate 1
            fallback=127.0.0.1:80 gate
            service=http
            scheduler=wrr
            checktype=negotiate
            checkport=80
            request=&quot;index.html&quot;
            receive=&quot;CentOS&quot;        

补充：共享存储
    NAS：Network Attached Storage
        nfs/cifs
        文件系统接口
    SAN：Storage Area Network
        “块”接口</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>​    </p>
]]></content>
  </entry>
  <entry>
    <title>nagle的tpc_nopush和ctp_nodelay</title>
    <url>/nagle%E7%9A%84tpc-nopush%E5%92%8Cctp-nodelay/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天一道面试题就是关于ngnix下的TCP_NODELAY 和 TCP_NOPUSH就提到这个问题<br>Nginx 有两个配置项： TCP_NODELAY 和 TCP_NOPUSH ，请说明它们的用途及注意事项。</p>
<p> 通俗来说<br>Nagle：<br>假如需要频繁的发送一些小包数据，比如说1个字节，以IPv4为例的话，则每个包都要附带40字节的头，也就是说，总计41个字节的数据里，其中只有1个字节是我们需要的数据。<br>为了解决这个问题，出现了Nagle算法。它规定：如果包的大小满足MSS，那么可以立即发送，否则数据会被放到缓冲区，等到已经发送的包被确认了之后才能继续发送。<br>通过这样的规定，可以降低网络里小包的数量，从而提升网络性能。</p>
<p>再看看DelayedAcknowledgment：<br>假如需要单独确认每一个包的话，那么网络中将会充斥着无数的ACK，从而降低了网络性能。<br>为了解决这个问题，DelayedAcknowledgment规定：不再针对单个包发送ACK，而是一次确认两个包，或者在发送响应数据的同时捎带着发送ACK，又或者触发超时时间后再发送ACK。<br>通过这样的规定，可以降低网络里ACK的数量，从而提升网络性能。</p>
<p>3、Nagle和DelayedAcknowledgment是如何影响性能的<br>Nagle和DelayedAcknowledgment虽然都是好心，但是它们在一起的时候却会办坏事。<br>如果一个 TCP 连接的一端启用了 Nagle‘s Algorithm，而另一端启用了 TCP Delayed Ack，而发送的数据包又比较小，则可能会出现这样的情况：<br>发送端在等待接收端对上一个packet 的 Ack 才发送当前的 packet，而接收端则正好延迟了此 Ack 的发送，那么这个正要被发送的 packet 就会同样被延迟。<br>当然 Delayed Ack 是有个超时机制的，而默认的超时正好就是 40ms。 </p>
<p>现代的 TCP/IP 协议栈实现，默认几乎都启用了这两个功能，你可能会想，按我上面的说法，当协议报文很小的时候，岂不每次都会触发这个延迟问题？<br>事实不是那样的。仅当协议的交互是发送端连续发送两个 packet，然后立刻 read 的 时候才会出现问题。</p>
<p>现在让我们假设某个应用程序发出了一个请求，希望发送小块数据。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。<br>如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。<br>例如，当我们正在发送一个较短的请求并且等候较大的响应时，相关过载与传输的数据总量相比就会比较低，而且，如果请求立即发出那么响应时间也会快一些。<br>以上操作可以通过设置套接字的TCP_NODELAY选项来完成，这样就禁用了Nagle 算法。 </p>
<p>另外一种情况则需要我们等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服务器。<br>应用Nagle算法在这种情况下就会产生问题。但是，如果你正在发送大量数据，你可以设置TCP_CORK选项禁用Nagle化，其方式正好同 TCP_NODELAY相反（TCP_CORK 和 TCP_NODELAY 是互相排斥的）。</p>
<p>假设客户端的请求发生需要等待服务端的应答后才能继续发生下一包，即串行执行，<br>好比在用ab性能测试时只有一个并发做10k的压力测试，测试地址返回的内容只有Hello world；ab发出的request需要等待服务器返回response时，才能发生下一个request；<br>此时ab只会发生一个get请求，请求的相关内容包含在header中；而服务器需要返回两个数据，一个是response头，另一个是html body；</p>
<p>服务器发送端发送的第一个 write 是不会被缓冲起来，而是立刻发送的（response header），<br>这时ab接收端收到对应的数据，但它还期待更多数据（html）才进行处理，所以不会往回发送数据，因此也没机会把 Ack 给带回去，根据Delayed Ack 机制， 这个 Ack 会被 Hold 住。<br>这时服务器发送端发送第二个包，而队列里还有未确认的数据包（response header），这个 packet（html） 会被缓冲起来。<br>此时，服务器发送端在等待ab接收端的 Ack；ab接收端则在 Delay 这个 Ack，所以都在等待，<br>直到ab接收端 Deplayed Ack 超时（40ms），此 Ack 被发送回去，发送端缓冲的这个 packet（html） 才会被真正送到接收端，<br>此时ab才接受到完整的数据，进行对应的应用层处理，处理完成后才继续发生下一个request，因此服务器端才会在read时出现40ms的阻塞。</p>
<p>4、tcp_nodelay为什么只在keep-alive才启作用<br>TCP中的Nagle算法默认是启用的，但是它并不是适合任何情况，对于telnet或rlogin这样的远程登录应用的确比较适合（原本就是为此而设计），但是在某些应用场景下我们却又需要关闭它。<br>在Apache对HTTP持久连接（Keep-Alive，Prsistent-Connection）处理时凸现的奇数包&amp;结束小包问题（The Odd/Short-Final-Segment Problem），<br>这是一个并的关系，即问题是由于已有奇数个包发出，并且还有一个结束小包（在这里，结束小包并不是指带FIN旗标的包，而是指一个HTTP请求或响应的结束包）等待发出而导致的。</p>
<p>我们来看看具体的问题详情，以3个包+1个结束小包为例，可能发生的发包情况：<br>服务器向客户端发出两个大包；客户端在接受到两个大包时，必须回复ack；<br>接着服务器向客户端发送一个中包或小包，但服务器由于Delayed Acknowledgment并没有马上ack；<br>由于发生队列中有未被ack的包，因此最后一个结束的小包被阻塞等待。</p>
<p>最后一个小包包含了整个响应数据的最后一些数据，所以它是结束小包，如果当前HTTP是非持久连接，那么在连接关闭时，最后这个小包会立即发送出去，这不会出现问题；<br>但是，如果当前HTTP是持久连接（非pipelining处理，pipelining仅HTTP 1.1支持，nginx目前对pipelining的支持很弱，它必须是前一个请求完全处理完后才能处理后一个请求），<br>即进行连续的Request/Response、Request/Response、…，处理，那么由于最后这个小包受到Nagle算法影响无法及时的发送出去<br>（具体是由于客户端在未结束上一个请求前不会发出新的request数据，导致无法携带ACK而延迟确认，进而导致服务器没收到客户端对上一个小包的的确认导致最后一个小包无法发送出来），<br>导致第n次请求/响应未能结束，从而客户端第n+1次的Request请求数据无法发出。</p>
<p>在http长连接中，服务器的发生类似于：Write-Write-Read，即返回response header、返回html、读取下一个request<br>而在http短连接中，服务器的发生类似于：write-read-write-read，即返回处理结果后，就主动关闭连接，短连接中的close之前的小包会立即发生，不会阻塞 </p>
<p>我的理解是这样的：因为第一个 write 不会被缓冲，会立刻到达接收端，如果是 write-read-write-read 模式，此时接收端应该已经得到所有需要的数据以进行下一步处理。<br>接收端此时处理完后发送结果，同时也就可以把上一个packet 的 Ack 可以和数据一起发送回去，不需要 delay，从而不会导致任何问题。 </p>
<p>我做了一个简单的试验，注释掉了 HTTP Body 的发送，仅仅发送 Headers， Content-Length 指定为 0。<br>这样就不会有第二个 write，变成了 write-read-write-read 模式。此时再用 ab 测试，果然没有 40ms 的延迟了。</p>
<p>因此在短连接中并不存在小包阻塞的问题，而在长连接中需要做tcp_nodelay开启。</p>
<p>5、那tcp_nopush又是什么？<br>TCP_CORK选项的功能类似于在发送数据管道出口处插入一个“塞子”，使得发送数据全部被阻塞，直到取消TCP_CORK选项（即拔去塞子）或被阻塞数据长度已超过MSS才将其发送出去。</p>
<p>选项TCP_NODELAY是禁用Nagle算法，即数据包立即发送出去，而选项TCP_CORK与此相反，可以认为它是Nagle算法的进一步增强，即阻塞数据包发送，<br>具体点说就是：TCP_CORK选项的功能类似于在发送数据管道出口处插入一个“塞子”，使得发送数据全部被阻塞，<br>直到取消TCP_CORK选项（即拔去塞子）或被阻塞数据长度已超过MSS才将其发送出去。<br>举个对比示例，比如收到接收端的ACK确认后，Nagle算法可以让当前待发送数据包发送出去，即便它的当前长度仍然不够一个MSS，<br>但选项TCP_CORK则会要求继续等待，这在前面的tcp_nagle_check()函数分析时已提到这一点，即如果包数据长度小于当前MSS &amp;&amp;（（加塞 || …）|| …），那么缓存数据而不立即发送：</p>
<p>在TCP_NODELAY模式下，假设有3个小包要发送，第一个小包发出后，接下来的小包需要等待之前的小包被ack，在这期间小包会合并，直到接收到之前包的ack后才会发生；<br>而在TCP_CORK模式下，第一个小包都不会发生成功，因为包太小，发生管道被阻塞，同一目的地的小包彼此合并后组成一个大于mss的包后，才会被发生</p>
<p>TCP_CORK选项“堵塞”特性的最终目的无法是为了提高网络利用率，既然反正是要发一个数据包（零窗口探测包），<br>如果有实际数据等待发送，那么干脆就直接发送一个负载等待发送数据的数据包岂不是更好？</p>
<p>我们已经知道，TCP_CORK选项的作用主要是阻塞小数据发送，所以在nginx内的用处就在对响应头的发送处理上。<br>一般而言，处理一个客户端请求之后的响应数据包括有响应头和响应体两部分，那么利用TCP_CORK选项就能让这两部分数据一起发送：</p>
<p>假设我们需要等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服务器。<br>应用Nagle算法在这种情况下就会产生问题。因为TCP_NODELAY在发生小包时不再等待之前的包有没有ack，网络中会存在较多的小包，但这会影响网络的传输能力；<br>但是，如果你正在发送大量数据，你可以设置TCP_CORK选项禁用Nagle化，其方式正好同 TCP_NODELAY相反（TCP_CORK 和 TCP_NODELAY 是互相排斥的）。</p>
<p>下面就让我们仔细分析下其工作原理。<br>假设应用程序使用sendfile()函数来转移大量数据。应用协议通常要求发送某些信息来预先解释数据，这些信息其实就是报头内容。<br>典型情况下报头很小，而且套接字上设置了TCP_NODELAY。有报头的包将被立即传输，在某些情况下（取决于内部的包计数器），因为这个包成功地被对方收到后需要请求对方确认。<br>这样，大量数据的传输就会被推迟而且产生了不必要的网络流量交换。</p>
<p>但是，如果我们在套接字上设置了TCP_CORK（可以比喻为在管道上插入“塞子”）选项，具有报头的包就会填补大量的数据，所有的数据都根据大小自动地通过包传输出去。<br>当数据传输完成时，最好取消TCP_CORK 选项设置给连接“拔去塞子”以便任一部分的帧都能发送出去。这同“塞住”网络连接同等重要。 </p>
<p>总而言之，如果你肯定能一起发送多个数据集合（例如HTTP响应的头和正文），那么我们建议你设置TCP_CORK选项，这样在这些数据之间不存在延迟。<br>能极大地有益于WWW、FTP以及文件服务器的性能，同时也简化了你的工作。</p>
<p>6、sendfile<br>从技术角度来看，sendfile()是磁盘和传输控制协议（TCP）之间的一种系统呼叫，但是sendfile()还能够用来在两个文件夹之间移动数据。<br>在各种不同的操作系统上实现sendfile()都会有所不同，当然这种不同只是极为细微的差别。通常来说，我们会假定所使用的操作系统是Linux核心2.4版本。<br>系统呼叫的原型有如下几种：<br>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)<br>in_fd 是一种用来读文件的文件描述符。<br>out_fd 是一种用来写文件的描述符。<br>Offset 是一种指向被输入文件变量位置的指针，sendfile()将会从它所指向的位置开始数据的读取。<br>Count 表示的是两个文件描述符之间数据拷贝的字节数。</p>
<p>sendfile()的威力在于，它为大家提供了一种访问当前不断膨胀的Linux网络堆栈的机制。<br>这种机制叫做“零拷贝(zero-copy)”,这种机制可以把“传输控制协议（TCP）”框架直接的从主机存储器中传送到网卡的缓存块（network card buffers）中去。</p>
<p>为了更好的理解“零拷贝（zero-copy）”以及sendfile()，让我们回忆一下以前我们在传送文件时所需要执行的那些步骤。<br>首先，一块在用户机器存储器内用于数据缓冲的位置先被确定了下来。<br>然后，我们必须使用read()这条系统呼叫来把数据从文件中拷贝到前边已经准备好的那个缓冲区中去。<br>（在通常的情况下，这个操做会把数据从磁盘上拷贝到操作系统的高速缓冲存储器中去，然后才会把数据从高速缓冲存储器中拷贝至用户空间中去，这种过程就是所谓的“上下文切换”。）<br>在完成了上述的那些步骤之后，我们得使用write()系统呼叫来将缓冲区中的内容发送到网络上去，程序段如下所示：<br>intout_fd, intin_fd;<br>char buffer[BUFLEN];<br>…<br>/* unsubstantial code skipped for clarity <em>/<br>…<br>read(in_fd, buffer, BUFLEN); /</em> syscall, make context switch <em>/<br>write(out_fd, buffer, BUFLEN); /</em> syscall, make context switch */</p>
<p>操作系统核心不得不把所有的数据至少都拷贝两次：先是从核心空间到用户空间的拷贝，然后还得再从用户空间拷贝回核心空间。<br>每一次操做都需要上下文切换（context-switch）的这个步骤，其中包含了许多复杂的高度占用CPU的操作。<br>系统自带的工具vmstat能够用来在绝大多数UNIX以及与其类似的操作系统上显示当前的“上下文切换（context-switch）”速率。<br>请看叫做“CS”的那一栏，有相当一部分的上下文切换是发生在取样期间的。用不同类型的方式进行装载可以让使用者清楚的看到使用这些参数进行装载时的不同效果。</p>
<p>在有了sendfile()零拷贝（zero-copy）之后，如果可能的话，通过使用直接存储器访问（Direct Memory Access）的硬件设备，数据从磁盘读取到操作系统高速缓冲存储器中会变得非常之迅速。<br>而TLB高速缓冲存储器则被完整无缺的放在那里，没有充斥任何有关数据传输的文件。<br>应用软件在使用sendfile() primitive的时候会有很高的性能表现，这是因为系统呼叫没有直接的指向存储器，因此，就提高了传输数据的性能。<br>通常来说，要被传输的数据都是从系统缓冲存储器中直接读取的，其间并没有进行上下文切换的操作，也没有垃圾数据占据高速缓冲存储器。<br>因此，在服务器应用程序中使用sendfile()能够显著的减少对CPU的占用。</p>
<p>TCP/IP网络的数据传输通常建立在数据块的基础之上。从程序员的观点来看，发送数据意味着发出（或者提交）一系列“发送数据块”的请求。<br>在系统级，发送单个数据块可以通过调用系统函数write() 或者sendfile() 来完成。<br>因为在网络连接中是由程序员来选择最适当的应用协议，所以网络包的长度和顺序都在程序员的控制之下。同样的，程序员还必须选择这个协议在软件中得以实现的方式。<br>TCP/IP协议自身已经有了多种可互操作的实现，所以在双方通信时，每一方都有它自身的低级行为，这也是程序员所应该知道的情况。</p>
<p>尽管有许多TCP选项可供程序员操作，而我们却最关注如何处置其中的两个选项，它们是TCP_NODELAY 和 TCP_CORK，这两个选项都对网络连接的行为具有重要的作用。<br>许多UNIX系统都实现了TCP_NODELAY选项，但是，TCP_CORK则是Linux系统所独有的而且相对较新；它首先在内核版本2.4上得以实现。<br>此外，其他UNIX系统版本也有功能类似的选项，值得注意的是，在某种由BSD派生的系统上的TCP_NOPUSH选项其实就是TCP_CORK的一部分具体实现。</p>
<p>三、总结<br>你的数据传输并不需要总是准确地遵守某一选项或者其它选择。在那种情况下，你可能想要采取更为灵活的措施来控制网络连接：<br>在发送一系列当作单一消息的数据之前设置TCP_CORK，而且在发送应立即发出的短消息之前设置TCP_NODELAY。</p>
<p>如果需要提供网络的传输效率，应该减少小包的传输，使用TCP_CORK来做汇总传输，在利用sendfile来提高效率；<br>但如果是交互性的业务，那应该让任意小包可以快速传输，关闭Nagle算法，提高包的传输效率。</p>
<p>TCP_CORK优化了传输的bits效率，tcp_nodelay优化了传输的packet效率。</p>
<p>语法: tcp_nodelay on | off;<br>默认值:<br>tcp_nodelay on;<br>上下文: http, server, location<br>开启或关闭nginx使用TCP_NODELAY选项的功能。 这个选项仅在将连接转变为长连接的时候才被启用。（译者注，在upstream发送响应到客户端时也会启用）。</p>
<p>语法: tcp_nopush on | off;<br>默认值:<br>tcp_nopush off;<br>上下文: http, server, location<br>开启或者关闭nginx在FreeBSD上使用TCP_NOPUSH套接字选项， 在Linux上使用TCP_CORK套接字选项。 选项仅在使用sendfile的时候才开启。</p>
<p>总结：打开tcp_nopush后，将会在发送响应时，把整个响应头放在一个tcp包中发送，能够达到优化吞吐的效果，建议打开。tcp_nodelay该参数打开后，会关闭Nagle算法，保证高频发送小数据报文的实时性，建议打开。</p>
]]></content>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003326.png" alt="image-20200930103335496"></p>
<p>Nginx</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>I/O模型：<br>    阻塞型、非阻塞型、复用型、信号驱动型、异步</p>
<p>同步/异步：<br>    关注消息通知机制；</p>
<pre><code>消息通知：
    同步：等待对方返回消息； 
    异步：被调用者通过状态、通知或回调机制通知调用者被调用者的运行状态；</code></pre><p>阻塞/非阻塞：<br>    关注调用者在等待结果返回之前所处的状态； </p>
<pre><code>阻塞：blocking，调用结果返回之前，调用者被挂起；
非阻塞：nonblocking，调用结果返回之前，调用者不会被挂起；</code></pre><p>一次文件IO请求，都会由两阶段组成：<br>    第一步：等待数据，即数据从磁盘到内核内存；<br>    第二步：复制数据，即数据内核内存到进程内存； </p>
<p>复用型IO调用：<br>    select()：1024<br>    poll()：</p>
<pre><code>event-driven：
    epoll（Linux）：libevent
    Kqueue（BSD）：
    /dev/poll（Solaris）</code></pre><h2 id="Nginx的程序架构："><a href="#Nginx的程序架构：" class="headerlink" title="Nginx的程序架构："></a>Nginx的程序架构：</h2><p>​    master/worker<br>​        一个master进程：<br>​            负载加载和分析配置文件、管理worker进程、平滑升级<br>​        一个或多个worker进程<br>​            处理并响应用户请求<br>​        缓存相关的进程：<br>​            cache loader：载入缓存对象<br>​            cache manager：管理缓存对象<br>​<br>​    特性：异步、事件驱动和非阻塞<br>​        并发请求处理：通过epoll/select<br>​        文件IO：高级IO sendfile，异步，mmap<br>​<br>​    nginx模块：高度模块化，但其模块早期不支持DSO机制；近期版本支持动态装载和卸载；<br>​        模块分类：<br>​            核心模块：core module<br>​            标准模块：<br>​                HTTP modules：<br>​                    Standard HTTP modules<br>​                    Optional HTTP modules<br>​                Mail modules<br>​                Stream modules：<br>​                    传输层代理<br>​            3rd party modules<br>​<br>​    nginx的功用：<br>​        静态的web资源服务器；(图片服务器，或js/css/html/txt等静态资源服务器)<br>​        结合FastCGI/uwSGI/SCGI等协议反代动态资源请求；<br>​        http/https协议的反向代理；<br>​        imap4/pop3协议的反向代理；<br>​        tcp/udp协议的请求转发；<br>​<br>nginx的安装配置：<br>​    官方的预制包：<br>​        <a href="http://nginx.org/packages/centos/7/x86_64/RPMS/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/x86_64/RPMS/</a><br>​        Fedora-EPEL:<br>​<br>​    编译安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">]<span class="hljs-comment"># yum groupinstall "Development Tools" "Server Platform Development"</span><br>~]<span class="hljs-comment"># yum install pcre-devel openssl-devel zlib-devel #pcre用来正则表达式，zlib用于支持传输压缩格式</span><br>~]<span class="hljs-comment"># useradd -r nginx</span><br>~]<span class="hljs-comment">#  ./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_dav_module --with-http_stub_status_module --with-threads --with-file-aio</span><br><br>]<span class="hljs-comment">#make &amp;&amp; make install</span><br></code></pre></td></tr></table></figure>

<p>​    程序环境<br>​        配置文件的组成部分：<br>​            主配置文件：nginx.conf<br>​                include conf.d/*.conf<br>​            fastcgi， uwsgi，scgi等协议相关的配置文件<br>​            mime.types：支持的mime类型<br>​        主程序文件：/usr/sbin/nginx<br>​        Unit File：nginx.service<br>​<br>​    配置：<br>​        主配置文件的配置指令：<br>​            directive value [value2 …];<br>​<br>​            注意：<br>​                (1) 指令必须以分号结尾；<br>​                (2) 支持使用配置变量；<br>​                    内建变量：由Nginx模块引入，可直接引用；<br>​                    自定义变量：由用户使用set命令定义；<br>​                        set variable_name value;<br>​                        引用变量：$variable_name</p>
<p>​<br>​            主配置文件结构：<br>​                main block：主配置段，也即全局配置段；<br>​                    event {<br>​                        …<br>​                    }：事件驱动相关的配置；<br>​                http {<br>​                    …<br>​                }：http/https 协议相关的配置段；<br>​                mail {<br>​                    …<br>​                }<br>​                stream {<br>​                    …<br>​                }<br>​            </p>
<p>​        http协议相关的配置结构<br>​            http {<br>​                …<br>​                …：各server的公共配置<br>​                server {<br>​                    …<br>​                }：每个server用于定义一个虚拟主机；<br>​                server {<br>​                    …<br>​                    listen<br>​                    server_name<br>​                    root<br>​                    alias<br>​                    location [OPERATOR] URL {<br>​                        …<br>​                        if CONDITION {<br>​                            …<br>​                        }<br>​                    }<br>​                }<br>​            }<br>​    </p>
<h2 id="main配置段常见的配置指令："><a href="#main配置段常见的配置指令：" class="headerlink" title="main配置段常见的配置指令："></a>main配置段常见的配置指令：</h2><p>​        分类：<br>​            正常运行必备的配置<br>​            优化性能相关的配置<br>​            用于调试及定位问题相关的配置<br>​            事件驱动相关的配置<br>​<br>​        正常运行必备的配置：<br>​            1、user<br>​                Syntax:    user user [group];<br>​                Default:    user nobody nobody;<br>​                Context:    main<br>​<br>​                Defines user and group credentials used by worker processes. If group is omitted, a group whose name equals that of user is used.<br>​<br>​            2、pid /PATH/TO/PID_FILE;<br>​                指定存储nginx主进程进程号码的文件路径；<br>​<br>​            3、include file | mask;<br>​                指明包含进来的其它配置文件片断；<br>​<br>​            4、load_module file;<br>​                指明要装载的动态模块；<br>​<br>​        性能优化相关的配置：<br>​            1、worker_processes number | auto;<br>​                worker进程的数量；通常应该等于小于当前主机的cpu的物理核心数；<br>​                auto：当前主机物理CPU核心数；<br>​<br>​            2、worker_cpu_affinity cpumask …;<br>​                worker_cpu_affinity auto [cpumask];<br>​<br>​                CPU MASK：<br>​                    00000000：<br>​                    00000001：0号CPU<br>​                    00000010：1号CPU<br>​                    … …<br>​            3、worker_priority number;<br>​                指定worker进程的nice值，设定worker进程优先级；[-20,20]<br>​<br>​            4、worker_rlimit_nofile number;<br>​                worker进程所能够打开的文件数量上限；<br>​<br>​        调试、定位问题：<br>​            1、daemon on|off;<br>​                是否以守护进程方式运行Nignx；<br>​<br>​            2、master_process on|off;<br>​                是否以master/worker模型运行nginx；默认为on；<br>​<br>​            3、error_log file [level];<br>​<br>​        事件驱动相关的配置:<br>​            events {<br>​                …<br>​            }<br>​<br>​            1、worker_connections number;<br>​                每个worker进程所能够打开的最大并发连接数数量；<br>​<br>​                worker_processes * worker_connections<br>​<br>​            2、use method;<br>​                指明并发连接请求的处理方法；<br>​<br>​                    use epoll;<br>​<br>​            3、accept_mutex on | off;<br>​                处理新的连接请求的方法；on意味着由各worker轮流处理新请求，Off意味着每个新请求的到达都会通知所有的worker进程；</p>
<p>​        http协议的相关配置：<br>​            http {<br>​                … …<br>​                server {<br>​                    …<br>​                    server_name<br>​                    root<br>​                    location [OPERATOR] /uri/ {<br>​                        …<br>​                    }<br>​                }<br>​                server {<br>​                    …<br>​                }<br>​            }<br>​<br>​            与套接字相关的配置：<br>​<br>​                1、server { … }<br>​                    配置一个虚拟主机；<br>​<br>​                    server {<br>​                        listen address[:PORT]|PORT;<br>​                        server_name SERVER_NAME;<br>​                        root /PATH/TO/DOCUMENT_ROOT;<br>​                    }<br>​<br>​                2、listen PORT|address[:port]|unix:/PATH/TO/SOCKET_FILE<br>​                      listen address[:port] [default_server] [ssl] [http2 | spdy]  [backlog=number] [rcvbuf=size] [sndbuf=size]<br>​<br>​                    default_server：设定为默认虚拟主机；<br>​                    ssl：限制仅能够通过ssl连接提供服务；<br>​                    backlog=number：后援队列长度；<br>​                    rcvbuf=size：接收缓冲区大小；<br>​                    sndbuf=size：发送缓冲区大小；<br>​<br>​                3、server_name name …;<br>​                    指明虚拟主机的主机名称；后可跟多个由空白字符分隔的字符串；<br>​                        支持<em>通配任意长度的任意字符；server_name *.magedu.com  <a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a>.</em><br>​                        支持<del>起始的字符做正则表达式模式匹配；server_name ~^www\d+.magedu.com$<br>​<br>​                    匹配机制：<br>​                        (1) 首先是字符串精确匹配;<br>​                        (2) 左侧<em>通配符；<br>​                        (3) 右侧*通配符；<br>​                        (4) 正则表达式；<br>​<br>​                    练习：定义四个虚拟主机，混合使用三种类型的虚拟主机；<br>​                        仅开放给来自于本地网络中的主机访问；<br>​<br>​                4、tcp_nodelay on | off;<br>​                    在keepalived模式下的连接是否启用TCP_NODELAY选项；<br>​<br>​                    tcp_nopush on|off;<br>​                    在sendfile模式下，是否启用TCP_CORK选项；<br>​<br>​                5、sendfile on | off;<br>​                    是否启用sendfile功能；<br>​<br>​            定义路径相关的配置：<br>​                6、root path;<br>​                    设置web资源路径映射；用于指明用户请求的url所对应的本地文件系统上的文档所在目录路径；可用的位置：http, server, location, if in location；<br>​<br>​                7、location [ = | ~ | ~</em> | ^</del> ] uri { … }<br>​                    Sets configuration depending on a request URI.<br>​<br>​                    在一个server中location配置段可存在多个，用于实现从uri到文件系统的路径映射；ngnix会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置；<br>​<br>​                    =：对URI做精确匹配；例如, <a href="http://www.magedu.com/" target="_blank" rel="noopener">http://www.magedu.com/</a>, <a href="http://www.magedu.com/index.html" target="_blank" rel="noopener">http://www.magedu.com/index.html</a><br>​                        location  =  / {<br>​                            …<br>​                        }<br>​                    <del>：对URI做正则表达式模式匹配，区分字符大小写；<br>​                    ~*：对URI做正则表达式模式匹配，不区分字符大小写；<br>​                    ^</del>：对URI的左半部分做匹配检查，不区分字符大小写；<br>​                    不带符号：匹配起始于此uri的所有的url；<br>​<br>​                    匹配优先级：=, ^~, ～/～*，不带符号；<br>​<br>​                    root /vhosts/www/htdocs/<br>​                        <a href="http://www.magedu.com/index.html" target="_blank" rel="noopener">http://www.magedu.com/index.html</a> –&gt; /vhosts/www/htdocs/index.html<br>​<br>​                    server {<br>​                        root  /vhosts/www/htdocs/<br>​<br>​                        location /admin/ {<br>​                            root /webapps/app1/data/<br>​                        }<br>​                    }<br>​<br>​                8、alias path;<br>​                    定义路径别名，文档映射的另一种机制；仅能用于location上下文；<br>​<br>​                    注意：location中使用root指令和alias指令的意义不同；<br>​                        (a) root，给定的路径对应于location中的/uri/左侧的/；<br>​                        (b) alias，给定的路径对应于location中的/uri/右侧的/；<br>​<br>​                9、index file …;<br>​                    默认资源；http, server, location；<br>​<br>​                10、error_page code … [=[response]] uri;<br>​                    Defines the URI that will be shown for the specified errors.<br>​<br>​                11、try_files file … uri;<br>​<br>​            定义客户端请求的相关配置<br>​<br>​                12、keepalive_timeout timeout [header_timeout];<br>​                    设定保持连接的超时时长，0表示禁止长连接；默认为75s；<br>​<br>​                13、keepalive_requests number;<br>​                    在一次长连接上所允许请求的资源的最大数量，默认为100;<br>​<br>​                14、keepalive_disable none | browser …;<br>​                    对哪种浏览器禁用长连接；<br>​<br>​                15、send_timeout time;<br>​                    向客户端发送响应报文的超时时长，此处，是指两次写操作之间的间隔时长；<br>​<br>​                16、client_body_buffer_size size;<br>​                    用于接收客户端请求报文的body部分的缓冲区大小；默认为16k；超出此大小时，其将被暂存到磁盘上的由client_body_temp_path指令所定义的位置；<br>​<br>​                17、client_body_temp_path path [level1 [level2 [level3]]];<br>​                    设定用于存储客户端请求报文的body部分的临时存储路径及子目录结构和数量；<br>​<br>​                        16进制的数字；<br>​<br>​                        client_body_temp_path   /var/tmp/client_body  2 1 1<br>​                            1：表示用一位16进制数字表示一级子目录；0-f<br>​                            2：表示用2位16进程数字表示二级子目录：00-ff<br>​                            2：表示用2位16进程数字表示三级子目录：00-ff<br>​<br>​            对客户端进行限制的相关配置：<br>​                18、limit_rate rate;<br>​                    限制响应给客户端的传输速率，单位是bytes/second，0表示无限制；<br>​<br>​                19、limit_except method … { … }<br>​                    限制对指定的请求方法之外的其它方法的使用客户端；<br>​<br>​                    limit_except GET {<br>​                        allow 192.168.1.0/24;<br>​                        deny  all;<br>​                    }<br>​<br>​             文件操作优化的配置<br>​                20、aio on | off | threads[=pool];<br>​                    是否启用aio功能；<br>​<br>​                21、directio size | off;<br>​                    在Linux主机启用O_DIRECT标记，此处意味文件大于等于给定的大小时使用，例如directio 4m;<br>​<br>​                22、open_file_cache off;<br>​                    open_file_cache max=N [inactive=time];<br>​                        nginx可以缓存以下三种信息：<br>​                            (1) 文件的描述符、文件大小和最近一次的修改时间；<br>​                            (2) 打开的目录结构；<br>​                            (3) 没有找到的或者没有权限访问的文件的相关信息；<br>​<br>​                        max=N：可缓存的缓存项上限；达到上限后会使用LRU算法实现缓存管理；<br>​<br>​                        inactive=time：缓存项的非活动时长，在此处指定的时长内未被命中的或命中的次数少于open_file_cache_min_uses指令所指定的次数的缓存项即为非活动项；<br>​<br>​                23、open_file_cache_valid time;<br>​                    缓存项有效性的检查频率；默认为60s;<br>​<br>​                24、open_file_cache_min_uses number;<br>​                    在open_file_cache指令的inactive参数指定的时长内，至少应该被命中多少次方可被归类为活动项；<br>​<br>​                25、open_file_cache_errors on | off;<br>​                    是否缓存查找时发生错误的文件一类的信息；<br>​<br>​            ngx_http_access_module模块：<br>​                实现基于ip的访问控制功能<br>​<br>​                26、allow address | CIDR | unix: | all;<br>​                27、deny address | CIDR | unix: | all;<br>​<br>​                    http, server, location, limit_except<br>​<br>​            ngx_http_auth_basic_module模块<br>​                实现基于用户的访问控制，使用basic机制进行用户认证；<br>​<br>​                28、auth_basic string | off;<br>​                29、auth_basic_user_file file;<br>​<br>​                    location /admin/ {<br>​                        alias /webapps/app1/data/;<br>​                        auth_basic “Admin Area”;<br>​                        auth_basic_user_file /etc/nginx/.ngxpasswd;<br>​                    }<br>​<br>​                    注意：htpasswd命令由httpd-tools所提供；<br>​<br>​            ngx_http_stub_status_module模块<br>​                用于输出nginx的基本状态信息；<br>​<br>​                Active connections: 291<br>​                server accepts handled requests<br>​                    16630948 16630948 31070465<br>​                Reading: 6 Writing: 179 Waiting: 106<br>​<br>​                Active connections: 活动状态的连接数；<br>​                accepts：已经接受的客户端请求的总数；<br>​                handled：已经处理完成的客户端请求的总数；<br>​                requests：客户端发来的总的请求数；<br>​                Reading：处于读取客户端请求报文首部的连接的连接数；<br>​                Writing：处于向客户端发送响应报文过程中的连接数；<br>​                Waiting：处于等待客户端发出请求的空闲连接数；<br>​<br>​                30、stub_status;<br>​<br>​                配置示例：<br>​                    location  /basic_status {<br>​                        stub_status;<br>​                    }<br>​<br>​            ngx_http_log_module模块<br>​                he ngx_http_log_module module writes request logs in the specified format.<br>​<br>​                31、log_format name string …;<br>​                    string可以使用nginx核心模块及其它模块内嵌的变量；<br>​<br>​                    课外作业：为nginx定义使用类似于httpd的combined格式的访问日志；<br>​<br>​                32、access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];<br>​                    access_log off;<br>​<br>​                    访问日志文件路径，格式及相关的缓冲的配置；<br>​                        buffer=size<br>​                        flush=time<br>​<br>​                33、open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];<br>​                    open_log_file_cache off;<br>​                        缓存各日志文件相关的元数据信息；<br>​<br>​                        max：缓存的最大文件描述符数量；<br>​                        min_uses：在inactive指定的时长内访问大于等于此值方可被当作活动项；<br>​                        inactive：非活动时长；<br>​                        valid：验正缓存中各缓存项是否为活动项的时间间隔；<br>​<br>​            ngx_http_gzip_module：<br>​                The ngx_http_gzip_module module is a filter that compresses responses using the “gzip” method. This often helps to reduce the size of transmitted data by half or even more.<br>​<br>​                1、gzip on | off;<br>​                    Enables or disables gzipping of responses.<br>​<br>​                2、gzip_comp_level level;<br>​                    Sets a gzip compression level of a response. Acceptable values are in the range from 1 to 9.<br>​<br>​                3、    gzip_disable regex …;<br>​                    Disables gzipping of responses for requests with “User-Agent” header fields matching any of the specified regular expressions.<br>​<br>​                4、    gzip_min_length length;<br>​                    启用压缩功能的响应报文大小阈值；<br>​<br>​                5、gzip_buffers number size;<br>​                    支持实现压缩功能时为其配置的缓冲区数量及每个缓存区的大小；<br>​<br>​                6、gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any …;<br>​                    nginx作为代理服务器接收到从被代理服务器发送的响应报文后，在何种条件下启用压缩功能的；<br>​                        off：对代理的请求不启用<br>​                        no-cache, no-store，private：表示从被代理服务器收到的响应报文首部的Cache-Control的值为此三者中任何一个，则启用压缩功能；<br>​<br>​                7、gzip_types mime-type …;<br>​                    压缩过滤器，仅对此处设定的MIME类型的内容启用压缩功能；</p>
<p>​                示例：<br>​                    gzip  on;<br>​                    gzip_comp_level 6;<br>​                    gzip_min_length 64;<br>​                    gzip_proxied any;<br>​                    gzip_types text/xml text/css  application/javascript;<br>​<br>​            ngx_http_ssl_module模块：<br>​<br>​                1、    ssl on | off;<br>​                    Enables the HTTPS protocol for the given virtual server.<br>​<br>​                2、ssl_certificate file;<br>​                    当前虚拟主机使用PEM格式的证书文件；<br>​<br>​                3、ssl_certificate_key file;<br>​                    当前虚拟主机上与其证书匹配的私钥文件；<br>​<br>​                4、ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2];<br>​                    支持ssl协议版本，默认为后三个；<br>​<br>​                5、ssl_session_cache off | none | [builtin[:size]] [shared:name:size];<br>​                    builtin[:size]：使用OpenSSL内建的缓存，此缓存为每worker进程私有；<br>​<br>​                    [shared:name:size]：在各worker之间使用一个共享的缓存；<br>​<br>​                6、ssl_session_timeout time;<br>​                    客户端一侧的连接可以复用ssl session cache中缓存 的ssl参数的有效时长；<br>​<br>​                配置示例：<br>​                    server {<br>​                        listen 443 ssl;<br>​                        server_name <a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a>;<br>​                        root /vhosts/ssl/htdocs;<br>​                        ssl on;<br>​                        ssl_certificate /etc/nginx/ssl/nginx.crt;<br>​                        ssl_certificate_key /etc/nginx/ssl/nginx.key;<br>​                        ssl_session_cache shared:sslcache:20m;<br>​                    }                            </p>
<p>​    ngx_http_rewrite_module模块：<br>​<br>​        The ngx_http_rewrite_module module is used to change request URI using PCRE regular expressions, return redirects, and conditionally select configurations.<br>​<br>​        bbs.magedu.com/ –&gt; <a href="http://www.magedu.com/bbs/" target="_blank" rel="noopener">www.magedu.com/bbs/</a>,  <a href="http://www.magedu.com/" target="_blank" rel="noopener">http://www.magedu.com/</a> –&gt; <a href="https://www.magedu.com/" target="_blank" rel="noopener">https://www.magedu.com/</a><br>​        <a href="http://www.magedu.com/login.php;username=tom" target="_blank" rel="noopener">http://www.magedu.com/login.php;username=tom</a> –&gt; <a href="http://www.magedu.com/tom/" target="_blank" rel="noopener">http://www.magedu.com/tom/</a><br>​<br>​        <a href="http://www.ilinux.io/bbs/" target="_blank" rel="noopener">http://www.ilinux.io/bbs/</a> –&gt; <a href="http://bbs.ilinux.io/" target="_blank" rel="noopener">http://bbs.ilinux.io/</a></p>
<p>​<br>​            将用户请求的URI基于regex所描述的模式进行检查，而后完成替换；<br>​<br>​            1、rewrite regex replacement [flag]<br>​                将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定的新的URI；<br>​                </p>
<p>​            注意：如果在同一级配置块中存在多个rewrite规则，那么会自下而下逐个检查；被某条件规则替换完成后，会重新一轮的替换检查，因此，隐含有循环机制；[flag]所表示的标志位用于控制此循环机制；<br>​<br>​            如果replacement是以http://或https://开头，则替换结果会直接以重向返回给客户端；<br>​                301：永久重定向；<br>​<br>​            [flag]：<br>​                last：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环；<br>​                break：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置；结束循环；<br>​                redirect：重写完成后以临时重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；不能以http://或https://开头；<br>​                permanent:重写完成后以永久重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；<br>​<br>​        2、return<br>​            return code [text];<br>​            return code URL;<br>​            return URL;<br>​<br>​            Stops processing and returns the specified code to a client.<br>​<br>​        3、    rewrite_log on | off;<br>​            是否开启重写日志；<br>​<br>​        4、    if (condition) { … }<br>​            引入一个新的配置上下文 ；条件满足时，执行配置块中的配置指令；server, location；<br>​<br>​            condition：<br>​                比较操作符：<br>​                    ==<br>​                    !=<br>​                    <del>：模式匹配，区分字符大小写；<br>​                    ~*：模式匹配，不区分字符大小写；<br>​                    !</del>：模式不匹配，区分字符大小写；<br>​                    !<del><em>：模式不匹配，不区分字符大小写；<br>​                文件及目录存在性判断：<br>​                    -e, !-e<br>​                    -f, !-f<br>​                    -d, !-d<br>​                    -x, !-x<br>​<br>​        5、set $variable value;<br>​            用户自定义变量 ；<br>​<br>​    ngx_http_referer_module模块：<br>​        The ngx_http_referer_module module is used to block access to a site for requests with invalid values in the “Referer” header field.<br>​<br>​        1、valid_referers none | blocked | server_names | string …;<br>​            定义referer首部的合法可用值；<br>​<br>​                none：请求报文首部没有referer首部；<br>​                blocked：请求报文的referer首部没有值；<br>​                server_names：参数，其可以有值作为主机名或主机名模式；<br>​                    arbitrary_string：直接字符串，但可使用</em>作通配符；<br>​                    regular expression：被指定的正则表达式模式匹配到的字符串；要使用</del>打头，例如 ~.<em>.magedu.com；<br>​<br>​            配置示例：<br>​                valid_referers none block server_names *.magedu.com *.mageedu.com magedu.</em> mageedu.* ~.magedu.;<br>​<br>​                if($invalid_referer) {<br>​                    return <a href="http://www.magedu.com/invalid.jpg" target="_blank" rel="noopener">http://www.magedu.com/invalid.jpg</a>;<br>​                }</p>
<p>​<br>Nginx(3)<br>​<br>​        ngx_http_proxy_module模块：<br>​<br>​            The ngx_http_proxy_module module allows passing requests to another server.<br>​<br>​            1、proxy_pass URL;<br>​                Context:    location, if in location, limit_except<br>​<br>                注意：proxy_pass后面的路径不带uri时，其会将location的uri传递给后端主机；</p>
<pre><code>            server {
                ...
                server_name HOSTNAME;
                location /uri/ {
                    proxy http://hos[:port];
                }
                ...
            }

            http://HOSTNAME/uri --&gt; http://host/uri 

        proxy_pass后面的路径是一个uri时，其会将location的uri替换为proxy_pass的uri；

            server {
                ...
                server_name HOSTNAME;
                location /uri/ {
                    proxy http://host/new_uri/;
                }
                ...
            }

            http://HOSTNAME/uri/ --&gt; http://host/new_uri/

        如果location定义其uri时使用了正则表达式的模式，或在if语句或limt_execept中使用proxy_pass指令，则proxy_pass之后必须不能使用uri; 用户请求时传递的uri将直接附加代理到的服务的之后；

            server {
                ...
                server_name HOSTNAME;
                location ~|~* /uri/ {
                    proxy http://host;
                }
                ...
            }

            http://HOSTNAME/uri/ --&gt; http://host/uri/；

    2、proxy_set_header field value;
        设定发往后端主机的请求报文的请求首部的值；Context:    http, server, location

        proxy_set_header X-Real-IP  $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    3、proxy_cache_path
        定义可用于proxy功能的缓存；Context:    http            

        proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];

    4、proxy_cache zone | off;
        指明要调用的缓存，或关闭缓存机制；Context:    http, server, location

    5、    proxy_cache_key string;
        缓存中用于“键”的内容；

        默认值：proxy_cache_key $scheme$proxy_host$request_uri;

    6、proxy_cache_valid [code ...] time;
        定义对特定响应码的响应内容的缓存时长；

        定义在http{...}中；
        proxy_cache_path /var/cache/nginx/proxy_cache levels=1:1:1 keys_zone=pxycache:20m max_size=1g;

        定义在需要调用缓存功能的配置段，例如server{...}；
        proxy_cache pxycache;
        proxy_cache_key $request_uri;
        proxy_cache_valid 200 302 301 1h;
        proxy_cache_valid any 1m;

    7、proxy_cache_use_stale

        proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off ...;

        Determines in which cases a stale cached response can be used when an error occurs during communication with the proxied server.

    8、proxy_cache_methods GET | HEAD | POST ...;
        If the client request method is listed in this directive then the response will be cached. “GET” and “HEAD” methods are always added to the list, though it is recommended to specify them explicitly. 

    9、proxy_hide_header field;
        By default, nginx does not pass the header fields “Date”, “Server”, “X-Pad”, and “X-Accel-...” from the response of a proxied server to a client. The proxy_hide_header directive sets additional fields that will not be passed.

    10、proxy_connect_timeout time;
        Defines a timeout for establishing a connection with a proxied server. It should be noted that this timeout cannot usually exceed 75 seconds.

        默认为60s；最长为75s；

    11、proxy_read_timeout time; 
        Defines a timeout for reading a response from the proxied server. The timeout is set only between two successive read operations, not for the transmission of the whole response.

    12、proxy_send_timeout time;
        Sets a timeout for transmitting a request to the proxied server. he timeout is set only between two successive write operations, not for the transmission of the whole request. If the proxied server does not receive anything within this time, the connection is closed.

ngx_http_headers_module模块
    The ngx_http_headers_module module allows adding the “Expires” and “Cache-Control” header fields, and arbitrary fields, to a response header.

    向由代理服务器响应给客户端的响应报文添加自定义首部，或修改指定首部的值；

    1、add_header name value [always];
        添加自定义首部；

        add_header X-Via  $server_addr;
        add_header X-Accel $server_name;

    2、expires [modified] time;
        expires epoch | max | off;

        用于定义Expire或Cache-Control首部的值；</code></pre><p>​<br>​<br>​        ngx_http_fastcgi_module模块：<br>​<br>​            The ngx_http_fastcgi_module module allows passing requests to a FastCGI server.<br>​<br>​            1、fastcgi_pass address;<br>​                address为fastcgi server的地址；    location, if in location；<br>​<br>                    <a href="http://www.ilinux.io/admin/index.php" target="_blank" rel="noopener">http://www.ilinux.io/admin/index.php</a> –&gt; /admin/index.php (uri)<br>                        /data/application/admin/index.php</p>
<p>​<br>​            2、fastcgi_index name;<br>​                fastcgi默认的主页资源;<br>​<br>​            3、fastcgi_param parameter value [if_not_empty];<br>​                Sets a parameter that should be passed to the FastCGI server. The value can contain text, variables, and their combination.<br>​<br>​            配置示例1：<br>​                前提：配置好fpm server和mariadb-server服务；<br>​                    location ~* .php$ {<br>​                        root           /usr/share/nginx/html;<br>​                        fastcgi_pass   127.0.0.1:9000;<br>​                        fastcgi_index  index.php;<br>​                        fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html$fastcgi_script_name;<br>​                        include        fastcgi_params;<br>​                    }<br>​<br>            配置示例2：通过/pm_status和/ping来获取fpm server状态信息；<br>                location ~* ^/(pm_status|ping)$ {<br>                    include        fastcgi_params;<br>                    fastcgi_pass 127.0.0.1:9000;<br>                    fastcgi_param  SCRIPT_FILENAME  $fastcgi_script_name;<br>                }            </p>
<pre><code>4、fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];

    定义fastcgi的缓存；缓存位置为磁盘上的文件系统，由path所指定路径来定义；

        levels=levels：缓存目录的层级数量，以及每一级的目录数量；levels=ONE:TWO:THREE
            leves=1:2:2
        keys_zone=name:size
            k/v映射的内存空间的名称及大小
        inactive=time
            非活动时长
        max_size=size
            磁盘上用于缓存数据的缓存空间上限

5、fastcgi_cache zone | off;
    调用指定的缓存空间来缓存数据；http, server, location

6、fastcgi_cache_key string;
    定义用作缓存项的key的字符串；

7、fastcgi_cache_methods GET | HEAD | POST ...;
    为哪些请求方法使用缓存；

8、fastcgi_cache_min_uses number;
    缓存空间中的缓存项在inactive定义的非活动时间内至少要被访问到此处所指定的次数方可被认作活动项；

9、fastcgi_cache_valid [code ...] time;
    不同的响应码各自的缓存时长；

    示例：
        http {
            ...
            fastcgi_cache_path /var/cache/nginx/fastcgi_cache levels=1:2:1 keys_zone=fcgi:20m inactive=120s;
            ...
            server {
                ...
                location ~* \.php$ {
                    ...
                    fastcgi_cache fcgi;
                    fastcgi_cache_key $request_uri;
                    fastcgi_cache_valid 200 302 10m;
                    fastcgi_cache_valid 301 1h;
                    fastcgi_cache_valid any 1m;    
                    ...
                }
                ...
            }
            ...
        }

    10、fastcgi_keep_conn on | off;
        By default, a FastCGI server will close a connection right after sending the response. However, when this directive is set to the value on, nginx will instruct a FastCGI server to keep connections open.</code></pre><p>​<br>​    博客作业：以上所有内容；<br>​    练习：实现lnmp，lnamp提供多个虚拟主机；nginx和php使用同一主机和不同主机；<br>​        (1) http, 提供wordpress；<br>​        (2) https, 提供pma；</p>
<p>​        </p>
<pre><code>ngx_http_upstream_module模块 
    The ngx_http_upstream_module module is used to define groups of servers that can be referenced by the proxy_pass, fastcgi_pass, uwsgi_pass, scgi_pass, and memcached_pass directives.</code></pre><p>​    </p>
<p>​<br>​<br>​<br>​<br>​<br>​    ngx_http_upstream_module模块<br>​        The ngx_http_upstream_module module is used to define groups of servers that can be referenced by the proxy_pass, fastcgi_pass, uwsgi_pass, scgi_pass, and memcached_pass directives.<br>​<br>​        1、upstream name { … }<br>​            定义后端服务器组，会引入一个新的上下文；Context: http<br>​<br>​            upstream httpdsrvs {<br>​                server …<br>​                server…<br>​                …<br>​            }<br>​<br>        2、server address [parameters];<br>            在upstream上下文中server成员，以及相关的参数；Context:    upstream</p>
<pre><code>        address的表示格式：
            unix:/PATH/TO/SOME_SOCK_FILE
            IP[:PORT]
            HOSTNAME[:PORT]

        parameters：
            weight=number
                权重，默认为1；
            max_fails=number
                失败尝试最大次数；超出此处指定的次数时，server将被标记为不可用；
            fail_timeout=time
                设置将服务器标记为不可用状态的超时时长；
            max_conns
                当前的服务器的最大并发连接数；
            backup
                将服务器标记为“备用”，即所有服务器均不可用时此服务器才启用；
            down
                标记为“不可用”；

    3、least_conn;
        最少连接调度算法，当server拥有不同的权重时其为wlc;

    4、    ip_hash;
        源地址hash调度方法；

    5、hash key [consistent];
        基于指定的key的hash表来实现对请求的调度，此处的key可以直接文本、变量或二者的组合；

        作用：将请求分类，同一类请求将发往同一个upstream server；

        If the consistent parameter is specified the ketama consistent hashing method will be used instead.

        示例：
            hash $request_uri consistent;
            hash $remote_addr;

    6、keepalive connections;
        为每个worker进程保留的空闲的长连接数量；

nginx的其它的二次发行版：
    tengine
    OpenResty

ngx_stream_core_module模块
    模拟反代基于tcp或udp的服务连接，即工作于传输层的反代或调度器；

    1、stream { ... }
        定义stream相关的服务；Context:main

        stream {
            upstream sshsrvs {
                server 192.168.22.2:22; 
                server 192.168.22.3:22; 
                least_conn;
            }

            server {
                listen 10.1.0.6:22022;
                proxy_pass sshsrvs;
            }
        }    

    2、listen
        listen address:port [ssl] [udp] [proxy_protocol] [backlog=number] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];


博客作业：以上所有内容；

思考：
    (1) 动态资源存储一组服务器、图片资源存在一组服务器、静态的文本类资源存储在一组服务器；如何分别调度？
    (2) 动态资源基于fastcgi或http协议（ap）?
        lnamp</code></pre><p>memcached：</p>
<pre><code>memcached is a high-performance, distributed memory object caching system, generic in nature, but intended for use in speeding up dynamic web applications by alleviating database load.


缓存服务器：
    缓存：cache，无持久存储功能；
    bypass缓存
    k/v cache，仅支持存储流式化数据；

LiveJournal旗下的Danga Interactive研发，

    特性：
        k/v cache：仅可序列化数据；存储项：k/v；
        智能性一半依赖于客户端（调用memcached的API开发程序），一半依赖于服务端；
        分布式缓存：互不通信的分布式集群；
            分布式系统请求路由方法：取模法，一致性哈希算法；
        算法复杂度：O(1)
        清理过期缓存项：
            缓存耗尽：LRU 
            缓存项过期：惰性清理机制

安装配置：
    由CentOS 7 base仓库直接提供：
        监听的端口：
            11211/tcp, 11211/udp 

    主程序：/usr/bin/memcached
    配置文件：/etc/sysconfig/memcached
    Unit File：memcached.service 

    协议格式：memcached协议
        文本格式
        二进制格式

    命令：
        统计类：stats, stats items, stats slabs, stats sizes
        存储类：set, add, replace, append, prepend
            命令格式：&lt;command name&gt; &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt;  
            &lt;cas unique&gt;
        检索类：get, delete, incr/decr
        清空：flush_all

        示例：
            telnet&gt; add KEY &lt;flags&gt; &lt;expiretime&gt; &lt;bytes&gt; \r
            telnet&gt; VALUE

    memcached程序的常用选项：
        -m &lt;num&gt;：Use &lt;num&gt; MB memory max to use for object storage; the default is 64 megabytes.
        -c &lt;num&gt;：Use &lt;num&gt; max simultaneous connections; the default is 1024.
        -u &lt;username&gt;：以指定的用户身份来运行进程；
        -l &lt;ip_addr&gt;：监听的IP地址，默认为本机所有地址；
        -p &lt;num&gt;：监听的TCP端口， the default is port 11211.
        -U &lt;num&gt;：Listen on UDP port &lt;num&gt;, the default is port 11211, 0 is off.
        -M：内存耗尽时，不执行LRU清理缓存，而是拒绝存入新的缓存项，直到有多余的空间可用时为止；
        -f &lt;factor&gt;：增长因子；默认是1.25；
        -t &lt;threads&gt;：启动的用于响应用户请求的线程数；

    memcached默认没有认证机制，可借用于SASL进行认证；
        SASL：Simple Authentication Secure Layer

    API:
        php-pecl-memcache
        php-pecl-memcached
        python-memcached
        libmemcached
        libmemcached-devel

    命令行工具：
        memcached-tool  SERVER:PORT  COMMAND</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​                </p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>Nginx(4)</p>
<pre><code>LB Cluster：
    传输层：lvs、nginx、haproxy
    应用层：nginx(http, https, smtp, pop, imap), haproxy(http), httpd(http/https), ats, perlbal, pound, ...

nginx load balancer：
    tcp/udp

nginx proxy：
    reverse proxy：

应用程序发布：
    灰度模型：
        (1) 如果存在用户会话；
            从服务器上拆除会话；
        (2) 新版本应用程序存在bug；
            回滚；

ngx_http_proxy_module

    (1) proxy_pass URL;
        location, if in location, limit_except

        注意：proxy_pass后面的路径不带uri时，其会将location的uri传递给后端主机；

            location /uri/ {
                proxy_pass http://HOST;
            }

        proxy_pass后面的路径是一个uri时，其会将location的uri替换为proxy_pass的uri；
            location /uri/ {
                proxy_pass http://HOST/new_uri/;
            }

        如果location定义其uri时使用正则表达式的模式，则proxy_pass之后必须不能使用uri；
            location ~|~* PATTERN {
                proxy_pass http://HOST;
            }

    (2) proxy_set_header field value;
        设定发往后端主机的请求报文的请求首部的值； 

        示例：
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for

    (3) proxy_cache_path

        proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];

    (4) proxy_cache zone | off;
        调用的缓存的名称，或禁用缓存；

    (5) proxy_cache_key string;
        缓存条目的键；

    (6) proxy_cache_valid [code ...] time;
        对各类响应码的缓存时长；

    使用示例：
        定义在http{}中：
            proxy_cache_path /var/cache/nginx/proxy_cache levels=1:2:1 keys_zone=pcache:10m max_size=1g;

        定义在server{}及其内部的组件中：
            proxy_cache pcache;
            proxy_cache_key $request_uri;
            proxy_cache_valid 200 302 10m;
            proxy_cache_valid 301 1h;
            proxy_cache_valid any 1m;                

    (7) proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off ...;

    (8)     proxy_connect_timeout
        proxy_read_timeout
        proxy_send_timeout

    (9)   proxy_buffer_size
        proxy_buffering
        proxy_buffers

ngx_http_headers_module
    The ngx_http_headers_module module allows adding the “Expires” and “Cache-Control” header fields, and arbitrary fields, to a response header.

    (1)     add_header name value [always];
        向响应报文中添加自定义首部；

        可用上下文：http, server, location, if in location

        add_header X-Via $server_addr;
        add_header X-Accel $server_name;

    (2) expires [modified] time;
        expires epoch | max | off;

        用于定义Expire或Cache-Control首部的值，或添加其它自定义首部；</code></pre><p>回顾：<br>    LB Cluster：<br>        传输层：lvs, nginx(stream), haproxy(mode tcp)<br>        应用层：<br>            http/https：nginx(upstream), haproxy(mode http), httpd, ats, perlbal, pound, …</p>
<pre><code>    lvs：
        类型：nat/dr/tun/fullnat
        算法：
            静态：rr, wrr, sh, dh
            动态：lc, wlc, sed, nq, lblc, lblcr

    session保持：
        session sticky（SourceIP/Cookie）
        session replication cluster
        session server（redis/...）

Nginx：
    web：web server, web reverse proxy
    mail：mail reverse proxy
    tcp/udp：stream module

    ngx_http_proxy_module
        proxy_path

        proxy_cache_path
        proxy_cache
        proxy_cache_key
        proxy_cache_valid
        proxy_cache_methods</code></pre><p>Nginx(4)</p>
<pre><code>ngx_http_upstream_module    
    The ngx_http_upstream_module module is used to define groups of servers that can be referenced by the proxy_pass, fastcgi_pass, uwsgi_pass, scgi_pass, and memcached_pass directives.

    (1) upstream name { ... }
        定义后端服务器组；引入一个新的上下文；只能用于http{}上下文中；

        默认的调度方法是wrr；

    (2) server address [parameters];
        定义服务器地址和相关的参数；
            地址格式：
                IP[:PORT]
                HOSTNAME[:PORT]
                unix:/PATH/TO/SOME_SOCK_FILE

            参数：
                weight=number
                    权重，默认为1；
                max_fails=number
                    失败尝试的最大次数；
                fail_timeout=time
                    设置服务器为不可用状态的超时时长；
                backup
                    把服务器标记为“备用”状态； 
                down
                    手动标记其为不可用；

    (3) least_conn;
        最少连接调度算法； 当server拥有不同的权重时为wlc；当所有后端主机的连接数相同时，则使用wrr进行调度；

    (4) least_time header | last_byte;
        最短平均响应时长和最少连接；
        header：response_header; 
        last_byte: full_response; 

        仅Nginx Plus有效；

    (5) ip_hash;
        源地址hash算法；能够将来自同一个源IP地址的请求始终发往同一个upstream server；

    (6) hash key [consistent];
        基于指定的key的hash表实现请求调度，此处的key可以文本、变量或二者的组合；

        consistent：参数，指定使用一致性hash算法；

        示例：
            hash $request_uri consistent
            hash $remote_addr
            hash $cookie_name

    (7) keepalive connections;
        可使用长连接的连接数量；

    (8) health_check [parameters];
        定义对后端主机的健康状态检测机制；只能用于location上下文；

        可用参数：
            interval=time：检测频率，默认为每隔5秒钟；
            fails=number：判断服务器状态转为失败需要检测的次数；
            passes=number：判断服务器状态转为成功需要检测的次数；
            uri=uri：判断其健康与否时使用的uri；
            match=name：基于指定的match来衡量检测结果的成败；
            port=number：使用独立的端口进行检测；

        仅Nginx Plus有效；

    (9) match name { ... }
        Defines the named test set used to verify responses to health check requests.
        定义衡量某检测结果是否为成功的衡量机制；

        专用指令：
            status：期望的响应码；
                status CODE
                status ! CODE
                ...
            header：基于响应报文的首部进行判断
                header HEADER=VALUE
                header HEADER ~ VALUE 
                ...
            body：基于响应报文的内容进行判断
                body ~ &quot;PATTERN&quot;
                body !~ &quot;PATTERN&quot;

        仅Nginx Plus有效；

博客作业：以上所有内容；
课外实践：实践tengine和Openresty；

ngx_stream_core_module

    The ngx_stream_core_module module is available since version 1.9.0. This module is not built by default, it should be enabled with the --with-stream configuration parameter.

    (1) listen address:port [ssl] [udp] [backlog=number] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
        监听的端口；
            默认为tcp协议；
            udp: 监听udp协议的端口；

ngx_stream_proxy_module

    The ngx_stream_proxy_module module (1.9.0) allows proxying data streams over TCP, UDP (1.9.13), and UNIX-domain sockets.

    (1) proxy_pass address;
        Sets the address of a proxied server. The address can be specified as a domain name or IP address, and a port or as a UNIX-domain socket path.

    (2) proxy_timeout timeout;
        Sets the timeout between two successive read or write operations on client or proxied server connections. If no data is transmitted within this time, the connection is closed.

        默认为10m; 

    (3) proxy_connect_timeout time;
        Defines a timeout for establishing a connection with a proxied server.

        设置nginx与被代理的服务器尝试建立连接的超时时长；默认为60s；</code></pre><p>​<br>​        示例：<br>​            stream {<br>​                upstream sshsrvs {<br>​                    server 192.168.10.130:22;<br>​                    server 192.168.10.131:22;<br>​                    hash $remote_addr consistent;<br>​                }<br>​<br>​                server {<br>​                    listen 172.16.100.6:22202;<br>​                    proxy_pass sshsrvs;<br>​                    proxy_timeout 60s;<br>​                    proxy_connect_timeout 10s;<br>​                }<br>​            }<br>​<br>​    编译安装：<br>​        前提：开发环境，包括nginx编译要启用的功能依赖到的开发库；<br>​            # yum groupinstall “Development Tools” “Server Platform Development”<br>​            # yum -y pcre-devel openssl-devel<br>​<br>        编译过程：<br>            # ./configure –prefix=/usr/local/nginx –sbin-path=/usr/sbin/nginx –conf-path=/etc/nginx/nginx.conf –error-log-path=/var/log/nginx/error.log –http-log-path=/var/log/nginx/access.log –user=nginx –group=nginx –with-http_ssl_module  –with-http_stub_status_module –with-http_flv_module –with-http_mp4_module –with-threads –with-file-aio<br>            # make &amp;&amp; make install</p>
<pre><code>课程实践：
    nginx--&gt; AMPs（wordpress）
    nginx--&gt; FPMs（wordpress）

    nginx--&gt; images servers ( imgs.magedu.com）
                location ~* \.(jpg|png|gif|jpeg)$ {
                    ...
                }
               dynamic content servers (shop.magedu.com)
                location ~* \.php$ {
                    ...
                }

                location / {
                    ...
                }

    自定义错误404和5xx错误页，文本静态内容传输压缩；</code></pre><p>​<br>​<br>​                    </p>
]]></content>
  </entry>
  <entry>
    <title>nginx的工作流程</title>
    <url>/nginx%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>nginx请求处理流程</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003441.png" alt="img"></p>
<p><strong>nginx进程结构</strong></p>
<p>master进程：是作为worker进程管理的</p>
<p>worker进程：处理真正的请求的而master进程则是管控这些进程的工作方式的；缓存是在多个worker进程共享数据的；进程间通信使用共享内存解决的，请求使用的缓存有worker管控的</p>
<p>cache magager进程 ：缓存管理</p>
<p>cache loader 进程：缓存载入</p>
<p>nginx设计的哲学理念：为什么多进程而非多线程；因为线程之间是共享同一个进程空间的，当第三方模块出现异常时会导致nginx挂掉，而多进程就不会出现这样的问题</p>
<p>为什么worker进程会很多：因为nginx采用事件驱动的模型，它希望每个worker进程从头到尾占用一颗cpu,往往把worker进程数量配置根worker进程一致以外，还需要把每个worker进程与CPU绑定在一起，这样可以更好使用每个cpu上的CPU缓存，来减少缓存失效命中率。</p>
<p> nginx进程间的信号管理</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003442.png" alt="img"></p>
<p>reload流程</p>
<p>1.向master进程发送HUP信号（reload）</p>
<p>2.maseer 进程校验配置语法是否正确</p>
<p>3.master进程打开新监听的端口</p>
<p>4.master进程用新配置启动worker子进程</p>
<p>5.master进程向老worker子进程发送quit信号</p>
<p>6.老worker进程关闭监听句柄，并处理完当前连接后退出结束进程</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003443.png" alt="img"></p>
<p> 热升级完整流程</p>
<p>1.将就的nginx文件缓存新的nginx文件。注意备份，及编译新版本nginx指定的路径要与就版本中一致</p>
<p>2.向master进程发送USR2信号</p>
<p>3.master进程会自己修改PID文件名，加后缀.oldbm</p>
<p>4.master进程用新的NGINX文件启动新的master进程</p>
<p>5.向老master进程发送quit信号，关闭老master进程；但老的master进程会保存下来</p>
<p>6.回滚：向老的master发送HUP，向新master发送QUIT信号</p>
<p>流程图</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003444.png" alt="img"></p>
<p>针对HTTP请求优雅关闭work进程，如果设置了超时时间有一些连接会立即停止</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003445.png" alt="img"></p>
<p>网络收发与nginx的事件对应关系；一个网络连接对应两个事件一个读事件一个写事件</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003446.png" alt="img"></p>
<p>网络传输中的报文</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003447.png" alt="img"></p>
<p>TCP协议与非阻塞接口</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003448.png" alt="img"></p>
<p>nginx事件循环</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003449.png" alt="img"></p>
<p>epoll模型</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201003450.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>nginx静态文件缓存的解决方案</title>
    <url>/nginx%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nginx的一大功能就是完成静态资源的分离部署，减轻后端服务器的压力，如果给这些静态资源再加一级nginx的缓存，可以进一步提升访问效率。</p>
<h4 id="第一步：添加nginx-conf的http级别的缓存配置"><a href="#第一步：添加nginx-conf的http级别的缓存配置" class="headerlink" title="第一步：添加nginx.conf的http级别的缓存配置"></a>第一步：添加nginx.conf的http级别的缓存配置</h4><p><a href="javascript:void(0);"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234204.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">##cache##<br>    proxy_connect_timeout 500;<br>    #跟后端服务器连接的超时时间_发起握手等候响应超时时间<br>    proxy_read_timeout 600;<br>    #连接成功后_等候后端服务器响应的时间_其实已经进入后端的排队之中等候处理<br>    proxy_send_timeout 500;<br>    #后端服务器数据回传时间_就是在规定时间内后端服务器必须传完所有数据<br>    proxy_buffer_size 128k;<br>    #代理请求缓存区_这个缓存区间会保存用户的头信息以供Nginx进行规则处理_一般只要能保存下头信息即可  <br>    proxy_buffers 4 128k;<br>    #同上 告诉Nginx保存单个用的几个Buffer最大用多大空间<br>    proxy_busy_buffers_size 256k;<br>    #如果系统很忙的时候可以申请更大的proxy_buffers 官方推荐*2<br>    proxy_temp_file_write_size 128k;<br>    #proxy缓存临时文件的大小<br>    proxy_temp_path &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;temp;<br>    #用于指定本地目录来缓冲较大的代理请求<br>    proxy_cache_path &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;cache_one:200m inactive&#x3D;1d max_size&#x3D;30g;<br>    #设置web缓存区名为cache_one,内存缓存空间大小为12000M，自动清除超过15天没有被访问过的缓存数据，硬盘缓存空间大小200g<br></code></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234204.gif" alt="复制代码"></a></p>
<p>此处的重点在最后一句，缓存存储路径为：/usr/local/nginx/cache，levels=1:2代表缓存的目录结构为2级目录</p>
<p>如下图，缓存会在/usr/local/nginx/cache目录下生成，包含2级目录，在之下就是缓存文件，测试的时候可以到该目录下查看缓存文件是否生成。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234205.png" alt="img"></p>
<h4 id="第二步：在访问静态文件的location上添加缓存"><a href="#第二步：在访问静态文件的location上添加缓存" class="headerlink" title="第二步：在访问静态文件的location上添加缓存"></a>第二步：在访问静态文件的location上添加缓存</h4><p><a href="javascript:void(0);"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234204.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#静态数据保存时效<br>location ~ \.html$ &#123;<br>      proxy_pass http:&#x2F;&#x2F;source.qingk.cn;<br>      proxy_redirect off;<br>      proxy_cache cache_one;<br>      #此处的cache_one必须于上一步配置的缓存区域名称相同<br>      proxy_cache_valid 200 304 12h;<br>      proxy_cache_valid 301 302 1d;<br>      proxy_cache_valid any 1m;<br>      #不同的请求设置不同的缓存时效<br>      proxy_cache_key $uri$is_args$args;<br>      #生产缓存文件的key，通过4个string变量结合生成<br>      expires 30d;<br>      #其余类型的缓存时效为30天<br>      proxy_set_header X-Forwarded-Proto $scheme;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234204.gif" alt="复制代码"></a></p>
<p>此处需要注意3点：</p>
<p>1、只有在proxy_pass的时候，才会生成缓存，下一次请求执行到proxy_pass的时候会判断是否有缓存，如果有则直接读缓存，返回给客户端，不会执行proxy_pass；如果没有，则执行proxy_pass，并按照规则生成缓存文件；可以到nginx的cache文件夹下看是否生成了缓存文件。</p>
<p>2、proxy_set_header Host $host 这一句可能导致缓存失败，所以不能配置这一句。我在测试的时候遇到了这个问题，不明原理。</p>
<p>3、proxy_pass使用upstream出差，换成域名或ip则可行。</p>
<h4 id="第三步：在proxy-pass跳转的location中配置静态文件的路径"><a href="#第三步：在proxy-pass跳转的location中配置静态文件的路径" class="headerlink" title="第三步：在proxy_pass跳转的location中配置静态文件的路径"></a>第三步：在proxy_pass跳转的location中配置静态文件的路径</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location ~ .*\.(html)$ &#123;<br>    default_type &#39;text&#x2F;html&#39;;<br>    root &quot;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;html&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将nginx本地存放静态文件的路径配到root指令处</p>
<p>如果没有这一句：default_type ‘text/html’，所有的请求都默认是下载文件，而不是访问html页面</p>
<p>到此，静态文件缓存已经配置完成。但是还差很重要的最后一步，缓存生成之后会阻止访问进入后台和nginx本地，如果有更新，则更新内容无法生效，还需要一种手动清除缓存的机制。</p>
<h4 id="第四步：清除缓存"><a href="#第四步：清除缓存" class="headerlink" title="第四步：清除缓存"></a>第四步：清除缓存</h4><p>缓存文件是根据proxy_cache_key这个指令生成的，所以找到对应的缓存文件，删除即可</p>
<p><a href="javascript:void(0);"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234204.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">location ~ &#x2F;purge(&#x2F;.*) &#123;<br>    #删除指定缓存区域cache_one的特定缓存文件$1$is_args$args<br>    proxy_cache_purge cache_one $1$is_args$args;<br>    #运行本机和10.0.217.0网段的机器访问，拒绝其它所有  <br>    allow           127.0.0.1;<br>    allow           10.0.217.0&#x2F;24;<br>    deny          all;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201234204.gif" alt="复制代码"></a></p>
<p>删除缓存用到proxy_cache_purge指令。</p>
<p>至此缓存生成和特定清除机制都已经实现。</p>
]]></content>
  </entry>
  <entry>
    <title>rsyslog</title>
    <url>/rsyslog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="rsyslog："><a href="#rsyslog：" class="headerlink" title="rsyslog："></a>rsyslog：</h2><p>​    </p>
<p>日志：历史事件日志<br>    历史事件：<br>        时间，事件<br>        事件级别（日志级别）：事件的关键性程度；</p>
<p>事件：系统引导启动、应用程序启动、应用程序尤其是服务类应用程序运行过程中的一些事件；<br>    系统日志服务：<br>        syslog：<br>            syslogd： system<br>            klogd：kernel</p>
<p>​    事件格式较为简单时，可统一由syslog进行记录：<br>​        事件产生的日期时间     主机     进程[pid] ：事件内容<br>​<br>​    支持C/S架构：可通过UDP或TCP协议提供日志记录服务；<br>​<br>​    rsyslog：<br>​        rsyslogd</p>
<p>​                </p>
<p>​            特性：<br>​                多线程；<br>​                UDP，TCP，SSL，TLS，RELP；<br>​                存储日志信息于MySQL、PGSQL、Oracle等数据管理系统；<br>​                强大的过滤器，实现过滤日志信息中任何部分的内容；<br>​                自定义输出格式；<br>​<br>​        elk stack：elasticsearch, logstash, kibana<br>​<br>rsyslog日志收集器重要术语：<br>​    facility：设施，从功能或程序上对日志收集进行分类；<br>​        auth, authpriv, cron, daemon, kern, lpr, mail, mark, news, security, user, uucp, local0-local7, syslog<br>​    priority：优先级，日志级别<br>​        debug, info, notice, warn(warning), err(error), crit(critical), alert, emerg(panic)<br>​<br>​        指定级别：<br>​            <em>：所有级别；<br>​            none：没有级别；<br>​            priority：此级别以高于此级别的所有级别；<br>​            =priorty：仅此级别；<br>​            ……<br>​<br>​    程序环境：<br>​        主程序：rsyslogd<br>​        主配置文件：/etc/rsyslog.conf，/etc/rsyslog.d/</em>.conf<br>​        服务脚本(centos6)：/etc/rc.d/init.d/rsyslog<br>​        Unit File(CentOS 7)：/usr/lib/systemd/system/rsyslog.service<br>​<br>​    配置文件格式rsyslog.conf<br>​        主要由三部分组成：<br>​            MODULES<br>​            GLOBAL DRICTIVES<br>​            RULES<br>​<br>​        RULES:<br>​            facilty.priority     target<br>​<br>​            target：<br>​                文件：记录日志事件于指定的文件中；通常应该位于/var/log目录下；文件路径之前的”-“表示异步写入；<br>​                用户：将日志事件通知给指定的用户；是通过将信息发送给登录到系统上的用户的终端进行的；<br>​                日志服务器：@host，把日志送往指定的服务器主机；<br>​                    host：即日志服务器地址，监听在tcp或udp协议的514端口以提供服务；<br>​                管道： | COMMAND<br>​<br>​        其它日志文件：<br>​            /var/log/wtmp：当前系统成功登录系统的日志；<br>​                需要使用last命令查看<br>​            /var/log/btmp：当前系统尝试登录系统失败相关的日志；<br>​                需要使用lastb命令查看<br>​<br>​                lastlog：显示当前系统上的所有用户最近一次登录系统的时间；<br>​<br>​            /var/log/dmesg：系统引导过程中的日志信息；<br>​                也可以使用dmesg命令进行查看；<br>​<br>​    rsyslog服务器：</p>
<p>Provides UDP syslog reception</p>
<p>​        $ModLoad imudp<br>​        $UDPServerRun 514</p>
<p>Provides TCP syslog reception</p>
<p>​        $ModLoad imtcp<br>​        $InputTCPServerRun 514<br>​<br>​    记录日志于mysql中：<br>​        (1) 于MySQL服务器：准备好MySQL服务器，创建用户，授权对Syslog数据库拥有全部访问权限；<br>​        (2) 于rsyslog主机：安装rsyslog-mysql程序包；<br>​        (3) 于rsyslog主机：通过导入createDB.sql脚本创建依赖到的数据库及表；<br>​            mysql    -uUSER  -hHOST  -pPASSWORD  &lt; /usr/share/doc/rsyslog-mysql-VERSION/createDB.sql<br>​        (4) 配置rsyslog使用ommysql模块</p>
<p>MODULES</p>
<p>​            $ModLoad  ommysql<br>​            </p>
<p>RULES</p>
<p>​            facility.priority         :ommysql:DBHOST,DB,DBUSER,DBUSERPASS<br>​<br>​            注意：重启rsyslog服务；<br>​        (5) web展示接口：loganalyzer<br>​            (a) 配置lamp组合<br>​                httpd, php, php-mysql, php-gd<br>​            (b) 安装loganalyzer</p>
<p>tar  xf  loganalyzer-3.6.5.tar.gz</p>
<p>cp  -r  loganalyzer-3.6.5/src  /var/www/html/loganalyzer</p>
<p>cp  -r loganalyzer-3.6.5/contrib/*.sh  /var/www/html/loganalyzer/</p>
<p>cd /var/www/html/loganalyzer/</p>
<p>chmod  +x  *.sh</p>
<p>./configure.sh</p>
<p>​<br>​                    </p>
<p>​            通过URL访问<br>​                <a href="http://HOST/loganalyzer" target="_blank" rel="noopener">http://HOST/loganalyzer</a><br>​                </p>
<p>./secure.sh</p>
<p>nsswitch and pam：</p>
<p>nsswitch：name service switch<br>    通用框架，与各种类型存储进行交互的公共实现；</p>
<p>实现：/usr/lib64/libnss<em>, /lib64/libnss</em><br>    框架：libnss<br>    驱动：libnss_files-</p>
<p>为每一种用到解析库的应用通过配置定义其位置：<br>    /etc/nsswitch.conf<br>        db:  store1  store2  …</p>
<pre><code>    例如：
    passwd: files
    hosts: files  dns 

解析库：
    文件、关系型数据管理系统(MySQL)、NIS、LDAP、DNS 

每种存储中的查找结果状态：
    STATSU =&gt; success | notfound | unavail | tryagain
对应于每种状态结果的行为（action）：
    return | continue 

例子：
    hosts: files  nis [NOTFOUND=return]  dns 

getent命令：
    getent  DATABASE  [key]</code></pre><p>pam：pluggable  authentication module</p>
<p>认证库：存储<br>    多种类型的存储：文件、关系型数据管理系统、LDAP、NIS</p>
<pre><code>pam：通用框架，提供了与各种类型存储进行交互的公共实现、以及多种辅助类的功能：
    /lib64/security/*

配置文件：为各种调用了pam的应用提供其专用配置；
    通用配置文件：/etc/pam.conf，可为每一种调用pam完成认证功能的应用程序提供配置；
    专用配置文件：/etc/pam.d/*，通常专用于为某种特定的应用程序提供配置；

    通常每个应用会使用一个单独的配置文件；

配置文件格式：
    通用配置文件：
        application      type        control         module-path         module-arguments
    专用配置文件：    
        type        control         module-path         module-arguments

    type：检查的功能类别
        auth：账号的认证和授权；
        account：与账号管理相关的非认证类的功能；
        password：用户修改密码时密码复杂度检查机制；
        session：用户获取到服务之前或使用服务完成之后需要进行一些附加性操作；

    control：同一种功能的多个检查之间如何进行组合；
        两种实现机制：
            (1) 简单实现：使用一个关键词来定义
            (2) 详细实现：使用一个或多个“status=action”

        简单实现：
            required：必须通过检查；否则，即为失败；无论成功还是失败，都需继续由后续同种功能的其它模块进行检查；
            requisite：一票否决；检测失败就直接返回失败；检测成功，则由由后续同种功能的其它模块进行检查；
            sufficient：一票通过，检测成功就直接返回成功；检测失败，则由由后续同种功能的其它模块进行检查；
            optional：可选的，参考性控制机制；
            include：调用其它配置文件中的同种功能的检测机制；

        详细实现：
            [status1=action1, status2=action2, ...]
                status：返回状态
                action：采取的行为，比如ok, done, die, bad, ignore, ...

    module-path：模块文件路径；
        相对路径：相对于/lib64/security/目录而言；
        绝对路径：可位于任何可访问路径；

    module-arguments：模块的专用参数；</code></pre><p>​                    </p>
<p>​        模块示例：<br>​            pam_limits.so：资源限制<br>​                在用户级别实现对其可使用的资源的限制，例如可打开的文件数量，可运行的进程数量，可用内存空间；<br>​<br>​                修改限制的实现方式：<br>​                    (1) ulimit命令<br>​                    (2) 配置文件：/etc/security/limits.conf, /etc/security/limits.d/*.conf<br>​<br>​                配置文件：每行一个定义；<br>​                    <domain>        <type>  <item>  <value><br>​<br>​                        <domain>：应用于哪些对象<br>​                            username<br>​                            @group<br>​                            *：所有用户<br>​<br>​                        <type>：限制的类型<br>​                            soft：软限制，普通用户自己可以修改；<br>​                            hard：硬限制，由root用户设定，且通过kernel强制生效；<br>​                            -：软硬使用相同限制；<br>​<br>​                        <item>：限制的资源类型<br>​                            nofile：所能够同时打开的最大文件数量；默认为1024；<br>​                            nproc：所能够同时运行的进程的最大数量；默认为1024；<br>​<br>​                ulimit命令：用于调整软限制；<br>​                    -n        最多的打开的文件描述符个数<br>​                    -u        最大用户进程数<br>​                    -S        使用 <code>soft&#39;（软）资源限制
​                    -H        使用</code>hard’（硬）资源限制<br>​<br>​        课外作业：分开实现；<br>​            (1) 限制centos用户只能够在worktime通过ssh远程连接本机；<br>​            (2) 限制只有distro组内的用户可通过ssh连接到本机；        </p>
<p>​                </p>
<h2 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@ashjian ~]<span class="hljs-comment">#vim /etc/rsyslog.conf </span><br><span class="hljs-comment"># Provides UDP syslog reception</span><br><span class="hljs-variable">$ModLoad</span> imudp <span class="hljs-comment">#输入模块，允许他人将日志输入本服务器</span><br><span class="hljs-variable">$UDPServerRun</span> 514    <span class="hljs-comment">#监听在udp 514   </span><br><span class="hljs-comment"># Provides TCP syslog reception</span><br><span class="hljs-variable">$ModLoad</span> imtcp<br><span class="hljs-variable">$InputTCPServerRun</span> 514 <span class="hljs-comment">#也可以同时udp和tcp一起监听</span><br><br><span class="hljs-comment">#另一台机子作为客户端</span><br>[root@wang ~]<span class="hljs-comment">#vim /etc/rsyslog.conf </span><br><span class="hljs-comment"># Log anything (except mail) of level info or higher.</span><br><span class="hljs-comment"># Don't log private authentication messages!</span><br>*.info;mail.none;authpriv.none;cron.none                @172.16.0.3  <br><span class="hljs-comment">#这样，这些日志就发给远程主机的rsyslog</span><br><br><span class="hljs-comment">#将rsyslog的日志存储到mysql中</span><br>[root@wang ~]<span class="hljs-comment">#yum install rsyslog-mysql -y #安装接口模块包</span><br>[root@wang ~]<span class="hljs-comment">#rpm -ql rsyslog-mysql</span><br>/usr/lib64/rsyslog/ommysql.so <span class="hljs-comment">#模块</span><br>/usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql <span class="hljs-comment">#sql脚本，用来生成ryslog的表和表结构</span><br>[root@ashjian ~]<span class="hljs-comment">#vim /etc/my.cnf.d/server.cnf</span><br><span class="hljs-comment"># this is only for the mysqld standalone daemon</span><br>[mysqld]<br>skip_name_resolve=ON<br>innodb_file_per_table=ON  <br>[root@ashjian ~]<span class="hljs-comment">#systemctl start mariadb.service </span><br>[root@ashjian ~]<span class="hljs-comment">#mysql &lt;/usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql</span><br>[root@ashjian ~]<span class="hljs-comment">#mysql -uroot -pm34s2q &lt;/usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql #设置了mysql的root密码则用这种写法</span><br>[root@ashjian ~]<span class="hljs-comment">#mysql -uroot -p</span><br>MariaDB [(none)]&gt; SHOW DATABASES;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| Syslog             | <span class="hljs-comment">#添加的Syslog数据库</span><br>| mysql              |<br>| performance_schema |<br>| <span class="hljs-built_in">test</span>               |<br>| wpdb               |<br>| zabbix             |<br>+--------------------+<br>7 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.02 sec)<br>MariaDB [(none)]&gt; use Syslog<br>MariaDB [Syslog]&gt; SHOW TABLES;<br>+------------------------+<br>| Tables_in_Syslog       |<br>+------------------------+<br>| SystemEvents           | <span class="hljs-comment">#事件</span><br>| SystemEventsProperties |<span class="hljs-comment">#事件属性</span><br>+------------------------+<br>2 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br>MariaDB [Syslog]&gt; DESC SystemEvents;<br>+--------------------+------------------+------+-----+---------+----------------+<br>| Field              | Type             | Null | Key | Default | Extra          |<br>+--------------------+------------------+------+-----+---------+----------------+<br>| ID                 | int(10) unsigned | NO   | PRI | NULL    | auto_increment |<br>| CustomerID         | bigint(20)       | YES  |     | NULL    |                |<br>| ReceivedAt         | datetime         | YES  |     | NULL    |                |<br>| DeviceReportedTime | datetime         | YES  |     | NULL    |                |<br>| Facility           | smallint(6)      | YES  |     | NULL    |                |<br>| Priority           | smallint(6)      | YES  |     | NULL    |                |<br>| FromHost           | varchar(60)      | YES  |     | NULL    |                |<br>| Message            | text             | YES  |     | NULL    |                |<br>| NTSeverity         | int(11)          | YES  |     | NULL    |                |<br>| Importance         | int(11)          | YES  |     | NULL    |                |<br>| EventSource        | varchar(60)      | YES  |     | NULL    |                |<br>| EventUser          | varchar(60)      | YES  |     | NULL    |                |<br>| EventCategory      | int(11)          | YES  |     | NULL    |                |<br>| EventID            | int(11)          | YES  |     | NULL    |                |<br>| EventBinaryData    | text             | YES  |     | NULL    |                |<br>| MaxAvailable       | int(11)          | YES  |     | NULL    |                |<br>| CurrUsage          | int(11)          | YES  |     | NULL    |                |<br>| MinUsage           | int(11)          | YES  |     | NULL    |                |<br>| MaxUsage           | int(11)          | YES  |     | NULL    |                |<br>| InfoUnitID         | int(11)          | YES  |     | NULL    |                |<br>| SysLogTag          | varchar(60)      | YES  |     | NULL    |                |<br>| EventLogType       | varchar(60)      | YES  |     | NULL    |                |<br>| GenericFileName    | varchar(60)      | YES  |     | NULL    |                |<br>| SystemID           | int(11)          | YES  |     | NULL    |                |<br>+--------------------+------------------+------+-----+---------+----------------+<br>24 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br>MariaDB [Syslog]&gt; DESC SystemEventsProperties;<br>+---------------+------------------+------+-----+---------+----------------+<br>| Field         | Type             | Null | Key | Default | Extra          |<br>+---------------+------------------+------+-----+---------+----------------+<br>| ID            | int(10) unsigned | NO   | PRI | NULL    | auto_increment |<br>| SystemEventID | int(11)          | YES  |     | NULL    |                |<br>| ParamName     | varchar(255)     | YES  |     | NULL    |                |<br>| ParamValue    | text             | YES  |     | NULL    |                |<br>+---------------+------------------+------+-----+---------+----------------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br>MariaDB [Syslog]&gt; GRANT ALL ON Syslgo.* TO <span class="hljs-string">'rsyslog'</span>@<span class="hljs-string">'172.16.%.%'</span> IDENTIFIED BY <span class="hljs-string">'rsyspass'</span>; <span class="hljs-comment">#用来程rsyslog进程登录mysql的账号</span><br>MariaDB [Syslog]&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.00 sec)<br>MariaDB [Syslog]&gt; <span class="hljs-built_in">exit</span><br>Bye<br><br><span class="hljs-comment">#客户端</span><br>[root@wang ~]<span class="hljs-comment">#vim /etc/rsyslog.conf</span><br><span class="hljs-comment">#指名用哪个模块进行输出，输出到哪</span><br><span class="hljs-comment">#### MODULES ####</span><br><span class="hljs-variable">$ModLoad</span> onmysql  <br><span class="hljs-comment">#### RULES ####</span><br>*.info;mail.none;authpriv.none;cron.none             :omysql:172.16.0.3,Syslog,rsyslog,rsyspass  <br>[root@wang ~]<span class="hljs-comment">#systemctl restart rsyslog.service</span><br></code></pre></td></tr></table></figure>


<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​     </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title>《情爱江南》“唐代礼乐复原组”</title>
    <url>/%E3%80%8A%E6%83%85%E7%88%B1%E6%B1%9F%E5%8D%97%E3%80%8B%E2%80%9C%E5%94%90%E4%BB%A3%E7%A4%BC%E4%B9%90%E5%A4%8D%E5%8E%9F%E7%BB%84%E2%80%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=415511604&bvid=BV1yV41187ma&cid=264036703&page=1as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>《秦王破阵乐》“唐代礼乐复原组”</title>
    <url>/%E3%80%8A%E7%A7%A6%E7%8E%8B%E7%A0%B4%E9%98%B5%E4%B9%90%E3%80%8B%E2%80%9C%E5%94%90%E4%BB%A3%E7%A4%BC%E4%B9%90%E5%A4%8D%E5%8E%9F%E7%BB%84%E2%80%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=330514115&bvid=BV17A41147mM&cid=264007806&page=1as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>《血源诅咒》原型浅考：猎人的水银诅咒</title>
    <url>/%E3%80%8A%E8%A1%80%E6%BA%90%E8%AF%85%E5%92%92%E3%80%8B%E5%8E%9F%E5%9E%8B%E6%B5%85%E8%80%83%EF%BC%9A%E7%8C%8E%E4%BA%BA%E7%9A%84%E6%B0%B4%E9%93%B6%E8%AF%85%E5%92%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://image.gcores.com/52723a69-b0a9-4291-a22c-91b06f9532d4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_2500,h_2500/quality,q_90" alt="封面图"></p>
<h1 id="被诅咒的猎人"><a href="#被诅咒的猎人" class="headerlink" title="被诅咒的猎人"></a>被诅咒的猎人</h1><p>非本人原创，用于收藏，转载：<a href="https://www.gcores.com/articles/120389" target="_blank" rel="noopener">https://www.gcores.com/articles/120389</a></p>
<p>上一篇文章《<a href="https://www.gcores.com/articles/117801" target="_blank" rel="noopener">雅楠城和兽化病的原型</a>》考据了古城雅楠和城中疾病的灵感来源，这回我们聊聊猎人。猎人是雅楠特有的职业，他们是野兽的克星，负责给患者们“物理除病”。</p>
<p>一开始，猎人对野兽的猎杀卓见成效，因此他们被雅楠居民视为英雄。但好景不长，猎人们一夜之间离奇消失。民间传说是猎人沉溺于野兽的鲜血，陷入无法脱身的噩梦。</p>
<p>当我们来到雅楠，野兽依然在街头上横行，猎人却早已被世人遗忘。老猎人格曼指导我们去寻找神秘的“苍白之血”，除此之外他很少提及别的事情，比如其他猎人的遭遇。</p>
<p>在我看来，猎人的没落实际上是应验了《血源诅咒》的世界观规律，或者说是创作者的史观。《血源诅咒》虽是幻想题材，其中的困境往往能从现实找到影子。雅楠人受困于轮回的月夜，同时也被时代的局限性所束缚。一切看上去如此绝望，是因为探索未知的积极意义在这个游戏中被淡化，而失败的代价则被夸大。</p>
<p>在考据猎人的过程中，我发现了一条隐藏的线索——<strong>水银</strong>。水银如同无形的诅咒，暗中主导了猎人命运。猎人的创作似乎是参考了现实历史中人类对水银的认知过程。</p>
<p><strong>水银子弹</strong>是猎人的力量来源，<strong>狩猎装束</strong>是猎人的身份象征，<strong>渔村惨剧</strong>是猎人的原初罪行。本文接下来将要依次考据这些内容，分析猎人与水银之间究竟存在什么样的联系。</p>
<h1 id="银还是水银，这是个问题"><a href="#银还是水银，这是个问题" class="headerlink" title="银还是水银，这是个问题"></a>银还是水银，这是个问题</h1><p>《血源诅咒》把时代背景放在十九世纪欧洲，游戏里自然少不了各种热兵器，但是创作者限制了火药的威力，让这个游戏的玩法更接近传统的剑与魔法，而不是射击游戏。</p>
<p><a href="https://image.gcores.com/7d47aae8-16ca-4727-956a-95dbd0123dc5.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7d47aae8-16ca-4727-956a-95dbd0123dc5.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水银子弹（水銀弾）"></a></p>
<p>水银子弹（水銀弾）</p>
<p>雅楠猎人使用的是一种具有神秘力量的水银子弹，水银子弹作为战斗资源，定位大致相当于其他RPG游戏中的魔法值。不仅枪械射击消耗弹药，使用仪式物品中的魔法和某些近战武器的特殊功能，同样需要消耗一定数量的水银子弹。</p>
<p>水银子弹克制兽化病借鉴了银子弹克制狼人的经典设定。古人认为白银能够杀菌，因此在宗教文化中白银具有对抗不洁的神圣属性。欧洲的狼人文化又与宗教猎巫息息相关，狼人和女巫这类邪恶存在往往都惧怕银器。</p>
<p><a href="https://image.gcores.com/8ebaf56b-3122-495f-acd9-70e8dc763932.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8ebaf56b-3122-495f-acd9-70e8dc763932.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《风暴英雄》狼人格雷迈恩的技能“诅咒枪弹”"></a></p>
<p>《风暴英雄》狼人格雷迈恩的技能“诅咒枪弹”</p>
<p>银弹驱邪的桥段在文艺作品中屡见不鲜，比如创作于十九世纪的《格林童话》，其中一篇《两兄弟》就出现了猎人对峙女巫的情景： </p>
<blockquote>
<p>女巫怪叫：“你想做什么？你根本就碰不到我！” 猎人却说：“你不下来，我就开枪把你打下来。” 女巫满不在乎：“你只管开枪，我根本就不怕你的子弹。” 猎人马上瞄准，朝着她开了一枪，但女巫竟然完全不怕猎枪击出的铅弹。只见她尖声怪笑，冲着猎人大喊：“你是不可能打中我的。” 猎人心中有数，他从自己的外套上，扯下三枚银质的纽扣当子弹。因为，女巫的魔法在白银面前，是完全没有效果的。给猎人上膛后，猎人瞄准女巫开了一枪，一下子把她从树上打了下来。</p>
</blockquote>
<p>雅楠猎人使用水银子弹的理由与上面的故事差不多，普通弹药很难伤害到雅楠的野兽。</p>
<blockquote>
<p>水銀弾 獣狩りの銃で使用される特別な弾丸 <strong>通常の弾丸では、獣に対する効果は期待できないため</strong> 触媒となる水銀に狩人自身の血を混ぜ、これを弾丸としたもの その威力は血の性質に依存する部分が大きい 水银子弹 猎兽火枪所使用的特殊子弹 <strong>因为普通的子弹对野兽的效果不太理想</strong> 水银作为触媒混入猎人自身的血液，以此制成子弹 其威力与血质有密切的关系</p>
</blockquote>
<p>不同的是，游戏中水银子弹的原材料不仅是水银，还融合了猎人自己的血液。这种制弹偏方的来历和原理都不明晰，推测可能来自上位者的知识，因为与上位者“无形的欧顿”有关的两个符文都会强化玩家使用水银子弹的能力。</p>
<p><a href="https://image.gcores.com/a5d65052-15a5-4dd7-8adc-67ef9bca18fb.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a5d65052-15a5-4dd7-8adc-67ef9bca18fb.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="“无形的欧顿”提高水银子弹携带数量，“欧顿的蠕动”使内脏暴击恢复水银子弹"></a></p>
<p>“无形的欧顿”提高水银子弹携带数量，“欧顿的蠕动”使内脏暴击恢复水银子弹</p>
<p>水银子弹的设定还可以解释一个遗留问题，上篇文章提到一群来路不明的外地警察追捕一头野兽来到雅楠，他们为什么会死于非命。警官服的物品文本指出他们对雅楠一无所知，所说的无知可能就包括了缺乏使用水银子弹猎兽的常识。</p>
<p>想要在雅楠活得长久，务必要记住这些雅楠特有的常识。除了携带水银子弹以外，猎人还有一个小习惯值得我们注意。</p>
<p><a href="https://image.gcores.com/d6d0e9a7-848b-48f0-be0b-24fc715885a8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d6d0e9a7-848b-48f0-be0b-24fc715885a8.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="毒手术刀（毒メス）"></a></p>
<p>毒手术刀（毒メス）</p>
<blockquote>
<p>毒メス たっぷりと毒に塗れた投げナイフ 歪んだ刃はメスのように薄く鋭く 医療教会の特殊医療者が護身用に持つことが多い <strong>伝統的に、狩人はあまり毒を用いない</strong> 通常の獣狩りでは、遅効にすぎるきらいがあるのだろう 毒手术刀 涂满了毒药的投掷匕首 歪曲的刀刃像手术刀一样轻薄锋利 大多数医疗教会的特殊医师携带用以防身 <strong>一般来说，猎人几乎不使用毒药</strong> 这是因为在常规的狩猎中，生效过于缓慢的缘故吧</p>
</blockquote>
<p>这种毒飞刀并非猎人武器，而是教会医师防身所用。在游戏机制上，毒药伤害不依靠使用者的个人能力，正好适合那些不擅长战斗的医师。</p>
<p>日文文本里有一个小细节在其他语言版本里没有翻译出来。官方曾表示过《血源诅咒》的所有韵笔都是宫崎英高一人负责。如果你想体会宫崎英高的阴阳怪气，这是个很好的例子。</p>
<p>道具的日文名称是“<strong>毒メス</strong>”。“メス”出自荷兰语“mes”，原意是刀刃，然而日语里“メス”专指手术用的<strong>柳叶刀</strong>（scalpel）。文本紧接着写着“刀刃像手术刀（メス）一样锋利”，也说明了道具名里的“メス”确实指的是手术刀。</p>
<p>但是这件暗器实质上只是飞刀，并不是真正的手术刀。我认为这是在讽刺教会的医师背离医德。就像“教会白色装束”的文本上所写的那样，在雅楠这个地方，所谓的医疗不再是为了治愈疾病，而是一种研究手段。</p>
<p>回到原来的话题，文本的后半段指出了猎人的一个传统是<strong>他们不使用毒药</strong>，因为毒药生效缓慢。这听起来有一定道理，野兽濒死一旦反扑会产生不必要的危险，倒不如速战速决。</p>
<p><a href="https://image.gcores.com/3bbea5ba-77e4-44d5-aa46-d75597110441.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3bbea5ba-77e4-44d5-aa46-d75597110441.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="形似眼球的小石子"></a></p>
<p>形似眼球的小石子</p>
<p>但在我看来，游戏文本似乎存在不可靠的叙述。比如游戏中玩家很少用到的道具“小石子”，无论是形状还是获得途径都让人联想到眼球，物品文本却故意强调石子只是石子，仅此而已。</p>
<p>毒手术刀的文本对猎人不用毒的讨论，或许是在转述游戏内某些人的观点。他们本身不是猎人，观察到猎人不用毒药，由结果反推原因。生效缓慢不见得是猎人禁用毒药的真正原因，至少我认为是不准确的。</p>
<p>宫崎英高创作文本的另一个特点是<strong>注重文本之间的相互解释</strong>。上文提到的警官服和水银子弹的文本就构成了这种互文的关系。调查猎人不用毒药的原因，我们也可以看看其他物品的文本是怎么说的。</p>
<p><a href="https://image.gcores.com/2135dc21-8d89-412e-b67c-0d35c10877b2.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2135dc21-8d89-412e-b67c-0d35c10877b2.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="投掷匕首（スローイングナイフ）"></a></p>
<p>投掷匕首（スローイングナイフ）</p>
<blockquote>
<p>スローイングナイフ 細かいギザ刃のついた投げナイフ 特に古狩人ヘンリックの愛用したもの <strong>獣に対して大きなダメージが期待できるものではないが うまく使えば、けん制と翻弄に威力を発揮するだろう</strong> 投掷匕首 刀刃附带细小锯齿的投掷匕首 古猎人亨利克尤其喜爱这种武器 <strong>虽然对野兽威力不佳 如果熟练使用，可以起到牵制和捉弄对方的作用</strong></p>
</blockquote>
<p>雅楠的猎人会在战斗中使用无毒的普通飞刀，神父盖斯科因的好友亨利克就是善用飞刀的好手。</p>
<p><a href="https://image.gcores.com/7436ca83-918f-487b-ba9a-d0a429971c07.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7436ca83-918f-487b-ba9a-d0a429971c07.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="古猎人亨利克"></a></p>
<p>古猎人亨利克</p>
<p>两种飞刀的物品文本格式一致，都表示花哨的手段对猎杀野兽没有什么大用，但评价却截然相反：前者认为猎人因此不用毒药，而后者认为熟练掌握可以锦上添花。这样看来，毒药伤害效率低下并不是禁用的主要原因。</p>
<p>那么猎人为什么不使用毒药呢？我认为可能是<strong>道德约束</strong>，雅楠猎人视下毒为耻辱。</p>
<p>很多玩家应该会对圣剑路德维希的BOSS战印象深刻。路德维希原是医疗教会的首席猎人，在游戏本篇，他仅出现在背景故事中，到了DLC“老猎人”才正式登场。</p>
<p><a href="https://image.gcores.com/8e4062eb-368a-46a8-9755-dbd23b8d798c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8e4062eb-368a-46a8-9755-dbd23b8d798c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="丑陋的野兽，路德维希（醜い獣、ルドウイーク）"></a></p>
<p>丑陋的野兽，路德维希（醜い獣、ルドウイーク）</p>
<p>路德维希在猎人噩梦里看守着大圣堂的下水道，形态极其扭曲。BOSS战的第一阶段，他兽化的程度已经到达极致。而到了第二阶段，路德维希拔出月光圣剑，举止反而更接近常人，面对面决斗仿佛重现了教会猎人曾经坚持的高尚品行。</p>
<p><a href="https://image.gcores.com/379a3160-e97e-47ee-8d79-fbdfb45cfe01.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/379a3160-e97e-47ee-8d79-fbdfb45cfe01.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="圣剑的路德维希（聖剣のルドウイーク）"></a></p>
<p>圣剑的路德维希（聖剣のルドウイーク）</p>
<p>猎人使用特制的变形武器狩猎，从这些武器的攻击属性设计上也能看出猎人的好恶。在所有武器中只有该隐赫斯特的<strong>千景</strong>，武器本身具有毒性效果。</p>
<p><a href="https://image.gcores.com/76fea005-fd12-411a-a728-12d8cc267d87.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/76fea005-fd12-411a-a728-12d8cc267d87.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="千景"></a></p>
<p>千景</p>
<p>使用血刃千景的该隐赫斯特近卫骑士被教会视为异端，可以认为他们不必遵从雅楠猎人的道德约束。</p>
<p>看到这里你可能会问，为什么要纠结猎人对毒药的看法？这得回到本章节最开始的话题——水银子弹的原型。</p>
<p><a href="https://image.gcores.com/8546b8ea-ab68-4062-af59-162668e94430.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8546b8ea-ab68-4062-af59-162668e94430.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="猎人子弹与水银子弹的图标对比"></a></p>
<p>猎人子弹与水银子弹的图标对比</p>
<p>水银子弹在早期测试版本里的名称是<strong>猎人子弹</strong>（hunter bullet），图标与现在不同。后续的开发过程中，猎人子弹更名为水银子弹，这明显区别于银子弹。我能理解水银子弹这个名字是在银子弹克制狼人的基础上，添加了水银疗法治疗梅毒的新意象，但是把银改成水银似乎有些问题。</p>
<p><a href="https://image.gcores.com/f37d48db-6f83-4a5f-bdf2-ab667517b3be.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f37d48db-6f83-4a5f-bdf2-ab667517b3be.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水银的炼金术符号"></a></p>
<p>水银的炼金术符号</p>
<p>首先是水银缺乏<strong>驱邪属性</strong>。水银的神秘意义主要体现于欧洲古代炼金术，并没有白银在宗教文化中那样强烈的神圣属性。但这方面的疑虑不是很有必要。</p>
<p><a href="https://image.gcores.com/c5f2aaeb-ee3e-48b1-b452-d357c0ac27a8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c5f2aaeb-ee3e-48b1-b452-d357c0ac27a8.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="液态金属水银"></a></p>
<p>液态金属水银</p>
<p>其次是水银的形态。水银在常温下呈液态，相比白银更不适合作为子弹的材料，不过我们可以假想水银子弹中的水银因为某些能量而凝固。</p>
<p>最大的矛盾在于水银毒性。假设猎人因为道德约束而禁用毒药，使用有毒的水银子弹就违背了猎人的教条。如果创作者考虑过这个问题，并且坚持采用水银子弹的设定，那么很可能隐藏了其他目的。</p>
<p>在我看来，这可能是在暗示猎人的内在矛盾。将血液与水银融合的行为颇有契约的意味，有毒的水银玷污了猎人的信念。他们在使用短视的手段解决眼前的问题——暴力猎杀雅楠城蔓延的兽化病——注定以失败告终。</p>
<p>更严重的是长期接触水银还会造成慢性中毒，水银中毒的主要症状之一就是<strong>发疯</strong>。</p>
<h1 id="帽中的疯狂"><a href="#帽中的疯狂" class="headerlink" title="帽中的疯狂"></a>帽中的疯狂</h1><p>格曼是猎人组织的创始者。我们不了解格曼过去的具体经历，只知道如今他作为建言者，在猎人梦境给新来的猎人指路。</p>
<p><a href="https://image.gcores.com/18aed5d9-360f-474d-ae76-65ddb74b1b69.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/18aed5d9-360f-474d-ae76-65ddb74b1b69.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="猎人梦境中的格曼"></a></p>
<p>猎人梦境中的格曼</p>
<p>猎人的最终使命是找到苍白之血，这个话题我们暂且不提，继续说猎人本身。总之，玩家一路斩妖除魔，在曼西斯噩梦里阻止了梅高的降生仪式。回到猎人梦境后会发现猎人工坊起火，标志着游戏进入了尾声。</p>
<p><a href="https://image.gcores.com/1afaa7a9-af08-4561-b905-ce9e46072e43.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1afaa7a9-af08-4561-b905-ce9e46072e43.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="燃烧的猎人工坊"></a></p>
<p>燃烧的猎人工坊</p>
<p>格曼在后院大树下等候我们，对工坊的火灾视而不见。我们被告知任务已经完成，他将要送我们离开梦境，此时有两个选项：</p>
<ol>
<li>同意介错，离开梦境</li>
<li>拒绝介错，与格曼战斗</li>
</ol>
<p>无论如何选择，格曼都会在相应的过场动画里更换帽子和披风。</p>
<p><a href="https://image.gcores.com/3e96ce4d-6b7b-4200-9830-32b069eff4d5.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3e96ce4d-6b7b-4200-9830-32b069eff4d5.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="换装后的格曼"></a></p>
<p>换装后的格曼</p>
<p>如果放在其他游戏里，解读换装细节也许大可不必，但在《血源诅咒》里却有特别的意义。</p>
<p>宫崎英高的作品往往会淡化角色的表情和动作演出，甚至连说话时都没有口型变化，转而通过外在装饰来刻画人物的内心世界。比如《黑暗之魂》系列里人见人爱的洋葱骑士，玩家先是通过滑稽的盔甲设计感受到绝望环境下为数不多的乐观情绪，等到了解他们的故事后，喜悲的反差带来了更大的冲击。</p>
<p><a href="https://image.gcores.com/f06aaca2-751e-4d9c-84b8-5993489bb4b0.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f06aaca2-751e-4d9c-84b8-5993489bb4b0.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="至今我都记不住几位洋葱骑士的全名"></a></p>
<p>至今我都记不住几位洋葱骑士的全名</p>
<p>早在宫崎英高入社之前，From Software 就已经开始使用类似的手法。最初也许只是开发能力受限的妥协，但发展到今天，这已经变成了这家游戏公司独树一帜的表现风格。</p>
<p><a href="https://image.gcores.com/0dda833b-865a-4176-b2cf-ae8c17c576df.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0dda833b-865a-4176-b2cf-ae8c17c576df.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="格曼换装前后对比"></a></p>
<p>格曼换装前后对比</p>
<p>格曼换装后的大礼帽不仅是维多利亚时代的标志，也暗示了他的精神状态。</p>
<p><a href="https://image.gcores.com/2390aa96-58e9-4872-8b3c-fe49ddb4b3ae.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2390aa96-58e9-4872-8b3c-fe49ddb4b3ae.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="大礼帽"></a></p>
<p>大礼帽</p>
<p><strong>大礼帽（top hat）</strong>兴起于十九世纪初的欧洲，因为帽子面料是河狸的毛皮，因此也叫作“河狸帽（beaver hat）”。对河狸毛皮的旺盛需求导致欧洲和美洲的河狸被大量捕杀，比如《荒野大镖客：救赎》这类游戏就少不了猎杀河狸的环节。</p>
<p><a href="https://image.gcores.com/d02f9dec-18a7-4f45-9fea-86cb80042bc9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d02f9dec-18a7-4f45-9fea-86cb80042bc9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="河狸（beaver）"></a></p>
<p>河狸（beaver）</p>
<p>后来便宜的丝绸取代河狸毛皮，降低了大礼帽的成本，大礼帽也有“丝绸帽（silk hat）”的别名。</p>
<p><a href="https://image.gcores.com/29949047-212a-4c6b-8120-4d863df2ef54.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/29949047-212a-4c6b-8120-4d863df2ef54.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="丝绸材质的大礼帽"></a></p>
<p>丝绸材质的大礼帽</p>
<p>大礼帽流行以后，制帽工厂发生了奇怪的现象。工人们纷纷出现喜怒无常、抑郁、妄想等精神症状，同时伴随无法控制的四肢颤抖。英语中形容疯癫的惯用语“像帽匠一样疯狂（mad as a hatter）”就是出自于此。</p>
<p>这种让人发疯的怪病实际上是慢性水银中毒。制作大礼帽需要先将动物毛皮加工成毛毡，维多利亚时代的主流做法是利用硝酸汞处理毛皮。因为加工使用的溶液呈胡萝卜色，这种制毡方法被称为“Carroting”。</p>
<p><a href="https://image.gcores.com/9c29ee1b-1228-44a0-9785-eab4af87bbfb.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9c29ee1b-1228-44a0-9785-eab4af87bbfb.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="工人在用硝酸汞处理毛皮"></a></p>
<p>工人在用硝酸汞处理毛皮</p>
<p>工人每天接触有毒的含汞溶液，日积月累导致中毒。慢性水银中毒会损伤人的神经系统，引发一系列精神失常的症状。受限于时代，当时的世人对水银缺乏了解，把制帽工厂的水银中毒症状叫作“疯帽病”，并且认为这种病会传染。</p>
<p>顺带一提，硝酸汞也是制作雷汞炸药的原料。雷汞是《只狼》中的顶级火药材料，物品文本上写着雷汞由南蛮（欧洲人）传入日本，内府掌握着制造雷汞的技术。为何十九世纪发明的雷汞炸药会出现在几百年前的日本战国时代，就只有宫崎英高自己知道了。</p>
<p><a href="https://image.gcores.com/e4757185-fd63-4143-a4f2-1835a16909ea.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e4757185-fd63-4143-a4f2-1835a16909ea.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《只狼》中的雷汞"></a></p>
<p>《只狼》中的雷汞</p>
<p>历史上的工业污染多如牛毛，疯帽病这么出名得益于一部维多利亚时代的文艺作品。文艺作品的社会价值——揭露社会问题，敲响警钟——发挥了应有的作用。</p>
<p>1865年，英国数学家查尔斯·路特维奇·道奇森用笔名路易斯·卡罗出版了《<strong>爱丽丝梦游仙境</strong>》。这部小说讲述了主人公爱丽丝跳入兔子洞穿越异世界的奇妙经历。</p>
<p><a href="https://image.gcores.com/9adb0b77-76a6-4305-bff3-1c1bec2a409a.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9adb0b77-76a6-4305-bff3-1c1bec2a409a.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Alice&#39;s Adventures in Wonderland"></a></p>
<p>Alice’s Adventures in Wonderland</p>
<p>小说第七章“疯狂的茶会”，爱丽丝看到一个戴礼帽的人与一只兔子在喝茶，于是她也加入茶会。他们一边喝茶一边说着难懂的怪话。</p>
<p><a href="https://image.gcores.com/3cdf572a-5103-4915-81b0-af91717f35c8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3cdf572a-5103-4915-81b0-af91717f35c8.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="疯狂的茶会（A Mad Tea-Party）"></a></p>
<p>疯狂的茶会（A Mad Tea-Party）</p>
<p>在不说人话这方面，《爱丽丝梦游仙境》可以说是《血源诅咒》的老前辈，粗略读一遍很难明白这部小说想表达什么，尽管如此，还是有很多读者很喜欢这部小说，晦涩的内容也吸引了无数“爱学家”分析研究。</p>
<p>茶会上戴着帽子的人，被称为帽子先生或是疯帽子。这个人物形象的灵感来源有很多不同的说法，有人认为疯帽子代表了被资本家压榨的劳动人民。</p>
<p>但后人更倾向是制帽工厂的疯帽病让作者创造了疯帽子。迪士尼在2010年将《爱丽丝梦游仙境》改编成电影，约翰尼·德普扮演电影版疯帽子。德普在采访里曾透露，他在电影中的形象参考了中毒的感觉，电影版疯帽子的头发呈橙色，我们可以推断他所说的中毒是指硝酸汞中毒。</p>
<p><a href="https://image.gcores.com/09eb8bd6-0f3d-468c-94ef-c1cd0636873d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/09eb8bd6-0f3d-468c-94ef-c1cd0636873d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="约翰尼·德普扮演的疯帽子"></a></p>
<p>约翰尼·德普扮演的疯帽子</p>
<p>《爱丽丝梦游仙境》让疯帽子成为流行的符号化形象，帽子与疯狂的组合被许多后来的文艺作品借鉴。例如漫威漫画中的反派 <strong>Madcap</strong>，他在一次化学事故中失去了家人和自己的理智。</p>
<p><a href="https://image.gcores.com/e744957f-8b18-4f31-a81e-4744d50ee38a.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e744957f-8b18-4f31-a81e-4744d50ee38a.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Madcap"></a></p>
<p>Madcap</p>
<p>借用疯帽子典故的游戏例子则是《铲子骑士》，游戏中有一个痴迷于收集帽子而无法自拔的角色也叫作<strong>帽子先生（Mr.Hat）</strong>。</p>
<p><a href="https://image.gcores.com/c25b9f51-4807-4005-94c7-76d023b449b4.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c25b9f51-4807-4005-94c7-76d023b449b4.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="&quot;Mr. Hat: Enough! I know not what came over me! My hunger for hats took control! Your.. beautiful hat..&quot;"></a></p>
<p>“Mr. Hat: Enough! I know not what came over me! My hunger for hats took control! Your.. beautiful hat..”</p>
<p>《血源诅咒》的创作者没有直接引用疯帽子的典故，理由显而易见：<strong>疯狂是这个游戏的核心主题</strong>，雅楠这地方一点儿都不缺疯子。在这种环境下不加思考地放入疯帽子形象，只会削弱这个符号的表现力。</p>
<p>说到借鉴，市面上充斥着大量粗制滥造的作品，创作者把各种朋克、克苏鲁等流行元素一股脑儿塞到作品里，根本不去思考这么做对创作本身有何意义。而宫崎英高的作品风格如此独特，很大程度上归功于创作时对借鉴和重构的巧思。</p>
<p>落实到疯帽子这个典故的利用，宫崎英高没有直接在游戏里设计一个戴着礼帽故作疯态的角色，而是将典故中的元素拆解，以一种更加阴郁委婉的方式重新组合，进而讨论疯狂的边界。</p>
<p><a href="https://image.gcores.com/0d10976b-6af3-4c4b-ba1d-e62250e47695.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0d10976b-6af3-4c4b-ba1d-e62250e47695.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="大礼帽（トップハット）"></a></p>
<p>大礼帽（トップハット）</p>
<blockquote>
<p>トップハット 紳士然とした様式美を愛する狩人たちの帽子 仕込み杖がそうであるように、ある種の狩人は様式美を重んじる 彼らにとっては、様式美であれ、あるいは美であれ正義であれ それらこそが人らしさであり、狩人を人に留めるよすがなのだ 大礼帽 钟情于绅士般形式感的猎人们所佩戴的帽子 和使用伸缩手杖的理由相同，一些猎人注重形式上的美感 对于他们来说，形式感、美和正义 就是人性本质，保持理智的关键</p>
</blockquote>
<p>一些猎人把维持理性的希望寄托于人类特有的仪式感，他们追求绅士风度，使用大礼帽和手杖等物件提醒自己要保持优雅，远离野蛮。</p>
<p><a href="https://image.gcores.com/597dd5cb-f659-469c-bcef-f3f703f965a7.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/597dd5cb-f659-469c-bcef-f3f703f965a7.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="都会的狩猎装束"></a></p>
<p>都会的狩猎装束</p>
<p>但这只说了一半，另一半信息在伸缩手杖的物品文本上。</p>
<p><a href="https://image.gcores.com/edff190e-4b23-45ea-a8b1-98aa40d215e8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/edff190e-4b23-45ea-a8b1-98aa40d215e8.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="伸缩手杖（仕込み杖）"></a></p>
<p>伸缩手杖（仕込み杖）</p>
<blockquote>
<p>仕込み杖 狩人が獣狩に用いる、工房の「仕掛け武器」の１つ 刃を仕込んだ硬質の杖は、そのままで十分に武器として機能するが 仕掛けにより刃は分かれ、まるで鞭のように振るうこともできる 武器を杖に擬し、獣に対するに鞭を振るう様は、様式美の類である それは、自ら獣狩りの血に飲まれまいとする意思だったろうか 伸缩手杖 猎人狩猎使用的工房“变形武器”之一 内藏刀刃的硬质手杖，可以直接作为武器使用 变形后刀刃分离，也能像鞭子一样挥动 将武器功能藏于杖中，对着野兽挥舞鞭子的模样，都是形式感的表现 那样就能保证猎兽不会迷失自我了吧</p>
</blockquote>
<p>猎人对仪式感的追求偏离了正轨，他们认为手杖变形而成的长鞭和不断抽打野兽的残忍场面呈现出某种更加深奥的美感，区别于以往简单粗暴的杀戮。</p>
<p>《血源诅咒》的世界观否定英雄史诗和机械降神，越是举足轻重的角色越要承担更多的责任，遭受更残酷的磨难，没有例外。这种事与愿违的感觉自始至终伴随着玩家。</p>
<p>格曼是猎人组织的创始者，而路德维希是医疗教会猎人组织的创始者，二人可以说是雅楠猎人的核心人物。路德维希人性的复苏让人感到一丝欣慰，但意料之外的转变却是因为他对神秘月光的执念。游戏中虽然没有明说月光的本质，通过种种细节能感觉到月光丝线与<strong>寄生虫</strong>之间不祥的联系。</p>
<p><a href="https://image.gcores.com/5f3f6957-db88-47e1-9896-1d7145608233.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5f3f6957-db88-47e1-9896-1d7145608233.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="“引导”符文提到路德维希闭上眼睛就能看到舞动的小人"></a></p>
<p>“引导”符文提到路德维希闭上眼睛就能看到舞动的小人</p>
<p>格曼的苦痛则更加难以察觉。绝大多数猎人都已经发疯甚至丧失人的形态，而格曼这个最能代表猎人的角色却幸免于难，他与我们正常交流，提供推动剧情的线索，但这一切是真实的吗？格曼做梦时一反常态，说着哀求解脱的梦话，希望有人能够让他离开这漫长的梦境。</p>
<blockquote>
<p>…ああ、ローレンス…ウィレーム先生…誰か、助けてください… 誰でもいい、解放してください… …私は夢に疲れました。もう、この夜に何も見えないのです… …ああ、誰か… ……啊啊，劳伦斯，威廉老师……谁来救救我…… 谁都可以，让我解脱吧…… ……做梦让我疲惫。这夜晚已经看不见任何东西了…… ……啊啊，谁来救救我……</p>
</blockquote>
<p>我猜宫崎英高也许是从哈兰·艾里森的小说《无声狂啸》获得了如何折磨一个人的灵感。对老玩家来说，这部短篇科幻小说改编的同名游戏知名度更高一些。</p>
<p><a href="https://image.gcores.com/578e8017-735c-419b-a9ea-d6a5ba6cf1bd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/578e8017-735c-419b-a9ea-d6a5ba6cf1bd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="小说《无声狂啸》"></a></p>
<p>小说《无声狂啸》</p>
<p>小说描绘了一个极其黑暗的未来世界，AI把人类残杀殆尽，仅留下五名“幸存者”当作自己的玩物。这些人无法通过自杀规避AI的折磨，但规则存在漏洞，并没有禁止杀害他人的行为，主角自我牺牲解脱了其他四个人。恼羞成怒的AI把他改造成没有嘴的永生肉团，小说的最后一句即是小说的标题：</p>
<blockquote>
<p>“我没有嘴，可我要咆哮。（I have no mouth. And I must scream.）”</p>
</blockquote>
<p>猎人梦境中的格曼就像是《无声狂啸》主人公的翻版。他被神秘的力量囚禁，确保完成猎人的终极使命，他能让其他猎人解脱，自己却永远无法离开梦境，甚至失去了发疯的资格。格曼所有的情感都被压抑在苍白月夜的宁静之下。</p>
<p><a href="https://image.gcores.com/5c94ffed-cf03-4807-ab89-4a5cf42fb5a8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5c94ffed-cf03-4807-ab89-4a5cf42fb5a8.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="格曼的设定稿"></a></p>
<p>格曼的设定稿</p>
<p>猎人使命完成后，格曼使用葬送之刃为我们介错，离开雅楠梦境。但如果我们拒绝介错，战胜格曼就要继承他的苦难，而他会从梦中解脱。</p>
<p><a href="https://image.gcores.com/80335a6b-902d-4f53-9885-2d90a3ab7c59.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/80335a6b-902d-4f53-9885-2d90a3ab7c59.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="达成“遗志继承者”结局，主角将代替格曼继续看守梦境"></a></p>
<p>达成“遗志继承者”结局，主角将代替格曼继续看守梦境</p>
<p>《血源诅咒》处处体现着轮回，大礼帽也不例外。</p>
<p>从轮椅站起来戴上大礼帽的格曼是游戏结束前我们见到的最后一个人，而游戏最开始出现在我们面前的第一个人同样坐着轮椅戴着大礼帽，他欲言又止地提到了苍白之血。</p>
<p><a href="https://image.gcores.com/b897b2c3-939c-4f74-bc59-9e568423cded.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b897b2c3-939c-4f74-bc59-9e568423cded.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="游戏开场出现的神秘角色"></a></p>
<p>游戏开场出现的神秘角色</p>
<p>结束本节之前，还要再补充一些游戏中出现的帽饰原型。这些原型虽然和水银主题没有直接联系，却有助于我们理解猎人的形象。</p>
<p><a href="https://image.gcores.com/1d29b0a2-40c8-4ccb-bb00-dcb261cf9322.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1d29b0a2-40c8-4ccb-bb00-dcb261cf9322.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="骨炭假面（骨炭の仮面）"></a></p>
<p>骨炭假面（骨炭の仮面）</p>
<blockquote>
<p>骨炭の仮面 最古の番人たちの、骨炭の仮面 上位者たちの眠りを守る番人たちは その姿と魂を業火に焼かれ、灰として永き生を得たという 鋭く尖った大きな帽子は、古い番人のシンボルであり 彼らがある種の罪人であった証であると考えられている 骨炭假面 最古老的看守者们的骨炭假面 确保上位者安眠的看守者们 身与魂被业火灼烧，据说因此获得了灰烬一般的永生 尖顶的大帽子，是古代看守者的象征 据说是他们曾为某种罪人的证据</p>
</blockquote>
<p>圣杯地牢中的古代看守者戴着“骨炭假面”，他们的身上有灼烧的痕迹。尖顶大沿儿帽是典型的女巫帽子样式，女巫帽子的罪人意象来自于宗教禁令，基督教教义禁止民间研究巫术，因此欧洲曾经出现持续数个世纪的猎巫运动，受害者最后往往都落得被火烧死的下场。中世纪风格的《黑暗之魂》里同样出现了代表异端的女巫帽子典故。</p>
<p><a href="https://image.gcores.com/1f29341f-db07-42a0-85e6-615e91bf3a47.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1f29341f-db07-42a0-85e6-615e91bf3a47.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="卡露拉三角帽子、黑魔女帽子（黑暗之魂3）"></a></p>
<p>卡露拉三角帽子、黑魔女帽子（黑暗之魂3）</p>
<p>古代守护者的形象可以算是某种彩蛋，暗示了火之时代的存在。这种彩蛋出现在宫崎英高的多部作品中，构成了一个实际上并不存在的<strong>宫崎英高宇宙</strong>，以后如果有机会可以详细讲讲这方面的内容。</p>
<p><a href="https://image.gcores.com/fd2d1bd5-62c8-484d-8bd6-6354177c476c.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fd2d1bd5-62c8-484d-8bd6-6354177c476c.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="骨炭狩猎服装"></a></p>
<p>骨炭狩猎服装</p>
<p>走出地牢回到十九世纪的雅楠城，猎人的帽饰样式主要分为两类：三角帽和大礼帽。</p>
<p><a href="https://image.gcores.com/13e1ffc7-81a4-4eda-857d-7062412a6c24.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/13e1ffc7-81a4-4eda-857d-7062412a6c24.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="三角帽（tricorne）"></a></p>
<p>三角帽（tricorne）</p>
<p><strong>三角帽（tricorne）</strong>流行于比维多利亚时代更早的十八世纪欧洲。游戏中出现了大量以三角帽为原型的猎人帽饰，他们大部分都是古猎人。</p>
<p>游戏物品中出现的三角帽样式：</p>
<ul>
<li>猎人帽（狩人の帽子）</li>
<li>雅楠狩猎帽（ヤーナムの狩帽子）</li>
<li>灰狼帽（灰狼の帽子）</li>
<li>亨利克的狩猎帽（ヘンリックの狩帽子）</li>
<li>玛利亚的狩猎帽（マリアの狩帽子）</li>
<li>遮眼帽（目隠し帽子）</li>
</ul>
<p><a href="https://image.gcores.com/8c4534b9-b233-4059-a08a-62585add8cdd.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8c4534b9-b233-4059-a08a-62585add8cdd.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>游戏封面上的“猎人帽”（左1）和古猎人裘达的“灰狼帽”（左3）有些特别，可以看作是只有两个侧边，去掉脑后边缘的三角帽变种，但有人认为这种设计有其他的原型，是出现于欧洲十三世纪到十六世纪的<strong>“Bycockets”</strong>。</p>
<p><a href="https://image.gcores.com/409d93fe-d906-42b6-8b83-74bbaed7e555.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/409d93fe-d906-42b6-8b83-74bbaed7e555.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Bycockets"></a></p>
<p>Bycockets</p>
<p>大礼帽在十九世纪初取代了三角帽，游戏物品中出现的大礼帽样式：</p>
<ul>
<li>大礼帽（トップハット）</li>
<li>古猎人大礼帽（古狩人のトップハット）</li>
<li>山村的狩猎帽（ヤマムラの狩帽子）</li>
<li>使者的大礼帽（使者のトップハット）</li>
<li>使者的褶皱大礼帽（使者のよれよれトップ）</li>
</ul>
<p><a href="https://image.gcores.com/211f444b-c12e-4a2c-91c2-261a49ab4db0.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/211f444b-c12e-4a2c-91c2-261a49ab4db0.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>有趣的是，山村套装的帽子（左3）结合了三角帽和大礼帽的设计，而混搭的服饰却是东瀛风格。</p>
<p><a href="https://image.gcores.com/f39512d4-721d-41f7-ab13-e42f2cd9f801.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f39512d4-721d-41f7-ab13-e42f2cd9f801.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="流浪猎人山村"></a></p>
<p>流浪猎人山村</p>
<p>大礼帽大起大落的发展历史也与猎人的兴衰有几分相似。流行之初，大礼帽受到社会各个阶层欢迎，就像猎人过去光辉的英雄时代。</p>
<p>维多利亚女王于1901年逝世，维多利亚时代随之结束。不久后欧洲爆发第一次世界大战，人民生活发生剧烈变化。在帽饰的选择上，实用性更占上风，轻便的软帽取代了笨重的硬质大礼帽。</p>
<p>但大礼帽没有就此消失，失去民众基础后反而凸显了特权阶级的尊贵，人民大众对政治家和资本家的抨击讽刺也波及到大礼帽。雅楠猎人后来也遭到污名化，我们在猎人噩梦击败路德维希后，他会述说自己曾被旁人辱骂和讽刺的经历。</p>
<p><a href="https://image.gcores.com/b5186112-7b2c-4ce7-987f-0aecc2d6a1c3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b5186112-7b2c-4ce7-987f-0aecc2d6a1c3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="污名化的大礼帽"></a></p>
<p>污名化的大礼帽</p>
<p>二十世纪初开始流行“Fedora”一类的软帽，与当今的时尚已经没有明显的区别。</p>
<p><a href="https://image.gcores.com/f69a4fe8-ac11-41c0-b6ad-85828349617d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f69a4fe8-ac11-41c0-b6ad-85828349617d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Fedora"></a></p>
<p>Fedora</p>
<p>玩家所在的时代，大部分当地居民戴着接近“Fedora”设计的软帽。</p>
<p><a href="https://image.gcores.com/4fd2c616-c988-4c61-8a11-e1ca4deaa2de.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4fd2c616-c988-4c61-8a11-e1ca4deaa2de.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="游荡的雅楠居民"></a></p>
<p>游荡的雅楠居民</p>
<p>游戏物品中出现的软帽样式：</p>
<ul>
<li>格曼的狩猎帽（ゲールマンの狩帽子）</li>
<li>教会的黑帽子（教会の黒帽子）</li>
<li>褶皱的雅楠帽（よれたヤーナム帽）</li>
<li>使者的黑帽子（使者の黒帽子）</li>
<li>使者的雅楠帽（使者のヤーナム帽）</li>
</ul>
<p><a href="https://image.gcores.com/30bb33dd-3e23-43f9-9d66-af58b1eafa6f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/30bb33dd-3e23-43f9-9d66-af58b1eafa6f.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>不过需要注意的是，游戏中帽饰的时代设定与现实原型不完全一致，比如格曼的狩猎帽虽然是软帽，在故事时间线上却是较早出现的帽饰之一。</p>
<p>前面说到骨炭假面有《黑暗之魂》的既视感，礼尚往来，黑魂系列也相继出现了三角帽和大礼帽。初代的<strong>了不起的切斯特</strong>戴着大礼帽，三代的<strong>无名指李奥纳德</strong>戴着三角帽，二人有很多相似之处：身份神秘，戴着面具，对待玩家先友善后敌对，就连站立姿势都差不多。</p>
<p><a href="https://image.gcores.com/366054be-cc76-4238-9949-99df615e9267.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/366054be-cc76-4238-9949-99df615e9267.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="切斯特和李奥纳德"></a></p>
<p>切斯特和李奥纳德</p>
<p>《血源诅咒》里还有个非常奇葩的“帽子”，那就是联盟长头上戴着的<strong>铁桶</strong>。可这个铁桶并不是凭空想象的行为艺术。</p>
<p><a href="https://image.gcores.com/8ec1cbf6-2785-4191-bec2-4cd969d1e7e6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8ec1cbf6-2785-4191-bec2-4cd969d1e7e6.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="联盟长维尔特（連盟の長、ヴァルトール）"></a></p>
<p>联盟长维尔特（連盟の長、ヴァルトール）</p>
<p>十九世纪初，欧洲各国的军队也开始弃用三角帽，取而代之的是一种名为“<strong>Shako</strong>”的军帽，形状就像是倒扣的水桶。</p>
<p><a href="https://image.gcores.com/20ff15a3-b06b-4abe-a89d-adf17af88fed.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/20ff15a3-b06b-4abe-a89d-adf17af88fed.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="联盟长铁盔与“Shako”军帽"></a></p>
<p>联盟长铁盔与“Shako”军帽</p>
<p>我一直认为，创作者不需要主动解释游戏中的细节和彩蛋，或者是回答玩家诸如创作意义之类的问题，所有信息都已经包含在作品之中。就拿这个例子来说，一旦玩家捕捉到铁桶对军帽的模仿，自然会去想象究竟发生了什么，以及这样设计的象征意义。</p>
<h1 id="渔村罪迹"><a href="#渔村罪迹" class="headerlink" title="渔村罪迹"></a>渔村罪迹</h1><p>水银诅咒最后的线索来自DLC“老猎人”。透过一颗病变的眼球，我们触及了猎人的罪恶记忆，记忆的最深处是一个阴冷又破败的偏远渔村。</p>
<p><a href="https://image.gcores.com/52587f6f-2f9f-422d-b4ce-3283d19b233f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/52587f6f-2f9f-422d-b4ce-3283d19b233f.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="渔村设定稿"></a></p>
<p>渔村设定稿</p>
<p>《血源诅咒》的上位者概念借鉴了洛夫克拉夫特的<strong>克苏鲁神话</strong>，说到崇拜上位者的渔村，必然会联想到洛夫克拉夫特的名篇《<strong>印斯茅斯的阴霾</strong>》。</p>
<p><a href="https://www.gcores.com/radios/111406" target="_blank" rel="noopener">机核有声书《印斯茅斯的阴霾》</a></p>
<p>我们像调查员一样，探索渔村的秘密。途中会遭遇各种怪异的村民。有的成群结队提着鱼叉在村中巡逻，有的释放邪恶的法术诅咒入侵者，有的像是人类女性与贝类的结合，对我而言，最恐怖的是那些全身遍布藤壶的渔村巨人。</p>
<p>虽然渔村的视觉设定很有《印斯茅斯的阴霾》的感觉，但如果我们从故事内核的角度看，渔村的惨剧并不克苏鲁，更像是一个朴素的灾难故事：外来者来到一个与世无争的偏远村庄，为了达成某种目的，破坏了当地居民的生活和信仰。</p>
<p>手持水银子弹的雅楠猎人是这个故事中的外来者，他们来到渔村的目的是调查上位者的秘密。同时还有一点不能忽视，《血源诅咒》是日本人做的游戏。</p>
<p><strong>日本、渔村、外来者、水银、灾难。</strong>这些关键词放在一起，原型一目了然，那就是日本四大公害病之一的<strong>水俣病</strong>。水俣病是日本熊本县水俣地区由工业污染引发的水银中毒灾难。</p>
<p><a href="https://image.gcores.com/af197813-3a5d-4f18-8346-d8ed1c4710e2.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/af197813-3a5d-4f18-8346-d8ed1c4710e2.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水俣病受害者"></a></p>
<p>水俣病受害者</p>
<p>这里尽量不赘述水俣病的详细过程，只展现与考据有关的内容。如果对水俣病的细节有兴趣，可以阅读蒂莫西·乔治的<a href="https://book.douban.com/subject/24860919/" target="_blank" rel="noopener">《水俣病 : 污染与战后日本的民主斗争》</a>，此书也是本文主要的参考资料。</p>
<p><a href="https://image.gcores.com/1bd1b865-5c85-49ad-8e18-78bc56a981e6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1bd1b865-5c85-49ad-8e18-78bc56a981e6.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水俣位于熊本西南沿海地区"></a></p>
<p>水俣位于熊本西南沿海地区</p>
<p>水俣市是日本熊本县的一个沿海城市。过去这里的居民以盐业为生，日本政府将盐业国有化以后，水俣人失去了重要的营生手段。</p>
<p>二十世纪初，日本一家名为“<strong>日本窒素肥料株式会社</strong>”的化工企业趁机介入此地，把水俣从一个渔村发展成围绕窒素公司运转的公司城，全盛时期整个城市十分之一的人口都是窒素公司的员工。</p>
<p>窒素公司真正的发展机遇是在二战结束以后。日本战败后开始经济复苏，化工业正是国家复兴的支柱产业。与雅楠的拜伦维斯学院相似的是，窒素公司非常重视科研，灾难因此由科学而生。</p>
<p><a href="https://image.gcores.com/12f73219-9397-4184-b9b2-f93bfc46e673.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/12f73219-9397-4184-b9b2-f93bfc46e673.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="窒素水俣工厂"></a></p>
<p>窒素水俣工厂</p>
<p>窒素公司的水俣工厂负责生产新型化肥，怪病随之降临。1953年开始，当地渔民陆续出现发疯的迹象，同时还有大量野猫离奇死亡，当时把这种怪病叫作“疯猫病”。</p>
<p>熊本大学建立水俣病研究小组，去水俣工厂调查病因却遭到窒素公司的阻挠。直到1958年，英国营养学家道格拉斯·麦克阿尔派恩访问熊本大学，发现水俣怪病与英国工厂的有机汞中毒症状类似。</p>
<p><a href="https://image.gcores.com/af7e17dc-0d0f-48f8-81bc-841ced2cc121.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/af7e17dc-0d0f-48f8-81bc-841ced2cc121.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="关于甲基汞中毒的研究"></a></p>
<p>关于甲基汞中毒的研究</p>
<p>这篇研究伦敦郊外工厂水银中毒的论文发表于1940年，由三名研究者共同完成，三人的名字分别是：<strong>Donald Hunter、Richard R. Bomford、Dorothy S. Russell。</strong></p>
<p>在日文资料中，这个症状被称为<strong>“Hunter-Russell综合征（ハンター·ラッセル症候群）”</strong>。可以看成是“猎人病”揭示了渔村的秘密，或者反过来说，渔村灾难的本质是“猎人病”，即水银中毒。</p>
<p>弄清调查方向后，研究组1959年确定了水俣病的病因正是有机汞中毒。工厂废水含有的有机汞在沿海鱼虾体内不断囤积，最后被食用鱼虾的人类和动物吸收，导致水银中毒。讽刺的是，水俣病的调查研究在同年被叫停。</p>
<p>回头看游戏，渔村惨剧之后，医疗教会在雅楠的实验栋进行实验，研究上位者与大海的关系。这个方向的研究最后也被放弃，玩家所在的时代，医疗教会已经把研究方向转向了别处。</p>
<p>如果把水俣病出现到研究停止看作是渔村惨剧的事发阶段，那么九年后水俣病的曝光，就对应了玩家进入噩梦调查原罪的时刻。1968年水俣病正式公开，引起日本社会各界重视。人们用各种方式声讨窒素公司的罪行。</p>
<p><a href="https://image.gcores.com/b9de02ef-7e58-4423-9f42-9d2eb9dd2a7d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b9de02ef-7e58-4423-9f42-9d2eb9dd2a7d.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="教会猎人西蒙"></a></p>
<p>教会猎人西蒙</p>
<p>在游戏中，教会猎人西蒙一路陪伴玩家揭露秘密。但进入渔村不久，西蒙就被教会刺客布拉多袭击身亡。</p>
<p><a href="https://image.gcores.com/8306f47a-0882-4b51-b76e-0fb92238ea4c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8306f47a-0882-4b51-b76e-0fb92238ea4c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="威廉·尤金·史密斯（William Eugene Smith）"></a></p>
<p>威廉·尤金·史密斯（William Eugene Smith）</p>
<p>水俣病的声讨者里也有这样一位“外乡人”——<strong>威廉·尤金·史密斯（William Eugene Smith）</strong>。史密斯是一位美国摄影师，他在进入工厂取材时遭到窒素公司的打手殴打，他们摔毁了他的相机，并把他打成重伤，一目暂时失明。史密斯事后感慨，他切身体会到了水俣病的受害者们多年以来所承受的痛苦和愤怒。</p>
<p><strong>《智子入浴（Tomoko Uemura in Her Bath）》</strong>是史密斯在水俣拍摄的一张最有代表性的作品。</p>
<p><a href="https://image.gcores.com/3982921a-7915-402f-bc7e-d1bc76c9eae8.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3982921a-7915-402f-bc7e-d1bc76c9eae8.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="智子入浴（Tomoko Uemura in Her Bath）"></a></p>
<p>智子入浴（Tomoko Uemura in Her Bath）</p>
<p>母亲良子给患有水俣病的女儿智子洗澡，爱与痛共同交织在这张照片的黑白光影之中。</p>
<p><a href="https://image.gcores.com/4dda508e-f1e2-43b2-9bf8-eaac61c8e478.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4dda508e-f1e2-43b2-9bf8-eaac61c8e478.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="哀悼基督"></a></p>
<p>哀悼基督</p>
<p>这张照片如此出名，还有一个原因是其构图神似米开朗琪罗的名作<strong>《哀悼基督》</strong>，受难而死的基督耶稣以类似的姿势躺在圣母玛利亚的怀中。</p>
<p><a href="https://image.gcores.com/471b976d-0e6e-4301-a9cd-f81b5fdc4cda.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/471b976d-0e6e-4301-a9cd-f81b5fdc4cda.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="劳伦斯"></a></p>
<p>劳伦斯</p>
<p>猎人噩梦也出现了模仿《哀悼基督》的场景。医疗教会的创始者劳伦斯，在噩梦中以火焰缠身的圣职者野兽形象登场，他像耶稣一样躺着噩梦大圣堂中央的椅子上。游戏里没有表现劳伦斯与渔村的直接关系，不过既然渔村惨剧的执行者格曼内心饱受煎熬，策划者劳伦斯应该也有类似的心境吧。</p>
<p>关于劳伦斯的考据，需要等到将来调查雅楠宗教时再展开，他的形象借鉴了基督耶稣的一部分元素。在宗教意义上，劳伦斯背负了雅楠和渔村居民的苦难而殉道。</p>
<h1 id="结语以及苍白的预告"><a href="#结语以及苍白的预告" class="headerlink" title="结语以及苍白的预告"></a>结语以及苍白的预告</h1><p>以上就是对猎人的水银诅咒的个人臆想，宫崎英高是否想过这些，除了他自己，没有人知道。每次打开《血源诅咒》重返雅楠，我都会有一些新的发现，或是对已知信息产生新的见解。雅楠的梦境提供的不是一个供玩家被动欣赏进而得到满足的故事，而是全方位袭来让人应接不暇的复杂感受，这种观感突破了故事结构的限制，是电子游戏独有的魅力。设计这样的世界非常困难，想要赋予其持久的生命力和深刻的内涵，离不开创作者对现实世界的观察思考和真诚表达。</p>
<p>关于猎人的考据，其实还有一部分没有讲，比如玩家扮演的主角、猎人的实质等等。想要解释这些问题必须牵涉到那个神秘的概念——苍白之血。</p>
<p>苍白之血是宫崎英高留下的谜题，甚至可以说，它是雅楠梦境的核心。通过兽化病和猎人前后两篇文章的铺垫，是时候去触碰这个谜题了，所以下一篇文章将会是苍白之血的专题。</p>
<p>那么就让我们在<strong>苍白与血</strong>的雅楠再见吧！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>维基百科</p>
<p><a href="https://www.bloodborne-wiki.com/" target="_blank" rel="noopener">Bloodborne Wiki</a></p>
<p><a href="https://www.grimmstories.com/zh/grimm_tonghua/liang_xiongdi" target="_blank" rel="noopener">两兄弟 - 童话</a></p>
<p><a href="https://lazyhistorian.com/mad-about-mad-hatter-disease/" target="_blank" rel="noopener">Mad about Mad Hatter Disease</a></p>
<p><a href="https://www.sciencelearn.org.nz/images/4191-mad-hatter-disease" target="_blank" rel="noopener">IMAGE - Mad hatter disease</a></p>
<p><a href="https://book.douban.com/subject/1021311/" target="_blank" rel="noopener">《爱丽丝梦游仙境》</a></p>
<p><a href="https://marvel.fandom.com/wiki/Madcap_(Earth-616)" target="_blank" rel="noopener">Marvel Database - Madcap</a></p>
<p><a href="https://shovelknight.fandom.com/wiki/Mr._Hat" target="_blank" rel="noopener">Shovel Knight Wiki - Mr. Hat</a></p>
<p>《I Have No Mouth, and I Must Scream》</p>
<p><a href="https://historicaltwist.com/index.php/history-of-the-british-infantry-shako-part-1-the-stovepipe/" target="_blank" rel="noopener">The Stovepipe Shako</a></p>
<p><a href="https://book.douban.com/subject/24860919/" target="_blank" rel="noopener">《水俣病：污染与战后日本的民主斗争》</a></p>
<p><a href="http://nimd.env.go.jp/syakai/webversion/pdfversion/houkokusho.pdf" target="_blank" rel="noopener">水俣病の悲劇を繰り返さないために</a></p>
<p><a href="http://www.asoshiranui.net/minamata/hunter.pdf" target="_blank" rel="noopener">POISONING BY METHYL MERCURY COMPOUNDS</a></p>
<p><a href="https://www.magnumphotos.com/photographer/w-eugene-smith/" target="_blank" rel="noopener">W. Eugene Smith</a></p>
<p><a href="https://www.magnumphotos.com/newsroom/health/w-eugene-smith-minamata-warning-to-the-world/" target="_blank" rel="noopener">W. Eugene Smith’s Warning to the World</a></p>
<p><a href="https://iconicphotos.wordpress.com/2009/05/06/tomoko-uemura-in-her-bath/" target="_blank" rel="noopener">Tomoko Uemura in Her Bath</a></p>
]]></content>
  </entry>
  <entry>
    <title>《血源诅咒》原型浅考：雅楠城与兽化病的原型</title>
    <url>/%E3%80%8A%E8%A1%80%E6%BA%90%E8%AF%85%E5%92%92%E3%80%8B%E5%8E%9F%E5%9E%8B%E6%B5%85%E8%80%83%EF%BC%9A%E9%9B%85%E6%A5%A0%E5%9F%8E%E4%B8%8E%E5%85%BD%E5%8C%96%E7%97%85%E7%9A%84%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="入梦之前"><a href="#入梦之前" class="headerlink" title="入梦之前"></a>入梦之前</h1><p>非本人原创，用于收藏，转载：<a href="https://www.gcores.com/articles/117801" target="_blank" rel="noopener">https://www.gcores.com/articles/117801</a></p>
<p>迟迟没有动笔，不知该如何谈论《血源诅咒》这个游戏。事隔多年重新体验了一遍日文版本，结合之前考据《只狼：影逝二度》时总结的思路，找到一些想写的东西。</p>
<p>《血源诅咒》发售已有五年之久，玩家社群创作了无数精彩的解读文章和视频，如果说撰写本文时没有参考任何他人成果，那是不可能的。若是追求纯粹的“创新”，难免会落入哗众取宠的境地。</p>
<p>考据的过程中我察觉到日文版的原生文本中隐藏着不少有趣的细节，翻译成其他语言后折损了原有的韵味和信息量。《血源诅咒》虽然是一个以十九世纪英国维多利亚时代为参考背景的西方幻想题材游戏，其中引用了大量西方的文化元素，但是无法忽视其创造者大部分都是日本人，即便是欧美文化圈的玩家，对日本文化过滤后的西方神话、历史、宗教等元素依然有很多难以理解的地方。</p>
<p>常有人说，《黑暗之魂》系列和《血源诅咒》披着西方幻想的外皮，骨子里却是日本文化的内核。如何摆脱视觉元素的束缚将内敛的文化特质传达给玩家，是我想通过考据去探讨的问题。理解日本的创作者如何使用西方文化元素，有利于我们将来也去做类似的事情。</p>
<p>游戏的考据也是一种学习，我会尽可能核实每条线索的来源，保证自己亲自读过文中提及的其他作品。因为考据涉及到很多不同领域的知识，现学现卖难免会出现错误，望指正。</p>
<p>曾在机核投稿的两篇《只狼》考据文章（<a href="https://www.gcores.com/articles/109450" target="_blank" rel="noopener">神之篇</a>、<a href="https://www.gcores.com/articles/110129" target="_blank" rel="noopener">国之篇</a>），文章结构和内容编排都有不满意的地方。大主题的合集形式难以保证每个小主题的质量，篇幅过长又影响阅读体验。故作出一些调整，每篇《血源诅咒》考据文章将会以一个独立主题为主，篇幅控制在万字左右，细水长流。</p>
<h1 id="关于语言版本和翻译"><a href="#关于语言版本和翻译" class="headerlink" title="关于语言版本和翻译"></a>关于语言版本和翻译</h1><p>《血源诅咒》由日本游戏公司 From Software 开发，主要创作者皆为日本人，所以日文版是最严谨且最适合考据的版本。</p>
<p>文中引用的物品描述和人物对话等文本内容以日文版为主并附以个人翻译，本人日语水平有限，若出现翻译错误，希望可以在评论区批评指出。</p>
<p>非必要情况下，文中使用的素材均来自网络，日文文本采用 BloodborneWiki 网站的整理：<a href="https://www.bloodborne-wiki.com/2017/10/lore-translation-guide.html" target="_blank" rel="noopener">BloodborneWiki：Lore Translation Guide</a></p>
<p>宫崎英高创作游戏文本有一些个人习惯，比如喜欢使用生僻词汇和别称来营造陌生感。本文在名词翻译上直接沿用中日汉字意义相近的名称，保持宫式行文的怪僻和统一感。</p>
<p><strong>例1</strong>：玩家可以在隐匿街亚哈古尔解救医疗教会的修女阿黛拉，指导她去欧顿教堂或者诊所避难。这个NPC的日文名是“<strong>尼僧アデーラ</strong>”，“尼僧”即中文的尼姑，日本的修女虽然有些情况下也使用“尼僧”来称呼，更多是使用“修道女”或“シスター（Sister）”。</p>
<p><a href="https://image.gcores.com/ac2b9afd-0253-4687-b3cf-965c4fc1462a.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ac2b9afd-0253-4687-b3cf-965c4fc1462a.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="修女阿黛拉（尼僧アデーラ）"></a></p>
<p>修女阿黛拉（尼僧アデーラ）</p>
<p>顺便一提，这位修女在《血源诅咒》中的表现可谓是恶女，如果玩家在欧顿小教堂多次向妓女索要血液，并且修女在场的话，游戏的中后期修女会趁玩家离开小教堂时杀死妓女。</p>
<p>而在宫崎英高的另一部作品《只狼》中也有一位“尼僧”，即看守源之宫大门的<strong>破戒僧</strong>。破戒僧所佩戴的面具是能面中的“<strong>真蛇</strong>”，头上的角比“生成”和“般若”更长，且<strong>没有耳朵</strong>无法听进别人的话语，用来表现最凶恶的怨女。</p>
<p><a href="https://image.gcores.com/4b663db3-acaf-413a-bc55-66c2241ada93.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4b663db3-acaf-413a-bc55-66c2241ada93.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="破戒僧和真蛇能面"></a></p>
<p>破戒僧和真蛇能面</p>
<p><strong>例2</strong>：游戏中的以下区域是雅楠城的不同街区，比如雅楠旧市街是雅楠城被废弃的一个谷底街区，废弃后鲜有人记得原本的街区名，所以用旧市街来称呼。</p>
<ul>
<li>ヤーナム市街 雅楠市街</li>
<li>ヤーナム聖堂街 雅楠圣堂街</li>
<li>ヤーナム旧市街 雅楠旧市街</li>
<li>ヘムウィックの墓地街 汉威克墓地街</li>
<li>隠し街ヤハグル 隐匿街亚哈古尔</li>
</ul>
<p>官方简繁中文版的地名转译自英文版，缺乏了城市不同区域的统一感甚至扭曲原意，本文中地名的翻译基本和日文名称一致。</p>
<p>宫式行文还经常出现倒装和省略，若有这类情况我会在翻译文本后面留下注释。</p>
<p><strong>例3</strong>：游戏初始时玩家面前会有一个神秘的留言。</p>
<blockquote>
<p>自筆の走り書き 「青ざめた血」を求めよ。狩りを全うするために</p>
</blockquote>
<p>这是一张字迹潦草的字条。字条的内容部分前后倒装，句号放在中间，省略了后面的标点。</p>
<p>正常顺序：</p>
<blockquote>
<p>狩りを全うするために、「青ざめた血」を求めよ。 为了完成狩猎，去寻找“苍白之血”吧。</p>
</blockquote>
<p>关于“青ざめた血”的翻译和解读，将来我会用单独一篇文章来分析。</p>
<h1 id="宫崎英高的两条作品线"><a href="#宫崎英高的两条作品线" class="headerlink" title="宫崎英高的两条作品线"></a>宫崎英高的两条作品线</h1><p>From Software 是一家历史悠久的日本老牌游戏公司，曾经以《装甲核心》等作品闻名。2009年《恶魔之魂》获得商业和口碑双丰收后，接着开发了《黑暗之魂》三部曲、《血源诅咒》、《只狼：影逝二度》以及还未公布具体信息的新作《Elden Ring》，这些拳头作品确立了这家游戏公司在新世代的定位和开发方向。</p>
<p>根据这几部作品的开发规模、发售顺序和细节特点，可以看出 From Software 这些年似乎在交替创作两条并行的作品线：<strong>黑暗幻想</strong>和<strong>怪谈志异</strong>。</p>
<p><a href="https://image.gcores.com/1d0050ba-2459-4506-9374-bea703773bd1.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1d0050ba-2459-4506-9374-bea703773bd1.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="黑暗幻想"></a></p>
<p>黑暗幻想</p>
<p>前者包括《<strong>恶魔之魂</strong>》、《<strong>黑暗之魂</strong>》系列和《<strong>Elden Ring</strong>》。这些游戏可以看作是该社的核心作品，采用王道的中世纪黑暗幻想题材，世界观宏大但没有参考明确的历史时代，各方面的设定一脉相承，游戏场景、NPC、武器、装备、法术技能等内容规模较大。</p>
<p>《黑暗之魂》继承自《恶魔之魂》，最新作《Elden Ring》公布时宫崎英高形容这部作品将会是《黑暗之魂》的王道进化。</p>
<p>很好理解 From Software 为什么会把大部分精力压在这条作品线上，魂系列是这家游戏公司步入新时代的奠基作品，而且骑士、魔法、龙等元素组成的中世纪幻想是全球范围最大众的背景设定之一。</p>
<p><a href="https://image.gcores.com/cc21cb37-531e-4d38-a5ab-21d5beeb2ff9.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cc21cb37-531e-4d38-a5ab-21d5beeb2ff9.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="怪谈志异"></a></p>
<p>怪谈志异</p>
<p>后者暂时只有《<strong>血源诅咒</strong>》和《<strong>只狼</strong>》两部作品，虽说样本少缺乏总结规律的信服力，依然可以看出一些共同点，这两部作品与前者比相对独立，在游戏的系统和核心玩法上一定程度做了简化和创新的尝试，游戏开发规模也较小。如果《Elden Ring》之后的下一个新作还是这种风格的作品，则可以确认双线创作的规划。这个系列的作品也可以认为是新玩法和不同时代背景重构练习的试验田。</p>
<p>这两部怪谈志异作品都采用了小格局的故事舞台，参考具体的时代背景。《血源诅咒》的故事发生在欧洲东部的偏僻古都雅楠，参考了<strong>英国维多利亚时代</strong>，《只狼》的故事发生在日本北方深山中的苇名城，参考了<strong>日本战国时代</strong>。</p>
<p>故事格局虽小，但玩家会感觉到在这个世界观下存在一个神秘的外部世界。《只狼》的苇名以外是战火纷飞的日本战国末期，以及强大的内府。</p>
<p>雅楠之外的世界是什么？我给出的答案是“<strong>伦敦</strong>”。“<strong>伦敦</strong>”指的不是一个具体的城市，而是文明世界的代称。想要理解为什么雅楠的外面是文明世界，我们需要知道《血源诅咒》的暗线是什么。</p>
<p>我曾提出《只狼》借着战国时代的外皮讲了一个大和民族侵略少数民族和平安末期天皇式微的故事，而《血源诅咒》在暗线的设置上也用了类似的技法，表面是十九世纪的英国维多利亚时代，雅楠人的骨子里却还保留着旧时代的落后思想，这个游戏真正的暗线也是<strong>时代的错位</strong>。 </p>
<h1 id="雅楠内外"><a href="#雅楠内外" class="headerlink" title="雅楠内外"></a>雅楠内外</h1><p>《血源诅咒》的时代背景参考了十九世纪的英国维多利亚时代，距离今时仅有一二百年，故事发生在一个名为“雅楠”的虚构城市。雅楠盛行独特的医疗手段，吸引无数外乡人前往此地治病，主角也是一名来自外乡的寻医者。</p>
<p>主角的身世和雅楠以外的世界在游戏中着墨甚少，但宫崎英高在游戏发售前的某次采访中曾透露过一些信息：</p>
<blockquote>
<p>プレイヤーキャラクターは、いってしまえば“異邦人”です。辺境の“ヤーナム”から遠く離れた場所からやってきた旅人です。<strong>この時代の中心地</strong>、現実でいえば<strong>ロンドン</strong>あたりから、というイメージでしょうか。“ヤーナム”では、独特な古い医療行為を行っている設定があり、その怪しげな医療行為を求めてやってきたわけです。 玩家的角色，简单概括是个“异乡人”。是从遥远的地方来到边境“雅楠”的旅人。来自<strong>这个时代的中心地区</strong>，参考现实的话大概对应<strong>伦敦</strong>的感觉吧。“雅楠”施行着独特古老的医疗行为，前往雅楠是为了寻求这种可疑的医疗行为。</p>
</blockquote>
<blockquote>
<p>先ほど、例としてイギリスのロンドンが出ましたが、舞台として想定している国のイメージはあるのでしょうか。 なんとなく<strong>東欧</strong>あたりをイメージしていますが、明確なものではありません。ゲーム中で明言もしないと思います。いずれにしても“ヤーナム”は、中央から遠く離れた辺境です。古く陰気で、偏見と秘密に満ちた場所ですね。 刚才举例提到了英国的伦敦，那游戏的舞台有什么假想的原型吗？ 参考了一些<strong>东欧</strong>的印象，但明确的原型是没有的。游戏中也不会有明确表示。总之“雅楠”位于远离中央的偏远边境。是个古老又阴暗，充满偏见和秘密的地方。</p>
</blockquote>
<blockquote>
<p>実際に東欧へロケなども行ったのですか？ ロケではないのですが、取材のために<strong>チェコ</strong>と<strong>ルーマニア</strong>に行きました。恐ろしい弾丸ツアーでしたが、刺激的で得るものはとても多く、当然そのままではありませんが、それらは本作の独特な雰囲気、空気感に生かされていると思います。 实际去东欧取了外景吗？ 虽然没有实地取景，为取材去过<strong>捷克</strong>和<strong>罗马尼亚</strong>。行程短暂收获颇多，得益于此行营造了本作独特的气氛和空气感。</p>
</blockquote>
<p>根据宫崎英高的解释，雅楠对标的现实城市并不是维多利亚时代的英国伦敦，《血源诅咒》的官方介绍上也特别指出了雅楠与伦敦的不同之处。</p>
<p><a href="https://image.gcores.com/4ad7c4d2-485e-4b9b-8320-67f620e19b10.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4ad7c4d2-485e-4b9b-8320-67f620e19b10.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="“那是个与同时代伦敦不同，荒凉又安静得诡异的世界。”"></a></p>
<p>“那是个与同时代伦敦不同，荒凉又安静得诡异的世界。”</p>
<p>玩家会产生雅楠像伦敦的印象，多半是因为雅楠宏伟的建筑群。《只狼》中的苇名城也存在这种错觉，夸张的建筑规模服务于游戏场景的需求，却不符合那个时代偏远地方的实际生产力。</p>
<p>雅楠与参考时代背景的矛盾主要体现在<strong>政治</strong>和<strong>医疗</strong>两个方面。</p>
<p>雅楠本地几乎没有政府存在的痕迹，政权由古老的教会掌控，对应维多利亚时代的大型中心城市的话，这显然是不合理的。</p>
<p>如果创作者无意去描写游戏世界中的政治环境，我们大可把这些缺失看作是与玩家的共识，就好比正常的玩家不会根据游戏中的建筑是否有厕所来判断其真实性。然而《血源诅咒》中对雅楠之外的政治环境是有所描绘的。</p>
<p><a href="https://image.gcores.com/c766406b-c1ed-4b8d-99c9-abb9e2b163ae.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c766406b-c1ed-4b8d-99c9-abb9e2b163ae.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="某警察局翻修前连个厕所都没有"></a></p>
<p>某警察局翻修前连个厕所都没有</p>
<p>玩家创建角色选择自己的出身，其中一个选项是“<strong>从军经验</strong>”。</p>
<blockquote>
<p>従軍経験 君には従軍経験がある 力も技術も、鍛えられた 从军经验 你有从军的经验 力量和技术都得到了锻炼</p>
</blockquote>
<p>如上文所述，主角是从伦敦印象的大城市而来的外乡人，说明在这个世界的其他地方存在一定规模的正规军队。</p>
<p><a href="https://image.gcores.com/673bf3cb-a672-42ef-ada6-b53be67d5899.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/673bf3cb-a672-42ef-ada6-b53be67d5899.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="联盟长维尔特（連盟の長、ヴァルトール）"></a></p>
<p>联盟长维尔特（連盟の長、ヴァルトール）</p>
<p>雅楠郊外的禁域森林有一个名为“联盟长维尔特（連盟の長、ヴァルトール）”的NPC，在猎人噩梦中能找到和他同款的制服。</p>
<p><a href="https://image.gcores.com/973b8798-d8aa-454a-9be2-c47dbccdecde.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/973b8798-d8aa-454a-9be2-c47dbccdecde.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="警官服"></a></p>
<p>警官服</p>
<blockquote>
<p>官憲の服 かつて一匹の獣を追い、ヤーナムを訪れた<strong>官憲隊</strong>の制服 彼らは皆獣の餌食となり、生き残った一人が獣を喰らったという それは、ヤーナム民の好む類の噂話だ 高圧的で偏見に満ちた異邦人たちは、ヤーナムを理解せず 故にその闇に血の躯を晒す。なんと溜飲の下がることか 警官服 过去追逐一匹野兽而来到雅楠的<strong>警队</strong>的制服 据说他们都沦为野兽的盘中餐，一名幸存者吃掉了野兽 那是雅楠民众津津乐道的市井流言 高压又充满偏见的外地人对雅楠一无所知 于是葬身黑暗之中，这多么令人解气的故事啊</p>
</blockquote>
<p>巧妙的流言往往基于一定程度的现实根据，可见雅楠以外的世界也不太平，或许是雅楠的兽化病患者向外扩散，政府派遣警察治安队前往偏僻的雅楠调查，结果惨遭不幸。</p>
<p>主角与雅楠市街闭门不出的居民们交谈，会遭到本地人对外来者的敌视。这种彼此不了解所产生的偏见是互相的，通过警官制服的物品描述，能感受到大城市的“贵客”对雅楠人也抱有鄙夷和蛮横的态度。《只狼》中也存在类似的冲突，内府的孤影众忍者袭击平田宅邸时，对话提到他们把枭看作是乡下的忍者。</p>
<p><a href="https://image.gcores.com/cc733471-90b2-4bdd-85c5-cb55b82a2205.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cc733471-90b2-4bdd-85c5-cb55b82a2205.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="罗伯特·皮尔爵士（Sir Robert Peel）1788-1850"></a></p>
<p>罗伯特·皮尔爵士（Sir Robert Peel）1788-1850</p>
<p>英国的现代警察体系恰好创立于维多利亚时代的前夕，1829年英国内政部长<strong>罗伯特·皮尔</strong>提出警察法案，经过议会和英皇的同意批准，现代化的警察出现在英国的街道上。</p>
<p>欧洲的现代医学在十九世纪也得到快速发展，<strong>微生物学</strong>的研究让人类对恐怖的传染病有了更深刻的理解，输血的治疗手段在此时变得更科学。</p>
<p>这些韵笔向我们揭示了雅楠之外的世界，似乎正在沿着人类历史前进。但是在雅楠看不到任何文明开化的迹象，这个远离现代社会的偏僻古城“停滞”在古旧的回忆中，没有政府，没有警察和军队，落后的医学知识像中世纪一样还掌握在教会手中，更讽刺的是这里的教会诞生于代表科学知识的学院。</p>
<p>雅楠已沦为愚昧持续发酵的温床，最终毁灭雅楠的不是疫病，不是上位者，而是雅楠人自己。</p>
<h1 id="雅楠的内部矛盾"><a href="#雅楠的内部矛盾" class="headerlink" title="雅楠的内部矛盾"></a>雅楠的内部矛盾</h1><p>《血源诅咒》中的场景建立在梦境的基础上，时间表现十分模糊，眼前看到的事物并不一定属于严格的现在时，也有可能是过去回忆的重现，让人产生一种与时间脱钩的感觉。所以我更倾向于把场景中发生的所有事件放在一起，视作静态的历史群像，不去追究具体的时间顺序。</p>
<p>雅楠的问题究竟出在哪里？从雅楠人的抱怨中可见端倪。在雅楠市街接近大桥的某个建筑中，玩家能找到一段匿名留言，上面是这么写的：</p>
<blockquote>
<p>獣狩りの夜、聖堂街への大橋は封鎖された 医療教会は俺たちを見捨てるつもりだ あの月の夜、旧市街を焼き棄てたように 猎兽之夜，通向圣堂街的大桥已被封锁 医疗教会打算抛弃我们了 就像那个皎月之夜烧弃旧市街那样</p>
</blockquote>
<p>这段留言我认为是《血源诅咒》中最优秀的文本，在<strong>引导</strong>和<strong>叙事</strong>上都很有份量。</p>
<p>对初到雅楠市街的新玩家来说，此信息提到两个新的地区，“安全”的<strong>圣堂街</strong>和遭遇灾祸的<strong>旧市街</strong>勾起了好奇心。从这个建筑出来后就是被封锁的大桥，玩家走到桥的尽头迎战圣职者野兽后发现无法继续前行，原路折返寻找其他前往圣堂街的方法。</p>
<p>同时在玩家的脑中还会留下一个旧市街的印象，虽然在雅楠市街我们找不到直通旧市街的道路，当穿过圣堂街低处某圣堂的密道，揭开通向旧市街大门的封条时，玩家也许会想起这段留言记载的内容。旧市街、雅楠市街和圣堂街三张地图从低到高在脑海中的位置更加立体。</p>
<p>重返雅楠的大桥时细心的玩家会意识到，面前是无法通行的圣堂街，背后是雅楠市街和发现留言的房间，向桥下望去是旧市街破弃无顶的圣杯教堂，可谓精妙的场景设计。</p>
<p>在叙事上则一针见血指出了雅楠内部的矛盾。这段文本中隐含了三个群体：<strong>雅楠市街居民</strong>、<strong>圣堂街居民</strong>以及<strong>旧市街曾经的居民</strong>。</p>
<p>圣堂街距离大圣堂最近；雅楠市街靠近城市外围，是雅楠的中心；旧市街位于采光差的深谷之中。根据地势高低大致可以推测，三个地区居民的社会等级也是从高到低排列。</p>
<p>留下信息的雅楠市街居民被夹在另外二者之间，他们既羡慕圣堂街的安全，因为通向圣堂街的大桥封锁让他们感到不安，又害怕自己居住的地方变成下一个旧市街，心里清楚旧市街的废弃是医疗教会造成的。</p>
<p>当我们达到圣堂街，很容易理解为什么雅楠市街的居民认为圣堂街更加安全，圣堂街以医疗教会的象征建筑大圣堂为中心，必然是教会最重视的地域。居住在圣堂街的居民也受到教会治安的福利。与这里的居民对话会发现他们没有雅楠市街居民的戾气，感恩于教会的保护。</p>
<p><strong>但我并不认为不同街区的雅楠居民在素质上有什么本质区别，他们的态度决定于自己的既得利益是否被侵犯。</strong>当雅楠市街的街道上挤满了猎兽队，这里的居民才发现形势不对，想起曾经被废弃封锁的旧市街。</p>
<p>除了这段留言，游戏内似乎没有更近一步描写雅楠不同街区的居民对待彼此的态度。但在《血源诅咒》的官网介绍中找到了一段信息。</p>
<p><a href="https://image.gcores.com/94acfd8d-3c17-4044-9e7c-46980b40240d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/94acfd8d-3c17-4044-9e7c-46980b40240d.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="“雅楠的居民忘掉了那件事情，或是想要忘却，但从谷底时常传来的野兽低吼提醒着他们曾犯下的罪过。”"></a></p>
<p>“雅楠的居民忘掉了那件事情，或是想要忘却，但从谷底时常传来的野兽低吼提醒着他们曾犯下的罪过。”</p>
<p>面对旧市街的烧弃，雅楠的其他居民抱有介于遗忘和装作遗忘之间的暧昧态度。虽然用寥寥几句点到为止，我们大可想象一下当时旧市街出现灾祸时，其他街区的居民都做了什么。</p>
<h1 id="逃避事故责任的医疗教会"><a href="#逃避事故责任的医疗教会" class="headerlink" title="逃避事故责任的医疗教会"></a>逃避事故责任的医疗教会</h1><p>医疗教会在酿成雅楠旧市街悲剧后还能继续在雅楠施行血液治疗，我认为有两方面因素的影响。</p>
<p>一方面是雅楠居民的漠视，体现了现实中人对疾病的认知。</p>
<p><a href="https://image.gcores.com/5a0ffbbf-07c7-447a-83c5-62f3b1ca41dc.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5a0ffbbf-07c7-447a-83c5-62f3b1ca41dc.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="猎人狩猎者艾琳的面具"></a></p>
<p>猎人狩猎者艾琳的面具</p>
<p>《血源诅咒》中的猎人穿着各具特色的服饰，<strong>猎人狩猎者艾琳（日：狩人狩りアイリーン）</strong>的面具来自于欧洲中世纪的瘟疫医生，鸟嘴面具中存放着香料。</p>
<p><a href="https://image.gcores.com/7bfdd5bd-b1d7-40e5-8516-f684b85eb7e2.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7bfdd5bd-b1d7-40e5-8516-f684b85eb7e2.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="瘟疫医生"></a></p>
<p>瘟疫医生</p>
<p>瘟疫医生出行时会携带一根手杖，代替双手接触病人和尸体。这种手杖也会用于抽打病人，因为当时的人们认为疾病是上天降罪，受到鞭挞可以得到救赎。</p>
<p><a href="https://image.gcores.com/c94e7e7e-94d5-4a13-b1ac-f7509f35177d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c94e7e7e-94d5-4a13-b1ac-f7509f35177d.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="变形手杖"></a></p>
<p>变形手杖</p>
<p>把疾病看作是罪业是古人的错误归因。所以施行血液治疗引发兽化病蔓延时，民众很大概率不会把两者直接联系在一起，而是更倾向于身怀罪恶和不洁的人才会身患疫病。</p>
<p>另一方面是医疗教会的血液治疗确实具有一定程度的效果，接受血液治疗的人获得了实际的好处，人们更在乎眼前可以触摸到的利益。</p>
<p>血液治疗的实效，我们可以从雅楠市街一个外乡人NPC的对话中得知：</p>
<blockquote>
<p>これは不治の病、一縷の望みでこの街を訪ね 怪しげな血に頼ってでも、今まで生き長らえたのです もう、十分ですよ 身患不治之症，抱着一丝希望来到这个城镇 就算是依靠可疑的血液，一直活到了现在 已经很满足了</p>
</blockquote>
<p>这个外乡人的情况与主角类似，身患了不知名的绝症来到雅楠寻医，接受血液治疗后有效延长了寿命。即便这种收益是短暂的，隐藏着难以预料的风险，对愚昧无知的群众来说依然极具诱惑力和说服力。</p>
<p>把这两方面的因素结合在一起，很自然可以得出大致的结论：人们不在乎兽化病的起因，认为变成野兽的人一定是自身有问题，人群内部产生分裂和隔阂。医疗教会施行的血液治疗确实可以治疗其他疾病，于是在雅楠居民之间口口相传。</p>
<p>医疗教会在政权和教权上统治雅楠是顺水推舟的事情。</p>
<p>血液治疗是通过什么契机推广的呢？游戏中提供了一条线索，正是这场摧毁了雅楠旧市街的灾难，当时旧市街流行一种叫“灰血病”的疾病。</p>
<h1 id="白色药丸和旧市街的灰血病"><a href="#白色药丸和旧市街的灰血病" class="headerlink" title="白色药丸和旧市街的灰血病"></a>白色药丸和旧市街的灰血病</h1><p>解毒药“白色药丸”的物品描述中记载了雅楠旧市街被废弃的具体原因。</p>
<p><a href="https://image.gcores.com/3fbe4d53-4d08-42e4-ad1b-b01720967f19.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3fbe4d53-4d08-42e4-ad1b-b01720967f19.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="白色药丸"></a></p>
<p>白色药丸</p>
<blockquote>
<p>白い丸薬 毒を治療する小さな丸薬 かつて旧市街を蝕んだ奇怪な病、灰血病の治療薬 もっとも、その効果はごく一時的なものにすぎず 灰血病は、後の悲劇、獣の病蔓延の引き金になってしまった 白色药丸 用于解毒的小药丸 曾经侵蚀了旧市街的奇怪疾病，灰血病的治疗药物 然而，这种药物只有短暂的效果 灰血病不幸成为了后来的悲剧，兽化病蔓延的诱因</p>
</blockquote>
<p>雅楠的旧市街曾经流行过一种叫做“<strong>灰血病</strong>”的奇怪疾病，人们服用白色的解毒药丸试图治疗灰血病，然而这种解毒药只能短暂的效果，无法真正治愈灰血病。</p>
<p>灰血病与兽化病的关系描述得很模糊，以我个人的理解，灰血病应该与血液治疗引发的兽化病无关，当然也不能排除医疗教会的阴谋，不过没有足够的线索就不继续猜测了。医疗教会趁着这次病灾的机遇在旧市街开始大规模施行血液治疗，但血液治疗却引发了更严重的兽化病蔓延。医疗教会无法控制疫情开始焚烧旧市街，把兽化的病患灭口处理。</p>
<p>灰血病是《血源诅咒》原创的疾病名称，虽然游戏中提供的信息很少，依然可以找到其灵感来源和现实原型。</p>
<p>宫崎英高在一次访谈中透露过灰血病名字的灵感来源于游戏中血的颜色。血液是《血源诅咒》的主题之一，血迹在场景中无处不在，猎人和野兽搏杀时伴随着夸张的喷血。</p>
<p><a href="https://image.gcores.com/250450c4-a964-48a4-a3ca-180b38a39638.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/250450c4-a964-48a4-a3ca-180b38a39638.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="满身血迹的猎人"></a></p>
<p>满身血迹的猎人</p>
<p>血液的表现决定了游戏视觉的基调。创作者将血色调得偏灰，就算是刚从活体中喷出的鲜血也显得十分黯淡，这样的调整的目的有两个：</p>
<ul>
<li>考虑到有的玩家会有恐血的状况，避免画面太过血腥。</li>
<li>黯淡的血液更符合游戏的世界观设定，这与“苍白之血”的含义有关。</li>
</ul>
<p>总之，偏灰的血色让创作者产生了灰血病名字的灵感。</p>
<p>根据灰血病的病名和病征，我们可以找到一个现实存在的疾病与之对应，那就是败血症。</p>
<p><strong>败血症（Sepsis）</strong>是指感染引发的全身发炎反应，患者会发烧，呼吸和心率加速，病情严重可能导致器官衰竭和休克。直至今日，败血症依然是死亡率极高的疾病。</p>
<p>在日语中，<strong>灰血（はいけつ）</strong>与<strong>败血（はいけつ）</strong>发音相同，败血症还有一个不再使用的旧名称是<strong>血液中毒（Blood poisoning）</strong>，所以剧情上治疗灰血病的白色药丸在游戏中的实际作用是解毒，旧市街的渴血兽也是个毒属性的BOSS。</p>
<p>败血症通常由细菌、病毒或寄生虫侵入体内感染引发。年长者、儿童和因其他疾病导致免疫力低下的患者是败血症的高发人群。常规的治疗方法是静脉输液、抗生素、透析、血液培养等等。现代医学对这种致命疾病的病症诊断、医疗手段和特殊情况的应对方案，都还处于难以攻克的阶段。</p>
<p>因为病原体感染血液可能会引发败血症，输血感染也是其病因之一，这也许暗示了游戏中灰血病和医疗教会的血液治疗之间的关系。</p>
<p><a href="https://image.gcores.com/614cf6bd-c041-48b3-a27a-4120ef6cb238.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/614cf6bd-c041-48b3-a27a-4120ef6cb238.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="雅楠旧市街"></a></p>
<p>雅楠旧市街</p>
<p>灰血病的名字可能还包含了一个比较牵强的文字典故，灰血和日语中的<strong>烟灰缸（灰皿）</strong>只差一笔，恰巧对应烟雾缭绕的旧市街，而且旧市街位于一个山谷之中。</p>
<h1 id="雅楠的兽化病"><a href="#雅楠的兽化病" class="headerlink" title="雅楠的兽化病"></a>雅楠的兽化病</h1><p>医疗教会借助旧市街的灰血病灾难，确立了自己在雅楠的统治地位。但导致旧市区烧毁废弃的血液治疗并没有被禁止，反而普及到雅楠的其他街区，大部分雅楠居民接受了教会圣血所赐予的临时恩惠。</p>
<p>兽化病参考了著名的黑死病（即鼠疫），猎人噩梦第二个大圣堂场景角落里的老鼠敌人代表鼠疫传播的意象。十四世纪欧洲黑死病横行，数千万人因此丧命；到了十七世纪，伦敦再次爆发淋巴腺鼠疫。</p>
<p><a href="https://image.gcores.com/275e1fd3-c748-44b5-8224-9bf8a1548932.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/275e1fd3-c748-44b5-8224-9bf8a1548932.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="噩梦大圣堂中的老鼠"></a></p>
<p>噩梦大圣堂中的老鼠</p>
<p>但我认为这可能是有意设置的误导。前文提到雅楠的很多特征都与维多利亚时代相悖，还保持着古老落后的观念，当他们面临兽化病的蔓延时，防治手段也都是历史上对待黑死病的古老方法，比如游戏中出现了鸟嘴瘟疫医生的形象，教会和雅楠居民在室内焚烧熏香驱赶兽化患者等等。</p>
<p>这些手段面对兽化病似乎毫无效果，大部分我们接触到的雅楠人最后都失去了理智。除了上位者的影响以外，另外一种理解是，尽管游戏中营造出黑死病的气氛，但兽化病对应的并不是黑死病。那么兽化病真正的原型是什么？我们来逐一分析这个疾病的特征。</p>
<p>先说结论，答案是<strong>梅毒</strong>。</p>
<h1 id="血源性疾病"><a href="#血源性疾病" class="headerlink" title="血源性疾病"></a>血源性疾病</h1><p>《血源诅咒》的正式标题是“<strong>Bloodborne</strong>”，出自“<strong>血源性疾病（Bloodborne diseases）</strong>”。</p>
<p><a href="https://image.gcores.com/610562db-7f27-438e-a972-0cfd9cbe67e1.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/610562db-7f27-438e-a972-0cfd9cbe67e1.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="血源诅咒标题"></a></p>
<p>血源诅咒标题</p>
<p>血源性疾病是指进入血液和体液的微生物引发的疾病，著名的血源性疾病有：</p>
<ul>
<li>疟疾（Malaria）</li>
<li>梅毒（Syphilis）</li>
<li>乙型肝炎（HBV）</li>
<li>丙型肝炎（HCV）</li>
<li>人类免疫缺陷病毒（HIV）</li>
</ul>
<p>梅毒的病原体是<strong>苍白螺旋体（Treponema pallidum）</strong>，拉丁语“pallidum”即英语中的“pale”。关于名字的由来，一种解释是苍白螺旋体在显微镜下呈现浅蓝色，另一种解释是这种细菌不易染色观察。</p>
<p><a href="https://image.gcores.com/59097db4-3476-442a-bfe5-de771e530e2d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/59097db4-3476-442a-bfe5-de771e530e2d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苍白螺旋体"></a></p>
<p>苍白螺旋体</p>
<p>玩家在游戏中寻找的<strong>苍白之血（日：青ざめた血；英：Paleblood）</strong>，暗指了被梅毒感染的血液（pale+blood）。当然，苍白之血还有其他的含义，将来的专题文章会详细分析。</p>
<p>梅毒会通过<strong>血液</strong>和<strong>体液</strong>传播，大部分常见的感染方式也都在《血源诅咒》中出现：</p>
<p><strong>输血</strong>：血液治疗是雅楠的特色之一，医疗教会为雅楠居民和前来寻医的外乡人输入有问题的血液，导致兽化病的爆发。</p>
<p>1948年，日本东大附属病院发生了一起输血感染梅毒的医疗事故。当时主要的输血手段是人体之间进行直接输血，一名接受输血的女性患者因此感染了梅毒。</p>
<p>此后日本开始建立血液银行，将采集的血液检查后保存，再输送给需要血液的患者，间接输血大幅度降低了输血感染的风险。</p>
<p><strong>伤口</strong>：兽化病是雅楠的特色之二，雅楠的猎人对野兽进行猎杀时伴随着夸张的鲜血喷溅，如果自己也有皮外伤，很可能受到血源性疾病的感染。医疗教会主导的血液治疗和猎杀病患相互作用，恶性循环使感染“梅毒”的人数不断上升。</p>
<p><strong>性行为</strong>：居住在雅楠圣堂街区的NPC<strong>妓女阿莉安娜</strong>，代表了性行为的传染途径。妓女可以在雅楠的中心地区生活和营业，暗示雅楠对娼妓行业缺乏管制。</p>
<p><a href="https://image.gcores.com/687439e3-223f-432e-9a47-7d7ad31bf7a6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/687439e3-223f-432e-9a47-7d7ad31bf7a6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="圣堂街妓女阿莉安娜（聖堂街の娼婦、アリアンナ）"></a></p>
<p>圣堂街妓女阿莉安娜（聖堂街の娼婦、アリアンナ）</p>
<p><strong>生育</strong>：《血源诅咒》的另一个重要主题，上位者在人类中寻找合适的代孕目标，而生育是梅毒等血源性疾病主要的传染途径之一。从这个角度来考虑，甚至可以把无形的欧顿看作是血源性疾病的神格化。</p>
<p>另外一个与生育有关的设定是<strong>神父盖斯科因（日：神父ガスコイン）</strong>的女儿，她被送到诊所后会掉落<strong>无形欧顿符文</strong>，暗示来自外乡的盖斯科因在雅楠定居后，可能因为猎人工作而染病，通过生育的方式传染给了两个女儿原生性梅毒。 </p>
<h1 id="梅毒的来源"><a href="#梅毒的来源" class="headerlink" title="梅毒的来源"></a>梅毒的来源</h1><p>引发兽化病的血液来自古老的地底墓穴。从疾病的角度也揭露了一个恐怖的事实，血源性病原体只能寄宿在活体之中，意味着墓穴里必然有活着的东西。</p>
<p>梅毒的来源传说同样耐人寻味。目前有两种主流的说法，一种是认为梅毒很早以前就存在于欧非大陆，但无论是欧非还是亚洲，关于梅毒的最早记录都出现在十五六世纪。</p>
<p>另外一种观点认为，<strong>梅毒是哥伦布从美洲带回欧洲的</strong>。美洲新大陆在被欧洲人征服之前可以视为未被上帝祝福的土地，盘踞着异神。游戏中兽化病来源于上位者的古老血液，医疗教会从古老的墓穴中带出血液，象征人类从美洲把梅毒带回了欧洲。</p>
<p><a href="https://image.gcores.com/9df3ba18-6224-4d2e-8d30-3366fa09bb7d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9df3ba18-6224-4d2e-8d30-3366fa09bb7d.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="星之女儿艾布利艾塔斯（星の娘、エーブリエタース）"></a></p>
<p>星之女儿艾布利艾塔斯（星の娘、エーブリエタース）</p>
<p><strong>星之女儿艾布利艾塔斯</strong>是雅楠圣堂街上层的上位者BOSS。</p>
<ul>
<li>日文：星の娘、エーブリエタース</li>
<li>英文：Ebrietas, Daughter of the Cosmos</li>
</ul>
<p>这个上位者的名字 Ebrietas 来自于一种生活在美洲的蝴蝶，目前已知的大部分亚种都发现于维多利亚时代末期。</p>
<p><a href="https://image.gcores.com/f66a559a-07d1-4853-ad57-2b40747ef6c2.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f66a559a-07d1-4853-ad57-2b40747ef6c2.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Ebrietas anacreon"></a></p>
<p>Ebrietas anacreon</p>
<p>美洲的神秘意象在《血源诅咒》中反复出现了多次，后面讲到其他主题时还会再次提起美洲。</p>
<h1 id="梅毒的病征"><a href="#梅毒的病征" class="headerlink" title="梅毒的病征"></a>梅毒的病征</h1><p>梅毒的症状同样会让人联想到野兽的模样。</p>
<p>梅毒<strong>初期</strong>，患者的局部皮肤产生<strong>下疳</strong>。大概四到十周转为<strong>二期</strong>，四肢出现<strong>红疹和溃疡</strong>，以及其他惊悚的症状。梅毒的中文名字来自于杨梅疮，即形似杨梅的红疹症状。</p>
<p>二期数年后可能会进入<strong>三期</strong>，产生慢性的<strong>梅毒瘤</strong>，持续发炎的肉瘤组织会改变患者的外貌，面部畸形狰狞如同怪兽。</p>
<p>巴黎人类博物馆中三期梅毒患者的头像：</p>
<p><a href="https://image.gcores.com/a73479d5-122e-49a3-9234-6413273bd38e.JPG?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a73479d5-122e-49a3-9234-6413273bd38e.JPG?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="梅毒三期的梅毒瘤"></a></p>
<p>梅毒三期的梅毒瘤</p>
<p>梅毒还可能感染患者的中枢神经，转为<strong>神经性梅毒</strong>。神经性梅毒进入晚期后患者会出现精神失常、癫痫、失智等症状，所以梅毒也常被和疯癫联系在一起。</p>
<p>随着病情不断加重，梅毒还会引发各种致命的并发症。当梅毒螺旋体侵入眼部，可能导致<strong>梅毒性葡萄膜炎</strong>，患者的瞳孔溃散扭曲，玻璃体浑浊。</p>
<p>葡萄膜炎（Uveitis）的瞳孔：</p>
<p><a href="https://image.gcores.com/bb994942-c4ce-454f-96bf-58a3ab4f4386.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/bb994942-c4ce-454f-96bf-58a3ab4f4386.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="葡萄膜炎"></a></p>
<p>葡萄膜炎</p>
<p>在《血源诅咒》的CG宣传动画中，有一个兽化病患者眼部的特写，瞳孔溃散的状态和葡萄膜炎类似。</p>
<p><a href="https://image.gcores.com/f908ae9f-6e99-474c-84ca-e3cdb0081063.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f908ae9f-6e99-474c-84ca-e3cdb0081063.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="兽化病患者的瞳孔"></a></p>
<p>兽化病患者的瞳孔</p>
<p>游戏中进入DLC内容猎人噩梦地图的关键道具“<strong>醉血猎人的眼眸</strong>”也是一个瞳孔溃散的眼球，根据文本描述，那些迷失的猎人大多数都感染了兽化病。</p>
<p><a href="https://image.gcores.com/51f3682d-7af4-4742-8790-2a356c144847.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/51f3682d-7af4-4742-8790-2a356c144847.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="醉血猎人的眼眸"></a></p>
<p>醉血猎人的眼眸</p>
<blockquote>
<p>血に酔った狩人の瞳 血に酔った狩人の瞳。瞳孔が崩れ、蕩けており それは獣の病の特徴でもある 血に酔った狩人は、悪夢に囚われるという 悪夢の中を永遠に彷徨い、獣を狩り続ける ただ狩人であったが故に 醉血猎人的眼眸 沉醉于鲜血的猎人的眼眸。瞳孔溃散浑浊 也是兽化病的特征 据说沉醉于血液的猎人被囚禁在噩梦中 永远彷徨于噩梦之中，无止尽地猎杀野兽 只因（他们）曾是猎人</p>
</blockquote>
<p>仔细观察会发现，挂在猎人噩梦天空中的其实也是一个巨大夸张化的溃散瞳孔，也许是在比喻这个可怕的噩梦回忆是映在迷失猎人眼底的场景重现吧。</p>
<p><a href="https://image.gcores.com/09730beb-517d-45e5-9f2b-e504b4aeb139.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/09730beb-517d-45e5-9f2b-e504b4aeb139.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="猎人噩梦"></a></p>
<p>猎人噩梦</p>
<h1 id="疾病的污名化"><a href="#疾病的污名化" class="headerlink" title="疾病的污名化"></a>疾病的污名化</h1><p>梅毒被视为恶毒的疾病，除了病症本身的摧残以外，还来自于社会的歧视和恐惧。性行为和生育途径进行传染的疾病，不禁让人们去猜疑患者和其家属的品行。</p>
<p><a href="https://image.gcores.com/281b9455-770c-42fe-b63f-19f48e4aa52a.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/281b9455-770c-42fe-b63f-19f48e4aa52a.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="守护雅楠市街大桥的圣职者野兽"></a></p>
<p>守护雅楠市街大桥的圣职者野兽</p>
<p>兽化病在视觉上借鉴了流行的<strong>狼人（Werewolf）</strong>元素，猎杀之夜对应月圆之夜，水银子弹对应克制狼人的银子弹，医疗教会猎人讨伐野兽，而很多版本的狼人也惧怕教会的神圣力量。</p>
<p><a href="https://image.gcores.com/6435679d-b944-447b-bb10-c8a57056f664.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6435679d-b944-447b-bb10-c8a57056f664.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="1512年德国的狼人版画"></a></p>
<p>1512年德国的狼人版画</p>
<p>梅毒和狼人都伴随着<strong>猎巫</strong>的性质。欧洲的狼人文化有一个来源是类似于猎巫的罪行，特别是在法语地区和德语地区。狼在基督教中是邪恶的存在，教会以释放禁忌魔法和盗墓等罪名剥夺罪人的全部财产流放荒野，这些人被称为“狼”，遭受其他人的排挤。走投无路的受刑者时常出没于村庄抢夺食物等生活用品，进一步加剧了狼人的妖魔化。</p>
<p><a href="https://image.gcores.com/39474a36-a449-430b-a125-c0c95ef19a1b.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/39474a36-a449-430b-a125-c0c95ef19a1b.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="猎人裘拉（日：古狩人デュラ）"></a></p>
<p>猎人裘拉（日：古狩人デュラ）</p>
<p>当疾病和人性同时作用于兽化病病患，难以判断是人变成了野兽，还是被视为野兽。踏入旧市街时，守护这里的<strong>猎人裘拉（日：古狩人デュラ）</strong>会警告玩家禁止在此狩猎，他坚信旧市街的居民还是人，没有变成野兽。</p>
<blockquote>
<p>貴公は獣など狩っていない。あれは…やはり人だよ 貴公もいつか思い知る… …さあ、もう行きたまえ 你所猎杀的并不是野兽，其实还是人 你也迟早会明白的 那么，离开这里吧</p>
</blockquote>
<p>现代医学发展之前，大部分人会认为疾病是上天的惩罚，病人是不被上帝保佑的恶人。这同样适用于雅楠的居民，当变成野兽的人被认为有罪，即便病灾袭卷了旧市街，也没有引起其他街区的居民警示和同情。</p>
<h1 id="历史上的“兽化病”患者"><a href="#历史上的“兽化病”患者" class="headerlink" title="历史上的“兽化病”患者"></a>历史上的“兽化病”患者</h1><p>梅毒是个让人头疼的流行病，历史上不少名人被怀疑有梅毒病史，其中一些可能只是流言，但现在已无从考证。</p>
<p>法国作家古斯塔夫·福楼拜年轻时染上了梅毒，58岁去世可能是梅毒并发症致死。福楼拜的学生居伊·德·莫泊桑在事业成功后也身患梅毒和抑郁症，在生命末期并发了精神病症被巴黎的精神病院收容，次年自杀。</p>
<p>德国哲学家弗里德里希·尼采45岁开始精神状态变得不稳定，有人认为他的疯狂与其哲学思想有关，另外一些人则认为这是梅毒等疾病导致的。哲学界疑似与梅毒有关的还有一生没有娶妻生子的叔本华。</p>
<p>《血源诅咒》中的上位者和宇宙恐怖，参考了霍华德·菲利普斯·洛夫克拉夫特的克苏鲁神话。</p>
<p><a href="https://image.gcores.com/2394bc4d-5bcf-4806-a27d-e324479d2ab9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2394bc4d-5bcf-4806-a27d-e324479d2ab9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="霍华德·菲利普斯·洛夫克拉夫特"></a></p>
<p>霍华德·菲利普斯·洛夫克拉夫特</p>
<p>洛夫克拉夫特的童年并不幸福，他的父亲精神失常，进入医院直到过世。洛夫克拉夫特父亲的死因至今还是个谜团，普遍认为他患有麻痹性痴呆，或是梅毒致死，洛夫克拉夫特的母亲曾使用过疑似与梅毒有关的药物。</p>
<p>著名音乐家贝多芬，全名是<strong>路德维希·范·贝多芬</strong>。贝多芬1827年去世，正是英国进入维多利亚时代的前夕。死因不明，推测可能是肝硬化或者梅毒，后世对他的毛发进行检测，也有可能是铅中毒害死了他。</p>
<p><a href="https://image.gcores.com/f4d9b56d-e7a5-4c6f-87d4-d21f8e33ef54.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f4d9b56d-e7a5-4c6f-87d4-d21f8e33ef54.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="路德维希·范·贝多芬"></a></p>
<p>路德维希·范·贝多芬</p>
<p>1801年贝多芬创作了“<strong>升c小调第十四钢琴鸣奏曲</strong>”。音乐评论家路德维希·莱尔斯塔勃在贝多芬去世后为这首曲子撰写评论，形容第一乐章的气氛像月光下荡漾的小舟，因此产生一个更广为人知的曲名：“<strong>月光奏鸣曲（Moonlight Sonata）</strong>”。</p>
<p>说到这里有人应该已经猜到贝多芬对应了《血源诅咒》中的哪位角色吧。在搜索资料时发现，早在老猎人资料片公布之前，就已经有玩家推测医疗教会猎人路德维希将会是月光大剑的持有者。</p>
<p><a href="https://image.gcores.com/f0fe5b16-ae5d-4297-9414-3621ab490478.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f0fe5b16-ae5d-4297-9414-3621ab490478.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="圣剑路德维希（聖剣のルドウイーク）"></a></p>
<p>圣剑路德维希（聖剣のルドウイーク）</p>
<p>逐渐恶化的耳疾让重病缠身的贝多芬失去了音乐家最重要的听觉，不禁让人联想到医疗教会首席猎人圣剑路德维希，自身沦为丑陋的怪兽，战斗时依然不忘保持教会猎人的尊严和优雅。</p>
<p><a href="https://image.gcores.com/f84927ef-40aa-4339-825a-b8bcad186ac4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f84927ef-40aa-4339-825a-b8bcad186ac4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="宫崎英高的黑暗温暖"></a></p>
<p>宫崎英高的黑暗温暖</p>
<p>创作悲壮的英雄圣剑路德维希纪念这位二百年前的乐圣，可能是宫崎英高独特的“黑暗人文关怀”吧。</p>
<h1 id="旧时代的梅毒治疗方法"><a href="#旧时代的梅毒治疗方法" class="headerlink" title="旧时代的梅毒治疗方法"></a>旧时代的梅毒治疗方法</h1><p>在现代医学发展之前存在很多离谱的梅毒治疗手段，我们能在《血源诅咒》中找到这些荒谬手段的影子。</p>
<p><strong>放血治疗</strong>：不仅限于梅毒，放血也是欧洲中世纪以来通用的医疗手段，当时的医生对待许多症状都会考虑先放放血。《血源诅咒》中根据放血疗法设计了医疗教会的狩猎武器<strong>放血锤</strong>。</p>
<p><a href="https://image.gcores.com/1e3005fb-7a0f-4d12-87e8-64fbae01e56d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1e3005fb-7a0f-4d12-87e8-64fbae01e56d.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="放血锤"></a></p>
<p>放血锤</p>
<blockquote>
<p>瀉血の槌 医療教会の刺客、狩人ブラドーの狂った狩武器 はらわたの、心の底に溜まった血を吸い おぞましい本性を露わにする それはまた、悪い血を外に出す唯一の方法だ 地下牢に籠ったブラドーは、そう信じ続けていた 放血锤 医疗教会的刺客，猎人布拉多的发狂狩猎武器 吸取腔内淤积在心底的血液 暴露了其恐怖的本性 那是将恶劣血液排除体外的唯一方法 囚禁于地下牢的布拉多一直坚信着</p>
</blockquote>
<p><strong>有毒金属治疗</strong>：梅毒在当时最为主流的治疗方法是使用有毒金属，比如<strong>铅</strong>和<strong>水银</strong>。</p>
<p>游戏中的消耗道具<strong>铅之秘药</strong>对应了铅液治疗。</p>
<blockquote>
<p>鉛の秘薬 重苦しくドロリとした飲み薬 一時的に比重を高め、攻撃を弾きやすくする効果があるが 動きは鈍り、また防御力も変わらないため、使いどころが難しい 製法が全く知られない謎めいた薬であるが 一説には、悪夢的な絶望の中でのみ、これが生まれるという 铅之秘药 浓厚粘稠的服用药 临时提高（自身的）比重，有使（遭受的）攻击容易弹开的效果 行动变得迟钝，并且防御力也不会变化，难以恰当地使用 制作方法完全无法得知，充满谜团的药物 有种说法认为这种药物只会产生于噩梦般的绝望之中</p>
</blockquote>
<p>虽然铅之秘药的物品描述中没有说明这种药的研制者是谁，但根据物品图标上的线索，铅之秘药的瓶盖和医疗教会发明的蓝色秘药极为相似，都附有象征着噩梦的纹理，说明二者很可能都出自医疗教会之手。</p>
<p><a href="https://image.gcores.com/43ed4324-4f35-49d8-9d66-6fe2d760b770.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/43ed4324-4f35-49d8-9d66-6fe2d760b770.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="铅之秘药和蓝色秘药"></a></p>
<p>铅之秘药和蓝色秘药</p>
<p>通过野兽拥抱符文可知，医疗教会成立之前做过很多抑制兽化病的实验均以失败告终，也许这些药物都是利用当时获得的知识研制而成的。</p>
<p><a href="https://image.gcores.com/b9c71f65-b778-45bb-913f-fcb69126eaf7.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b9c71f65-b778-45bb-913f-fcb69126eaf7.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="野兽拥抱"></a></p>
<p>野兽拥抱</p>
<blockquote>
<p>獣の抱擁 <strong>獣の病を制御する、そのために繰り返された実験</strong>の末 優しげな「抱擁」は見出された <strong>試み自体は失敗し</strong>、今や「抱擁」は厳重な禁字の１つであるが その知見は確かに、医療教会の礎になっている この契約にある者は、おぞましい獣の姿となり 一時的獣化の効果も高まる だがその本性は、獣性の武器でこそ現れるだろう 野兽拥抱 <strong>为了抑制兽化病而反复试验</strong>之后 发现了柔和的“拥抱”文字 虽然<strong>试验本身失败</strong>，现在“拥抱”是严禁的文字之一 这些知识却成为了医疗教会的基础 缔结此契约者，会化身成野兽的形态 提高临时的兽化效果 其本性，只有在使用兽性的武器时才会展现吧</p>
</blockquote>
<p><strong>水银疗法</strong>是利用水银熏蒸或涂抹身体，甚至有人考虑过静脉注射水银，然而我们现在知道这样做会造成水银中毒，而且对治疗梅毒没什么实际效果。</p>
<p>水银克制梅毒的设定在《血源诅咒》中表现为一个非常重要的道具，<strong>水银子弹</strong>。猎人狩猎时将自己的血混入水银子弹，这样做对野兽有特殊的效果，水银子弹也是下一篇文章的引子。</p>
<p><a href="https://image.gcores.com/19af1167-085d-48bf-9f66-3e4c8eae9999.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/19af1167-085d-48bf-9f66-3e4c8eae9999.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="混着血液的水银子弹"></a></p>
<p>混着血液的水银子弹</p>
<blockquote>
<p>水銀弾 獣狩りの銃で使用される特別な弾丸 <strong>通常の弾丸では、獣に対する効果は期待できないため</strong> 触媒となる水銀に狩人自身の血を混ぜ、これを弾丸としたもの その威力は血の性質に依存する部分が大きい 水银子弹 猎兽火枪所使用的特殊子弹 <strong>因为普通的子弹对野兽的效果不太理想</strong> 水银作为触媒混入猎人自身的血液，以此制成子弹 其威力与血质有密切的关系</p>
</blockquote>
<p>维多利亚时代结束，二十世纪人类发现真正可以治疗梅毒的<strong>青霉素</strong>，挽救了无数人的生命，这些荒谬的治疗的手段也逐渐淡出历史舞台。</p>
<h1 id="现实版“医疗教会”的血之研究：塔斯基吉梅毒实验"><a href="#现实版“医疗教会”的血之研究：塔斯基吉梅毒实验" class="headerlink" title="现实版“医疗教会”的血之研究：塔斯基吉梅毒实验"></a>现实版“医疗教会”的血之研究：塔斯基吉梅毒实验</h1><p>血液的研究始于拜伦维斯学院的课堂和实验室，然而无数次的尝试都没有得到令人满意的结果。学院内反对血液研究的声音开始显现，一部分学生带着半成的成果离开了学院，创立医疗教会继续研究。研究者在追求真理的过程中渐渐丧失良知，将雅楠的平民都当成了实验品。</p>
<p>艺术源于生活，现实版“医疗教会”有过之而无不及。</p>
<p>1932年，<strong>美国公共卫生局</strong>的性病部门与美国阿拉巴马州的<strong>塔斯基吉大学</strong>合作开启了研究梅毒的医学实验。研究者在阿拉巴马州当地的农民中找到600名非洲裔男性受验者，其中399名身患梅毒，201名是身体健康的对照组。参与者被承诺免费医疗等福利，却不知道实验的真实目的，研究者向参与者解释他们得病的原因是体内“<strong>恶劣的血液（Bad blood）</strong>”。</p>
<p>实验早期阶段梅毒还属于无法治愈的绝症，这个实验暂时没有暴露邪恶的本质。</p>
<p><a href="https://image.gcores.com/a3a75c16-fb3c-4d17-8d6b-9069048bd000.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a3a75c16-fb3c-4d17-8d6b-9069048bd000.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="塔斯基吉梅毒实验"></a></p>
<p>塔斯基吉梅毒实验</p>
<p>问题发生在1943年，二十世纪最伟大的发明之一青霉素出现后不久，人们发现青霉素是治疗梅毒的有效药物，但塔斯基吉梅毒实验的研究者为了保证梅毒观察实验能够继续进行，获得理想的实验数据，并没有对患者施以有效的青霉素治疗，任凭梅毒浸蚀他们的身体。</p>
<p>1972年该实验被揭发并终止。当初募集的600名参与者，此时仅剩下74名存活，其中29名患者死于梅毒，100名患者死于梅毒的并发症，40名患者的妻子被梅毒感染，19名患者的子女被梅毒感染。直到二十世纪即将结束的1997年，美国政府才正式对受害者公开道歉赔偿。</p>
<p><a href="https://image.gcores.com/688e0864-91ef-4f75-8a1c-b970fd9505b4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/688e0864-91ef-4f75-8a1c-b970fd9505b4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="1997年，美国总统克林顿与94岁的塔斯基吉梅毒实验受害者合影"></a></p>
<p>1997年，美国总统克林顿与94岁的塔斯基吉梅毒实验受害者合影</p>
<p>可见现实中的人，远比故事里更坏更蠢。</p>
<h1 id="灾难过后"><a href="#灾难过后" class="headerlink" title="灾难过后"></a>灾难过后</h1><p>无知的雅楠人酿成了灭城悲剧，但我不认为创作者是在全盘否定人类的愚昧。在宫崎英高不同的作品中都可以感受到“世界的延续”这一共同主题。历史前进必然伴随着愚昧，当人不再愚昧，意味着认知的停滞，历史不再产生一轮又一轮有意义的上升螺旋。</p>
<p><a href="https://image.gcores.com/1bcf21df-3dd1-4053-8cc2-863135c0404f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1bcf21df-3dd1-4053-8cc2-863135c0404f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="血之遗志和启蒙"></a></p>
<p>血之遗志和启蒙</p>
<p>《血源诅咒》中有两种资源：<strong>血之遗志</strong>和<strong>启蒙</strong>。血之遗志追忆过去，启蒙望向未来，二者正是医疗教会与拜伦维斯学院的分歧。</p>
<p>启蒙在中文版中被翻译成灵视或洞察，对应克苏鲁神话的理智。但我认为日文中的启蒙更加恰当，启蒙即启迪蒙昧之意，只不过能够启蒙人类的不是上位者或者其他存在，而是人类自己。</p>
<p>《血源诅咒》用夸张的手法描绘了人对未知的探索，医疗教会专注研究血液的奥秘，教会的两个上位会派，一个将自己囚禁在噩梦中，另一个沉迷于星辰的呼唤。</p>
<ul>
<li>血液象征生命，生命是怎么起源的？</li>
<li>噩梦诞于意识，人的意识如何产生？</li>
<li>星辰代表宇宙，浩瀚宇宙存在什么？</li>
</ul>
<p>面对这些问题，我们依然无知，现实中的人类并不比雅楠人更加高明，后人不断嘲笑前人的愚昧，正说明历史没有停滞。</p>
<p>罗德兰的时间在黑暗中再次流淌，雅楠结束了猎杀之夜迎来黎明，苇名人坦然面对终将一死的命运，宫崎英高创造的每个世界都拥有向前迈进的未来。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>日文维基百科</p>
<p><a href="https://www.jp.playstation.com/scej/title/bloodborne/" target="_blank" rel="noopener">Bloodborne ブラッドボーン | プレイステーション® オフィシャルサイト</a></p>
<p><a href="https://www.amazon.co.jp/dp/4048657984/ref=sr_1_2?ie=UTF8&keywords=bloodborne&language=ja_JP&qid=1580673006&sr=8-2" target="_blank" rel="noopener">Bloodborne Official Artworks</a></p>
<p><a href="https://www.bloodborne-wiki.com/2017/10/lore-translation-guide.html" target="_blank" rel="noopener">Lore Translation Guide</a></p>
<p><a href="https://dengekionline.com/elem/000/000/865/865467/" target="_blank" rel="noopener">『Bloodborne（ブラッドボーン）』宮崎英高氏インタビュー 電撃オンライン</a></p>
<p><a href="https://www.niid.go.jp/niid/ja/kansennohanashi/465-syphilis-info.html" target="_blank" rel="noopener">梅毒とは 国立感染症研究所</a></p>
<p><a href="http://www.bccdc.ca/health-info/disease-types/bloodborne-diseases" target="_blank" rel="noopener">Bloodborne Diseases</a></p>
<p><a href="http://kigs.jp/db/history.php?nid=2567&PHPSESSID=8ab6d96e143c47cdec3a2f9f7" target="_blank" rel="noopener">東大付属小石川分院での輸血による梅毒感染事故</a></p>
<p><a href="http://www.nic.funet.fi/pub/sci/bio/life/insecta/lepidoptera/ditrysia/hesperioidea/hesperiidae/pyrginae/ebrietas/index.html" target="_blank" rel="noopener"><em>Ebrietas</em> Godman &amp; Salvin, [1896]</a></p>
<p><a href="http://www.nichigan.or.jp/member/guideline/uveitis_guideline.pdf" target="_blank" rel="noopener">ぶどう膜炎診療ガイドライン</a></p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2261112/" target="_blank" rel="noopener">The Treatment of Syphilis by the Hypodermic Injection of the Salts of Mercury</a></p>
<p><a href="https://www.cdc.gov/tuskegee/timeline.htm" target="_blank" rel="noopener">The Tuskegee Timeline</a></p>
]]></content>
  </entry>
  <entry>
    <title>『忍者噩梦』开场动画</title>
    <url>/%E3%80%8E%E5%BF%8D%E8%80%85%E5%99%A9%E6%A2%A6%E3%80%8F%E5%BC%80%E5%9C%BA%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=5034178&bvid=BV1cs411v7VX&cid=8177042&page=1&as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>【R18】婦長でApple Pie【紳士向け】</title>
    <url>/%E3%80%90R18%E3%80%91%E5%A9%A6%E9%95%B7%E3%81%A7Apple%20Pie%E3%80%90%E7%B4%B3%E5%A3%AB%E5%90%91%E3%81%91%E3%80%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"loop":"yes","screenshot":"yes","hotkey":true,"preload":"metadata","video":{"url":"https://ashjian.github.io/video/%E3%80%90R18%E3%80%91%E5%A9%A6%E9%95%B7%E3%81%A7Apple%20Pie%E3%80%90%E7%B4%B3%E5%A3%AB%E5%90%91%E3%81%91%E3%80%91.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 


]]></content>
  </entry>
  <entry>
    <title>【只狼】从设定集到游戏：人物篇</title>
    <url>/%E3%80%90%E5%8F%AA%E7%8B%BC%E3%80%91%E4%BB%8E%E8%AE%BE%E5%AE%9A%E9%9B%86%E5%88%B0%E6%B8%B8%E6%88%8F%EF%BC%9A%E4%BA%BA%E7%89%A9%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=74179848&bvid=BV1rE41187KU&cid=126898078&page=1as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>【只狼】从设定集到游戏：场景篇</title>
    <url>/%E3%80%90%E5%8F%AA%E7%8B%BC%E3%80%91%E4%BB%8E%E8%AE%BE%E5%AE%9A%E9%9B%86%E5%88%B0%E6%B8%B8%E6%88%8F%EF%BC%9A%E5%9C%BA%E6%99%AF%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=80405737&bvid=BV1NJ411x7Yz&cid=141123370&page=1as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>【只狼】苇名绝景</title>
    <url>/%E3%80%90%E5%8F%AA%E7%8B%BC%E3%80%91%E8%8B%87%E5%90%8D%E7%BB%9D%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=49657710&bvid=BV11b41157nV&cid=86944156&page=1as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>【只狼】超越动作电影的极致华丽打斗 苇名之狼VS巅峰剑圣</title>
    <url>/%E3%80%90%E5%8F%AA%E7%8B%BC%E3%80%91%E8%B6%85%E8%B6%8A%E5%8A%A8%E4%BD%9C%E7%94%B5%E5%BD%B1%E7%9A%84%E6%9E%81%E8%87%B4%E5%8D%8E%E4%B8%BD%E6%89%93%E6%96%97%20%E8%8B%87%E5%90%8D%E4%B9%8B%E7%8B%BCVS%E5%B7%85%E5%B3%B0%E5%89%91%E5%9C%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe height=520 width=800 src="//player.bilibili.com/player.html?aid=50526704&bvid=BV1V4411h7f8&cid=88449150&page=1&as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>三分钟看懂Nginx服务器的缓存原理和机制</title>
    <url>/%E4%B8%89%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Nginx服务器的缓存原理，是在学习过程中比较重要的一个知识点，学习通透之后，对于自己的能力会有不小的提升——而且提升不只限于nginx一方面，技术理论一通百通，对于理解其他内容也会有很大帮助。</p>
<p>Web缓存主要思想</p>
<p>Web缓存技术的基本思想是利用客户访问的时间局部性原理，对客户已经访问过的内容在Nginx服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过Ｎginx服务器再次向后端服务器发出请求，所以能够减少Ｎginx服务器与后端服务器之间的网络流量，减轻网络拥塞，同时还能减小数据传输延迟，提高用户访问速度。同时，当后端服务器宕机时，Nginx服务器上的副本资源还能够回应相关的用户请求，这样能够提高后端服务器的鲁棒性。</p>
<p>Nginx缓存实现原理</p>
<p>基于Proxy Store的缓存机制</p>
<p>01</p>
<p>404错误驱动</p>
<p>当Nginx服务器发现，用户请求数据在服务器本地不存在时，会产生404错误，服务器能够捕捉该错误，进一步转向后端服务器请求相关数据，最后将后端请求到的数据传回客户端，并在服务器本地缓存。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223808.png" alt="img"></p>
<p>02</p>
<p>资源不存在驱动</p>
<p>原理上基本等同于404错误驱动，不同之处在于该方法是通过location块的location if条件判断直接驱动Nginx服务器和后端服务器的通信和Ｗeb缓存，而不对资源不存在产生404错误。</p>
<p>配置文件片段：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223809.png" alt="img"></p>
<p>这两种缓存机制只能缓存200状态下的响应数据，同时不支持动态链接请求。比如:getsource?id=1和getsource?id=2这两个请求，返回的是相同的资源。所以实际上，一般是采用Nginx搭配Squid服务器架构实现方案。</p>
<p>基于memcached的缓存机制</p>
<p>memcached在内存中开辟一块空间，然后建立一个Ｈash表，将缓存数据通过键/值存储在Hash表中进行管理。memcached由服务端和客户端两个核心模块组成，服务端通过计算“键”的Hash值来确定键/值对在服务端所处的位置。当位置确定后，客户端就会向对应的服务端发送一个查询请求，让服务端查找并返回所需数据。</p>
<p>到这里，关于nginx服务器缓存的内容就暂时告一段落了，希望大家在这篇文章里都能有所收获。如果你有更好的想法，欢迎在评论区留言讨论哦~</p>
<blockquote>
<p>作者：LifeIsButA_Span</p>
<p>来源：</p>
<p><a href="http://blog.csdn.net/lifeisbuta_span/article/details/70598586" target="_blank" rel="noopener">http://blog.csdn.net/lifeisbuta_span/article/details/70598586</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>乌龙错误：两个httpd冲突造成的AH00558警告</title>
    <url>/%E4%B9%8C%E9%BE%99%E9%94%99%E8%AF%AF%EF%BC%9A%E4%B8%A4%E4%B8%AAhttpd%E5%86%B2%E7%AA%81%E9%80%A0%E6%88%90%E7%9A%84AH00558%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>BUG<h2 id="乌龙错误：两个httpd冲突造成的AH00558警告"><a href="#乌龙错误：两个httpd冲突造成的AH00558警告" class="headerlink" title="乌龙错误：两个httpd冲突造成的AH00558警告"></a>乌龙错误：两个httpd冲突造成的AH00558警告</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian httpd]#httpd -t<br>AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using 127.0.0.1. Set the &#39;ServerName&#39; directive globally to suppress this message<br>Syntax OK<br></code></pre></td></tr></table></figure>

<p>httpd -t 和 httpd -M时出现错误警告AH00558: httpd: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1. Set the ‘ServerName’ directive globally to suppress this message</p>
<p>而本人的/etc/httpd/conf/httpd.conf中的ServerName是设置的,怎么也想不明白会有警告。本来想着后来才解决的。但发现影响到httpd -M 命令的作用了（明明有些模块已经加载了，但就是显示不出来,比如mod_ssl和mod_deflate）。</p>
<p>脑光一亮，想起来之前手动编译了几次httpd。whereis httpd 查看一下。果然还有一个/user/loal/apache/。将该目录移走，正常了。</p>
]]></content>
      <tags>
        <tag>http</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>事件驱动IO和五种IO模型</title>
    <url>/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8IO%E5%92%8C%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>　　Linux下主要的IO主要分为：阻塞IO(Blocking IO)，非阻塞IO(Non-blocking IO)，同步IO(Sync IO)和异步IO(Async IO)。 同步：调用端会一直等待服务端响应，直到返回结果。 异步：调用端发起调用之后不会立刻返回，不会等待服务端响应。服务端通过通知机制或者回调函数来通知客户端。 阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行。 非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回。</p>
<p>　　同步异步的区别在于：服务端在拷贝数据时是否阻塞调用端线程；阻塞和非阻塞的区别在于：调用端线程在调用function后是否立刻返回。要理解这些I/O，需要先理解一些基本的概念。</p>
<p><strong><em>2\</em></strong>|<strong><em>0**</em></strong>用户态和核心态**</p>
<p>　　Linux系统中分为核心态(Kernel model)和用户态(User model)，CPU会在两个model之间切换。</p>
<ol>
<li><ol>
<li>核心态代码拥有完全的底层资源控制权限，可以执行任何CPU指令，访问任何内存地址，其占有的处理机是不允许被抢占的。内核态的指令包括：启动I/O，内存清零，修改程序状态字，设置时钟，允许/终止中断和停机。内核态的程序崩溃会导致PC停机。</li>
<li>用户态是用户程序能够使用的指令，不能直接访问底层硬件和内存地址。用户态运行的程序必须委托系统调用来访问硬件和内存。用户态的指令包括：控制转移，算数运算，取数指令，访管指令（使用户程序从用户态陷入内核态）。</li>
</ol>
</li>
</ol>
<p><strong><em>2\</em></strong>|<strong><em>1**</em></strong>用户态和核心态的切换**</p>
<p>　　用户态切换到核心态有三种方式：</p>
<p>　　　　a.系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>　　　　b.异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>　　　　c.外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p><strong><em>3\</em></strong>|<strong><em>0**</em></strong>进程切换**</p>
<p>　　为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li><ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
</li>
</ol>
<p><strong><em>4\</em></strong>|<strong><em>0**</em></strong>进程阻塞**</p>
<p>　　正在执行的进程由于一些事情发生，如请求资源失败、等待某种操作完成、新数据尚未达到或者没有新工作做等，由系统自动执行阻塞原语，使进程状态变为阻塞状态。因此，进程阻塞是进程自身的一种主动行为，只有处于运行中的进程才可以将自身转化为阻塞状态。<strong>当进程被阻塞，它是不占用CPU资源的。</strong></p>
<p><strong><em>5\</em></strong>|<strong><em>0**</em></strong>文件描述符(fd, File Descriptor)**</p>
<p>　　FD用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p><strong><em>6\</em></strong>|<strong><em>0**</em></strong>缓存I/O**</p>
<p>　　缓存IO又被称作标准IO，大多数文件系统的默认IO 操作都是缓存IO。在Linux的缓存IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>　　缓存I/O的缺点</p>
<p>　　数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p><strong><em>7\</em></strong>|<strong><em>0**</em></strong>事件驱动模型**</p>
<p>　　事件驱动模型是一种编程范式，也就是编程思想。这种思想会在我们以后经常性的用到，它与传统编程思想最大不同的地方在于他是一种<strong>非线性的模式</strong>。</p>
<p>　　这个有点不好解释，我们来看一个例子。</p>
<p><a href="https://img2020.cnblogs.com/blog/1881426/202007/1881426-20200705161808504-1788907384.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223841.png" alt="img"></a></p>
<p>　　我们用最常见的网页浏览做一个引子，任何的UI编程都是基于事件驱动模型来完成的，当我们的鼠标放在任何一段文字之上，它会根据文字不同而做出对应的不同反应。</p>
<p>并且，我们进入一个网页不仅仅可以用鼠标与网页产生交互，也可以使用键盘与网页产生交互，那么这里就会有很多很多种不同的选择，如果想尝试用传统的编程思想来解决识别用户的操作无疑效率是非常低下的。</p>
<blockquote>
<p>　　传统编程思想解决方案：</p>
<p>　　　　1.死循环来不断的检测是否有鼠标点击，键盘按下，鼠标悬浮等等操作。</p>
<p>　　　　2.通过阻塞的方式来等待用户的一次点击或者键盘按下或者鼠标悬浮的等等操作。</p>
</blockquote>
<p>　　这种解决方案看似十分完美，但实际上是非常不明智的，它的缺点如下：</p>
<blockquote>
<p>　　1.死循环占用大量CPU资源，并且如果需要检测的事件太多势必会引发延迟问题。</p>
<p>　　2.通过阻塞方式只能检测一种操作，并不能同时检测多种操作。</p>
</blockquote>
<p>　　那么到底有什么方案能够完美的解决这些问题呢？我们看看UI编程的事件驱动模型的是怎么解决这些问题的：</p>
<blockquote>
<p>　　1. 有一个事件(消息)队列，包括但不仅是鼠标事件，键盘事件，悬浮事件等等。</p>
<p>　　2. 假设当鼠标按下，便往这个队列中增加一个点击事件(消息)。</p>
<p>　　3. 有一个循环，不断的从队列中取出事件，根据不同的事件调用不同的函数。</p>
<p>　　4. 事件（消息）一般都各自保存各自的处理函数指针，这样每个消息都有独立的处理函数。</p>
</blockquote>
<p>　　事件驱动模型图解：</p>
<p><a href="https://img2020.cnblogs.com/blog/1881426/202007/1881426-20200705161850220-1683490443.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223842" alt="img"></a></p>
<p>　　所以说事件驱动的一大特点就是：</p>
<blockquote>
<p>　　包含一个事件循环并且只有当外部事件发生时才使用回调机制来触发相应的处理。也就是说程序运行的整个流程都是取决于用户触发的各种事件来决定的，开发者并不用关心大体流程，而只是需要做好每一个事件对应的处理方式即可。</p>
</blockquote>
<p><strong><em>8\</em></strong>|<strong><em>0**</em></strong>Linux下的五种I/O模型**</p>
<p>　　Linux下主要有以下五种I/O模型：</p>
<ol>
<li>阻塞I/O（blocking IO）</li>
<li>非阻塞I/O (nonblocking I/O)</li>
<li>I/O 复用 (I/O multiplexing)</li>
<li>信号驱动I/O (signal driven I/O (SIGIO))</li>
<li>异步I/O (asynchronous I/O)</li>
</ol>
<p><strong><em>8\</em></strong>|<strong><em>1**</em></strong>阻塞IO模型**</p>
<p>　　进程会一直阻塞，直到数据拷贝完成 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。数据准备好后，从内核拷贝到用户空间，IO函数返回成功指示。阻塞IO模型图</p>
<p><a href="https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200811234710877-1991634109.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223843.png" alt="img"></a></p>
<p><strong><em>8\</em></strong>|<strong><em>2**</em></strong>非阻塞IO模型**</p>
<p>　　通过进程反复调用IO函数，在数据拷贝过程中，进程是阻塞的。模型图如下所示:</p>
<p><a href="https://user-gold-cdn.xitu.io/2019/2/24/1691ebf25c789918?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223844.png" alt="non-blocking-io"></a></p>
<p><strong><em>8\</em></strong>|<strong><em>3**</em></strong>IO复用模型**</p>
<p>　　主要是select和epoll。一个线程可以对多个IO端口进行监听，当socket有读写事件时分发到具体的线程进行处理。模型如下所示：</p>
<p><a href="https://user-gold-cdn.xitu.io/2019/2/24/1691ebf25c7146fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223845" alt="io-multiplexing"></a></p>
<p><strong>信号驱动IO模型</strong></p>
<p>　　信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p>
<p><a href="https://user-gold-cdn.xitu.io/2019/2/24/1691ec1919c6fa00?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223846" alt="sigio"></a></p>
<p><strong><em>8\</em></strong>|<strong><em>4\</em></strong> <strong>异步IO模型</strong></p>
<p>　　相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。异步过程如下图所示：</p>
<p><a href="https://user-gold-cdn.xitu.io/2019/2/24/1691ec1919b4b16b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223847" alt="aio"></a></p>
<p><strong><em>8\</em></strong>|<strong><em>5**</em></strong>五种IO模型比较**</p>
<p>　　<strong>阻塞IO和非阻塞IO的区别</strong> 调用阻塞IO后进程会一直等待对应的进程完成，而非阻塞IO不会等待对应的进程完成，在kernel还在准备数据的情况下直接返回。 <strong>同步IO和异步IO的区别</strong> 首先看一下POSIX中对这两个IO的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">A synchronous I&#x2F;O operation causes the requesting process to be blocked until that I&#x2F;O operation completes;An asynchronous I&#x2F;O operation does not cause the requesting process to be blocked;<br></code></pre></td></tr></table></figure>

<p>　　<strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。</strong>按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。注意到non-blocking IO会一直轮询(polling)，这个过程是没有阻塞的，但是recvfrom阶段blocking IO,non-blocking IO和IO multiplexing都是阻塞的。 而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p><a href="https://user-gold-cdn.xitu.io/2019/2/24/1691ec1919cbe0ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223848" alt="io-diff"></a></p>
<p><strong><em>9\</em></strong>|<strong><em>0**</em></strong>IO复用之select、poll、epoll简介**</p>
<p>　　epoll是linux所特有，而select是POSIX所规定，一般操作系统均有实现。</p>
<p><strong><em>9\</em></strong>|<strong><em>1**</em></strong>select**</p>
<p>　　select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是：</p>
<ol>
<li><ol>
<li>单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说和系统内存有关，具体数目可以cat /proc/sys/fs/file-max察看。32位默认是1024个，64位默认为2048个</li>
<li>对socket进行扫描时是线性扫描，即采用轮询方法，效率低。当套接字比较多的时候，每次select()都要遍历FD_SETSIZE个socket来完成调度，不管socket是否活跃都遍历一遍。会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是epoll与kqueue做的</li>
<li>需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大</li>
</ol>
</li>
</ol>
<p><strong><em>9\</em></strong>|<strong><em>2**</em></strong>poll**</p>
<p>　　poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd。它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是：</p>
<ol>
<li><ol>
<li>大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。</li>
<li>poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。</li>
</ol>
</li>
</ol>
<p><strong><em>9\</em></strong>|<strong><em>3**</em></strong>epoll**</p>
<p>　　epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一量该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。epoll的优点：</p>
<ol>
<li><ol>
<li>没有最大并发连接的限制。</li>
<li>效率提升，只有活跃可用的FD才会调用callback函数。</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。</li>
</ol>
</li>
</ol>
<p><strong><em>9\</em></strong>|<strong><em>4**</em></strong>select、poll、epoll区别总结**</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">支持一个进程打开连接数</th>
<th align="center">IO效率</th>
<th align="center">消息传递方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">32位机器1024个，64位2048个</td>
<td align="center">IO效率低</td>
<td align="center">内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
</tr>
<tr>
<td align="center">poll</td>
<td align="center">无限制，原因基于链表存储</td>
<td align="center">IO效率低</td>
<td align="center">内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
</tr>
<tr>
<td align="center">epoll</td>
<td align="center">有上限，但很大，2G内存20W左右</td>
<td align="center">只有活跃的socket才调用callback，IO效率高</td>
<td align="center">通过内核与用户空间共享一块内存来实现</td>
</tr>
</tbody></table>
<p><strong><em>10\</em></strong>|<strong><em>0\</em></strong> <strong>扩展：水平触发与边缘触发</strong></p>
<p><a href="https://img2020.cnblogs.com/blog/1881426/202007/1881426-20200705163152511-266868205.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223849.png" alt="img"></a></p>
]]></content>
  </entry>
  <entry>
    <title>从传统东方园林的造园思路，看《只狼》的场景设计</title>
    <url>/%E4%BB%8E%E4%BC%A0%E7%BB%9F%E4%B8%9C%E6%96%B9%E5%9B%AD%E6%9E%97%E7%9A%84%E9%80%A0%E5%9B%AD%E6%80%9D%E8%B7%AF%EF%BC%8C%E7%9C%8B%E3%80%8A%E5%8F%AA%E7%8B%BC%E3%80%8B%E7%9A%84%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于个人收藏，转载：<a href="https://www.gcores.com/articles/118473" target="_blank" rel="noopener">https://www.gcores.com/articles/118473</a><br>恭喜只狼拿到年度游戏了，老贼陪跑多年这次也算实至名归，心疼我秀夫一秒，两个月前分析过一篇只狼的场景设计。这次从另外的角度聊一聊，可能对现在的游戏场景设计有另外一些启发。</p>
<p><strong>本篇6800字，并且有些理论需要一定时间消化，请找一个合适的时间进行阅读。</strong></p>
<h1 id="如画构成"><a href="#如画构成" class="headerlink" title="如画构成"></a><strong>如画构成</strong></h1><p>欧洲造园的如画式风格，被视为受到过中国园林造型的影响，但康德却更愿意将其视为欧洲近代风景绘画的分支，其“如画”的名称，却也恰如其分-人们争论如画造园，到底是该再现普桑画中的风景构图，还是应该模仿洛兰画中的风景构图，继而决定植物选型，应该临摹洛兰画中常见的丛林茂密，还是刻画浦桑画中的单株古木。</p>
<p>——摘自董豫赣《玖章造园》<br><a href="https://image.gcores.com/7a19340d-bdef-4bdb-9bdd-abaee8bffd6f.JPG?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7a19340d-bdef-4bdb-9bdd-abaee8bffd6f.JPG?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《牧羊人洋桥景观》画作"></a><br>《牧羊人洋桥景观》画作</p>
<p><a href="https://image.gcores.com/4d7d8525-068c-4aea-ac43-c474cd8d4ae9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4d7d8525-068c-4aea-ac43-c474cd8d4ae9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="英国斯杜海园林"></a></p>
<p>英国斯杜海园林</p>
<p>前景的大树，中景的石桥，远景的建筑，斯杜海园林都在模仿牧羊人洋桥景观这张画作现代游戏场景的制作流程也大致遵循这一方法，先由2D的原画气氛/效果图决定大概的场景意向，然后细化单体设计建模，在引擎里组合渲染后得到最终的实际画面。</p>
<p><a href="https://image.gcores.com/0b5f8331-3230-4169-9c49-a86d5c1d2b2c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0b5f8331-3230-4169-9c49-a86d5c1d2b2c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="破旧寺庙原画"></a></p>
<p>破旧寺庙原画</p>
<p><a href="https://image.gcores.com/a7d44b6b-4cb5-44fc-befb-3acc2ca6049b.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a7d44b6b-4cb5-44fc-befb-3acc2ca6049b.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="破旧寺庙实机图"></a></p>
<p>破旧寺庙实机图</p>
<p><a href="https://image.gcores.com/026089fe-7734-4f68-b05f-d409bd890dcc.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/026089fe-7734-4f68-b05f-d409bd890dcc.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城主城前台阶原画图"></a></p>
<p>苇名城主城前台阶原画图</p>
<p><a href="https://image.gcores.com/fa0bc3ee-c209-4981-b938-15db06d9adef.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fa0bc3ee-c209-4981-b938-15db06d9adef.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城主城前台阶实机图  只狼的场景原画与实机，FS很多时候实机是要好于2d原画阶段的。"></a></p>
<p>苇名城主城前台阶实机图  只狼的场景原画与实机，FS很多时候实机是要好于2d原画阶段的。</p>
<h1 id="成画而不成景"><a href="#成画而不成景" class="headerlink" title="成画而不成景"></a><strong>成画而不成景</strong></h1><p>我们假设能够想上面那种方式将效果图（原画），平立剖，细节大样，所有还原，将某一个角度的景观设计无限美好，那么可能会出现什么问题呢？ </p>
<p><a href="https://image.gcores.com/2b21d911-7014-4c0f-81a3-8d17788ff435.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2b21d911-7014-4c0f-81a3-8d17788ff435.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苏州博物馆假山"></a></p>
<p>苏州博物馆假山</p>
<p>贝聿铭的苏州博物馆的假山设计:贝先生通过石材本身的颜色深浅和纹理来体现远近（近处的石头有着明显的褶皱），并且用火烧石材的边缘来模拟水墨渲染的笔触，以白墙做画布，极尽去还原中国山水画意向，从正面去观察确实无懈可击，但如果换个角度去看这堆假山却是溃不成军。 </p>
<p><a href="https://image.gcores.com/96da26e1-a99f-4508-81e6-a817741ca49f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/96da26e1-a99f-4508-81e6-a817741ca49f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="假山的另外角度"></a></p>
<p>假山的另外角度</p>
<p>我们移动到另外一个角度去看这堆假山，已经无法成画或者成景，问题在哪儿呢？</p>
<h1 id="眼睛的镜头是连续的"><a href="#眼睛的镜头是连续的" class="headerlink" title="眼睛的镜头是连续的"></a>眼睛<strong>的镜头是连续的</strong></h1><p> 我们看下面这组镜头，都是以屋顶奔跑为主题：</p>
<p><a href="https://image.gcores.com/83168fe6-0f6c-42f8-bce6-be68f2677496.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/83168fe6-0f6c-42f8-bce6-be68f2677496.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="武侠  镜头有明显的切分，每个镜头的景别，运镜的方式都有很大差别"></a></p>
<p>武侠  镜头有明显的切分，每个镜头的景别，运镜的方式都有很大差别</p>
<p><a href="https://image.gcores.com/6ffcf43b-147d-4de5-af4e-dbea5ee9bd73.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/6ffcf43b-147d-4de5-af4e-dbea5ee9bd73.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="邪不压正  长镜头，镜头虽然没有切分，但是镜头与主体的距离一直在产生变化"></a></p>
<p>邪不压正  长镜头，镜头虽然没有切分，但是镜头与主体的距离一直在产生变化</p>
<p><a href="https://image.gcores.com/82030587-e111-42de-b4c4-dfeb9c9dbc2d.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/82030587-e111-42de-b4c4-dfeb9c9dbc2d.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="只狼  一般第三人称游戏的经典视角，固定的摄像机距离与连续运镜。"></a></p>
<p>只狼  一般第三人称游戏的经典视角，固定的摄像机距离与连续运镜。</p>
<p><a href="https://image.gcores.com/899a8d59-5a9a-4fd4-9b12-af48a0cf978a.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/899a8d59-5a9a-4fd4-9b12-af48a0cf978a.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="进击的巨人第一季13集  也是长镜头，仔细对比上面只狼的镜头，有没有感觉很像，摄像机几乎一直在跟随主角周围，看这段的时候代入感超强的有没有，但这种高速运动的镜头也只有CG和动画才能实现。"></a></p>
<p>进击的巨人第一季13集  也是长镜头，仔细对比上面只狼的镜头，有没有感觉很像，摄像机几乎一直在跟随主角周围，看这段的时候代入感超强的有没有，但这种高速运动的镜头也只有CG和动画才能实现。</p>
<p>影视类镜头拥有非常灵活的镜头切换以及应用，但游戏正常游玩的时候不可能做过多的镜头切换，切换过多发生操作和具体范围认知的错位等等各种问题的出现，所以游戏镜头几乎都是固定的。</p>
<p><strong>“镜头固定并且连续，你可以想象第三人称其实就是有个人端着摄像机在你后面跑，并且距离固定，第一人称则是你自己头戴摄像机，3d游戏的镜头特征也是人类正常的视觉习惯，距离固定的超长镜头”。</strong></p>
<p>连续的镜头，让我们体验到的是空间的变化而不是静帧的画面，就像上面苏州博物馆的假山，我们可以固定在正面观察，但因为你的移动，你一定会看到他的其他角度，拍电影或许你只要取正面假山的镜头就好，假山的侧面不需要去考虑，但游戏场景设计却不行，你的位置稍加移动就会看到其他角度。</p>
<h1 id="既成画也成景"><a href="#既成画也成景" class="headerlink" title="既成画也成景"></a>既<strong>成画也成景</strong></h1><p>那么如果场景的一个角度不行，是不是进行多个角度进行同时控制是不是就可以了？</p>
<p>现代景观和建筑的的做法是进行平立剖的设计与细节大样的设计，越复杂则相关的图纸就会越多，并且施工以及建造误差与现场突发情况也会难以控制，因为单体相对来说好做平立剖，但一个城市或者山林景观要做平立剖一是不好控制，二是不好表达。</p>
<p><a href="https://image.gcores.com/4312916f-d475-45fb-8179-72af7dd5852d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4312916f-d475-45fb-8179-72af7dd5852d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="吴彬的《十面灵璧图》  从不同的角度观看同一石头，几乎没有东南西北立面之说，单纯以建筑单体的方式来表达景观的立面明显是不可行的。"></a></p>
<p>吴彬的《十面灵璧图》  从不同的角度观看同一石头，几乎没有东南西北立面之说，单纯以建筑单体的方式来表达景观的立面明显是不可行的。</p>
<p><a href="https://image.gcores.com/70a3e4d3-349a-40bf-b1e1-2d15ed4477c8.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/70a3e4d3-349a-40bf-b1e1-2d15ed4477c8.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺的幻境树  "></a></p>
<p>仙峰寺的幻境树  </p>
<p>以只狼中的幻境为例，幻境中间的树，我从周边一圈的围廊对他几个不同的角度进行截图，明显这颗树在各个角度都已经被调整过构成了，不然很难看起来如此自然生长，是不是有点像上面的十面灵璧图，我们能从一圈的围廊，以及树上的几个勾爪点进行观察，这几乎已经是一个单个景点设计的极限了，几乎上下左右没有任何死角的去观察一个景点。</p>
<p>园林建造的时候造园者一定需要各个角度去观察和控制，从某个窗洞里看，从某个台阶上俯瞰，从另外的亭子上看来决定这部分。</p>
<p> <strong>同时控制景点与其可游走的路线作为设计骨架进行展开。</strong> </p>
<p><a href="https://image.gcores.com/6433f96c-6f16-430a-91ad-3ac0af041b4d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6433f96c-6f16-430a-91ad-3ac0af041b4d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城城邑与苇名城主城总平面  这个平面应该最开始就拿来控制景点与游走路线，黄色为前进路线。 "></a></p>
<p>苇名城城邑与苇名城主城总平面  这个平面应该最开始就拿来控制景点与游走路线，黄色为前进路线。 </p>
<p>我在总平面上标了几个重要的节点，仔细观察苇名城主城的位置，城邑部分几乎是围绕着主城分布，并且城邑部分的分布弯折有致，使主城被建筑或者植物遮挡若隐若现，大部分时间因为遮挡你感觉不到主城存在，但几个关键节点却都一直在强调主城，比较明显的就是刚出破旧寺庙你第一眼看到的就是苇名城主城（图1）还有桥下山谷鬼佛处和鬼刑部的大广场，你都能从不同距离不同角度看到主城。无处不在却又若隐若现的主城，你甚至能在仙峰寺主堂看到苇名城主城。</p>
<p><a href="https://image.gcores.com/8bf09192-2a99-4191-b4fb-b5bf250695b3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8bf09192-2a99-4191-b4fb-b5bf250695b3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城城邑节点看主城"></a></p>
<p>苇名城城邑节点看主城</p>
<p><a href="https://image.gcores.com/7990dd38-0571-47d9-86e3-d753b87b3a0f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7990dd38-0571-47d9-86e3-d753b87b3a0f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺主堂看苇名城主城"></a></p>
<p>仙峰寺主堂看苇名城主城</p>
<h1 id="相互成景"><a href="#相互成景" class="headerlink" title="相互成景"></a><strong>相互成景</strong></h1><p>上面我们讨论的是单个物件的与其路径的控制，那么如果出现多组景点呢？</p>
<p>仙峰寺建筑较多，并且有横向的通天桥（铠甲武士处），竖向的五重塔（先锋脚秘籍处），这两者在整个场景里共同统领了整个场景，你在场景的各个位置都能较明显的看到这两个建筑，在场景最初规划的时候应该就已经设计过这些视点的设计。</p>
<p><strong>同一个场景能够保证可以从其他的角度去观察，在造景的同时，也在为另一个场景添加远景。一旦景点众多，视点的控制就会变得极为复杂，此时限制人物的可移动范围就显得尤为重要。</strong></p>
<p> 这是以通天桥为参照物进行截图： </p>
<p><a href="https://image.gcores.com/b3290faf-965a-4ba8-8540-d580fd002693.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b3290faf-965a-4ba8-8540-d580fd002693.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<ul>
<li>从主堂看通天桥</li>
<li>从寺院境内看通天桥</li>
<li>从通天桥看寺院境内</li>
</ul>
<p><a href="https://image.gcores.com/a6a441df-e2ac-4121-8dea-0a4cf1df5b2b.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a6a441df-e2ac-4121-8dea-0a4cf1df5b2b.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<ul>
<li>通天桥看主堂</li>
<li>从寺院境内看通天桥</li>
<li>从五重塔看通天桥</li>
</ul>
<h1 id="装折如画：出幕若分别院，连墙拟越深斋"><a href="#装折如画：出幕若分别院，连墙拟越深斋" class="headerlink" title="装折如画：出幕若分别院，连墙拟越深斋"></a><strong>装折如画：</strong>出幕若分别院，连墙拟越深斋</h1><p>此篇章需要切身玩过只狼与死亡搁浅这两款游戏才能体会其中之情趣。</p>
<p><strong>便径他居，复成别馆。砖墙留夹，可通不断之房廊，板壁常空，隐出别壶之天地。亭台影罅，楼阁虚邻。绝处犹开，低方忽上，楼梯仅乎室侧，台级藉矣山阿。-《园冶》装折篇</strong></p>
<p>园冶中的装折并非讨论的是大木作的结构之事，也不是小木作装修之事，其强调的是景与空间这些体验之间的关系与变化，其装折中的“装”在于设置的时机，而合适的时机在于前后的关系，“折”在于变化，空间，景观和体验的变化，而变化本身在于感知之奇，不落俗套但又合乎情理。</p>
<p><strong>低方乎上，楼梯仅乎室侧，台级籍矣山阿：</strong>从道理而言，爬楼与攀梯类似，因为人的行动都是向上的，但是从感知上却又有区别，爬楼是日常起居行为，而爬山却是山水行乐之事，两者相互错置，却又能得感知之奇却又合乎常理。</p>
<p> <strong>装折如画：看的风景之间的变化</strong> </p>
<p><a href="https://image.gcores.com/04fe6beb-4ab1-4c4a-90a5-adac5bece146.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/04fe6beb-4ab1-4c4a-90a5-adac5bece146.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="平田宅邸："></a></p>
<p>平田宅邸：</p>
<p>在经历过前面竹林部分到后面着火的主宅部分，这一场景在前面几乎都是被完全遮挡住的，我们只能隐隐约约看到一些浓雾，在完全进入宅院内部后，是与前面的灰暗竹林形成强烈对比的一片火海，关键不在于火海，也不在于竹林，而是竹林与火海之间的关系，变化是如何产生的才是关键，并且这个地方刚好也是整个关卡的中部位置，，能够看到义父和拿隐藏佛堂钥匙，算是整个关卡的一个重要节点。</p>
<p><a href="https://image.gcores.com/644d9c9d-0f1c-4a20-8f25-39f50a135214.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/644d9c9d-0f1c-4a20-8f25-39f50a135214.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="还是平田宅邸"></a></p>
<p>还是平田宅邸</p>
<p>蝴蝶夫人见面前，不知各位是否有印象，蚺蛇重藏的位置是几乎是没有火的，宅邸内部也是没有火，隐藏佛堂在设定初期也是不着火的，我猜想是为了要和前面的场景形成对比与变化，作为整个关卡的最后一战，最后选择让屋顶着火，这里的燃烧的屋顶简直用的恰到好处，形成光源的同时也让整体地下的氛围显得与前面的场景有足够的区别，作为最后的高潮结尾。</p>
<p><strong>所以平田宅邸的这两个场景变化其实非常明显，而且这两个场景变化最剧烈的位置刚好位于关卡的中部与结尾，其装折中“装”的位置恰到好处，但整个场景里并不缺少灰暗色调与大火燃烧的场景，关键在于变化之情趣，假使整个宅邸都处于燃烧的状态，则隐藏佛堂熊熊燃烧的火焰就不会给人如此震撼。</strong></p>
<p><a href="https://image.gcores.com/b13409cf-9865-4fc6-88c6-a1caffa43401.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b13409cf-9865-4fc6-88c6-a1caffa43401.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="隐藏佛堂初期设定稿"></a></p>
<p>隐藏佛堂初期设定稿</p>
<p><a href="https://image.gcores.com/56a151f6-6e92-48ea-8bbd-d319884de96f.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/56a151f6-6e92-48ea-8bbd-d319884de96f.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="初入仙峰寺"></a></p>
<p>初入仙峰寺</p>
<p>在经历过地牢一连串灰暗的地下水沟进入这样如画风景所带来的震撼不亚于死亡搁浅里“bones”响起的瞬间，但其变化的关系与上述平田宅邸的两个场景变化并无二异，关键在于变化之间的关系与时机。</p>
<p><strong>装折入画：整体体验上的区别变化</strong> </p>
<p><a href="https://image.gcores.com/102023df-ad5a-4413-9a2a-8b49fcf1194b.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/102023df-ad5a-4413-9a2a-8b49fcf1194b.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城平面图  "></a></p>
<p>苇名城平面图  </p>
<p>我们看下游玩的顺序：赤鬼-山内典善-大蛇-鬼刑部-火牛-进入主城，城邑-山谷-城邑。</p>
<p>桥下山谷这个场景打断了城邑连续的场景节奏，应该是故意为之的，大蛇的出现在城邑地图的中间段，在经历过一段密集建筑群以及敌人的城邑场景，忽然转到廖无人烟的白色山谷，并且玩法上也从打铁变成了以潜行为主。此为装折之情趣，断桥不通而行山下，空间的变化和体验上的变化增加了些游戏上的情趣。 </p>
<p><strong>这里选择机核有关《死亡搁浅》的一段评论：</strong></p>
<p>满载着货物的我骑着机车赶往下一个大关卡港结市，按照刚做好表示路线前行，马上到达了满是石子的山谷，不远处有一个拱形的石洞，很明显那就是必经之路。 石子越来越多，而且不出所料，天开始下雨，接着bt立刻出现，更糟糕的是，因为脚下的石子实在太多，只能靠牺牲耐久撞着石头卡过去，不料，当我正想用雷达的时候，一直bt马上就出现在旁边并接近了我，而此时我急于将车卡过去，但事与愿违，下车取血雷已经来不及，于是我被拖入了二阶段，也是游戏进行到现在第一次攻击那个大乌贼。 虽然付出了不小的代价，但还是干掉了他，心里想着幸好多带了几颗差点不够了，然后继续找回我的车子往前开，发现马上出现了一段平坦的路直通目的地，便想着如果当时石子路那有座桥，就应该很顺利的通过了吧，于是我拿出了建造台开始寻找合适的位置，跑了挺久找到好位置结果发现没有信号不能建造，而且居然又下起了雨。  不幸的事再次发生，就在我急着跑回去骑车时，我又被抓住了，挣脱后在黑水里想着赶紧骑车跑路，没想到刚骑上去就又被抓住了，舍不得车子的我又被拉入了第二阶段。即便有支援的弹药，我的弹药还是不足以杀死那只乌贼，同时，机车也报废了，货物也遭到损坏，而且因为东西太多可能连命都要交代，只好拿了任务需要的箱子赶紧跑路。劫后余生，啥都没了，穿过石洞，视野一片平坦，想着当时如果没有考虑去为人造桥，我现在应该是开心的在这片旷野上骑行去往目的地吧？ 我带着心酸、懊悔、遗憾、犹豫的心情背着残破的箱子走在这旷野上，平坦的山谷下方港结市出现在眼前，突然 Asylums For the feeling feat响起，随着音乐我开始颤栗，心里只想着卧槽卧槽卧槽！！！！！等这片区域的网络解锁我tmd一定要去造那座桥！我想这一切只有真正在玩游戏的人才能体会吧。</p>
<p>无意想放这么长的一段文字，但因为情绪之间的变化缺一不可，在经历过一路坎坷，躲避BT，劫后余生，天气逐渐变晴，在山顶看到宽阔的景色然后慢慢地在耳边响起音乐这时的心情与在网易云听死亡搁浅的歌单是完全不一样的。</p>
<p>装折中的“折”就是打完bt之后雨过天气，经历过坎坷山路后的壮阔风景，劫后余生后响起空灵音乐，变化，为什么选择这样的变化，变化之间的关系是否足够有情趣是折之关键。</p>
<p>装折中的“装”就是什么时候出现这样的变化，是我在经历过一段苇名城城邑打过几个精英怪之后出现大蛇，还是在打过鬼刑部之后出现大蛇，这是“装”在时机上的选择。</p>
<p>装折入画在于整体体验上的区别变化，其“折”的内容不再局限于视觉层面上，更加强调的是整体的情绪体验，视听与心理与玩法同时“折”，当然是否成功还是得看“折”得是否足够有情趣。 </p>
<h1 id="如画构成与动态入画"><a href="#如画构成与动态入画" class="headerlink" title="如画构成与动态入画"></a><strong>如画构成与动态入画</strong></h1><p>如画构成是什么开头已经讲过，这里不再赘述，其本身并无好坏，只是一个设计的基础手段，但在一些小范围的场景里，如画构成会成为主要的设计手段，比如破旧寺庙，隐藏佛堂这类场景会经常使用。那什么是动态入画呢？这里先解释下园林设计因借中“因”的概念：</p>
<p>“‘因’者：随基势之高下，体形之端正，碍木删桠，泉流石注，互相借资;宜亭斯亭，宜榭斯榭，不妨偏径，顿置婉转，斯谓‘精而合宜’者也。园林中的“因”是要根据远景来做调整的，其中的亭榭因为是人为而做所以易于调整，然而借来之景却无法调试，因此我们只能控制近景的亭榭林木来配合远景的远山高塔。</p>
<p>上述这是园林的“因”，那么游戏里的“因”是什么呢，我们能操控的是什么呢，只有一个就是我们控制的主角，“借”则是我们已经做好的如画构成的舞台，那么怎么动态入画呢？</p>
<p><strong>动态入画</strong>：</p>
<p>一个好的场景构成与移动范围的控制，结合boss战的攻击招式与微小的镜头控制能够很好营造出电影般体验。场景是基础的舞台，提供基础的近中远三景，而你和另外一个对象则完善了近景和中景。</p>
<p> <strong>破戒僧BOSS战</strong> </p>
<p><a href="https://image.gcores.com/e0b3e143-c575-4034-b923-e2b88c1798a2.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/e0b3e143-c575-4034-b923-e2b88c1798a2.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="机核小五试玩视频录"></a></p>
<p>机核小五试玩视频录</p>
<p><a href="https://image.gcores.com/ce25e153-9ed0-4780-9c80-31f756621f88.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/ce25e153-9ed0-4780-9c80-31f756621f88.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>如画构成是一个场景基础几何图形构成上的控制，两侧的巨大红树的枝干与朱桥上的栏杆在构图上进行了很好的引导，将视觉中心点都集中在破戒僧身上。</p>
<p>场景的移动范围只限制在朱桥这一线型空间内，结合破戒僧大开大合的招式，主角和对象的距离一直在进行变化，在出招和躲招的时候就很容易出现上面的这类镜头，破戒僧出招，只狼后退，视平线被拉高，在场景舞台上，距离拉开到一定程度后，只狼与破戒僧共同成为了画内的近景与中景。</p>
<p> PS:试玩版之所以选择破戒僧这场战斗我想应该是因为这是所有战斗中电影感最强的一段，并且试玩版中明显针对这段做过视觉优化，正式版的这一场景是没有光影的！不知道为什么明明已经做了却在正式版取消了光影！对比起来的话效果差很多，好想玩一遍试玩版~！ </p>
<p><a href="https://image.gcores.com/536d4b83-010e-45c0-aec2-7ee266bbfb86.JPG?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/536d4b83-010e-45c0-aec2-7ee266bbfb86.JPG?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="正式版的阉割画面"></a></p>
<p>正式版的阉割画面</p>
<p> <strong>苇名弦一郎BOSS战</strong> </p>
<p><a href="https://image.gcores.com/cb57d2a3-50ce-4eab-b1d2-fdd80be1314a.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/cb57d2a3-50ce-4eab-b1d2-fdd80be1314a.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>只狼里我最喜欢的一场boss战！天守阁望楼这个场景是三面透空，并且顺带框了三个景，一旦和弦一郎拉开距离喝药的时候弦一郎就会拉弓射箭，完美弹反后镜头会微微下移，这个时候前景的只狼，中景的弦一郎，远景的山与天空刚好构成一幅动态画面，和弦一郎对战中我几次会出现在看电影的错觉，通过与boss间的距离变化与一些微小的镜头移动，游戏画面会重新构图，时不时会出现电影般的打斗画面，但和底特律变人的那种互动电影或者大表哥2的暴力的电影模式不同，只狼角色几乎是一直被我所控制的，并且镜头是一直连续可控的，这给我感觉是我不是在看电影，而是电影的一部分，因为你（只狼）随时都可能成为景中的一部分。 </p>
<p>天守阁望楼的如画构成：天守阁望楼开了超大的三个横向落地窗，之所以说超大是因为其并不符合建筑结构，这么大跨度正还需要在每品方向上要增加4根以上的立柱才有可能成立，但取消立柱这一手段可以有几个效果，完整的框景，为了让远景的山更加连续。弦一郎的轮廓更加清晰，这一层几乎没有任何明显的立柱，这也是游戏的优势，为了表现让一切看起来合理即可。 </p>
<p><a href="https://image.gcores.com/dcdc051d-2e54-4bdf-844a-a8e735c62952.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/dcdc051d-2e54-4bdf-844a-a8e735c62952.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><a href="https://image.gcores.com/e8379f35-90bb-4c5f-acc1-8345f013e539.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e8379f35-90bb-4c5f-acc1-8345f013e539.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="从预告片中也能看出，宫崎英高英高应该是想创造一种画中战斗的感觉，上面的布帘，地面的阴影，两侧立柱所构成的画框。"></a></p>
<p>从预告片中也能看出，宫崎英高英高应该是想创造一种画中战斗的感觉，上面的布帘，地面的阴影，两侧立柱所构成的画框。</p>
<p> <strong>蝴蝶夫人BOSS战</strong> </p>
<p><a href="https://image.gcores.com/6d8da677-3026-46d9-acf0-d5cbe204a6ac.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/6d8da677-3026-46d9-acf0-d5cbe204a6ac.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/18ed46cf-e15d-404d-98e1-9acd68fbd850.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/18ed46cf-e15d-404d-98e1-9acd68fbd850.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="蝴蝶夫人这个走钢丝的设定实在太帅了！在锁定情况下，蝴蝶夫人跳上钢丝时镜头会微微上抬，能够看到蝴蝶夫人的位置并且也能看到大佛，瞬间成景。"></a></p>
<p>蝴蝶夫人这个走钢丝的设定实在太帅了！在锁定情况下，蝴蝶夫人跳上钢丝时镜头会微微上抬，能够看到蝴蝶夫人的位置并且也能看到大佛，瞬间成景。</p>
<p>美中不足的是蝴蝶夫人的战斗场景其实有点大了，并且场景两侧能够不太能够成景，唯一可以成景的就是背后的大佛，但实际游玩更多时候是把蝴蝶夫人窝在角落里打，或者到处追着打，蝴蝶夫人走钢丝的机会并不多。因此上述的两个镜头在实际游玩的时候并不常见，在观赏性上是一场比较可惜的boss战，但是充满潜力的一个boss战。 </p>
<p>移动范围与成景是相互关联的两件事，越大的移动范围则观景的角度越多，能看到的东西也越多，所要设计的景观也越多，破戒僧的朱桥限制了一定的移动范围，并在前后方向成景，天守阁望楼虽然偏向正形平面，但却是三面成景，移动的范围与景的设计相互关联和影响，最终也会影响到游戏中的boss招式的设计与主角之间的镜头的关系。</p>
<h1 id="中国的游戏场景设计应该是什么样子的？"><a href="#中国的游戏场景设计应该是什么样子的？" class="headerlink" title="中国的游戏场景设计应该是什么样子的？"></a><strong>中国的游戏场景设计应该是什么样子的？</strong></h1><p>中国建筑汉唐到明清建筑的样式并没有发生过剧烈的变化，因为改朝换代与耐久问题，中国的建筑为了能够快速建造练图纸几乎都是固定的，因此才有了样式雷这样的建造家族。中国建筑形制的剧烈变化并非是由时间造成的，而是地域环境，中国有6个不同的气候带，不同的地域环境诞生的建筑形制有天然的差别。多样的环境特征产生了多样的建筑形制，但大多游戏中设计单体单体阶段完全不考虑环境对建筑的影响几乎是不合理的。</p>
<p>和西方不同，堆砌一堆的建筑符号和形式这类做法其实在中国很少见，中国从3000多年前的四合院开始就已经有了空间序列的概念，到后期的由文人执笔的古典园林对于空间的巧妙运用达到相当高的境界。并且中国园林其实一直有一个非常清晰的前进脉络：“魏晋的山水诗，宋元的山水画，明清的山水园，从文字到图像到具体场景实现几乎是非常完整的脉络，并且中国造园的都是文人，因此在对意境的理解和重现上并非普通花匠可比。在几亩地内不断通过掇山理水，林木装折，追求自然山水景观，深远不尽的意向，像不像今天我们对着20来寸的屏幕却想横穿整个美利坚？</p>
<p>如何在有限的资源，面积下，去在游戏中追求深远不尽，在中国的园林设计里会有答案。上面所有理论基于中国古典园林，但有大量个人理解存在，但请理性讨论。 </p>
<p><strong>参考资料：</strong></p>
<p>计成：园冶 董豫赣：造园九章 田朝阳：中国古典园林与现代转译 汉宝德：中国园林的物象与心境 只狼原画设定集 只狼实机截图以及录屏</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>只狼</tag>
      </tags>
  </entry>
  <entry>
    <title>作业01(linux基础认识)</title>
    <url>/%E4%BD%9C%E4%B8%9A01-linux%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1、别名，内部，外部，hash 优先级？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">别名&#96;&gt;&#96;内部&#96;&gt;&#96;hash&#96;&gt;&#96;外部<br></code></pre></td></tr></table></figure>

<p><strong>2、实现screen 协助</strong></p>
<ol>
<li>一台<code>screen -S</code>协助名称</li>
<li>另外一台<code>screen -ls</code>列出目前开的协助会话(session)，找到上面协助名称对应的session号。</li>
<li><code>screen -x SESSION</code>，SESSION为上面的会话号码。如果是只有一个的话，可以只输入<code>screen -x</code></li>
</ol>
<p><strong>3、显示昨天是星期几</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@centos7 ~]# date --date&#x3D;&quot;yesterday&quot; +%a<br>Sun<br>[root@centos7 ~]# date --date&#x3D;&quot;yesterday&quot; +%A<br>Sunday<br></code></pre></td></tr></table></figure>

<p><strong>4、显示当前时间，格式：2016-06-18 10:20:30</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">date +&quot;%F %T&quot;<br></code></pre></td></tr></table></figure>

<p><strong>5、设置当前日期为2019-08-07 06:05:10</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">date 080706052019.10<br></code></pre></td></tr></table></figure>

<p><strong>6、在本机字符终端登录时，除显示原有信息外，再显示当前登录终端号，主机名和当前时间</strong></p>
<p>man issue发现不详细，然后看到提示有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SEE ALSO<br>       motd(5), agetty(8), mingetty(8)<br></code></pre></td></tr></table></figure>



<p>agetty也不详细，mingetty最详细，我们找到想要的信息了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ISSUE ESCAPES<br>       mingetty recognizes the following escapes sequences which might be embedded in the &#x2F;etc&#x2F;issue file:<br><br>       \d     insert current day (localtime),<br><br>       \l     insert line on which mingetty is running,<br><br>       \m     inserts machine architecture (uname -m),<br><br>       \n     inserts machine’s network node hostname (uname -n),<br><br>       \o     inserts domain name,<br><br>       \r     inserts operating system release (uname -r),<br><br>       \t     insert current time (localtime),<br><br>       \s     inserts operating system name,<br><br>       \u     resp. \U the current number of users which are currently logged in.  \U inserts &quot;n users&quot;, where as \u only inserts &quot;n&quot;.<br><br>       \v     inserts operating system version (uname -v).<br></code></pre></td></tr></table></figure>

<p>可以根据需要来自定义了,<code>vim /etc/issue</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Terminal: \l<br>Hostname: \n<br>Localtime: \t<br></code></pre></td></tr></table></figure>

<p><strong>7、今天18：30自动关机，并提示用户</strong><br><code>shutdown -h 18:30 &quot;System will shutdown at 18:30, please backup your data&quot;</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>修改hexo的文章模版</title>
    <url>/%E4%BF%AE%E6%94%B9hexo%E7%9A%84%E6%96%87%E7%AB%A0%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="修改hexo的文章模版"><a href="#修改hexo的文章模版" class="headerlink" title="修改hexo的文章模版"></a>修改hexo的文章模版</h1><ul>
<li><p>前提</p>
<p>每次新建文章（hexo n “文章标题”）都要手动添加categories很麻烦，查阅得知hexo/scaffolds为模版文件夹，会根据其目录下的文件post.md产生文章。</p>
<p>因此，在hexo/scaffolds/post.md中添加需要的内容，即可修改文章模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[root@ashjian blog]$vim scaffolds&#x2F;post.md<br>---<br>title: &#123;&#123; title &#125;&#125;<br>date: &#123;&#123; date &#125;&#125;<br>tags:<br>categories:<br>---<br></code></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>配置</p>
<ul>
<li>_config.yml<ul>
<li>大部分配置信息，您可以在此配置大部分的参数。</li>
</ul>
</li>
<li>package.json<ul>
<li>应用程序的信息EJS、Stylus和Markdown renderer默认安装</li>
</ul>
</li>
<li>scaffolds<ul>
<li>模板文件夹新建文章时，Hexo 会根据 scaffold 来建立文件。</li>
<li>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</li>
</ul>
</li>
<li>source–资源文件夹，除<em>posts文件夹外，开头命名为</em>（下划线的文件） / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li>
<li>themes<ul>
<li>主题 文件夹。Hexo 会根据主题来生成静态页面。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆虚拟机后，需要对克隆的虚拟机做的相关操作</title>
    <url>/%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%8E%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AF%B9%E5%85%8B%E9%9A%86%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%81%9A%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模拟实验机器相关配置：</p>
<ul>
<li>操作系统：CentOS6.9</li>
<li>两块网卡<code>eth0</code> 和<code>eth1</code></li>
</ul>
<p>1） 用自带的克隆虚机功能</p>
<p><a href="http://www.yulongjun.com/images/14984836328721.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215826.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/14984836828558.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826221504.jpg" alt="img"></a></p>
<p>启动两台机器，我们<code>ifconfig</code>看到两块网卡的名称、ip地址、mac地址都变了。</p>
<p><a href="http://www.yulongjun.com/images/14984839001048.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215919.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/14984839130165.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215931.jpg" alt="img"></a></p>
<p>然后看到网卡配置文件里面也是旧的文件，还有一个重要的文件<code>/etc//etc/udev/rules.d/70-persistent-net.rules</code>也是错的：<br><a href="http://www.yulongjun.com/images/14984847674508.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215953.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/14984852278880.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215953.jpg" alt="img"></a></p>
<p>我们先把<code>/etc/udev/rules.d/70-persistent-net.rules</code>下的前面两条注释掉，然后修改第三条第四条的<code>eth2</code>和<code>eth3</code>为<code>eth0</code>和<code>eth1</code>。</p>
<p><a href="http://www.yulongjun.com/images/14984853922322.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826220007.jpg" alt="img"></a></p>
<p>然后修改<code>/etc/sysconfig/network-scripts/</code>下的<code>ifcfg-eth0</code> 和<code>ifcfg-eth1</code>,把文件里的<code>UUID</code>和<code>HWADDR</code>给删掉，PART如果是DHCP的，就不用改，如果原来是固定IP的，把IP地址改一下。</p>
<p>可以重启电脑，如果不想重启电脑，可以用卸载然后重新加载网卡驱动模块的方法来使之生效：</p>
<p>我们用<code>ethtool -i eth2</code>可以看到网卡驱动型号：<br><a href="http://www.yulongjun.com/images/14984859283751.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826215818.jpg" alt="img"></a></p>
<p>然后我们可以先卸载，然后装载驱动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 卸载网卡驱动：<br><br>modprobe -r e1000<br><br>#或者 &#96;rmmod e1000&#96;也可以<br><br># 装载网卡驱动：<br><br>modprobe e1000<br><br>service network restart<br>service NetworkManager restart<br></code></pre></td></tr></table></figure>

<p>这时候发现，有一个网卡获取不到ip</p>
<p>这时候笔者更改了网卡的默认名字<code>system eth0</code>为<code>eth0</code>（同样的<code>system eth1</code>也改）,这时候再次重启NetworkManager服务，正常获取到了ip。这里猜测NetworkManager某些地方有bug（6里的NetworkManager真是个坑啊！），在名字方面不能跟原来的相同。</p>
<p>至此，克隆的CentOS6完全可用。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>向日葵图床</title>
    <url>/%E5%90%91%E6%97%A5%E8%91%B5%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://i.ibb.co/Jy2CYfG/GLOD0158-gallery-25.jpg" alt="GLOD0158-gallery-25" border="0">
<img src="https://i.ibb.co/Ln1Wyys/GLOD0158-gallery-26.jpg" alt="GLOD0158-gallery-26" border="0">
<img src="https://i.ibb.co/LNVrNFt/GLOD0158-gallery-27.jpg" alt="GLOD0158-gallery-27" border="0">
<img src="https://i.ibb.co/P4NLC8C/GLOD0158-gallery-28.jpg" alt="GLOD0158-gallery-28" border="0">
<img src="https://i.ibb.co/PTphvgH/GLOD0158-gallery-29.jpg" alt="GLOD0158-gallery-29" border="0">
<img src="https://i.ibb.co/RN7nCMc/GLOD0158-gallery-30.jpg" alt="GLOD0158-gallery-30" border="0">
<img src="https://i.ibb.co/85jfmDR/image.jpg" alt="image" border="0">
<img src="https://i.ibb.co/gjJymLk/GLOD0158-gallery-1.jpg" alt="GLOD0158-gallery-1" border="0">
<img src="https://i.ibb.co/W06xZNv/GLOD0158-gallery-2.jpg" alt="GLOD0158-gallery-2" border="0">
<img src="https://i.ibb.co/XkxMc2B/GLOD0158-gallery-3.jpg" alt="GLOD0158-gallery-3" border="0">
<img src="https://i.ibb.co/ZxS8yZN/GLOD0158-gallery-4.jpg" alt="GLOD0158-gallery-4" border="0">
<img src="https://i.ibb.co/VvbYVzt/GLOD0158-gallery-5.jpg" alt="GLOD0158-gallery-5" border="0">
<img src="https://i.ibb.co/bmpYLF4/GLOD0158-gallery-6.jpg" alt="GLOD0158-gallery-6" border="0">
<img src="https://i.ibb.co/mBY6FGF/GLOD0158-gallery-7.jpg" alt="GLOD0158-gallery-7" border="0">
<img src="https://i.ibb.co/L53Lpf6/GLOD0158-gallery-9.jpg" alt="GLOD0158-gallery-9" border="0">
<img src="https://i.ibb.co/JvhtsJR/GLOD0158-gallery-10.jpg" alt="GLOD0158-gallery-10" border="0">
<img src="https://i.ibb.co/N6jwL2R/GLOD0158-gallery-11.jpg" alt="GLOD0158-gallery-11" border="0">
<img src="https://i.ibb.co/g7MbGH8/GLOD0158-gallery-12.jpg" alt="GLOD0158-gallery-12" border="0">
<img src="https://i.ibb.co/wCZBQn2/GLOD0158-gallery-13.jpg" alt="GLOD0158-gallery-13" border="0">
<img src="https://i.ibb.co/SRfVTvV/GLOD0158-gallery-14.jpg" alt="GLOD0158-gallery-14" border="0">
<img src="https://i.ibb.co/94NPtQ6/GLOD0158-gallery-15.jpg" alt="GLOD0158-gallery-15" border="0">
<img src="https://i.ibb.co/vB1TmTb/GLOD0158-gallery-16.jpg" alt="GLOD0158-gallery-16" border="0">
<img src="https://i.ibb.co/42DJm6Q/GLOD0158-gallery-17.jpg" alt="GLOD0158-gallery-17" border="0">
<img src="https://i.ibb.co/S0HzqLN/GLOD0158-gallery-18.jpg" alt="GLOD0158-gallery-18" border="0">
<img src="https://i.ibb.co/4TFxLJF/GLOD0158-gallery-19.jpg" alt="GLOD0158-gallery-19" border="0">
<img src="https://i.ibb.co/sqx05ws/GLOD0158-gallery-20.jpg" alt="GLOD0158-gallery-20" border="0">
<img src="https://i.ibb.co/j63Bc2n/GLOD0158-gallery-21.jpg" alt="GLOD0158-gallery-21" border="0">
<img src="https://i.ibb.co/FsMdL6y/GLOD0158-gallery-22.jpg" alt="GLOD0158-gallery-22" border="0">
<img src="https://i.ibb.co/1RhR36P/GLOD0158-gallery-23.jpg" alt="GLOD0158-gallery-23" border="0">
<img src="https://i.ibb.co/k9drZJR/GLOD0158-gallery-24.jpg" alt="GLOD0158-gallery-24" border="0">]]></content>
  </entry>
  <entry>
    <title>如何优雅的使用和理解线程池</title>
    <url>/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2a8dad64.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224031.jpg" alt="img"></a></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<ul>
<li>线程是稀缺资源，不能频繁的创建。</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>应当将其放入一个池子中，可以给其他任务进行复用。</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<ul>
<li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
<li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
<li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>
<p>其实看这三种方式创建的源码就会发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public static ExecutorService newCachedThreadPool() &#123;<br>    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>                                  60L, TimeUnit.SECONDS,<br>                                  new SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>
<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)<br></code></pre></td></tr></table></figure>

<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">threadPool.execute(new Job());<br></code></pre></td></tr></table></figure>

<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2a9bc566.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224032.jpg" alt="img"></a></p>
<ul>
<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>
<p>用图表示为：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2aa81655.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224033.jpg" alt="img"></a></p>
<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2ab921db.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224034.jpg" alt="img"></a></p>
<ol>
<li>获取当前线程池的状态。</li>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
<li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
<li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
<li>如果当前线程池为空就新创建一个线程并执行。</li>
<li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>
<p>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2ac0936c.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224035.jpg" alt="img"></a></p>
<h3 id="如何配置线程"><a href="#如何配置线程" class="headerlink" title="如何配置线程"></a>如何配置线程</h3><p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<ul>
<li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2</li>
<li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>
<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>
<p>但他们有着重要的区别：</p>
<ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<blockquote>
<p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>
<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">long start &#x3D; System.currentTimeMillis();<br>for (int i &#x3D; 0; i &lt;&#x3D; 5; i++) &#123;<br>    pool.execute(new Job());<br>&#125;<br><br>pool.shutdown();<br><br>while (!pool.awaitTermination(1, TimeUnit.SECONDS)) &#123;<br>    LOGGER.info(&quot;线程还在执行。。。&quot;);<br>&#125;<br>long end &#x3D; System.currentTimeMillis();<br>LOGGER.info(&quot;一共处理了【&#123;&#125;】&quot;, (end - start));<br></code></pre></td></tr></table></figure>

<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<h2 id="SpringBoot-使用线程池"><a href="#SpringBoot-使用线程池" class="headerlink" title="SpringBoot 使用线程池"></a>SpringBoot 使用线程池</h2><p>2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。</p>
<p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class TreadPoolConfig &#123;<br><br><br>    &#x2F;**<br>     * 消费队列线程<br>     * @return<br>     *&#x2F;<br>    @Bean(value &#x3D; &quot;consumerQueueThreadPool&quot;)<br>    public ExecutorService buildConsumerQueueThreadPool()&#123;<br>        ThreadFactory namedThreadFactory &#x3D; new ThreadFactoryBuilder()<br>                .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();<br><br>        ExecutorService pool &#x3D; new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,<br>                new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());<br><br>        return pool ;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Resource(name &#x3D; &quot;consumerQueueThreadPool&quot;)<br>private ExecutorService consumerQueueThreadPool;<br><br><br>@Override<br>public void execute() &#123;<br><br>    &#x2F;&#x2F;消费队列<br>    for (int i &#x3D; 0; i &lt; 5; i++) &#123;<br>        consumerQueueThreadPool.execute(new ConsumerQueueThread());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>
<h2 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h2><p>谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。</p>
<p>线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。</p>
<p>关于 actuator 就不再细说了，感兴趣的可以看看<a href="http://t.cn/ReimM0o" target="_blank" rel="noopener">这篇</a>，有详细整理过如何暴露监控端点。</p>
<p>其实 ThreadPool 本身已经提供了不少 api 可以获取线程状态：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2accbbcf.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224036.jpg" alt="img"></a></p>
<p>很多方法看名字就知道其含义，只需要将这些信息暴露到 SpringBoot 的监控端点中，我们就可以在可视化页面查看当前的线程池状态了。</p>
<p>甚至我们可以继承线程池扩展其中的几个函数来自定义监控逻辑：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2add4d31.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224037.jpg" alt="img"></a></p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2aeea439.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224038.jpg" alt="img"></a></p>
<p>看这些名称和定义都知道，这是让子类来实现的。</p>
<p>可以在线程执行前、后、终止状态执行自定义逻辑。</p>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><blockquote>
<p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>
<p>如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>
<p>通常的做法是按照业务进行划分：</p>
<blockquote>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h3><p>这样的需求 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix</a> 已经帮我们实现了。</p>
<blockquote>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>
<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * Function:订单服务<br> *<br> * @author crossoverJie<br> *         Date: 2018&#x2F;7&#x2F;28 16:43<br> * @since JDK 1.8<br> *&#x2F;<br>public class CommandOrder extends HystrixCommand&lt;String&gt; &#123;<br><br>    private final static Logger LOGGER &#x3D; LoggerFactory.getLogger(CommandOrder.class);<br><br>    private String orderName;<br><br>    public CommandOrder(String orderName) &#123;<br><br><br>        super(Setter.withGroupKey(<br>                &#x2F;&#x2F;服务分组<br>                HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;))<br>                &#x2F;&#x2F;线程分组<br>                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;))<br><br>                &#x2F;&#x2F;线程池配置<br>                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()<br>                        .withCoreSize(10)<br>                        .withKeepAliveTimeMinutes(5)<br>                        .withMaxQueueSize(10)<br>                        .withQueueSizeRejectionThreshold(10000))<br><br>                .andCommandPropertiesDefaults(<br>                        HystrixCommandProperties.Setter()<br>                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))<br>        )<br>        ;<br>        this.orderName &#x3D; orderName;<br>    &#125;<br><br><br>    @Override<br>    public String run() throws Exception &#123;<br><br>        LOGGER.info(&quot;orderName&#x3D;[&#123;&#125;]&quot;, orderName);<br><br>        TimeUnit.MILLISECONDS.sleep(100);<br>        return &quot;OrderName&#x3D;&quot; + orderName;<br>    &#125;<br><br><br>&#125;<br><br><br>&#x2F;**<br> * Function:用户服务<br> *<br> * @author crossoverJie<br> *         Date: 2018&#x2F;7&#x2F;28 16:43<br> * @since JDK 1.8<br> *&#x2F;<br>public class CommandUser extends HystrixCommand&lt;String&gt; &#123;<br><br>    private final static Logger LOGGER &#x3D; LoggerFactory.getLogger(CommandUser.class);<br><br>    private String userName;<br><br>    public CommandUser(String userName) &#123;<br><br><br>        super(Setter.withGroupKey(<br>                &#x2F;&#x2F;服务分组<br>                HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;))<br>                &#x2F;&#x2F;线程分组<br>                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;))<br><br>                &#x2F;&#x2F;线程池配置<br>                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()<br>                        .withCoreSize(10)<br>                        .withKeepAliveTimeMinutes(5)<br>                        .withMaxQueueSize(10)<br>                        .withQueueSizeRejectionThreshold(10000))<br><br>                &#x2F;&#x2F;线程池隔离<br>                .andCommandPropertiesDefaults(<br>                        HystrixCommandProperties.Setter()<br>                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))<br>        )<br>        ;<br>        this.userName &#x3D; userName;<br>    &#125;<br><br><br>    @Override<br>    public String run() throws Exception &#123;<br><br>        LOGGER.info(&quot;userName&#x3D;[&#123;&#125;]&quot;, userName);<br><br>        TimeUnit.MILLISECONDS.sleep(100);<br>        return &quot;userName&#x3D;&quot; + userName;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public static void main(String[] args) throws Exception &#123;<br>    CommandOrder commandPhone &#x3D; new CommandOrder(&quot;手机&quot;);<br>    CommandOrder command &#x3D; new CommandOrder(&quot;电视&quot;);<br><br><br>    &#x2F;&#x2F;阻塞方式执行<br>    String execute &#x3D; commandPhone.execute();<br>    LOGGER.info(&quot;execute&#x3D;[&#123;&#125;]&quot;, execute);<br><br>    &#x2F;&#x2F;异步非阻塞方式<br>    Future&lt;String&gt; queue &#x3D; command.queue();<br>    String value &#x3D; queue.get(200, TimeUnit.MILLISECONDS);<br>    LOGGER.info(&quot;value&#x3D;[&#123;&#125;]&quot;, value);<br><br><br>    CommandUser commandUser &#x3D; new CommandUser(&quot;张三&quot;);<br>    String name &#x3D; commandUser.execute();<br>    LOGGER.info(&quot;name&#x3D;[&#123;&#125;]&quot;, name);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>运行结果：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2b06ef2d.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224039.jpg" alt="img"></a></p>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<blockquote>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>
<p>通过刚才的构造函数也能证明：</p>
<p><a href="https://i.loli.net/2019/05/08/5cd1d2b69cd32.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201224040.jpg" alt="img"></a></p>
<p>还要注意的一点是：</p>
<blockquote>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 <code>This instance can only be executed once. Please instantiate a new instance.</code> 异常。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>
<p>文末的 hystrix 源码</p>
]]></content>
  </entry>
  <entry>
    <title>开源协议的介绍</title>
    <url>/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://raw.githubusercontent.com/ashjian/picBed/a4ca5912dd91a7eb7bfd6bc6f554ad7e77db509a/license.svg" alt="license"></p>
<blockquote>
<p>图片来自于：<a href="https://github.com/phodal/licenses" target="_blank" rel="noopener">https://github.com/phodal/licenses</a></p>
</blockquote>
<blockquote>
<p>下面介绍了各种协议。内容转载自<a href="https://github.com/phodal/licenses" target="_blank" rel="noopener">https://www.oschina.net/question/54100_9455</a></p>
</blockquote>
<p><strong>什么是许可协议？</strong></p>
<p>什么是许可，当你为你的产品签发许可，你是在出让自己的权利，不过，你仍然拥有版权和专利（如果申请了的话），许可的目的是，向使用你产品的人提供 一定的权限。</p>
<p>不管产品是免费向公众分发，还是出售，制定一份许可协议非常有用，否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作者身份，对于后者，你将不得不花费比开发更多的精力用来逐个处理用户的授权问题。</p>
<p>而<a href="http://en.wikipedia.org/wiki/Open-source_license" target="_blank" rel="noopener">开源许可协议</a>使这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可，开源许可协议还可以阻止其它人将某个产品据为己有。以下是开源界的 5 大许可协议。</p>
<h3 id="GNU-GPL"><a href="#GNU-GPL" class="headerlink" title="GNU GPL"></a>GNU GPL</h3><p><a href="http://www.opensource.org/licenses/gpl-2.0.php" target="_blank" rel="noopener">GNU General Public Licence</a> (GPL) 有可能是开源界最常用的许可模式。GPL 保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利：</p>
<ul>
<li><strong>可自由复制</strong><br>你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。</li>
<li><strong>可自由分发</strong><br>在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。</li>
<li><strong>可以用来盈利</strong><br>你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。</li>
<li><strong>可自由修改</strong><br>如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。</li>
</ul>
<p>需要注意的是，分发的时候，需要明确提供源代码和二进制文件，另外，用于某些程序的某些协议有一些问题和限制，你可以看一下 <a href="http://www.twitter.com/PierreJoye" target="_blank" rel="noopener">@PierreJoye</a> 写的 <a href="http://www.softwarefreedom.org/resources/2008/compliance-guide.html" target="_blank" rel="noopener">Practical Guide to GPL Compliance</a> 一文。使用 GPL 协议，你必须在源代码代码中包含相应信息，以及协议本身。</p>
<h3 id="GNU-LGPL"><a href="#GNU-LGPL" class="headerlink" title="GNU LGPL"></a>GNU LGPL</h3><p>GNU 还有另外一种协议，叫做 LGPL （<a href="http://www.opensource.org/licenses/lgpl-2.1.php" target="_blank" rel="noopener">Lesser General Public Licence</a>），它对产品所保留的权利比 GPL 少，总的来说，LGPL 适合那些用于非 GPL 或非开源产品的开源类库或框架。因为 GPL 要求，使用了 GPL 代码的产品必须也使用 GPL 协议，开发者不允许将 GPL 代码用于商业产品。LGPL 绕过了这一限制。</p>
<h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD 在软件分发方面的限制比别的开源协议（如 GNU GPL）要少。该协议有多种版本，最主要的版本有两个，新 BSD 协议与简单 BSD 协议，这两种协议经过修正，都和 GPL 兼容，并为开源组织所认可。</p>
<p>新 BSD 协议（3条款协议）在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制。另外，该协议还禁止拿开发者的名义为衍生产品背书，但简单 BSD 协议删除了这一条款。</p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p><a href="http://www.opensource.org/licenses/mit-license.php" target="_blank" rel="noopener">MIT 协议</a>可能是几大开源协议中最宽松的一个，核心条款是：</p>
<p>该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版权和许可提示。</p>
<p>这意味着：</p>
<ul>
<li>你可以自由使用，复制，修改，可以用于自己的项目。</li>
<li>可以免费分发或用来盈利。</li>
<li>唯一的限制是必须包含许可声明。</li>
</ul>
<p>MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。</p>
<h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>Apache 协议 2.0 和别的开源协议相比，除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合（<a href="http://www.howstuffworks.com/question492.htm" target="_blank" rel="noopener">这里有 一篇文章阐述这个问题</a>）。</p>
<p>Apache 协议还有以下需要说明的地方:</p>
<ul>
<li><strong>永久权利</strong><br>一旦被授权，永久拥有。</li>
<li><strong>全球范围的权利</strong><br>在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li><strong>授权免费，且无版税</strong><br>前期，后期均无任何费用。</li>
<li><strong>授权无排他性</strong><br>任何人都可以获得授权</li>
<li><strong>授权不可撤消</strong><br>一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。</li>
</ul>
<p>分发代码方面包含一些要求，主要是，要在声明中对参与开发的人给予认可并包含一份许可协议原文。</p>
<h3 id="Creative-Commons"><a href="#Creative-Commons" class="headerlink" title="Creative Commons"></a>Creative Commons</h3><p>Creative Commons (CC) 并非严格意义上的开源许可，它主要用于设计。Creative Commons 有多种协议，每种都提供了相应授权模式，CC 协议主要包含 4 种基本形式：</p>
<ul>
<li><strong>署名权</strong><br>必须为原始作者署名，然后才可以修改，分发，复制。</li>
<li><strong>保持一致</strong><br>作品同样可以在 CC 协议基础上修改，分发，复制。</li>
<li><strong>非商业</strong><br>作品可以被修改，分发，复制，但不能用于商业用途。但商业的定义有些模糊，比如，有的人认为非商业用途指的是不能销售，有的认为是甚至不能放在有广告的网站，也有人认为非商业的意思是非盈利。</li>
<li><strong>不能衍生新作品</strong><br>你可以复制，分发，但不能修改，也不能以此为基础创作自己的作品。</li>
</ul>
<p>这些许可形式可以结合起来用，其中最严厉的组合是“署名，非商用，不能衍生新作品”，意味着，你可以分享作品，但不能改动或以此盈利，而且必须为原 作者署名。在这种许可模式下，原始作者对作品还拥有完全的控制权，而最宽松的组合是“署名”，意味着，只要为原始作者署名了，就可以自由处置。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>手动刷新jsdelivr的CDN缓存</title>
    <url>/%E6%89%8B%E5%8A%A8%E5%88%B7%E6%96%B0jsdelivr%E7%9A%84CDN%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jsDelivr的缓存是24小时刷新一次的，太慢了，可以手动更新，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;ashjian&#x2F;videoBed&#x2F;12&#x2F;02.jpg<br></code></pre></td></tr></table></figure>
<p>改成把域名中的 cdn 改为 purge 即可，访问这个URL即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">https:&#x2F;&#x2F;purge.jsdelivr.net&#x2F;gh&#x2F;ashjian&#x2F;videoBed&#x2F;12&#x2F;02.jpg<br></code></pre></td></tr></table></figure>

<p>再次访问原来URL，确认正确</p>
]]></content>
  </entry>
  <entry>
    <title>## 文件查找</title>
    <url>/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>文本处理之awk</title>
    <url>/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B9%8Bawk/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h3><p>awk是一个强大的文本分析工具，与grep（查找）、sed（编辑）一并称为“文本处理三剑客”。awk最强大的功能是对数据分析并生成报告。</p>
<p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk是AWK的GNU版本。</p>
<p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。awk能读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分，将每片直接保存在内建的变量中，$1,$2,$3….，引用指定的变量，可以显示指定断，或者多个断。如果需要显示全部的，需要使用$0来引用。可以对单个片断进行判断，也可以对所有断进行循环判断。其默认分隔符为空格</p>
<ol>
<li>按行读取文本（文件的每一行称为记录）</li>
<li>按输入分隔符进行切片</li>
<li>对切片自动生命变量 $1,$2…（域标识；$0为所有域）</li>
<li>对指定目标做处理（处理及打印等）</li>
</ol>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>awk [options] ‘program’ FILE……</p>
<p>[options]<br>–F：指明输入时的分隔符<br>–v：自定义变量<br>–f：调用awk脚本<br>program:pattern{action statements;..}<br>-pattern：触发条件<br>-action statements：对数据处理动作</p>
<p>步骤</p>
<ol>
<li>执行BEGIN{action;…}<br>BEGIN在输入之前执行，通常用来打印表头，变量初始化。</li>
<li>读取，执行pattern{action;…}<br>默认执行{ print }</li>
<li>执行END{action;…}<br>读取到打印结束后执行，通常用作分析结果，信息汇总。</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>内置变量</strong></p>
<ul>
<li>FS：输入字段分隔符</li>
<li>OFS：输出字段分隔符</li>
<li>RS：输入记录分隔符</li>
<li>ORS：输出记录分隔符</li>
<li>ARGC：命令行参数的个数</li>
<li>ARGV：数组，保存命令行给定的各参数</li>
<li>NF：字段数量</li>
<li>NR：行号</li>
<li>FNR：个文件分别计数，行号</li>
<li>FILENAME：当前文件名</li>
</ul>
<p><strong>自定义变量</strong></p>
<ol>
<li>选项位置定义：-v var=hello</li>
<li>在program中定义：awk ‘BEGIN{test=”hello”;print test}’</li>
</ol>
<p><strong>字符串处理</strong></p>
<ol>
<li>length([s]) ：返回指定字符串的长度</li>
<li>sub(r,s,[t]) ：对t字符串进行搜索r 表示的模式匹配的内容，并将第一个匹配的内容替换为s<br>echo “2008:08:08 08:08:08″ | awk ‘sub(/:/,”-“,$0)’</li>
<li>gsub(r,s,[t]) ：对t字符串进行搜索r表示的模式匹配的内容，并全部替换为s所表示的内容<br>echo “2008:08:08 08:08:08″ | awk ‘gsub(/:/,”-“,$0)’</li>
<li>split(s,array,[r]) ：以r为分隔符，切割字符串s，并将切割后的结果保存至array 所表示的数组中，第一个索引值为1, 第二个索引值为2,…<br>netstat -tan | awk ‘/^tcp&gt;/{split($5,ip,”:”);count[ip[1]]++} END{for (i in count) {print i,count[i]}}’</li>
</ol>
<h3 id="Printf命令"><a href="#Printf命令" class="headerlink" title="Printf命令"></a>Printf命令</h3><ol>
<li>print不需要指定，printf需要<strong>指定format</strong></li>
<li>printf后面的字串需要使用<strong>双引号</strong></li>
<li>字串定义后的内容需要<strong>使用”,”分隔</strong>，后面直接跟Item1,item2….</li>
<li>format用于指定后面的每个item的输出格式</li>
<li>printf语句不会自动打印<strong>换行符\n</strong></li>
</ol>
<p><strong>格式符</strong></p>
<ol>
<li>%s: 显示字符串</li>
<li>%d,%i: 显示十进制整数</li>
<li>%e,%E: 科学计数法数值显示</li>
<li>%f: 显示为浮点数</li>
<li>%g,%G: 以科学数法或浮点形式显示数值</li>
<li>%c: 显示字符的ASCII码</li>
<li>%u: 无符号整数</li>
<li>%%: 显示%号自身，相当于转义</li>
</ol>
<p><strong>修饰符</strong></p>
<ol>
<li>N: 显示宽度</li>
<li>-: 左对齐（默认为右对齐）</li>
<li>+: 显示数值符号</li>
</ol>
<p><strong>操作符</strong></p>
<ul>
<li>算数<br>x+y, x-y, x*y, x/y, x^y, x%y</li>
<li>赋值<br>=, +=, -=, *=, /=, %=, ^=,++, —</li>
<li>比较<br>==, !=, &gt;, &gt;=, &lt;, &lt;=</li>
<li>模式匹配符<br><del>：左边是否和右边匹配包含!</del>：是否不匹配</li>
<li>逻辑<br>&amp;&amp;,||,!</li>
</ul>
<p>awk -F: ‘{printf “Username: %-15s,UID:%d\n”,$1,$3}’ /etc/passwd</p>
<h3 id="PROGRAM"><a href="#PROGRAM" class="headerlink" title="PROGRAM"></a>PROGRAM</h3><p><strong>pattern</strong></p>
<ol>
<li>）默认匹配每一行</li>
<li>）/pattern/：仅处理匹配到的行</li>
<li>）/pattern1/,/pattern2/：处理 pattern1 到 pattern2 之间</li>
<li>）关系表达式：真：非0假：空或0</li>
</ol>
<p><strong>action</strong></p>
<ol>
<li>）Expressions: 算术，比较表达式等</li>
<li>） Control statements ：if, while等</li>
<li>） Compound statements ：组合语句</li>
<li>） input statements</li>
<li>） output statements ：print等</li>
</ol>
<p><strong>控制语句</strong></p>
<ol>
<li>if-else<br>awk ‘BEGIN{ test=100;if(test&gt;90){print “very good”} else if(test&gt;60){ print “good”}else{print “no pass”}}’<br>成绩为100；大于90打印“very good”；大于60打印“good”；其余打印“no pass”</li>
<li>while 循环<br>条件”真”，进入循环；条件”假”，退出循环<br>awk ‘/^[[:space:]]*Linux16/{i=1;while(i&lt;=NF) {if(length($i)&gt;=10){print $i,length($i)}; i++}}’ /etc/grub2.cfg<br>以空白符开头后跟”Linux16″的行中，把字符数大于10的字符串打印出来。</li>
<li>do-while 循环<br>无论真假，至少执行一次<br>awk ‘BEGIN{ sum=0;i=0;do{sum+=i;i++;}while(i&lt;=100);print sum}’<br>累加</li>
<li>for 循环<br>遍历<br>awk ‘/^[[:space:]]*Linux16/{for(i=1;i&lt;=NF;i++) {print$i,length($i)}}’ /etc/grub2.cfg</li>
<li>switch 语句</li>
<li>break 和 continue<br>awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i%2==0)continue;sum+=i}print sum}’<br>awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i==66)break;sum+=i}print sum}’</li>
<li>next<br>提前 结束对本行处理而直接进入下一行处理<br>seq {1,20} | awk -F: ‘{if($1%2==0)next ; print $1}’<br>打印奇数行</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>）可使用任意字符串；字符串要使用双引号括起来</li>
<li>）如果某数组元素事先不存在，在引用时，awk 会自动创建此元素，并将其值初始化为“空字符串（即为”假”）”</li>
</ol>
<ul>
<li>若要判断数组中是否存在某元素，要使用“index in array”格式进行遍历</li>
</ul>
<p>示例练习：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs bsh">[root@localhost ~]# awk -F: &#39;$NF ~ &#x2F;bash$&#x2F;&#123;print $1,$NF&#125;&#39; &#x2F;etc&#x2F;passwd<br>root &#x2F;bin&#x2F;bash<br>wang &#x2F;bin&#x2F;bash<br>lao &#x2F;bin&#x2F;bash<br>cai &#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs bsh">[root@localhost ~]# awk -F: &#39;$NF&#x3D;&#x3D;&quot;&#x2F;bin&#x2F;bash&quot;&#123;print $1,$NF&#125;&#39; &#x2F;etc&#x2F;passwd<br>root &#x2F;bin&#x2F;bash<br>wang &#x2F;bin&#x2F;bash<br>lao &#x2F;bin&#x2F;bash<br>cai &#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs bsh">[root@localhost ~]# cat f<br>aa<br>bb<br>cc<br>dd<br>aa<br>bb<br>cc<br>dd<br>[root@localhost ~]# awk &#39;!arr[$0]++&#39; f<br>aa<br>bb<br>cc<br>dd<br>[root@localhost ~]# awk &#39;&#123;!arr[$0]++;print $0,arr[$0]&#125;&#39; f<br>aa 1<br>bb 1<br>cc 1<br>dd 1<br>aa 2<br>bb 2<br>cc 2<br>dd 2<br>[root@localhost ~]# awk &#39;&#x2F;^UUID&#x2F;||&#x2F;^\&#x2F;dev&#x2F;&#123;fs[$3]++&#125; END&#123;for (i in fs)&#123;print i,fs[i]&#125;&#125;&#39; &#x2F;etc&#x2F;fstab<br>swap 1<br>xfs 4<br>[root@localhost ~]# awk &#39;&#123;for(i&#x3D;1;i&lt;&#x3D;NF;i++)&#123;count[$i]++&#125;&#125;END&#123;for(i in count)&#123;print i,count[i]&#125;&#125;&#39; &#x2F;etc&#x2F;fstab<br>man 1<br>and&#x2F;or 1<br>maintained 1<br>xfs 4<br>Accessible 1<br>Thu 1<br>UUID&#x3D;63af8e82-3a2a-40ed-8f76-64f56502ee1c 1are 1<br>defaults 4<br>blkid(8) 1<br>&#x2F; 1<br>&#x2F;dev&#x2F;mapper&#x2F;cl-root 1<br>0 10<br>[root@localhost ~]# echo &quot;Yd$C@M05MB%9&amp;Bdh7dq+YVixp3vpw&quot; | awk -F &quot;[^[:digit:]]&quot; &#39;&#123;for(k&#x3D;1;k&lt;&#x3D;NF;k++)&#123;a[$k]&#125;&#125; END&#123;for(i in a) &#123;printf &quot;%s&quot;,i&#125;printf &quot;\n&quot;&#125;&#39;<br>79053<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈事件驱动和多路IO复用</title>
    <url>/%E6%B5%85%E8%B0%88%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="编程模式的变化"><a href="#编程模式的变化" class="headerlink" title="编程模式的变化"></a>编程模式的变化</h4><p>我们写服务器处理模型的程序时，有以下几种模型</p>
<blockquote>
<p>（1）每收到一个请求，创建一个新的进程，来处理该请求；<br> （2）每收到一个请求，创建一个新的线程，来处理该请求；<br> （3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</p>
</blockquote>
<p>第（1）种现在肯定是不用了，没有人会傻到每次新来一个任务就会创建一个进程。<br> 第（2）是比较常用的一种方式，但是一般大家都会想到一个问题，请求过多但是并不会无限制的创建线程，理论上也不可能一直创建线程，于是大家会采用<strong>线程池</strong>来处理。这是目前最常用的方式。但是创建线程池一定是完美的吗?当然不是，“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务，这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。<br> 第（3）中就是事件驱动模型,流程如下</p>
<blockquote>
<ol>
<li>有一个事件(消息)队列</li>
<li>鼠标按下时，往这个队列中增加一个点击事件(消息)；</li>
<li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li>
<li>事件(消息)一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；</li>
</ol>
</blockquote>
<h4 id="事件模型优点"><a href="#事件模型优点" class="headerlink" title="事件模型优点"></a>事件模型优点</h4><p>1、支持重用，容易并发处理；2、有良好的扩展性；3、只需要单进程单线程处理所有请求这一块，减少资源的消耗</p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p><img src="https:////upload-images.jianshu.io/upload_images/7240203-54c0f4f121bfa371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="img"></p>
<p>image.png</p>
<p>在同一个线程里面， 通过快速拨开关的方式，来同时传输多个I/O流，ngnix（采用epoll模型）会有很多链接进来， epoll（包含事件驱动机制）会把他们都监视起来，然后监控他们的状态（事件驱动机制），当谁的状态发生变化时，也就是事件驱动机制监控到状态的变化，然后像拨开关一样，谁有状态就拨向谁，然后调用相应的代码处理。</p>
<h5 id="出现的历史背景"><a href="#出现的历史背景" class="headerlink" title="出现的历史背景"></a>出现的历史背景</h5><h6 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h6><p>select、poll、epoll都是io多路复用的机制，区别如下</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/7240203-445c44dc22a7f7f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/959/format/webp" alt="img"></p>
<p>image.png</p>
<p>共同点就是大家都是io多路复用，不同点就是epoll采用事件驱动的方式。使得连接没有上限。</p>
<p>作者：帅子锅<br>链接：<a href="https://www.jianshu.com/p/eb827c49b679" target="_blank" rel="noopener">https://www.jianshu.com/p/eb827c49b679</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解select、poll和epoll及区别</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题：如果我们先前创建的几个进程承载不了目前快速发展的业务的话，是不是还得增加进程数？我们都知道系统创建进程是需要消耗大量资源的，所以这样就会导致系统资源不足的情况。</p>
<p>那么有没有一种方式可以让一个进程同时为多个客户端端提供服务？</p>
<p>接下来要讲的<strong>IO复用技术</strong>就是对于上述问题的最好解答。</p>
<p>对于IO复用，我们可以通过一个例子来很好的理解它。（</p>
<p>例子来自于《TCP/IP网络编程》）</p>
<p>某教室有10名学生和1名老师，这些学生上课会不停的提问，所以一个老师处理不了这么多的问题。那么学校为每个学生都配一名老师，也就是这个教室目前有10名老师。此后，只要有新的转校生，那么就会为这个学生专门分配一个老师，因为转校生也喜欢提问题。如果把以上例子中的学生比作客户端，那么老师就是负责进行数据交换的服务端。则该例子可以比作是多进程的方式。</p>
<p>后来有一天，来了一位具有超能力的老师，这位老师回答问题非常迅速，并且可以应对所有的问题。而这位老师采用的方式是学生提问前必须先举手，确认举手学生后在回答问题。则现在的情况就是IO复用。</p>
<h1 id="目前的常用的IO复用模型有三种：select，poll，epoll。"><a href="#目前的常用的IO复用模型有三种：select，poll，epoll。" class="headerlink" title="目前的常用的IO复用模型有三种：select，poll，epoll。"></a>目前的常用的IO复用模型有三种：select，poll，epoll。</h1><p>(1)select==&gt;时间复杂度O(n)</p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<p>(2)poll==&gt;时间复杂度O(n)</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p>
<p>(3)epoll==&gt;时间复杂度O(1)</p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p>
<p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p>
<p><strong>select：</strong></p>
<p><strong>select的调用过程如下所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223952.png" alt="img"></p>
<p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p>
<p>（2）注册回调函数__pollwait</p>
<p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p>
<p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p>
<p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p>
<p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p>
<p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p>
<p>（8）把fd_set从内核空间拷贝到用户空间。</p>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>
<p>   一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p>
<p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p>
<p>​    当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p>
<p><strong>poll：</strong></p>
<p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多,管理多个描述符也是进行轮询，根据描述符的状态进行处理，<strong>但是poll没有最大文件描述符数量的限制</strong>。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。          </p>
<p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<p><strong>epoll:</strong></p>
<p>epoll有EPOLL LT和EPOLL ET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
<p><strong>epoll为什么要有EPOLL ET触发模式？</strong></p>
<p>如果采用EPOLL LT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLL ET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！<strong>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</strong></p>
<p><strong>epoll的优点：</strong></p>
<p>1、<strong>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</strong>；<br><strong>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p>
<p><strong>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</strong></p>
<p>epoll既然是对select和poll的改进，就应该能避免上述缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</p>
<p>　　epoll没有FD个数这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h1 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a><strong>select、poll、epoll 区别总结：</strong></h1><p>1、支持一个进程所能打开的最大连接数</p>
<p>select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p>
<p>poll：poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
<p>epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</p>
<p>2、FD剧增后带来的IO效率问题</p>
<p>select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p>
<p>poll：同上</p>
<p>epoll：因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p>
<p>3、 消息传递方式</p>
<p>select：内核需要将消息传递到用户空间，都需要内核拷贝动作</p>
<p>poll：同上</p>
<p>epoll：epoll通过内核和用户空间共享一块内存来实现的。</p>
<p><strong>总结：</strong></p>
<p><strong>综上，在选择select，p**</strong>oll，epoll时要根据具体的使用场合以及这三种方式的自身特点。**</p>
<p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p>
<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong> </p>
<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<h1 id="epoll-IO多路复用模型实现机制详解"><a href="#epoll-IO多路复用模型实现机制详解" class="headerlink" title="epoll IO多路复用模型实现机制详解"></a>epoll IO多路复用模型实现机制详解</h1><p>由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</p>
<p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</p>
<p>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</p>
<p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p>
<p>3）调用epoll_wait收集发生的事件的连接</p>
<p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>
<h2 id="下面来看看Linux内核具体的epoll机制实现思路。"><a href="#下面来看看Linux内核具体的epoll机制实现思路。" class="headerlink" title="下面来看看Linux内核具体的epoll机制实现思路。"></a>下面来看看Linux内核具体的epoll机制实现思路。</h2><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> eventpoll&#123;<br>    ....<br>    <span class="hljs-comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><br>    <span class="hljs-keyword">struct</span> rb_root  rbr;<br>    <span class="hljs-comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span><br>    <span class="hljs-keyword">struct</span> list_head rdlist;<br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>
<p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> epitem&#123;<br>    <span class="hljs-keyword">struct</span> rb_node  rbn;<span class="hljs-comment">//红黑树节点</span><br>    <span class="hljs-keyword">struct</span> list_head    rdllink;<span class="hljs-comment">//双向链表节点</span><br>    <span class="hljs-keyword">struct</span> epoll_filefd  ffd;  <span class="hljs-comment">//事件句柄信息</span><br>    <span class="hljs-keyword">struct</span> eventpoll *ep;    <span class="hljs-comment">//指向其所属的eventpoll对象</span><br>    <span class="hljs-keyword">struct</span> epoll_event event; <span class="hljs-comment">//期待发生的事件类型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201223953.png" alt="img"></p>
<p>从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</p>
<p>OK，讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。</p>
<p>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p>
<p>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。</p>
<p>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//   </span><br><span class="hljs-comment">// a simple echo server using epoll in linux  </span><br><span class="hljs-comment">//    </span><br><span class="hljs-comment">// 2013-03-22:修改了几个问题，1是/n格式问题，2是去掉了原代码不小心加上的ET模式;</span><br><span class="hljs-comment">// 本来只是简单的示意程序，决定还是加上 recv/send时的buffer偏移</span><br><span class="hljs-comment">// by sparkling  </span><br><span class="hljs-comment">//   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;  </span></span><br>using namespace std;  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENTS 500  </span><br><span class="hljs-keyword">struct</span> myevent_s  <br>&#123;  <br>    <span class="hljs-keyword">int</span> fd;  <br>    <span class="hljs-keyword">void</span> (*call_back)(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span> *arg);  <br>    <span class="hljs-keyword">int</span> events;  <br>    <span class="hljs-keyword">void</span> *arg;  <br>    <span class="hljs-keyword">int</span> status; <span class="hljs-comment">// 1: in epoll wait list, 0 not in  </span><br>    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">128</span>]; <span class="hljs-comment">// recv data buffer  </span><br>    <span class="hljs-keyword">int</span> len, s_offset;  <br>    <span class="hljs-keyword">long</span> last_active; <span class="hljs-comment">// last active time  </span><br>&#125;;  <br><span class="hljs-comment">// set event  </span><br><span class="hljs-keyword">void</span> EventSet(myevent_s *ev, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> (*call_back)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>*), <span class="hljs-keyword">void</span> *arg)  <br>&#123;  <br>    ev-&gt;fd = fd;  <br>    ev-&gt;call_back = call_back;  <br>    ev-&gt;events = <span class="hljs-number">0</span>;  <br>    ev-&gt;arg = arg;  <br>    ev-&gt;status = <span class="hljs-number">0</span>;<br>    bzero(ev-&gt;buff, <span class="hljs-keyword">sizeof</span>(ev-&gt;buff));<br>    ev-&gt;s_offset = <span class="hljs-number">0</span>;  <br>    ev-&gt;len = <span class="hljs-number">0</span>;<br>    ev-&gt;last_active = time(<span class="hljs-literal">NULL</span>);  <br>&#125;  <br><span class="hljs-comment">// add/mod an event to epoll  </span><br><span class="hljs-keyword">void</span> EventAdd(<span class="hljs-keyword">int</span> epollFd, <span class="hljs-keyword">int</span> events, myevent_s *ev)  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> epoll_event epv = &#123;<span class="hljs-number">0</span>, &#123;<span class="hljs-number">0</span>&#125;&#125;;  <br>    <span class="hljs-keyword">int</span> op;  <br>    epv.data.ptr = ev;  <br>    epv.events = ev-&gt;events = events;  <br>    <span class="hljs-keyword">if</span>(ev-&gt;status == <span class="hljs-number">1</span>)&#123;  <br>        op = EPOLL_CTL_MOD;  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>&#123;  <br>        op = EPOLL_CTL_ADD;  <br>        ev-&gt;status = <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(epoll_ctl(epollFd, op, ev-&gt;fd, &amp;epv) &lt; <span class="hljs-number">0</span>)  <br>        printf(<span class="hljs-string">"Event Add failed[fd=%d], evnets[%d]\n"</span>, ev-&gt;fd, events);  <br>    <span class="hljs-keyword">else</span>  <br>        printf(<span class="hljs-string">"Event Add OK[fd=%d], op=%d, evnets[%0X]\n"</span>, ev-&gt;fd, op, events);  <br>&#125;  <br><span class="hljs-comment">// delete an event from epoll  </span><br><span class="hljs-keyword">void</span> EventDel(<span class="hljs-keyword">int</span> epollFd, myevent_s *ev)  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> epoll_event epv = &#123;<span class="hljs-number">0</span>, &#123;<span class="hljs-number">0</span>&#125;&#125;;  <br>    <span class="hljs-keyword">if</span>(ev-&gt;status != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <br>    epv.data.ptr = ev;  <br>    ev-&gt;status = <span class="hljs-number">0</span>;<br>    epoll_ctl(epollFd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);  <br>&#125;  <br><span class="hljs-keyword">int</span> g_epollFd;  <br>myevent_s g_Events[MAX_EVENTS+<span class="hljs-number">1</span>]; <span class="hljs-comment">// g_Events[MAX_EVENTS] is used by listen fd  </span><br><span class="hljs-keyword">void</span> RecvData(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span> *arg);  <br><span class="hljs-keyword">void</span> SendData(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span> *arg);  <br><span class="hljs-comment">// accept new connections from clients  </span><br><span class="hljs-keyword">void</span> AcceptConn(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span> *arg)  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> sockaddr_in sin;  <br>    socklen_t len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);  <br>    <span class="hljs-keyword">int</span> nfd, i;  <br>    <span class="hljs-comment">// accept  </span><br>    <span class="hljs-keyword">if</span>((nfd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;sin, &amp;len)) == <span class="hljs-number">-1</span>)  <br>    &#123;  <br>        <span class="hljs-keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)  <br>        &#123;  <br>        &#125;<br>        printf(<span class="hljs-string">"%s: accept, %d"</span>, __func__, errno);  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">do</span>  <br>    &#123;  <br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; MAX_EVENTS; i++)  <br>        &#123;  <br>            <span class="hljs-keyword">if</span>(g_Events[i].status == <span class="hljs-number">0</span>)  <br>            &#123;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(i == MAX_EVENTS)  <br>        &#123;  <br>            printf(<span class="hljs-string">"%s:max connection limit[%d]."</span>, __func__, MAX_EVENTS);  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        <span class="hljs-comment">// set nonblocking</span><br>        <span class="hljs-keyword">int</span> iret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>((iret = fcntl(nfd, F_SETFL, O_NONBLOCK)) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            printf(<span class="hljs-string">"%s: fcntl nonblocking failed:%d"</span>, __func__, iret);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// add a read event for receive data  </span><br>        EventSet(&amp;g_Events[i], nfd, RecvData, &amp;g_Events[i]);  <br>        EventAdd(g_epollFd, EPOLLIN, &amp;g_Events[i]);  <br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>);  <br>    printf(<span class="hljs-string">"new conn[%s:%d][time:%d], pos[%d]\n"</span>, inet_ntoa(sin.sin_addr),<br>            ntohs(sin.sin_port), g_Events[i].last_active, i);  <br>&#125;  <br><span class="hljs-comment">// receive data  </span><br><span class="hljs-keyword">void</span> RecvData(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span> *arg)  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> myevent_s *ev = (<span class="hljs-keyword">struct</span> myevent_s*)arg;  <br>    <span class="hljs-keyword">int</span> len;  <br>    <span class="hljs-comment">// receive data</span><br>    len = recv(fd, ev-&gt;buff+ev-&gt;len, <span class="hljs-keyword">sizeof</span>(ev-&gt;buff)<span class="hljs-number">-1</span>-ev-&gt;len, <span class="hljs-number">0</span>);    <br>    EventDel(g_epollFd, ev);<br>    <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ev-&gt;len += len;<br>        ev-&gt;buff[len] = <span class="hljs-string">'\0'</span>;  <br>        printf(<span class="hljs-string">"C[%d]:%s\n"</span>, fd, ev-&gt;buff);  <br>        <span class="hljs-comment">// change to send event  </span><br>        EventSet(ev, fd, SendData, ev);  <br>        EventAdd(g_epollFd, EPOLLOUT, ev);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)  <br>    &#123;  <br>        close(ev-&gt;fd);  <br>        printf(<span class="hljs-string">"[fd=%d] pos[%d], closed gracefully.\n"</span>, fd, ev-g_Events);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        close(ev-&gt;fd);  <br>        printf(<span class="hljs-string">"recv[fd=%d] error[%d]:%s\n"</span>, fd, errno, strerror(errno));  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// send data  </span><br><span class="hljs-keyword">void</span> SendData(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span> *arg)  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> myevent_s *ev = (<span class="hljs-keyword">struct</span> myevent_s*)arg;  <br>    <span class="hljs-keyword">int</span> len;  <br>    <span class="hljs-comment">// send data  </span><br>    len = send(fd, ev-&gt;buff + ev-&gt;s_offset, ev-&gt;len - ev-&gt;s_offset, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)  <br>    &#123;<br>        printf(<span class="hljs-string">"send[fd=%d], [%d&lt;-&gt;%d]%s\n"</span>, fd, len, ev-&gt;len, ev-&gt;buff);<br>        ev-&gt;s_offset += len;<br>        <span class="hljs-keyword">if</span>(ev-&gt;s_offset == ev-&gt;len)<br>        &#123;<br>            <span class="hljs-comment">// change to receive event</span><br>            EventDel(g_epollFd, ev);  <br>            EventSet(ev, fd, RecvData, ev);  <br>            EventAdd(g_epollFd, EPOLLIN, ev);  <br>        &#125;<br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        close(ev-&gt;fd);  <br>        EventDel(g_epollFd, ev);  <br>        printf(<span class="hljs-string">"send[fd=%d] error[%d]\n"</span>, fd, errno);  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">void</span> InitListenSocket(<span class="hljs-keyword">int</span> epollFd, <span class="hljs-keyword">short</span> port)  <br>&#123;  <br>    <span class="hljs-keyword">int</span> listenFd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);  <br>    fcntl(listenFd, F_SETFL, O_NONBLOCK); <span class="hljs-comment">// set non-blocking  </span><br>    printf(<span class="hljs-string">"server listen fd=%d\n"</span>, listenFd);  <br>    EventSet(&amp;g_Events[MAX_EVENTS], listenFd, AcceptConn, &amp;g_Events[MAX_EVENTS]);  <br>    <span class="hljs-comment">// add listen socket  </span><br>    EventAdd(epollFd, EPOLLIN, &amp;g_Events[MAX_EVENTS]);  <br>    <span class="hljs-comment">// bind &amp; listen  </span><br>    sockaddr_in sin;  <br>    bzero(&amp;sin, <span class="hljs-keyword">sizeof</span>(sin));  <br>    sin.sin_family = AF_INET;  <br>    sin.sin_addr.s_addr = INADDR_ANY;  <br>    sin.sin_port = htons(port);  <br>    bind(listenFd, (<span class="hljs-keyword">const</span> sockaddr*)&amp;sin, <span class="hljs-keyword">sizeof</span>(sin));  <br>    listen(listenFd, <span class="hljs-number">5</span>);  <br>&#125;  <br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)  <br>&#123;  <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port = <span class="hljs-number">12345</span>; <span class="hljs-comment">// default port  </span><br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)&#123;  <br>        port = atoi(argv[<span class="hljs-number">1</span>]);  <br>    &#125;  <br>    <span class="hljs-comment">// create epoll  </span><br>    g_epollFd = epoll_create(MAX_EVENTS);  <br>    <span class="hljs-keyword">if</span>(g_epollFd &lt;= <span class="hljs-number">0</span>) printf(<span class="hljs-string">"create epoll failed.%d\n"</span>, g_epollFd);  <br>    <span class="hljs-comment">// create &amp; bind listen socket, and add to epoll, set non-blocking  </span><br>    InitListenSocket(g_epollFd, port);  <br>    <span class="hljs-comment">// event loop  </span><br>    <span class="hljs-keyword">struct</span> epoll_event events[MAX_EVENTS];  <br>    printf(<span class="hljs-string">"server running:port[%d]\n"</span>, port);  <br>    <span class="hljs-keyword">int</span> checkPos = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;  <br>        <span class="hljs-comment">// a simple timeout check here, every time 100, better to use a mini-heap, and add timer event  </span><br>        <span class="hljs-keyword">long</span> now = time(<span class="hljs-literal">NULL</span>);  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++, checkPos++) <span class="hljs-comment">// doesn't check listen fd  </span><br>        &#123;  <br>            <span class="hljs-keyword">if</span>(checkPos == MAX_EVENTS) checkPos = <span class="hljs-number">0</span>; <span class="hljs-comment">// recycle  </span><br>            <span class="hljs-keyword">if</span>(g_Events[checkPos].status != <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;  <br>            <span class="hljs-keyword">long</span> duration = now - g_Events[checkPos].last_active;  <br>            <span class="hljs-keyword">if</span>(duration &gt;= <span class="hljs-number">60</span>) <span class="hljs-comment">// 60s timeout  </span><br>            &#123;  <br>                close(g_Events[checkPos].fd);  <br>                printf(<span class="hljs-string">"[fd=%d] timeout[%d--%d].\n"</span>, g_Events[checkPos].fd, g_Events[checkPos].last_active, now);  <br>                EventDel(g_epollFd, &amp;g_Events[checkPos]);  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// wait for events to happen  </span><br>        <span class="hljs-keyword">int</span> fds = epoll_wait(g_epollFd, events, MAX_EVENTS, <span class="hljs-number">1000</span>);  <br>        <span class="hljs-keyword">if</span>(fds &lt; <span class="hljs-number">0</span>)&#123;  <br>            printf(<span class="hljs-string">"epoll_wait error, exit\n"</span>);  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fds; i++)&#123;  <br>            myevent_s *ev = (<span class="hljs-keyword">struct</span> myevent_s*)events[i].data.ptr;  <br>            <span class="hljs-keyword">if</span>((events[i].events&amp;EPOLLIN)&amp;&amp;(ev-&gt;events&amp;EPOLLIN)) <span class="hljs-comment">// read event  </span><br>            &#123;  <br>                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>((events[i].events&amp;EPOLLOUT)&amp;&amp;(ev-&gt;events&amp;EPOLLOUT)) <span class="hljs-comment">// write event  </span><br>            &#123;  <br>                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// free resource  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>理解同步,异步,阻塞,非阻塞,多路复用,事件驱动IO</title>
    <url>/%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8IO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="以下是IO的一个基本过程"><a href="#以下是IO的一个基本过程" class="headerlink" title="以下是IO的一个基本过程"></a>以下是IO的一个基本过程</h3><p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233937.png" alt="img"></p>
<p>先理解一下用户空间和内核空间，系统为了保护内核数据，会将寻址空间分为用户空间和内核空间，32位机器为例，高1G字节作为内核空间，低3G字节作为用户空间。当用户程序读取数据的时候，会经历两个过程：磁盘到内核空间（这块消耗性能，下面简称内核数据准备），内核空间拷贝到用户空间（下面简称用户空间拷贝）。</p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233938.png" alt="img"></p>
<p>内核数据准备这部分是由DMA芯片实现的，而用户空间拷贝的实现则是由CPU实现的，后者非常快，能到1G以上，所以，所谓的阻塞基本是内核数据准备的过程，这块消耗时间。为啥呢？简单的理解就是，磁盘和内核缓存的速度本身就存在很大的差距。</p>
<h3 id="基于这个前提，聊一下同步异步IO，阻塞非阻塞IO"><a href="#基于这个前提，聊一下同步异步IO，阻塞非阻塞IO" class="headerlink" title="基于这个前提，聊一下同步异步IO，阻塞非阻塞IO"></a>基于这个前提，聊一下同步异步IO，阻塞非阻塞IO</h3><p><strong>同步异步是基于任务序列可靠性的角度区分</strong>，当一个任务依赖另外一个任务时，</p>
<p>同步就是，只有等被依赖的任务完成之后，依赖任务才算完成，是一种可靠任务序列。比如打电话。</p>
<p>异步就是，只是通知被依赖任务去做某件事情，由被依赖任务完成之后通知依赖任务，但是不能保证被依赖任务完成，是一个不可靠任务序列。比如发短信。</p>
<p>同步异步的选择其实就是可靠性和性能之前的取舍和平衡。</p>
<p><strong>而阻塞非阻塞则是从CPU消耗的角度去区分</strong>。</p>
<p>阻塞就是让CPU闲置，等IO等慢操作完成之后再继续。</p>
<p>非阻塞则是在等IO等慢操作的完成的同时，CPU去做一些其他事情。存在上下文切换。</p>
<p>阻塞非阻塞的选择就是在CPU利用率和系统切换成本之间的平衡。</p>
<p><strong>上面四者两两组合情况如下</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233939.png" alt="img"></p>
<h3 id="接下来了解一下linux下的几种IO模型"><a href="#接下来了解一下linux下的几种IO模型" class="headerlink" title="接下来了解一下linux下的几种IO模型"></a>接下来了解一下linux下的几种IO模型</h3><p>当我们进行IO操作的时候，如果被调用者将任务全部执行完返回，称为<strong>同步/阻塞 IO</strong>。</p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233940.png" alt="img"></p>
<p>如果被调用者，不管没有操作成功，直接返回一个结果码，但是不再主动通知后续结果，称为<strong>非阻塞IO</strong>；这种情况下需要重复调用查询状态。</p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233941.png" alt="img"></p>
<p>如果被调用者，不管有没有操作成功，直接返回个结果码，等到全部操作完成之后再发一个信号通知调用者，称为<strong>异步IO</strong>。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233942.png" alt="img"></p>
<h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><p>家里有个专门帮忙做饭的阿姨，有一天我想喝水了，我让阿姨帮忙烧一壶水。</p>
<p>我看着她去烧水，灌水，给我倒水，期间没有做其他任何事情，这就是同步。</p>
<p>我想着也不用一直等，可以先看会儿电视，我就隔一会儿来看一次，隔一会儿来看一次，这叫非阻塞。</p>
<p>再想想，这也烦，我索性跟阿姨说，好了叫我一声，然后就去看电视去了，这叫异步。</p>
<h3 id="而IO多路复用，信号驱动IO则是基于前面四个模型的衍生。"><a href="#而IO多路复用，信号驱动IO则是基于前面四个模型的衍生。" class="headerlink" title="而IO多路复用，信号驱动IO则是基于前面四个模型的衍生。"></a>而IO多路复用，信号驱动IO则是基于前面四个模型的衍生。</h3><p><strong>IO多路复用</strong>是基于阻塞IO的衍生，主要是为了提高内核空间数据准备这一块的功能复用，即阻塞的同时监听多个端口，有一个端口有数据就进行处理，提高性能。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233943.png" alt="img"></p>
<p><strong>信号驱动IO</strong>则是在内核空间数据准备这一块采用异步，在用户空间拷贝这一块采用同步。</p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233944.png" alt="img"></p>
<h2 id="Java中的IO则分为以下几种"><a href="#Java中的IO则分为以下几种" class="headerlink" title="Java中的IO则分为以下几种"></a>Java中的IO则分为以下几种</h2><p><strong>同步阻塞IO</strong>（Java IO）</p>
<p>l 用户进程发起一个IO操作之后，必须等待IO操作完成。</p>
<p><strong>同步非阻塞IO</strong>（Java NIO）</p>
<p>l 用户发起一个IO操作之后，返回做其他事情，时不时的去询问IO是否就绪。</p>
<p><strong>多路复用IO</strong></p>
<p>l 用户发起一个IO操作之后，返回，等内核完成IO之后通知应用程序，这里的阻塞是指返回之后并没有做其他是，而是一并监听多个文件句柄，在select函数中，提高系统并发性。</p>
<p><strong>异步非阻塞IO</strong>（Java NIO2）</p>
<p>l 用户发起一个IO操作之后，返回，等待 内核数据准备 和 用户空间拷贝都完成之后通知应用进程，中有实现。</p>
<p>NIO中的概念</p>
<p><strong>Buffer</strong>：高效的数据容器，除了布尔类型，所有数据类型都有相应的Buffer实现。</p>
<p><strong>Channel</strong>：作用类似Linux系统中的文件描述符，是用于支持抽象批量IO的一种抽象。相对于File/Socket：Channel是更加接近操作系统底层的一种抽象。</p>
<p><strong>Selector</strong>：是NIO中多路复用的基础，可以同时检测注册在Selector上的多个Channel，进而对准备好的任一Channel进行处理。（这部分在linux中依赖epoll，windows上依赖iocp）</p>
<p><strong>Charset</strong>,提供了字符编解码器，可以实现字符到ByteBuffer的转换。</p>
<p><strong>内存映射</strong>：可以将内核空间地址和用户空间地址映射到同一物理地址</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233945.png" alt="img"></p>
<p><strong>零拷贝技术</strong>：数据只在内核空间流转，没有经过用户空间。</p>
<p> <img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201233946.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>生日记录</title>
    <url>/%E7%94%9F%E6%97%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="生日记录"><a href="#生日记录" class="headerlink" title="生日记录"></a>生日记录</h2><table>
<thead>
<tr>
<th></th>
<th>生日日期（农历）</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>家姐</td>
<td>十一月初七</td>
<td></td>
</tr>
<tr>
<td>羊咩</td>
<td></td>
<td></td>
</tr>
<tr>
<td>飞猪</td>
<td></td>
<td></td>
</tr>
<tr>
<td>阿妈</td>
<td></td>
<td></td>
</tr>
<tr>
<td>阿爸</td>
<td></td>
<td></td>
</tr>
<tr>
<td>我</td>
<td>四月初十</td>
<td></td>
</tr>
</tbody></table>
<iframe height=480 width=800 src="//player.bilibili.com/player.html?aid=457933273&bvid=BV1h541157nQ&cid=259407474&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
  </entry>
  <entry>
    <title>### 硬盘机制</title>
    <url>/%E7%A1%AC%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>系统启动和内核管理</title>
    <url>/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载:<a href="https://blog.51cto.com/13683480/2120916" target="_blank" rel="noopener">https://blog.51cto.com/13683480/2120916</a></p>
<p>​        Centos5和6的启动流程</p>
<p>​           服务管理</p>
<p>​           Grub管理</p>
<p>​        自制Linux</p>
<p>​        启动排错</p>
<p>​        编译安装内核</p>
<p>​        Centos7启动流程</p>
<p>​           Unit介绍</p>
<p>​           服务管理和查看</p>
<p>​           启动排错</p>
<p>​           破解口令</p>
<p>​           修复grub2</p>
<p>Linux组成：———————————————————————</p>
<p>​        Linux：kernel+rootfs</p>
<p>​               kernel：进程管理、内存管理、网络管理、驱动程序、文件系统、安全功能</p>
<p>​               rootfs：程序和glibc</p>
<p>​              库：函数集合，function，调用接口</p>
<p>​                      过程调用：procedure，无返回值</p>
<p>​                      函数调用：function</p>
<p>​               程序：二进制执行文件</p>
<p>​        内核设计流派：</p>
<p>​              单内核（monolithic kernel）：linux</p>
<p>​                      把所有功能集成于同一个程序</p>
<p>​              微内核（micro kernel）：windows，solaris</p>
<p>内核：</p>
<p>​        linux内核特点：</p>
<p>​              支持模块化：.ko</p>
<p>​                      如：文件系统，硬件驱动，网络协议等</p>
<p>​               支持内核模块的动态装载和卸载</p>
<p>​        组成部分</p>
<p>​              核心文件：/boot/vmlinuz-VERSION-release</p>
<p>​                      ramdisk:辅助的伪根文件系统</p>
<p>​                          centos5：/boot/initrd-VERSION-release.img</p>
<p>​                          centos6,7:/boot/initramfs-VERSION-release.img</p>
<p>​              模块文件：/lib/modules/VERSION-release</p>
<p>Centos5,6 启动流程：—————————————————————-</p>
<p>​        </p>
<p>​        post–mbr引导–bootloader加载grub–加载内核–启动init–读取默认运行级别–</p>
<p>​        –执行rc.sysinit系统初始化脚本–根据运行级别执行rc N，开启运行级别下默认开启的服务</p>
<p>​        –执行/etc/rc.d下rc.local–执行/bin/login，等待用户登录</p>
<p>​        POST加电自检</p>
<p>​        boot sequence 按照启动顺序查找第一个拥有启动功能的设备</p>
<p>​        读取MBR前446个字节的bootloador，也就是grub第一阶段</p>
<p>​        第一阶段的目的是在磁盘分区表之后的扇区上寻找grub1.5阶段</p>
<p>​        grub1.5阶段读取boot分区文件系统驱动，并且找到boot分区，读取grub第2阶段</p>
<p>​        grub第2阶段会根据事先写好的配置文件加载选定内核 和ramdisk或ramfs</p>
<p>​        内核启动之后首先会进行自身初始化，加载硬件驱动程序（可能借助于ramdisk或者ramfs）</p>
<p>​        内核完成初始化之后，找根，借助grub.conf第二阶段配置文件root=找到根</p>
<p>​        借助ramdisk或者ramfs加载真正的根文件系统驱动，之后只读挂载真正的根文件系统</p>
<p>​        启动第一个进程/sbin/init，centos5  /etc/inittab centos6 /etc/inittab /etc/init/*.conf</p>
<p>​        根据运行配置文件运行默认运行级别</p>
<p>​        运行/etc/rc.d/rc.sysinit 初始化脚本</p>
<p>​              1   设置主机名</p>
<p>​              2   设置欢迎信息</p>
<p>​              3   激活udev和selinux</p>
<p>​              4   挂载/etc/fstab文件中定义的文件系统</p>
<p>​              5   检测根文件系统，并以读写方式重新挂载根文件系统</p>
<p>​              6   设置系统时钟</p>
<p>​              7   激活swap设备</p>
<p>​              8   根据/etc/sysctl.conf文件设置内核参数</p>
<p>​              9   激活lvm及software.conf文件设置内核参数</p>
<p>​              10  加载额外设备的驱动程序</p>
<p>​              11  清理操作</p>
<p>​        根据选择的运行级别，执行rc N，关闭/开启 对应级别的服务以及/etc/rc.d/rc.local</p>
<p>​        执行/bin/login，等待用户登录</p>
<p>​        登录之后开启shell获取控制权</p>
<p>​     </p>
<p>启动流程：</p>
<p>​        POST：power-on-self-test，加电自检，是bios功能的一个主要部分。负责完成对cpu、</p>
<p>​            主板、内存、硬盘子系统、显示子系统、串并行接口、键盘、CD-ROM光驱等硬件情况的检测</p>
<p>​              ROM：bios（basic input and output  system），保存着有关计算机系统最重要的</p>
<p>​                   基本输入输出程序，系统信息设置，开机加电自检程序和系统启动自举程序等</p>
<p>​              RAM：CMOS互补禁书氧化物半导体，保存各项参数的设定</p>
<p>​               按次序查找引到设备，第一个有引到程序的设备为本次启动设备</p>
<p>​        </p>
<p>​        bootloader：引到加载器，引到程序</p>
<p>​              window：ntloader，仅是启动os</p>
<p>​               linux：功能丰富，提供菜单，雨荨用户选择要启动系统或不同的内核版本，把用户选定的</p>
<p>​                   内核装载到内存中的特定空间中，解压，展开，并把系统控制权移交给内核</p>
<p>​                      lolo：linux loader</p>
<p>​                      grub：grand unified  bootloader</p>
<p>​                      </p>
<p>​        MBR：446 bootloader ，64  分区表，2 55AA标识符</p>
<p>​        </p>
<p>​        Grub：   stage1 bootloader</p>
<p>​              stage1.5 0扇区之后的扇区</p>
<p>​              stage2      磁盘文件系统上，boot目录下</p>
<p>​        </p>
<p>​        kernel 自身初始化：</p>
<p>​               探测可识别到的所有硬件设备</p>
<p>​               加载硬件驱动程序（借助于ramdisk加载驱动）</p>
<p>​               以只读方式挂载根文件系统</p>
<p>​               运行用户空间的第一个应用程序：/sbin/init</p>
<p>​               </p>
<p>​        ramdisk:</p>
<p>​              与内核一起被grub加载进内存，放在内存指定的地方，模拟磁盘上的微型根文件系统</p>
<p>​               centos5,6上为gz压缩之后的cpio文件，如要查看，改名解压 使用cpio -tv &lt;  查看</p>
<p>​              centos7  直接为cpio文件，没有压缩</p>
<p>​               </p>
<p>​              centos 5 initrd</p>
<p>​                      工具程序：mkinitrd</p>
<p>​              centos 6,7   initramfs</p>
<p>​                      工具程序，mkinitrd,dracut</p>
<p>​               </p>
<p>ramdisk管理：</p>
<p>​        ramdisk文件的制作：</p>
<p>mkinitrd     1.    mkinitrd命令</p>
<p>​               为当前正在使用的内核重新制作ramdisk文件</p>
<p>​              mkinitrd  /boot/initramfs-<code>uname -r</code>.img $<code>uname -r</code></p>
<p>dracut          2   dracut命令</p>
<p>​               为当前正在使用的内核重新制作ramdisk文件</p>
<p>​              dracut  /boot/initramfs-<code>uname -r</code>.img $<code>uname -r</code></p>
<p>​        PS:  mkinitrd 本是是一个脚本  根据参数：  $(uname -r)  来生成initramfs文件</p>
<p>init程序：</p>
<p>​        init程序的类型：</p>
<p>​              sysv:init  centos5之前</p>
<p>​                      配置文件：   /etc/inittab</p>
<p>​              upstart:init,centos  6</p>
<p>​                      配置文件：   /etc/inittab,/etc/init/*.conf</p>
<p>​               systemd:systemd,centos7</p>
<p>​                      配置文件：   /usr/lib/systemd/system</p>
<p>​                                 /etc/systemd/system</p>
<p>​        PS:     init命令通过  /var/lock/subsys/文件存在与否来判断服务是否是开启状态                        </p>
<p>/etc/inittab 文件：</p>
<p>​              初始运行级别（0-6）      centos6 只剩这一项了</p>
<p>​              系统初始化脚本，/etc/rc.d/rc.sysinit</p>
<p>​              rc N  运行对应级别的脚本目录</p>
<p>​               捕获某个关键字顺序</p>
<p>​              定义UPS电源终端、恢复脚本</p>
<p>​              在虚拟控制台生成getty，mingetty会自动调用login程序</p>
<p>​              在运行级别5初始化X</p>
<p>​        </p>
<p>​        每一行定义一种action以及与之对应的process</p>
<p>​           id：runlevel：action：process</p>
<p>​        </p>
<p>​        action：</p>
<p>​               wait：切换至此级别运行一次</p>
<p>​               respawn：此process终止，就重新启动</p>
<p>​               initdefault：设定默认运行级别；process省略</p>
<p>​               sysinit：设定系统初始化方式，此处一般为指定  /etc/rc.d/rc.sysinit</p>
<p>​        </p>
<p>​        ca::ctrlaltdel:/sbin/shutdown -t3 -r now  ctrl+alt+del 重启</p>
<p>​        </p>
<p>/etc/rc.d/rc.sysinit 初始化脚本</p>
<p>​              1   设置主机名</p>
<p>​              2   设置欢迎信息</p>
<p>​              3   激活udev和selinux</p>
<p>​              4   挂载/etc/fstab文件中定义的文件系统</p>
<p>​              5   检测根文件系统，并以读写方式重新挂载根文件系统</p>
<p>​              6   设置系统时钟</p>
<p>​              7   激活swap设备</p>
<p>​              8   根据/etc/sysctl.conf文件设置内核参数</p>
<p>​              9   激活lvm及software.conf文件设置内核参数</p>
<p>​              10  加载额外设备的驱动程序</p>
<p>​              11  清理操作</p>
<p>​          </p>
<p>CentOS 6 /etc/inittab和相关文件   </p>
<p>​            /etc/inittab</p>
<p>​                   设置系统默认的运行级别</p>
<p>​                   id:3:initdefault:</p>
<p>​           /etc/init/control-alt  -delete.conf</p>
<p>​            /etc/init/tty.conf</p>
<p>​           /etc/init/start  -ttys.conf</p>
<p>​            /etc/init/rc.conf</p>
<p>​           /etc/init/prefdm.conf      ·</p>
<p>rc N ：</p>
<p>​        N为运行级别，读取/etc/rc.d/rcN.d/中的文件</p>
<p>​           K<em>，K##</em>: 关闭服务，数字越小，越先运行；数字越小的服务，通常为依赖到别的服务</p>
<p>​           S<em>，S##</em>: 开启服务，数字越小，越先运行；数字越小的服务，通常为被依赖到的服务</p>
<p>​     注意：   正常级别下，最后启动一个服务S99local没有链接至/etc/rc.d/init.d一个</p>
<p>​               服务脚本，而是指向了/etc/rc.d/rc.local脚本</p>
<p>​           不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录，且又想开机时自动运行</p>
<p>​               的命令，可直接放置于/etc/rc.d/rc.local文件中</p>
<p>​            /etc/rc.d/rc.local在指定运行级别脚本后运行</p>
<p>​           可以根据情况，进行自定义修改</p>
<p>init：服务管理命令—————————————————————-</p>
<p>chkconfig命令：</p>
<p>​        查看服务在所有级别的启动或者关闭设定</p>
<p>​              chkconfig [–list]  name</p>
<p>​        添加服务：</p>
<p>​               SysV的服务脚本放在/etc/rc.d/init.d 下（centos6  /etc/init.d为软链接   centos5为硬链接）</p>
<p>​              chkconfig –add  name</p>
<p>​                   #！/bin/bash</p>
<p>​                   #chkconfig:LLLL nn mm    </p>
<p>​                          LLLL:运行级别</p>
<p>​                          nn：S##编号，开启的顺序</p>
<p>​                          mm：K##编号，关闭的顺序</p>
<p>​                             </p>
<p>​        删除：   </p>
<p>​              chkconfig –del  name</p>
<p>​        修改服务的默认启动/关闭</p>
<p>​              chkconfig [–level  LLLL] name &lt;on | off |reset &gt;</p>
<p>​                  LLLL  为运行级别，默认2345</p>
<p>​        </p>
<p>ntsysv    [–level=LLLL] 字符下的窗口界面，修改服务的默认启动或者关闭</p>
<p>service命令：</p>
<p>​        通过chkconfig –add 添加的服务，可以被service命令手动管理</p>
<p>​        设置开启，关闭，重启，查看   </p>
<p>​              service SERVERNAME  start|stop|restart|status</p>
<p>​        查看所有服务当前状态：</p>
<p>​              service  –status-all</p>
<p>​               </p>
<p>grub：————————————————————————–</p>
<p>安装grub：</p>
<p>​           grub-install  –root-directory=DIR /dev/DISK</p>
<p>​                   安装grub stage1 和stage1.5到/dev/DISK 磁盘上，并复制GRUB相关文件到</p>
<p>​               DIR/boot目录下</p>
<p>​               </p>
<p>​           grub命令：交互式</p>
<p>​                   grub&gt;root(hd#,#)</p>
<p>​                   grub&gt;setup(hd#)</p>
<p>grub legacy            </p>
<p>​        配置文件：/boot/grub/grub.conf  &lt;–/etc/gurb.conf</p>
<p>​        stage2及内核等通常放置于一个基本磁盘分区</p>
<p>​        功用：</p>
<p>​              1   提供启动菜单、并提供交互式接口</p>
<p>​                     a   内核参数</p>
<p>​                     e   编辑模式，用于编辑菜单</p>
<p>​                     c   命令模式，交互式接口</p>
<p>​              2   加载用户选择的内核或操作系统</p>
<p>​                      允许传递参数给内核</p>
<p>​                      可以隐藏启动菜单</p>
<p>​              3   为菜单提供了保护机制</p>
<p>​                      为编辑启动菜单进行认证（可设置密码）</p>
<p>​                      为启动内核或操作系统进行认证（设置密码）</p>
<p>​        grub的命令行接口：</p>
<p>​              help | help  KEYWORD</p>
<p>​              find  (hd0,0)/path/to/file</p>
<p>​               root(hd0,0)</p>
<p>​               kernerl</p>
<p>​               initrd</p>
<p>​              boot  引导启动选定的内核</p>
<p>​        </p>
<p>​        内核参数文档：</p>
<p>​              cat  /usr/share/doc/kernel-doc-2.6.32/Documentation/kernel-parameters.txt</p>
<p>​              需安装kernel-doc包</p>
<p>​              cat  /proc/cmdline 查看内核参数</p>
<p>​                      </p>
<p>​        识别硬盘设备:</p>
<p>​               (hd#,#)</p>
<p>​                hd#:磁盘编号，用数字表示；从0开始编号</p>
<p>​               #：分区编号，用数字表示，从0开始编号</p>
<p>​               (hd0,0)第一块硬盘的第一个分区</p>
<p>​        手动在grub命令行接口启动系统</p>
<p>​           root  (hd0,0)</p>
<p>​            kernerl</p>
<p>​            initrd</p>
<p>​           boot</p>
<p>配置文件：/boot/grub/grub.conf   </p>
<p>​        default=#        设定默认启动的菜单项；title编号从0开始</p>
<p>​        timeout=#       指定菜单项等待选项选择的时间。单位为秒</p>
<p>​        splashimage=(hd#,#)/grub/abc.xpm.gz      菜单背景图片文件路径</p>
<p>​        password [–md5|–encrypted] STRING      启动菜单编辑认证密码可以明文</p>
<p>​        hiddenmenu：    隐藏菜单</p>
<p>​        title TITLE        定义菜单项“标题”  ，可以有多个</p>
<p>​              root(hd#,#)  查找stage2及kernel文件所在的设备分区，为grub的根</p>
<p>​              kernel  [/boot]/kernel-  使用启动的内核</p>
<p>​              initrd  [/boot]/initramfs-    使用的ramfs文件</p>
<p>​              password  [–md5|–encrypted] STRING       启动内核编辑的认证密码可以明文</p>
<p>​               </p>
<p>grub加密：</p>
<p>​        生成grub口令</p>
<p>​              grub-md5-crypt     md5</p>
<p>​              grub-crypt          sha512</p>
<p>​        修改grub.conf文件：</p>
<p>​              password  [–md5|–encrypted] STRING</p>
<p>​        破解root口令</p>
<p>​               启动系统时，设置其运行级别为1</p>
<p>​                   进入单用户模式，编辑grub菜单，kernel后加 1 s S single 都可以</p>
<p>​              使用passwd命令修改密码</p>
<p>​               </p>
<p>设置grub背景图片</p>
<p>​        1   提供一张图片，640*480尺寸 pic.jpg</p>
<p>​        2   安装ImageMagick工具包，使用    convert工具转化格式为xpm  色深14</p>
<p>​           convert -resize 640x480  -colors 14 pic.jpg pic.xpm</p>
<p>​           可以使用head 查看pic.xpm属性</p>
<p>​        3   使用gzip 压缩pic.xpm 复制pic.xpm.gz到grub目录下</p>
<p>​        4   修改grub.conf    splashimage=(hd0,0)/grub/pic.xpm.gz</p>
<p>​        </p>
<p>自制linuz系统：——————————————————————-</p>
<p>​        1   分区并创建文件系统</p>
<p>​              fdisk /dev/sdb  分两个必要的分区</p>
<p>​               /dev/sdb1—-boot</p>
<p>​               /dev/sdb2—-root</p>
<p>​              mkfs.ext4  创建文件系统</p>
<p>​        2   挂载boot</p>
<p>​              mkdir  /mnt/boot</p>
<p>​              mount /dev/sdb1  /mnt/boot</p>
<p>​        3   安装grub</p>
<p>​              grub-install  –root-directory=/mnt /dev/sdb</p>
<p>​        4   复制内核和initramfs文件</p>
<p>​           cp  /boot/vmlinuz-2.6.32-642.el6.x86_64 /mnt/boot/</p>
<p>​           cp  /boot/initramfs-2.6.32-642.el6.x86_64.img /mnt/boot</p>
<p>​        5   创建grub.conf文件</p>
<p>​              vim  /mnt/boot/grub/grub.conf</p>
<p>​                      default=0</p>
<p>​                      timeout=5</p>
<p>​                      splasgimage=(hd0,0)/grub/pic.xpm.gz</p>
<p>​                     title  minicentos</p>
<p>​                             root (hd0,0)</p>
<p>​                             kernel /vmlinuz-2.6.32-642.el6.x86_64 root=/dev/sda2 selinux=0  init=/bin/bash</p>
<p>​                             initrd /initramfs-2.6.32-642.el6.x86_64.img</p>
<p>​        6   复制root文件</p>
<p>​              mkdir  /mnt/sysroot</p>
<p>​              mount /dev/sdb2  /mnt/sysroot</p>
<p>​              mkdir -pv  {etc,lib,usr,home,root,proc,sys,boot,dev,mnt…}</p>
<p>​        7   复制bash和相关库文件</p>
<p>​           复制相关命令及相关库文件</p>
<p>​           如：ifconfig,insmod,ping,mount,ls,cat,df,lsblk,blkid,insmod,lsmod,modinfo等</p>
<p>​           可是使用如下脚本复制</p>
<p>​        </p>
<p>​        8    如果需要使用网路功能，还需要复制驱动程序e1000      </p>
<p>​           cp  /lib/modules/2.6.32-696.el6.x86_64/kernel/drivers/net/e1000/e1000.ko  /mnt/sysroot/lib/</p>
<p>​           自制系统开机之后：</p>
<p>​                   使用insmod /lib/e1000.ko 安装驱动</p>
<p>​                   使用ifconfig 配置IP即可</p>
<p>​          </p>
<p>救援环境，inittab文件误删除恢复</p>
<p>​        centos6:毫无影响，正常启动，自行复制就可</p>
<p>​        </p>
<p>​        centos5：</p>
<p>​              现象：</p>
<p>​                      使用reboot命令无法重启，开机提示输入runlevel，之后启动处于停止状态</p>
<p>​              修复：</p>
<p>​                      救援模式，页面输入linux rescue进入</p>
<p>​                     chroot  /mnt/sysimage</p>
<p>​                     bikid  可以查看到光盘</p>
<p>​                     mount  /dev/hdc /mnt</p>
<p>​                     cd  /mnt/Server</p>
<p>​                     rpm  -ivh initscripts-8.45.30-2.el5.i386.rpm  –force|–replacepkgs</p>
<p>​              也可以使用  </p>
<p>​                  rpm2cpio  /mnt/Server/initscripts-8.45.30-2.el5.i386.rpm |cpio -idv ./etc/inittab  /etc/</p>
<p>/proc目录</p>
<p>​        /proc：</p>
<p>​               内核把自己内部状态信息及统计信息，以及可配置参数通过proc伪文件系统加以输出</p>
<p>​        参数：</p>
<p>​              只读：输出信息</p>
<p>​               可写：可接受用户指定”新值”来实现对内核某功能或特性的配置</p>
<p>​        /proc/sys</p>
<p>​              1   sysctl命令用来查看或设定此目录中诸多参数</p>
<p>​                     sysctl  -w path.to.paremeter=VALUE</p>
<p>​                     sysctl  -w kernel.hostname=HOSTNAME</p>
<p>​              2   echo 命令用于查看或设定此目录中诸多参数</p>
<p>​                     echo  “VALUE” &gt; /proc/sys/PATH/TO/PARAMETER</p>
<p>​                     echo  “websrv” &gt; /proc/sys/kernel/hostname</p>
<p>​        </p>
<p>​        PS:     如果使用sysctl命令修改，使用”.”作为分隔</p>
<p>​              如果使用echo 1|0 &gt; 修改，使用”/“作为分隔</p>
<p>​     </p>
<p>sysctl命令：</p>
<p>​        默认配置文件：/etc/sysctl.conf</p>
<p>​           1   设置某参数</p>
<p>​                  sysctl -w  parameter=VALUE</p>
<p>​           2   通过读取配置文件设置参数</p>
<p>​                  sysctl -p  /path/file</p>
<p>​           3   查看所有生效参数</p>
<p>​                  sysctl  -a</p>
<p>​        </p>
<p>​        常用的几个参数：</p>
<p>​               net.ipv4.ip_forword              路由转发功能</p>
<p>​               net.ipv4.icmp_echo_ignore_all    禁ping</p>
<p>​              vm.drop_caches                清除缓存</p>
<p>​               </p>
<p>/sys目录</p>
<p>​        sysfs：为用户使用的伪文件系统，输出内核识别出的各硬件设备的相关属性信息，也有</p>
<p>​               内核对硬件特性的设定信息；有些参数时可以修改的，用于调整硬件工作特性</p>
<p>​        </p>
<p>​        udev通过此路径下输出的信息动态为个设备创建所需要设备文件，udev是运行用户空间程序</p>
<p>​        </p>
<p>​        专用工具：   udevadmin hotplug</p>
<p>​        udev为设备创建设备文件时，会读取其实现定义好的规则文件，一般在</p>
<p>​                   /etc/udev/rules.d</p>
<p>​                   /usr/lib/udev/rules.d</p>
<p>​        </p>
<p>​        </p>
<p>内核组成部分：</p>
<p>​        分类：单内核，微内核     </p>
<p>​               kernel：一般为：/boot/vmlinuz-VERSION-release</p>
<p>​              kernel object 内核模块，一般位于  /lib/modules/VERSION-RELEASE/</p>
<p>​              辅助文件： ramdisk： /boot/initrd 或者 initramfs</p>
<p>​                   </p>
<p>​        运行中的内核：   </p>
<p>​              uname  [option]</p>
<p>​              -n      显示节点名称</p>
<p>​              -r      显示VERSION-RELEASE</p>
<p>​              -a      显示所有信息</p>
<p>​        </p>
<p>内核模块命令：</p>
<p>lsmod：</p>
<p>​        显示由核心已经装载的内核模块</p>
<p>​        显示的内容来自于:/prco/modules</p>
<p>moinfo</p>
<p>​        显示模块的详细描述信息，当前没有装载也可以查看</p>
<p>​              modeinfo [-k kernel]  [modulename | filename]</p>
<p>​                  -n      只显示模块文件路径</p>
<p>​                  -p      只显示模块参数</p>
<p>​                  -a      作者</p>
<p>​                  -d      description   描述</p>
<p>​                  -l      license  遵守的协议类型</p>
<p>​     </p>
<p>modprobe</p>
<p>​        装载或卸载内核模块</p>
<p>​              modprobe  modname  装载</p>
<p>​                  -r             卸载</p>
<p>​        配置文件：   /etc/modprobe.conf    </p>
<p>​                   /etc/modprobe.d/*.conf</p>
<p>​                   </p>
<p>depmod:    内核模块依赖关系文件及系统信息映射文件的生成工具</p>
<p>insmod 装载内核模块，不会自动解决依赖关系</p>
<p>​           insmod [filename] [module  options..]</p>
<p>​           insmod <code>modinfo -n  xfs</code></p>
<p>rmmod   卸载模块</p>
<p>​           rmmod  xfs</p>
<p>​     </p>
<p>​          </p>
<p>​        </p>
<p>编译安装内核:——————————————————————–</p>
<p>前提：</p>
<p>​        1   准备好开发环境</p>
<p>​              包组：  Server Platform  Development   (centos7没有)</p>
<p>​                      Development Tools</p>
<p>​                      </p>
<p>​        2   获取目标主机上硬件设备的相关信息</p>
<p>​              CPU:    cat /proc/cpuinfo,x86info  -a,lscpu</p>
<p>​              PCI: lspci -v -vv ,lsusb -v -vv   lsblk</p>
<p>​               </p>
<p>​        3   获取目标主机系统功能的相关信息</p>
<p>​               例如：需要启用相应的文件系统</p>
<p>​        4   获取内核源代码包</p>
<p>​        </p>
<p>内核编译安装流程       </p>
<p>​        完整编译：</p>
<p>​              安装开发包组</p>
<p>​              下载源码文件       解压并cd进入解压生成的目录</p>
<p>​               装备文本配置文件，”.config” 可以从现有系统复制改名得到 （/boot下config-VERSION）</p>
<p>​              make menuconfig    配置内核选项，选择或者不选择相应模块</p>
<p>​              make [-j #]      编译，可选择cpu个数</p>
<p>​              make  modules—install 安装模块</p>
<p>​              make install         安装核心</p>
<p>​                      vmlinuz-</p>
<p>​                      initramfs-        </p>
<p>​                      编辑grub配置文件</p>
<p>​               reboot</p>
<p>​        </p>
<p>​        部分编译：</p>
<p>​               只编译某子目录中的相关代码</p>
<p>​                     cd  进入解压目录，</p>
<p>​                     make  dir/    只能使用相对路径</p>
<p>​               只编译一个特定的模块：</p>
<p>​                     make  dir/file.ko</p>
<p>​                      </p>
<p>​        交叉编译：</p>
<p>​               如何交叉编译内核：</p>
<p>​                      编译的目标平台与当前平台不相同</p>
<p>​                     make  ARCH=arch_name</p>
<p>​               获取特定目标平台的使用帮助</p>
<p>​                     make  ARCH=arch_name help</p>
<p>​                          make ARCH=arm help 手机平台</p>
<p>​                          </p>
<p>​        清理：</p>
<p>​              make clean      清理大多数编译生成的文件，但会保留config文件等</p>
<p>​              make mrproper   清理所有编译生成的文件、config及某些备份文件</p>
<p>​              make distclean   mrproper、patches以及编辑器备份文件</p>
<p>​        </p>
<p>卸载内核：</p>
<p>​        删除/lib/modules/ 下不需要的内核</p>
<p>​        删除/usr/src/linux 解压目录下不需要的内核源码</p>
<p>​        删除/boot 目录下启动的内核和initramfs文件</p>
<p>​        更改grub的配置文件，删除不需要的内核启动列表</p>
<p>​        </p>
<p>​        </p>
<p>练习：</p>
<p>1、破解root口令，并为grub设置保护功能</p>
<p>2、破坏本机grub  stage1，而后在救援模式下修复之</p>
<p>3、删除vmlinuz和initramfs文件后无法启动,两种方法恢复之</p>
<p>4、增加新硬盘，在其上制作能单独运行kernel和bash的系统</p>
<p>5、在U盘上定制linux，使其可启动系统，并具有网络功能</p>
<p>6、删除/etc/fstab和/boot目录的所有文件，并恢复之</p>
<p>7、编译安装kernel，启用支持ntfs文件系统功能       </p>
<p>​        </p>
<p>​        </p>
<p>​        </p>
<p>systemd：—————————————————————————–     </p>
<p>​        syetemd：centos7 上的第一个进程</p>
<p>​               系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源、</p>
<p>​               服务器进程和其他进程</p>
<p>​        新特性：</p>
<p>​               系统引导时实现服务并行启动</p>
<p>​              按需启动守护进程</p>
<p>​               自动化的服务依赖关系管理</p>
<p>​              同时采用socket式和D-bus总线式激活服务</p>
<p>​              系统状态快照</p>
<p>​               </p>
<p>​        核心概念：unit</p>
<p>​               unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了</p>
<p>​              系统服务、监听socket、保存的系统快照以及其他与init相关的信息</p>
<p>​        </p>
<p>​        配置文件：   /usr/lib/systemd/system    每个服务最主要的启动脚本设置，类似于/etc/init.d/</p>
<p>​                   /run/systemd/system      系统执行过程中所产生的服务脚本，比上面的优先运行</p>
<p>​                   /etc/systemd/system       管理员建立的执行脚本，比上面的目录优先运行</p>
<p>​        </p>
<p>​        特性：   向后兼容sysv init 脚本</p>
<p>​               systemctl命令固定不变，不可扩展</p>
<p>​              非由systemd启动的服务，systemctl无法与之通信的控制</p>
<p>​        </p>
<p>unit类型：</p>
<p>systemctl -t help     查看unit类型</p>
<p>​           service unit .service    用于定义系统服务</p>
<p>​           .target      用于模拟实现运行级别</p>
<p>​           .device      用于定义内核识别的设备</p>
<p>​           .mount      定义文件系统挂载点</p>
<p>​           .socket      用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动</p>
<p>​           .snapshot    管理系统快照</p>
<p>​           .automount  文件系统的自动挂载点</p>
<p>​           .path        用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，</p>
<p>​                      延迟激活服务，如spool目录</p>
<p>​          </p>
<p>管理服务：</p>
<p>​        管理系统服务：service unit</p>
<p>​        命令：   </p>
<p>​              systemctl  [start|stop|restart|status] name.service</p>
<p>​        条件式重启：已启动才重启，否则不做操作</p>
<p>​              systemctl  try-restart name.service</p>
<p>​        重载或重启服务：先加载，启动</p>
<p>​              systemctl  reload-or-restart name.service</p>
<p>​        重载或条件式重启：</p>
<p>​              systemctl  reload-or-try-restart name.service</p>
<p>​        </p>
<p>​        禁止自动和手动启动：</p>
<p>​              systemctl mask  name.service        通过创建软链接指向/dev/null来禁止启动</p>
<p>​        取消禁止</p>
<p>​              systemctl unmask  name.service</p>
<p>​               </p>
<p>​        查看某服务当前激活与否的状态：</p>
<p>​              systemctl is-active  name.service 激活状态$?为0  非激活状态非0</p>
<p>​        </p>
<p>​        查看所有已激活的服务：</p>
<p>​              systemctl list-units  –type|-t service</p>
<p>​                     -t  service</p>
<p>​        </p>
<p>​        systemctl单独使用：</p>
<p>​              等于systemctl list-units     查看所有活动units</p>
<p>​        </p>
<p>​        查看所有服务：</p>
<p>​              systemctl list-units  -type|-t service –all|-a</p>
<p>​                      -at  service</p>
<p>​                      </p>
<p>​        设定某服务开机启动：</p>
<p>​              systemctl enable  name.service</p>
<p>​        设置某服务开机禁止启动</p>
<p>​              systemctl disable  name.service</p>
<p>​        </p>
<p>​        查看所有服务的开机自启状态：</p>
<p>​              systemctl  list-unit-files -t service</p>
<p>​               </p>
<p>​        查看服务是否开机自启：</p>
<p>​              systemctl is-enabled  name.service</p>
<p>​              自启$?为0  否则为1</p>
<p>​        </p>
<p>​        用来列出该服务在那些运行级别下启用和禁用</p>
<p>​              ls  /etc/systemd/system/*.wants/name.service</p>
<p>​        </p>
<p>​        查看服务的依赖关系：</p>
<p>​              systemctl  list-dependencies name.service</p>
<p>​        </p>
<p>​        杀掉进程：</p>
<p>​              systemctl kill  unitname</p>
<p>服务状态：</p>
<p>​           使用systemctl -at service查看状态</p>
<p>​           loaded：        unit配置文件已处理</p>
<p>​           active（running） 一次或多次持续处理的运行</p>
<p>​           active（exited）   成功完成一次性的配置</p>
<p>​           active（waiting）  运行中，等待一个事件</p>
<p>​           inactive         不运行</p>
<p>​           enabled            开机启动</p>
<p>​           disabled        开机不启动</p>
<p>​           static               开机不启动，但可被另一个启动的服务激活</p>
<p>​        </p>
<p>service unit 文件格式</p>
<p>​        /etc/systemd/system:      系统管理员和用户使用</p>
<p>​        /usr/lib/systemd/system:    发行版打包使用</p>
<p>​        以”#”开头的行后面的内容被任务是注视</p>
<p>​        相关布尔值，1，yes，on,true都是开启，0,no,of,false都是关闭</p>
<p>​        时间单位默认是秒，所以要用毫秒ms 分钟m  等需要显式说明</p>
<p>​        </p>
<p>​        servic unit file 通常由三部分组成：</p>
<p>​        </p>
<p>​               Dsecription： 描述信息</p>
<p>​              After：         定义unit的启动次序，表示当前unit应该晚于哪些unit启动，与Before相反</p>
<p>​               Requires：      依赖到的其他units，强依赖，被依赖的unit无法激活时</p>
<p>​                             当前unit也无法激活</p>
<p>​              Wants：        弱依赖</p>
<p>​               Conflicts：      定义units间的冲突关系</p>
<p>​               </p>
<p>​        [Service]: 与unit类型相关的专用选项，service|socket 等</p>
<p>​              Type:       定义影响Execstart及相关参数的功能的unit进程启动类型</p>
<p>​                   simple： 默认值，这个daemon主要由ExceStart接的指令串来启动，启动后</p>
<p>​                             常驻于内存中</p>
<p>​                   forking：     有ExceStart启动的程序通过spawns延伸出其他子程序来作为此daemon</p>
<p>​                             的主要服务，原生父进程在启动结束后就会终止</p>
<p>​                   oneshot：    与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中</p>
<p>​                   dbus：      与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作。</p>
<p>​                             因此通常也要同时设定BusName= 才行</p>
<p>​                   notify：  在启动完成后发送一个通知消息，还需要配合NotifyAccess来让Systemd接受消息</p>
<p>​                   idle：       与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。</p>
<p>​                             这类的daemon通常是开机到最后才执行即可的服务</p>
<p>​               EnvironmentFile： 环境配置文件</p>
<p>​               ExecStart：         指明启动unit要运行命令或脚本的绝对路径</p>
<p>​                ExecStartPre：       ExecStart前运行</p>
<p>​              ExecStartPost:    ExecStart后运行</p>
<p>​               ExecStop：         指明停止unit要运行的命令或脚本</p>
<p>​              Restart：       当设定Restart=1时，则当次daemon服务以外终止后，会再次自动启动</p>
<p>​        [install]：     定义由”systemctl enable” 以及”systemctl disable” 命令在实现服务启用</p>
<p>​                   或禁用时用到的一些选项</p>
<p>​              Alias：  别名，可使用systemctl command Alias.service</p>
<p>​               RequiredBy： 被哪些units所依赖，强依赖</p>
<p>​               WantedBy：      被哪些units所依赖，弱依赖</p>
<p>​              Also：          安装本服务的时候还要安装别的相关服务</p>
<p>​        </p>
<p>​        注意：   对于新创建的unit文件，或者修改了unit文件，要通知systemd重载此配置文件，</p>
<p>​              而后可以选择重启</p>
<p>​              systemctl  daemon-reload</p>
<p>服务Unit文件示例：</p>
<p>​           vim  /etc/systemd/system/bak.service</p>
<p>​                   <a href="定义与unit类型无关的通用选项，用于提供unit的描述信息，unit行为以及依赖性关系">Unit</a></p>
<p>​                   Description=backup /etc</p>
<p>​                   Requires=atd.service</p>
<p>​                   [Service]</p>
<p>​                   Type=simple</p>
<p>​                   ExecStart=/bin/bash -c “echo /testdir/bak.sh|at  now”</p>
<p>​                   [Install]</p>
<p>​                   WantedBy=multi-user.target</p>
<p>​           systemctl  daemon-reload</p>
<p>​           systemctl start bak            </p>
<p>target units</p>
<p>​        unit配置文件： .target</p>
<p>​        查看所有target</p>
<p>​              ls  /usr/lib/systemd/system/*.target</p>
<p>​              systemctl  list-unit-files -t target -a</p>
<p>​               </p>
<p>​        运行级别</p>
<p>​               /usr/lib/systemd/system/runlevel0.target -&gt;  poweroff.target</p>
<p>​               /usr/lib/systemd/system/runlevel1.target -&gt;  rescue.target</p>
<p>​               /usr/lib/systemd/system/runlevel2.target -&gt;  multi-user.target</p>
<p>​               /usr/lib/systemd/system/runlevel3.target -&gt;  multi-user.target</p>
<p>​               /usr/lib/systemd/system/runlevel4.target -&gt;  multi-user.target</p>
<p>​               /usr/lib/systemd/system/runlevel5.target -&gt;  graphical.target</p>
<p>​               /usr/lib/systemd/system/runlevel6.target -&gt;  reboot.target</p>
<p>​        查看依懒性:</p>
<p>​              systemctl  list-dependencies graphical.target</p>
<p>​        级别切换：   init N ==&gt; systemctl isolate name.target</p>
<p>​               </p>
<p>​              注意：只有/lib/systemd/system/*.target 文件中AllowIsolate=yes，才能切换</p>
<p>​                      （修改文件需执行 systemctl daemon-reload  才能生效）</p>
<p>​        查看target：</p>
<p>​                  runlevel     链接指向systemctl</p>
<p>​                  who  -r</p>
<p>​                  systemctl  list-units -t target</p>
<p>​        </p>
<p>​        获取默认运行级别：</p>
<p>​              /etc/inittab ===&gt;  systemctl get-default</p>
<p>​              ll  /etc/systemd/system/default.target</p>
<p>​        </p>
<p>​        修改默认运行级别：</p>
<p>​              systemctl  set-default name.target</p>
<p>​               </p>
<p>​        进入默认target：</p>
<p>​              systemctl  default</p>
<p>​               </p>
<p>其他命令：</p>
<p>​        切换至紧急救援模式：</p>
<p>​              systemctl  rescue</p>
<p>​        切换至emergency模式</p>
<p>​              systemctl  emergency</p>
<p>​        其他常用命令：</p>
<p>​              传统命令：  init poweroff halt reboot 都称为systemctl的软链接</p>
<p>​              关机：  systemctl hatl  、systemctl poweroff</p>
<p>​              重启：  systemctl reboot  </p>
<p>​              挂起：  systemctl  suspend</p>
<p>​              休眠：  systemctl  hibernate</p>
<p>​              休眠并挂起：systemctl hybrid-sleep</p>
<p>​               </p>
<p>CentOS 7 引到顺序：</p>
<p>​           POST开机自检</p>
<p>​           boot sequence  选择启动设备</p>
<p>​           引导装载程序，grub2</p>
<p>​           加载装载程序的配置文件：/boot/grub2/grub.cfg，给出内核选项</p>
<p>​           加载内核，以及initramfs</p>
<p>​           内核初始化</p>
<p>​           开启第一个进程：systemd</p>
<p>​           执行initrd.target所有单元，包括挂载/etc/fstab</p>
<p>​           切换根文件系统</p>
<p>​           systemd 执行默认target配置，配置文件/etc/systemd/system/default.target</p>
<p>​           systemd 执行sysinit.target 初始化系统及basic.target  准备操作系统</p>
<p>​           systemd 执行multi-user.target 下的本机与服务器服务</p>
<p>​           systemd 执行  multi-user.target下  /etc/rc.d/rc.local</p>
<p>​           systemd 执行multi-user.target下   getty.target及登录服务</p>
<p>​           systemd 执行graphical 需要的服务</p>
<p>​          </p>
<p>设置启动内核参数：</p>
<p>​           启动时，在linux16行后添加 systemd.unit=multi-user.target  启动进入3模式</p>
<p>​            systemd.unit=rescue.target</p>
<p>​            systemd.unit=emergency.target</p>
<p>​           rescue.target 比emergency 支持更多的功能，例如日志等</p>
<p>​          </p>
<p>centos7 破解root口令</p>
<p>​           方法1：</p>
<p>​                   启动项e键修改</p>
<p>​                   找到lunux16 内核这一项，rd.break,ctrl+x启动</p>
<p>​                  mount -o  rw,remount /sysroot</p>
<p>​                  chroot  /sysroot</p>
<p>​                  passwd  修改密码</p>
<p>​                   如果selinux启动状态，则需要touch  /.autorelabel</p>
<p>​                   exit</p>
<p>​                   reboot</p>
<p>​           方法2：</p>
<p>​                   启动项e键修改</p>
<p>​                   找到linux16，行尾添加 rw  init=/sysroot/bin/sh ,ctrl+x启动</p>
<p>​                  chroot  /sysroot</p>
<p>​                  passwd  修改密码</p>
<p>​                   如果selinux启动状态，则需要touch  /.autorelabel</p>
<p>​                   exit</p>
<p>​                   reboot</p>
<p>修复grub2</p>
<p>​        主要配置文件:    /boot/grub2/grub.conf</p>
<p>​              辅助配置文件：/etc/default/grub</p>
<p>​        修复配置文件：</p>
<p>​              grub2-mkconfig &gt;  /boot/grub2/grub.cfg</p>
<p>​        修复grub2</p>
<p>​              grub2-install  /dev/sda     BIOS环境</p>
<p>​              grub2-install UEFI环境</p>
<p>​        调整默认启动内核：</p>
<p>​              vim  /etc/default/grub</p>
<p>​               GRUB_DEFAULT=0</p>
<p>​              grub2-mkconfig &gt;  /boot/grub2/grub.cfg</p>
<p>​               </p>
<p>练习：</p>
<p>为编译安装的httpd服务，实现service unit文件</p>
<p>破解centos7  口令</p>
<p>修改默认的启动内核为新编译内核</p>
<p>启动时临时禁用SELinux</p>
<p>启动时进入emergency模式</p>
<p>卸载编译安装的新内核</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>系统启动</tag>
        <tag>内核管理</tag>
      </tags>
  </entry>
  <entry>
    <title>紫阳花图床</title>
    <url>/%E7%B4%AB%E9%98%B3%E8%8A%B1%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://i.ibb.co/3cvY9M6/01-001.jpg" alt="01-001" border="0">
<img src="https://i.ibb.co/F4FKg6H/210006617610-1p.jpg" alt="210006617610-1p" border="0">
<img src="https://i.ibb.co/tb2fxtg/GLOD0156-gallery-1.jpg" alt="GLOD0156-gallery-1" border="0">
<img src="https://i.ibb.co/Ksw4CzG/GLOD0156-gallery-3.jpg" alt="GLOD0156-gallery-3" border="0">
<img src="https://i.ibb.co/ySXxLMD/GLOD0156-gallery-4.jpg" alt="GLOD0156-gallery-4" border="0">
<img src="https://i.ibb.co/FDvFJzP/GLOD0156-gallery-5.jpg" alt="GLOD0156-gallery-5" border="0">
<img src="https://i.ibb.co/kKwvXqS/GLOD0156-gallery-6.jpg" alt="GLOD0156-gallery-6" border="0">
<img src="https://i.ibb.co/dj9RTSs/GLOD0156-gallery-7.jpg" alt="GLOD0156-gallery-7" border="0">
<img src="https://i.ibb.co/wdjQ378/GLOD0156-gallery-8.jpg" alt="GLOD0156-gallery-8" border="0">
<img src="https://i.ibb.co/Jc45tGL/GLOD0156-gallery-9.jpg" alt="GLOD0156-gallery-9" border="0">
<img src="https://i.ibb.co/1GPj1WK/GLOD0156-gallery-10.jpg" alt="GLOD0156-gallery-10" border="0">
<img src="https://i.ibb.co/MGTxHPt/GLOD0156-gallery-11.jpg" alt="GLOD0156-gallery-11" border="0">
<img src="https://i.ibb.co/L562qKs/GLOD0156-gallery-12.jpg" alt="GLOD0156-gallery-12" border="0">
<img src="https://i.ibb.co/Qkwxpjz/GLOD0156-gallery-13.jpg" alt="GLOD0156-gallery-13" border="0">
<img src="https://i.ibb.co/Zd1Np9h/GLOD0156-gallery-14.jpg" alt="GLOD0156-gallery-14" border="0">
<img src="https://i.ibb.co/gyQNCtZ/GLOD0156-gallery-15.jpg" alt="GLOD0156-gallery-15" border="0">
<img src="https://i.ibb.co/5st2QXc/GLOD0156-gallery-16.jpg" alt="GLOD0156-gallery-16" border="0">
<img src="https://i.ibb.co/h1BqKb9/GLOD0156-gallery-17.jpg" alt="GLOD0156-gallery-17" border="0">
<img src="https://i.ibb.co/nj9JHdC/GLOD0156-gallery-18.jpg" alt="GLOD0156-gallery-18" border="0">
<img src="https://i.ibb.co/sgSWM5Q/GLOD0156-gallery-19.jpg" alt="GLOD0156-gallery-19" border="0">
<img src="https://i.ibb.co/k0MsrRR/GLOD0156-gallery-20.jpg" alt="GLOD0156-gallery-20" border="0">
<img src="https://i.ibb.co/jgPL5sz/GLOD0156-gallery-21.jpg" alt="GLOD0156-gallery-21" border="0">
<img src="https://i.ibb.co/5cfQG3c/GLOD0156-gallery-22.jpg" alt="GLOD0156-gallery-22" border="0">
<img src="https://i.ibb.co/LZFwZC3/GLOD0156-gallery-23.jpg" alt="GLOD0156-gallery-23" border="0">
<img src="https://i.ibb.co/2kmZjxc/GLOD0156-gallery-24.jpg" alt="GLOD0156-gallery-24" border="0">
<img src="https://i.ibb.co/2gVjSY8/GLOD0156-gallery-25.jpg" alt="GLOD0156-gallery-25" border="0">
<img src="https://i.ibb.co/TW3Dj0N/GLOD0156-gallery-26.jpg" alt="GLOD0156-gallery-26" border="0">
<img src="https://i.ibb.co/Gn37pdp/GLOD0156-gallery-27.jpg" alt="GLOD0156-gallery-27" border="0">
<img src="https://i.ibb.co/BKKMpQ9/GLOD0156-gallery-28.jpg" alt="GLOD0156-gallery-28" border="0">
<img src="https://i.ibb.co/P4sxGsP/GLOD0156-gallery-29.jpg" alt="GLOD0156-gallery-29" border="0">
<img src="https://i.ibb.co/jZRHHR4/GLOD0156-gallery-30.jpg" alt="GLOD0156-gallery-30" border="0">
<img src="https://i.ibb.co/30jy79n/1.jpg" alt="1" border="0">
<img src="https://i.ibb.co/XFqmn54/2.jpg" alt="2" border="0">]]></content>
  </entry>
  <entry>
    <title>紫陽花の散ル頃に</title>
    <url>/%E7%B4%AB%E9%99%BD%E8%8A%B1%E3%81%AE%E6%95%A3%E3%83%AB%E9%A0%83%E3%81%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="OVA紫陽花の散ル頃に"><a href="#OVA紫陽花の散ル頃に" class="headerlink" title="OVA紫陽花の散ル頃に"></a>OVA紫陽花の散ル頃に</h2><video src="http://www.ashjian.xyz/self/videos/love/紫陽花の散ル頃に.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;" poster="http://www.ashjian.xyz/self/img/%E7%B4%AB%E9%98%B3%E8%8A%B1/%E7%B4%AB%E9%98%B3%E8%8A%B1.gif" autoplay >
your browser does not support the video tag
</video>

<p>激エロ製作集団ルネピクチャーズが贈る、 サークル真珠貝原作の背徳的オリジナル寝取られコミックスをOVA化！<br>ルネピクチャーズ新進気鋭ブランド『あんてきぬすっ』に登場！</p>
<p>山野勇太には年上の幼馴染、紫ノ宮夏花という清い付き合いをしている恋人がいた。<br>昔は下ネタすらも嫌悪するお堅い夏花だったが、ここ最近妙に積極的になっていることに勇太は気になっていた。<br>夏休みに入り、ついには初体験を迎える２人だった。<br>しかし、夏花は勇太との行為だけでは満足できず、ヤリチンで有名な男をその日の内に呼び出して……</p>
<p>【オナニーサポート音声特典】オナ♥ビゲーター（副音声に収録）<br>※パッケージ版DVDのみ</p>
<h3 id="ストーリー"><a href="#ストーリー" class="headerlink" title="ストーリー"></a>ストーリー</h3><p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171100.jpg" alt="GLOD0156_story"></p>
<p>山野勇太には年上の幼馴染、紫ノ宮夏花という清い付き合いをしている恋人がいた。<br>昔は下ネタすらも嫌悪するお堅い夏花だったが、ここ最近妙に積極的になっていることに勇太は気になっていた。<br>夏休みに入り、ついには初体験を迎える２人だった。<br>しかし、夏花は勇太との行為だけでは満足できず、ヤリチンで有名な男をその日の内に呼び出して……</p>
<h3 id="製品情報"><a href="#製品情報" class="headerlink" title="製品情報"></a>製品情報</h3><table>
<thead>
<tr>
<th align="left">タイトル</th>
<th>OVA紫陽花の散ル頃に</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ブランド</td>
<td><a href="http://www.lune-soft.jp/ova/brand_ova/antechinus" target="_blank" rel="noopener">あんてきぬすっ</a></td>
</tr>
<tr>
<td align="left">ジャンル</td>
<td><a href="http://www.lune-soft.jp/ova/type_ova/パイズリ" target="_blank" rel="noopener">パイズリ</a><a href="http://www.lune-soft.jp/ova/type_ova/中出し" target="_blank" rel="noopener">中出し</a><a href="http://www.lune-soft.jp/ova/type_ova/寝取り・寝取られ（ntr）" target="_blank" rel="noopener">寝取り・寝取られ（NTR）</a><a href="http://www.lune-soft.jp/ova/type_ova/巨乳" target="_blank" rel="noopener">巨乳</a><a href="http://www.lune-soft.jp/ova/type_ova/武田弘光" target="_blank" rel="noopener">武田弘光</a></td>
</tr>
<tr>
<td align="left">発売日</td>
<td>2021年1月29日</td>
</tr>
<tr>
<td align="left">価格</td>
<td>3,800円（税別）</td>
</tr>
<tr>
<td align="left">年齢制限</td>
<td>18歳以上</td>
</tr>
<tr>
<td align="left">内容</td>
<td>２０２１年発売／日本／カラー作品／本編２０分／ドルビーデジタル・ステレオ／言語：日本語／１６：９ ＬＢ／片面１層／MPEG-2</td>
</tr>
<tr>
<td align="left">copyright</td>
<td>（ｃ）２０２１　「紫陽花の散ル頃に」制作委員会／あんてきぬすっ</td>
</tr>
<tr>
<td align="left">原作</td>
<td>真珠貝「紫陽花の散ル頃に」</td>
</tr>
<tr>
<td align="left">企画</td>
<td>あんてきぬすっ</td>
</tr>
<tr>
<td align="left">監督</td>
<td>雷火剣</td>
</tr>
<tr>
<td align="left">脚本</td>
<td>特区03</td>
</tr>
<tr>
<td align="left">キャラクター原案</td>
<td>武田弘光</td>
</tr>
<tr>
<td align="left">絵コンテ</td>
<td>サガリ眼鏡</td>
</tr>
<tr>
<td align="left">制作</td>
<td>T-REX</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171115.jpg" alt="GLOD0156_gallery_1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171116.jpg" alt="GLOD0156_gallery_3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171117.jpg" alt="GLOD0156_gallery_7"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171118.jpg" alt="GLOD0156_gallery_8"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171119.jpg" alt="GLOD0156_gallery_9"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171120.jpg" alt="GLOD0156_gallery_10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171121.jpg" alt="GLOD0156_gallery_11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171122.jpg" alt="GLOD0156_gallery_12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171123.jpg" alt="GLOD0156_gallery_13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171124.jpg" alt="GLOD0156_gallery_14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171125.jpg" alt="GLOD0156_gallery_15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171126.jpg" alt="GLOD0156_gallery_16"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171127.jpg" alt="GLOD0156_gallery_17"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171128.jpg" alt="GLOD0156_gallery_18"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171129.jpg" alt="GLOD0156_gallery_19"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171130.jpg" alt="GLOD0156_gallery_20"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171131.jpg" alt="GLOD0156_gallery_21"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171132.jpg" alt="GLOD0156_gallery_22"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171133.jpg" alt="GLOD0156_gallery_23"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171134.jpg" alt="GLOD0156_gallery_24"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171135.jpg" alt="GLOD0156_gallery_25"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171136.jpg" alt="GLOD0156_gallery_26"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171137.jpg" alt="GLOD0156_gallery_27"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171138.jpg" alt="GLOD0156_gallery_28"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171139.jpg" alt="GLOD0156_gallery_29"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ashjian/picBed@1.0/20201221171140.jpg" alt="GLOD0156_gallery_30"></p>
]]></content>
  </entry>
  <entry>
    <title>练习题(SHELL脚本编程基础)</title>
    <url>/%E7%BB%83%E4%B9%A0%E9%A2%98-SHELL%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>1、编写脚本 systeminfo.sh，显示当前主机系统信息，包括主机名，IPv4地址，操作系统版本，内核版本，CPU型号，内存大小，硬盘大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOSTNAME</span> <br>ifconfig | grep <span class="hljs-string">"inet .*"</span> | tr -s <span class="hljs-string">" "</span> | cut -d <span class="hljs-string">" "</span> -f3 <br>cat /etc/centos-release <br>uname -r <br>cat /proc/cpuinfo | grep <span class="hljs-string">"model name"</span> | cut -d : -f2 | grep <span class="hljs-string">"[[:alpha:]].*"</span> -o <br>cat /proc/meminfo | grep MemTotal | tr -s <span class="hljs-string">" "</span> | cut -d <span class="hljs-string">" "</span> -f2,3 <br>lsblk | grep <span class="hljs-string">"\(s\|v\)d[a-z]\&gt;"</span> | tr -s <span class="hljs-string">" "</span> | cut -d <span class="hljs-string">" "</span> -f<br></code></pre></td></tr></table></figure>

<p>2、编写脚本 backup.sh，可实现每日将/etc/目录备份到/backup/etcYYYY-mm-dd中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir -p &#x2F;backup&#x2F;etc&#96;date +$F&#96;<br>cp -a &#x2F;etc &#x2F;backup&#x2F;etc&#96;date +%F<br></code></pre></td></tr></table></figure>

<p>3、编写脚本 disk.sh，显示当前硬盘分区中空间利用率最大的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">df -h | grep &quot;^&#x2F;dev&#x2F;[s\|v]d[a-z][0-9]&quot; | tr -s &quot; &quot; | cut -d &quot; &quot; -f1,5 | sort -t &quot; &quot; -k2 -nr<br></code></pre></td></tr></table></figure>

<p>4、编写脚本 links.sh，显示正连接本主机的每个远程主机的IPv4地址和连接数，并按连接数从大到小排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">netstat -nta | grep tcp | tr -s &quot; &quot; | cut -d &quot; &quot; -f5 | sort | uniq -c | sort -nr<br></code></pre></td></tr></table></figure>

<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>1、编写脚本 sumid.sh，计算/etc/passwd文件中的第10个用户和第20用户的UID之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">declare -i UID1&#x3D;&#96;head -10 &#x2F;etc&#x2F;passwd | tail -1 | cut -d : -f3&#96;<br>declare -i UID2&#x3D;&#96;head -20 &#x2F;etc&#x2F;passwd | tail -1 | cut -d : -f3&#96;<br>UIDADD&#x3D;$[UID1+UID2] <br>echo $UIDADD<br></code></pre></td></tr></table></figure>

<p>2、编写脚本 sumspace.sh，传递两个文件路径作为参数给脚本，计算这两个文件中所有空白行之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">declare -i SPACE1&#x3D;&#96;grep &quot;^$&quot; $1 | uniq -c  <br>declare -i SPACE2&#x3D;&#96;grep &quot;^$&quot; $2 | uniq -c<br>let SpaceSum&#x3D;SPACE1+SPACE2<br>echo $SpaceSum<br></code></pre></td></tr></table></figure>

<p>3、编写脚本 sumfile.sh，统计/etc, /var, /usr 目录中共有多少个一级子目录和文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Di1LrSum&#x3D;$(find &#x2F;etc &#x2F;usr &#x2F;var -maxdepth 1 -type d | wc -l)<br>FileSum&#x3D;$(find &#x2F;etc &#x2F;usr &#x2F;var | wc -l)<br>echo &quot;Dir1LSum is $Dir1LSum ,FileSum is $FileSum&quot;<br></code></pre></td></tr></table></figure>



<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>1、编写脚本 createuser.sh，实现如下功能：使用一个用户名做为参数，如果指定参数的用户存在，就显示其存在，否则添加之；显示添加的用户的id号等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if id $1 &amp;&gt; &#x2F;dev&#x2F;null; then<br>    echo &quot;user already exit&quot;<br>    id $1<br>else<br>    useradd $1 &amp;&gt; &#x2F;dev&#x2F;null &amp;&amp; echo &quot;user is adding&quot;<br>    id $1<br>fi<br></code></pre></td></tr></table></figure>

<p>2、编写脚本 yesorno.sh，提示用户输入yes或no,并判断用户输入的是yes还是no,或是其它信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">read</span> -p <span class="hljs-string">"please input y or n :"</span> ans<br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$ans</span> =~ ^[yY]([[eE][sS])?$ ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"your answer is yes"</span><br><span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$ans</span> =~ ^[nN][oO]?$ ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"your answer is no"</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"your answer is not right!"</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>3、编写脚本 filetype.sh，判断用户输入文件路径，显示其文件类型（普通，目录，链接，其它文件类型）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">read -p &quot;请输入一个文件路径：&quot; FilePath<br>file $FilePath | cut -d : -f2<br></code></pre></td></tr></table></figure>

<p>4、编写脚本 checkint.sh，判断用户输入的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">read -p &quot;please input a int:&quot; intnum<br>[ $intnum -ge 0 ] &amp;&amp; echo &quot;This is a integer&quot; || echo &quot;This isn&#39;t a integer&quot;<br></code></pre></td></tr></table></figure>



<h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h2><p>1、让所有用户的PATH环境变量的值多出一个路径，例如：<br>/usr/local/apache/bin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;profile.d&#x2F;env.sh<br>PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;apache&#x2F;bin:$PATH<br></code></pre></td></tr></table></figure>

<p>2、用户 root 登录时，将命令指示符变成红色，并自动启用如下别名：</p>
<blockquote>
<p>rm=‘rm –i’<br>cdnet=‘cd /etc/sysconfig/network-scripts/’<br>editnet=‘vim /etc/sysconfig/network-scripts/ifcfg-eth0’</p>
<p>editnet=‘vim /etc/sysconfig/network-scripts/ifcfg-eno16777736 或 ifcfg-ens33 ’ (如果系统是CentOS7) </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ./root/bashrc<br><span class="hljs-comment"># .bashrc</span><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -f /etc/bashrc ]; <span class="hljs-keyword">then</span><br>        . /etc/bashrc<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># Uncomment the following line if you don't like systemctl's auto-paging feature:</span><br><span class="hljs-comment"># export SYSTEMD_PAGER=</span><br><span class="hljs-comment"># User specific aliases and functions</span><br>PS1=<span class="hljs-string">"\[\e[1;31m\][\u@\h \W]\\$\[\e[0m\]"</span><br><span class="hljs-built_in">alias</span> rm=<span class="hljs-string">'rm -i'</span><br><span class="hljs-built_in">alias</span> cdnet=<span class="hljs-string">'cd /etc/sysconfig/network-scripts/'</span><br><span class="hljs-built_in">alias</span> editnet=<span class="hljs-string">'vim /etc/sysconfig/network-scripsts/ifcfg-eth0'</span><br></code></pre></td></tr></table></figure>

<p>3、任意用户登录系统时，显示红色字体的警示提醒信息“Hi,dangerous！”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;profile.d&#x2F;env.sh<br>echo -e &quot;\e[1;31mhello.dangerous\e[0m&quot;<br></code></pre></td></tr></table></figure>

<p>4、编写生成脚本基本格式的脚本，包括作者，联系方式，版本，时间，描述等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim ~/.vimrc<br><span class="hljs-built_in">set</span> ignorecase<br><span class="hljs-built_in">set</span> cursorline<br><span class="hljs-built_in">set</span> autoindent<br>autocmd BufNewFile *.sh <span class="hljs-built_in">exec</span> <span class="hljs-string">":call SetTitle()"</span><br>func SetTitle()<br>        <span class="hljs-keyword">if</span> expand(<span class="hljs-string">"%:e"</span>) == <span class="hljs-string">'sh'</span><br>        call setline(1,<span class="hljs-string">"#!/bin/bash"</span>)<br>        call setline(2,<span class="hljs-string">"#"</span>)<br>        call setline(3,<span class="hljs-string">"#********************************************************************"</span>)<br>        call setline(4,<span class="hljs-string">"#Author:                ashjian"</span>)<br>        call setline(5,<span class="hljs-string">"#QQ:                    2672259469"</span>)<br>        call setline(6,<span class="hljs-string">"#Date:                  "</span>.strftime(<span class="hljs-string">"%Y-%m-%d"</span>))<br>        call setline(7,<span class="hljs-string">"#FileName：             "</span>.expand(<span class="hljs-string">"%"</span>))<br>        call setline(8,<span class="hljs-string">"#URL:                   http://www.ashjian.xyz"</span>)<br>        call setline(9,<span class="hljs-string">"#Description：          The test script"</span>)<br>        call setline(10,<span class="hljs-string">"#Copyright (C):        "</span>.strftime(<span class="hljs-string">"%Y"</span>).<span class="hljs-string">" All rights reserved"</span>)<br>        call setline(11,<span class="hljs-string">"#********************************************************************"</span>)<br>        call setline(12,<span class="hljs-string">""</span>)<br>        endif<br>endfunc<br>autocmd BufNewFile * normal G<br></code></pre></td></tr></table></figure>

<p>5、编写用户的环境初始化脚本reset.sh，包括别名，登录提示符，vim的设置，环境变量等、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#vim reset.sh   </span><br><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#********************************************************************</span><br><span class="hljs-comment">#Author:                ashjian</span><br><span class="hljs-comment">#QQ:                    2672259469</span><br><span class="hljs-comment">#Date:                  2020-08-21</span><br><span class="hljs-comment">#FileName：             /root/f2.sh</span><br><span class="hljs-comment">#URL:                   http://www.ashjian.xyz</span><br><span class="hljs-comment">#Description：          The test script</span><br><span class="hljs-comment">#Copyright (C):         2020 All rights reserved</span><br><span class="hljs-comment">#********************************************************************</span><br>CS=<span class="hljs-string">"\033[1;$[RANDOM%7+31]m"</span><br>CE=<span class="hljs-string">"\033[0m"</span>   <br>   这儿是定义了一些别名登陆时自动启用的，还有就是登陆提示符。<br>cat &gt; /etc/profile.d/env.sh &lt;&lt; EOF<br><span class="hljs-built_in">alias</span> cdnet=<span class="hljs-string">"cd /etc/sysconfig/network-scripts"</span><br><span class="hljs-built_in">alias</span> editnet=<span class="hljs-string">"vim /etc/sysconfig/network-scripts/ifcfg-ens33"</span><br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">"[\[\e[32m\]\u\[\e[36m\]@\h_v7\[\e[31m\]\[\e[0m\] \w]\\$ "</span><br><span class="hljs-built_in">export</span> PATH=/app/bin:<span class="hljs-variable">$PATH</span><br>&gt;EOF<br>cat &gt; ~/.vimrc &lt;&lt; EOF<br><span class="hljs-built_in">set</span> nu<br>&gt;EOF  <br> <span class="hljs-comment">#取os版本号</span><br>VER=`sed -rn <span class="hljs-string">'s@^.* ([0-9]+)\..*@\1@p'</span> /etc/redhat-release`  <br><span class="hljs-comment">#修改centos7,8网卡名为传统网卡名</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$VER</span> -ge 7 ];<span class="hljs-keyword">then</span><br>      sed -ir <span class="hljs-string">'/GRUB_CMDLINE_LINUX/s@"$@ net.ifnames=0"@'</span> /etc/default/grub<br>        grub2-mkconfig -o /etc/grub2.cfg<br><span class="hljs-keyword">fi</span>    <br> <span class="hljs-comment">#这个是更改selinux启用和关闭</span><br><span class="hljs-comment">#Disable selinux</span><br>sed -i <span class="hljs-string">'s@^SELINUX=enforcing@SELINUX=disabled@p'</span> /etc/selinux/config<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL编程</tag>
        <tag>练习题</tag>
      </tags>
  </entry>
  <entry>
    <title>练习题（shell进阶之函数）</title>
    <url>/%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88shell%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>1 打印国际象棋</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br># ┌───────────────────────────────────────────────────────┐<br># │Script Name | cheer.sh                      ▮▮▮▮▮▮▮▮   │<br># │Date        | 2020-07-04                       ▮▮      │<br># │Author      | ashjian                  ▮▮▮▮▮▮▮▮▮▮▮▮ │<br># │Blog        | http:&#x2F;&#x2F;www.ashjian.xyz        ▮▮      │<br># │Version     | 1.0                           ▮▮▮▮▮      │<br># │Description | This is description.             ▮▮      │<br># └───────────────────────────────────────────────────────┘<br>red()&#123; echo -ne &quot;\033[41m      \033[0m&quot;; &#125;<br>yellow()&#123; echo -ne &quot;\033[43m      \033[0m&quot;; &#125;<br><br>for i in &#96;seq 9&#96;; do<br>    for k in &#96;seq 3&#96;;do<br>        for j in &#96;seq 9&#96;; do<br>            let sum&#x3D;i+j<br>            let mod&#x3D;sum%2<br>            if [ $mod -eq 1 ]; then<br>               red<br>            else<br>               yellow<br>            fi<br>        done<br>        echo<br>    done<br>done<br></code></pre></td></tr></table></figure>

<blockquote>
<p>2 斐波那契数列又称黄金分割数列，因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2）<br>利用函数，求n阶斐波那契数列</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bash<br># ┌───────────────────────────────────────────────────────┐<br># │Script Name | fib.sh                        ▮▮▮▮▮▮▮▮   │<br># │Date        | 2017-07-04                       ▮▮      │<br># │Author      | ashjian                  ▮▮▮▮▮▮▮▮▮▮▮▮ │<br># │Blog        | http:&#x2F;&#x2F;www.ashjian.xyz        ▮▮      │<br># │Version     | 1.0                           ▮▮▮▮▮      │<br># │Description | This is description.             ▮▮      │<br># └───────────────────────────────────────────────────────┘<br>read -p &quot;请输入数列个数：&quot; n<br><br>fib()&#123;<br>    if [ $1 -eq 0 ] ; then<br>        ret&#x3D;0<br>        echo $ret<br>    elif [ $1 -eq 1 ]; then<br>        ret&#x3D;1<br>        echo $ret<br>    elif [ $1 -gt 1 ]; then<br>        let ret&#x3D;$(fib $[$1-1])+$(fib $[$1-2])<br>        echo $ret<br>    fi<br>&#125;<br><br>for i in &#96;seq $n&#96;; do<br>    fib $i<br>done<br>#!&#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure>

<blockquote>
<p>3 编写服务脚本/root/bin/testsrv.sh，完成如下要求<br>(1) 脚本可接受参数：start, stop, restart, status<br>(2) 如果参数非此四者之一，提示使用格式后报错退出<br>(3) 如是start:则创建/var/lock/subsys/SCRIPT_NAME, 并显示“启动成功”<br>考虑：如果事先已经启动过一次，该如何处理？<br>(4) 如是stop:则删除/var/lock/subsys/SCRIPT_NAME, 并显示“停止完成”<br>考虑：如果事先已然停止过了，该如何处理？<br>(5) 如是restart，则先stop, 再start<br>考虑：如果本来没有start，如何处理？<br>(6) 如是status, 则如果/var/lock/subsys/SCRIPT_NAME文件存在，则显示“SCRIPT_NAMEis running…”<br>如果/var/lock/subsys/SCRIPT_NAME文件不存在，则显示“SCRIPT_NAME is stopped…”<br>其中：SCRIPT_NAME为当前脚本名<br>(7)在所有模式下禁止启动该服务，可用chkconfig和service命令管理</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/env bash</span><br><span class="hljs-comment">#chkconfig: 345 99 0</span><br><span class="hljs-comment"># ┌───────────────────────────────────────────────────────┐</span><br><span class="hljs-comment"># │Script Name | testsrv.sh                    ▮▮▮▮▮▮▮▮   │</span><br><span class="hljs-comment"># │Date        | 2020-07-04                       ▮▮      │</span><br><span class="hljs-comment"># │Author      | ashjian                  ▮▮▮▮▮▮▮▮▮▮▮▮ │</span><br><span class="hljs-comment"># │Blog        | http://www.ashjian.xyz        ▮▮      │</span><br><span class="hljs-comment"># │Version     | 1.0                           ▮▮▮▮▮      │</span><br><span class="hljs-comment"># │Description | This is description.             ▮▮      │</span><br><span class="hljs-comment"># └───────────────────────────────────────────────────────┘</span><br><br>srvfile=<span class="hljs-string">"/var/lock/subsys/`basename <span class="hljs-variable">$0</span>`"</span><br><br><span class="hljs-function"><span class="hljs-title">func_start</span></span>()&#123; <br>    <span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$srvfile</span> ];<span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"服务已启动,无需再次启动"</span><br>    <span class="hljs-keyword">else</span><br>        touch <span class="hljs-variable">$srvfile</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"启动成功"</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">func_stop</span></span>()&#123;<br>    <span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$srvfile</span> ];<span class="hljs-keyword">then</span><br>        rm -f <span class="hljs-variable">$srvfile</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"停止完成"</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"服务未启动，无需停止"</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">func_restart</span></span>()&#123; <br>    func_stop<br>    func_start<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">func_status</span></span>()&#123;<br>    <span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$srvfile</span> ];<span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"`basename <span class="hljs-variable">$0</span>` is running..."</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"`basename <span class="hljs-variable">$0</span>` has stoped..."</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-string">"start"</span>)<br>        func_start<br>        ;;<br>    <span class="hljs-string">"stop"</span>)<br>        func_stop<br>        ;;<br>    <span class="hljs-string">"restart"</span>)<br>        func_restart<br>        ;;<br>    <span class="hljs-string">"status"</span>)<br>        func_status<br>        ;;<br>    *)<br>        <span class="hljs-string">"输入参数错误, Usage: `basename <span class="hljs-variable">$0</span>` start|stop|restart|status"</span><br>        ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
        <tag>练习题</tag>
      </tags>
  </entry>
  <entry>
    <title>练习（sed文本处理）</title>
    <url>/%E7%BB%83%E4%B9%A0%EF%BC%88sed%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、删除centos7系统/etc/grub2.cfg文件中所有以空白开头的行行首的空白字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sed -r &#39;s@^([[:space:]]*)@@g&#39; &#x2F;etc&#x2F;grub2.cfg<br>sed -r &#39;s&#x2F;^([[:blank:] ]+)(.+)$&#x2F;\2&#x2F;g&#39; &#x2F;etc&#x2F;grub2.cfg<br>sed -nr &#39;s&#x2F;^[[:space:]]+&#x2F;&#x2F;p&#39; &#x2F;etc&#x2F;grub2.cfg<br></code></pre></td></tr></table></figure>

<p>2、删除/etc/fstab文件中所有以#开头，后面至少跟一个空白字符的行的行首的#和空白字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sed -r &#39;s@^(#[[:space:]]+)@@g&#39; &#x2F;etc&#x2F;fstab<br></code></pre></td></tr></table></figure>

<p>3、在centos6系统/root/install.log每一行行首增加#号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sed -r &#39;s@^(.*)@#\1@g&#39; &#x2F;root&#x2F;install.log<br></code></pre></td></tr></table></figure>

<p>4、在/etc/fstab文件中不以#开头的行的行首增加#号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sed -r &#39;s&#x2F;^([[:alnum:]])&#x2F;#\1&#x2F;g&#39; &#x2F;etc&#x2F;fstab<br></code></pre></td></tr></table></figure>

<p>5、处理/etc/fstab路径,使用sed命令取出其目录名和基名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">echo &#39;&#x2F;etc&#x2F;fstab&#39; | sed -r &#39;s@[[:alpha:]]*$@@&#39;;#取目录名<br>echo &#39;&#x2F;etc&#x2F;fstab&#39; | sed -r &#39;s@^.*&#x2F;@@&#39;; #取基名<br></code></pre></td></tr></table></figure>

<p>6、利用sed 取出ifconfig命令中本机的IPv4地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ifconfig | sed -r &#39;2!d;s@^(.*addr:)(.*)(\ Bc.*)@\2@&#39;;#CentOS6<br>ifconfig | sed -r &#39;2!d;s&#x2F;^(.*inet )(.*)( net.*)&#x2F;\2&#x2F;&#39;;#CentOS7<br></code></pre></td></tr></table></figure>

<p>7、统计centos安装光盘中Package目录下的所有rpm文件的以.分隔倒数第二个字段的重复次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ls -1 &#x2F;media&#x2F;CDROM&#x2F;Packages&#x2F; | sed -r &#39;s@^(.*\.)(.*)(\.rpm)$@\2@g&#39; | sort | uniq -c;#CentOS6<br>ls -1 &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS\ 7\ x86_64&#x2F;Packages&#x2F; | sed -r &#39;s@^(.*\.)(.*)(\.rpm)$@\2@g&#39; | sort | uniq -c;#CentOS7<br><br>ls &#x2F;misc&#x2F;cd&#x2F;Packages&#x2F;|grep &quot;rpm$&quot;|sed -r &#39;s@.*\.(.*)\.rpm@\1@&#39;|sort|uniq -c<br>ls &#x2F;misc&#x2F;cd&#x2F;Packages&#x2F;|grep &quot;rpm$&quot;|sed -e &#39;s@.rpm$@@&#39; -e &#39;s@.*\.@@&#39;|sort|uniq -c<br>ls &#x2F;misc&#x2F;cd&#x2F;Packages&#x2F;|rev|cut -d. -f2|sort -nr|rev|uniq -c|sort -nr|head -n3<br></code></pre></td></tr></table></figure>

<p>8、统计/etc/init.d/functions文件中每个单词的出现次数，并排序（用grep和sed两种方法分别实现）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">cat &#x2F;etc&#x2F;init.d&#x2F;functions|tr -c &#39;[:alpha:]&#39; &#39;\n&#39;|tr -s &#39;\n&#39;|sort|uniq -c|sort -nr<br>sed -nre &#39;s&#x2F;[^[:alnum:]]+&#x2F;\n&#x2F;g&#39; -e &#39;s&#x2F;[0-9]&#x2F;\n&#x2F;gp&#39; &#x2F;etc&#x2F;init.d&#x2F;functions|sort|uniq -c|sort -n<br>grep -Eo &quot;\&lt;[[:alpha:]_]+[[:alnum:]]+\&gt;&quot; &#x2F;etc&#x2F;init.d&#x2F;functions|sort|uniq -c|sort -n<br></code></pre></td></tr></table></figure>

<p>9、将文本文件的n和n+1行合并为一行，n为奇数行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nl &#x2F;etc&#x2F;fstab | sed -n &#39;N;s&#x2F;\n&#x2F;&#x2F;p&#39;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本处理</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>练习（文件查找）</title>
    <url>/%E7%BB%83%E4%B9%A0%EF%BC%88%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、查找/var目录下属主为root，且属组为mail的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;var&#x2F; -user root -a -group mail -ls<br></code></pre></td></tr></table></figure>

<p>2、查找/var目录下不属于root、lp、gdm的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;var&#x2F; ! ( -user root -o -user lp -o -user gdm ) -ls<br>或 <br>find &#x2F;var&#x2F; ! -user root -a ! -user lp -a ! -user gdm -ls<br></code></pre></td></tr></table></figure>

<p>3、查找/var目录下最近一周内其内容修改过，同时属主不为root，也不是postfix的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;var&#x2F; -mtime -7 ! ( -user root -o -user postfix ) -ls<br></code></pre></td></tr></table></figure>

<p>4、查找当前系统上没有属主或属组，且最近一个周内曾被访问过的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find -nouser -o -nogroup -a -atime -7 -ls<br></code></pre></td></tr></table></figure>

<p>5、查找/etc目录下大于1M且类型为普通文件的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;etc&#x2F; -type f -size +1M -ls<br></code></pre></td></tr></table></figure>

<p>6、查找/etc目录下所有用户都没有写权限的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;etc&#x2F; ! -perm &#x2F;222 -ls<br></code></pre></td></tr></table></figure>

<p>7、查找/etc目录下至少有一类用户没有执行权限的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;etc&#x2F; ! -perm -111 -ls<br></code></pre></td></tr></table></figure>

<p>8、查找/etc/init.d目录下，所有用户都有执行权限，且其它用户有写权限的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">find &#x2F;etc&#x2F;init.d&#x2F; -perm -111 -a -perm -002 -ls<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>练习（软件包安装）</title>
    <url>/%E7%BB%83%E4%B9%A0%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、查询命令java来自于哪个rpm包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum search java<br>dnf info java 或 dnf list java<br></code></pre></td></tr></table></figure>

<p>2、yum的配置和使用,包括yum仓库的创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地源（光盘）</span><br><span class="hljs-comment">## 1、插入并挂载光盘</span><br>[root@ashjian ~]<span class="hljs-comment"># mount /dev/sr0 /mnt</span><br><br><span class="hljs-comment">## 2、备份系统自带的 repo 文件</span><br>[root@ashjian ~]<span class="hljs-comment"># mkdir /etc/yum.repos.d/bak</span><br>[root@ashjian ~]<span class="hljs-comment"># mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak/</span><br><br><span class="hljs-comment">## 3、创建 local.repo 文件</span><br>[root@ashjian ~]<span class="hljs-comment"># vim /etc/yum.repos.d/local.repo</span><br><br><span class="hljs-comment">### 填入以下内容</span><br>[<span class="hljs-built_in">local</span>]<br>name=<span class="hljs-built_in">local</span> base<br>baseurl=file:///mnt/<br>gpgcheck=0<br><br><span class="hljs-comment">## 4、查看</span><br>[root@ashjian ~]<span class="hljs-comment"># yum repolist</span><br><br><span class="hljs-comment"># 网络源（服务器IP为 10.10.10.111）</span><br><span class="hljs-comment">## 1、安装 httpd</span><br>[root@ashjian ~]<span class="hljs-comment"># yum imstall -y httpd</span><br>[root@ashjian ~]<span class="hljs-comment"># systemctl start httpd</span><br>[root@ashjian ~]<span class="hljs-comment"># systemctl enable httpd</span><br><br><span class="hljs-comment">## 2、创建目录结构</span><br>[root@ashjian ~]<span class="hljs-comment"># mkdir /var/www/html/centos/&#123;6,7&#125;/os/x86_64</span><br><br><span class="hljs-comment">## 3、挂载光盘文件（先插入 centos 7 和 centos 6 的光盘，对应的设备分别为 /dev/sr0 和 /dev/sr1）</span><br>[root@ashjian ~]<span class="hljs-comment"># mount /dev/sr0 /var/www/html/centos/7/os/x86_64/</span><br>[root@ashjian ~]<span class="hljs-comment"># mount /dev/sr1 /var/www/html/centos/6/os/x86_64/</span><br><br><span class="hljs-comment">##客户端设置</span><br><span class="hljs-comment">###（1）创建 aliyun.repo 文件</span><br>[root@ashjian ~]<span class="hljs-comment"># vim /etc/yum.repos.d/net.repo</span><br><br><span class="hljs-comment">#### 填入以下内容</span><br>[net]<br>name=net base<br>baseurl=http://10.10.10.111/centos/<span class="hljs-variable">$releasever</span>/os/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=0<br><br><span class="hljs-comment">###（2）查看</span><br>[root@ashjian ~]<span class="hljs-comment"># yum repolist</span><br><br><span class="hljs-comment"># 安装</span><br>[root@ashjian ~]<span class="hljs-comment"># yum install httpd -y</span><br><br><span class="hljs-comment"># 卸载</span><br>[root@ashjian ~]<span class="hljs-comment"># yum remove httpd -y</span><br></code></pre></td></tr></table></figure>

<p>3、编写系统初始化脚本 reset.sh，包括别名，提示符颜色，yum仓库配置文件,安装tree,ftp,lftp,telnet等包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 设置别名</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"alias cdnet='cd /etc/sysconfig/network-script/'"</span> &gt; /etc/profile.d/start.sh<br><br><span class="hljs-comment"># 设置PS1</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'PS1="\[\e[0;34m\][\[\e[0;31m\]\t \[\e[0;34m\]\u\[\e[1;32m\]@\h \[\e[0;36m\]\W\[\e[0;34m\]\[\e[0;34m\]]\\$\[\e[0m\]"'</span> &gt;&gt; /etc/profile.d/start.sh<br><br><span class="hljs-comment"># yum 配置</span><br>mkdir /etc/yum.repos.d/bak &amp;&gt; /dev/null<br>mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak/ &amp;&gt; /dev/null<br>OS_VER=`cat /etc/redhat-release | sed -nr <span class="hljs-string">'s/^.* ([0-9]+).*$/\1/p'</span>`<br>wget -O /etc/yum.repos.d/aliyun.repo https://mirrors.aliyun.com/repo/Centos-<span class="hljs-variable">$&#123;OS_VER&#125;</span>.repo<br><br><span class="hljs-comment"># 安装 tree,ftp,lftp,telnet</span><br>yum install -y tree ftp lftp telnet<br></code></pre></td></tr></table></figure>

<p>4、在CentOS 7上编译安装 apache 2.4.25 源码包,并启动此服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装相关工具</span><br>[root@ashjian ~]<span class="hljs-comment"># yum -y install gcc openssl-devel pcre-devel apr-devel apr-util-devel</span><br><br><span class="hljs-comment"># 下载安装包</span><br>[root@ashjian ~]<span class="hljs-comment"># wget https://downloads.apache.org/httpd/httpd-2.4.43.tar.bz2</span><br><br><span class="hljs-comment"># 解压</span><br>[root@ashjian ~]<span class="hljs-comment"># tar -xvf httpd-2.4.43.tar.bz2</span><br><br><span class="hljs-comment"># 安装</span><br>[root@ashjian ~]<span class="hljs-comment"># cd httpd-2.4.43</span><br>[root@ashjian httpd-2.4.43]<span class="hljs-comment"># ./configure --prefix=/apps/httpd24 --sysconfdir=/etc/httpd --enable-ssl --enable-so</span><br>[root@ashjian httpd-2.4.43]<span class="hljs-comment"># make &amp;&amp; make install</span><br><br><span class="hljs-comment"># 启动服务</span><br>[root@ashjian httpd-2.4.43]<span class="hljs-comment"># /apps/httpd24/bin/apachectl start</span><br><br><span class="hljs-comment"># 测试</span><br>[root@ashjian httpd-2.4.43]<span class="hljs-comment"># curl 127.0.0.1</span><br>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure>



<p>以下为转载：<a href="https://blog.csdn.net/suika_xiaoyuzhenren/article/details/102664715" target="_blank" rel="noopener">https://blog.csdn.net/suika_xiaoyuzhenren/article/details/102664715</a></p>
<p>在安装httpd软件包时，可以先做好安装前的步骤</p>
<ul>
<li>获取Apache httpd源码包，可以在官网<a href="https://www.apache.org/dist/httpd/" target="_blank" rel="noopener">https://www.apache.org/dist/httpd/</a>  选择你想下载的版本，我已经下载下来了，在/data目录下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202444.png" alt="img"></p>
<ul>
<li>解压下载的httpd源码包</li>
</ul>
<p>解压命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tar xzf httpd-2.4.34.tar.gz<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826202444.png" alt="img"></p>
<ul>
<li>进入解压后的目录，查看INSTALL、README、./configure –help里的安装信息、注意事项、你想要的功能选项</li>
</ul>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">./configure --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213358.png" alt="img"></p>
<ul>
<li>查看完帮助文档后，开始进行./configure编译（我想启用ssl功能）</li>
</ul>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">./configure --prefix=/usr/<span class="hljs-built_in">local</span>/httpd --<span class="hljs-built_in">enable</span>-ssl<br></code></pre></td></tr></table></figure>

<ul>
<li>./configure 编译报错 1：</li>
</ul>
<p>configure: error: pcre-config for libpcre not found. PCRE is required and available from <a href="http://pcre.org/" target="_blank" rel="noopener">http://pcre.org/</a></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213352.png" alt="img"></p>
<p>貌似是提示我缺少某个东西（有可能是包文件，也有可能是其他东西），yum源中搜索关键字  pcre </p>
<p>试试安装 pcre-devel.x86_64 这个包后在重新./configure编译</p>
<p>诶，好像没有再报  错误1 的信息了，但是又出现了错误2</p>
<ul>
<li>./configure 编译报错 1：</li>
</ul>
<p>checking for OpenSSL… checking for user-provided OpenSSL base directory… none</p>
<p>checking for OpenSSL version &gt;= 0.9.8a… FAILED</p>
<p>configure: WARNING: OpenSSL version is too old</p>
<p>no</p>
<p>checking whether to enable mod_ssl… configure: error: mod_ssl has been requested but can not be built due to prerequisite failures</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213340.png" alt="img"></p>
<p>这个报错是我在添加 enable-ssl 这个功能时出现的，提示需要OpenSSL版本大于等于0.9.8a</p>
<p>yum源搜索，然后安装后。。。。。要的包依赖更多了。。。。。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213322.png" alt="img"></p>
<p>（ps:说实话，我给公司搭建小型网站架构时，如果有需要的功能选项，都是直接下源码包编译安装，再指定安装后的路径给httpd编译。这是因为，可以不用管rpm包依赖问题。有些时候，包依赖看得脑壳疼。。。。）</p>
<p>然后。。。我不要  ssl 功能试试看？看看可以不</p>
<p>结果：安装成功，报错2可以忽略掉</p>
<ol>
<li>./configure编译成功后会生成Makefile  运行命令  make &amp;&amp; make install</li>
</ol>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">make &amp;&amp; make install<br></code></pre></td></tr></table></figure>

<p>结果：编译、安装成功</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213253.png" alt="img"></p>
<p>安装后的步骤</p>
<p>#创建用户httpd为系统用户，并指定uid为80，不能登录系统，家目录为/usr/local/httpd/htdocs/</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">useradd -r -u 80  -s /sbin/nologin -d /usr/<span class="hljs-built_in">local</span>/httpd/htdocs/ httpd<br></code></pre></td></tr></table></figure>



<p>#设置/usr/local/httpd/htdocs/的权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chown -R httpd:httpd /usr/<span class="hljs-built_in">local</span>/httpd/htdocs &amp;&amp; chmod -R 775 /usr/<span class="hljs-built_in">local</span>/httpd/htdocs<br></code></pre></td></tr></table></figure>



<p>#将/usr/local/httpd/bin/apachectl复制到/etc/init.d 目录下面命名为httpd，并在文档里面第二行后添加文本信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cp /usr/<span class="hljs-built_in">local</span>/httpd/bin/apachectl /etc/init.d/httpd &amp;&amp; sed  -i <span class="hljs-string">'2a\#chkconfig: 2345 10 90'</span> /etc/init.d/httpd<br></code></pre></td></tr></table></figure>

<p>#启动httpd服务,并将服务添加到chkconfig</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl start httpd &amp;&amp; chkconfig --level 2345 httpd on<br></code></pre></td></tr></table></figure>



<p>#判断httpd服务有没有启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netstat -tuanlep | grep httpd &amp;&gt; /dev/null &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> flase<br></code></pre></td></tr></table></figure>



<p>启动成功，成功页面~~</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213239.png" alt="img"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>软件包管理</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>网卡绑定(bonding)</title>
    <url>/%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A-bonding/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>就是将多块网卡绑定同一IP地址对外提供服务，可以实现高 可用或者负载均衡。当然，直接给两块网卡设置同一IP地址 是不可能的。通过bonding，虚拟一块网卡对外提供连接， 物理网卡的被修改为相同的MAC地址。</p>
<ul>
<li>Mode 0 (balance-rr)</li>
</ul>
<p>轮转（Round-robin）策略：从头到尾顺序的在每一个slave 接口上面发送数据包。本模式提供负载均衡和容错的能力</p>
<ul>
<li>Mode 1 (active-backup)</li>
</ul>
<p>活动-备份（主备）策略：只有一个slave被激活，当且仅当活动 的slave接口失败时才会激活其他slave。为了避免交换机发生混 乱此时绑定的MAC地址只有一个外部端口上可见</p>
<ul>
<li>Mode 3 (broadcast)</li>
</ul>
<p>广播策略：在所有的slave接口上传送所有的报文,提供容错能力</p>
<ul>
<li>active-backup、balance-tlb 和 balance-alb 模式不需要 交换机的任何特殊配置。其他绑定模式需要配置交换机以便 整合链接。如：Cisco 交换机需要在模式 0、2 和 3 中使用 EtherChannel，但在模式4中需要 LACP和 EtherChannel</li>
</ul>
<p>配置方法：</p>
<p>新建文件<code>/etc/sysconfig/network-scripts/ifcfg-bond0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">DEVICE&#x3D;bond0<br>BONDING_OPTS&#x3D;&quot;miimon&#x3D;100 mode&#x3D;0&quot;<br>BOOTPROTO&#x3D;none<br>IPADDR&#x3D;<br>PREFIX&#x3D;<br>GATEWAY&#x3D;<br>DNS1&#x3D;<br>DNS2&#x3D;<br>DOMAIN&#x3D;<br>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0<br>DEVICE&#x3D;eth0<br>BOOTPROTO&#x3D;none<br>MASTER&#x3D;bond0<br>SLAVE&#x3D;yes<br>USERCTL&#x3D;no<br></code></pre></td></tr></table></figure>

<p>同样的，也要修改eth1的ifcfg文件。</p>
<p>查看bond0状态：/proc/net/bonding/bond0</p>
<p>各种bond模式详细说明：<br>详细帮助：</p>
<p>/usr/share/doc/kernel-doc-version/Documentation/networking/bonding.txt</p>
<p><a href="https://www.kernel.org/doc/Documentation/networking/bonding.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/networking/bonding.txt</a></p>
<h2 id="team"><a href="#team" class="headerlink" title="team"></a>team</h2><p>team网络组：是将多个网卡聚合在一起方法，从而实现冗错和提 高吞吐量</p>
<p>网络组不同于旧版中bonding技术，提供更好的性能和扩展性</p>
<p>网络组由内核驱动和teamd守护进程实现.</p>
<p>多种方式runner</p>
<ul>
<li>broadcast</li>
<li>roundrobin</li>
<li>activebackup</li>
<li>loadbalance</li>
<li>lacp (implements the 802.3ad Link Aggregation Control Protocol)</li>
</ul>
<p><strong>命令格式：</strong></p>
<p><strong>创建team：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con add type team con-name CNAME ifname INAME [config JSON]<br></code></pre></td></tr></table></figure>

<ul>
<li><code>CNAME</code> 连接名，<code>INAME</code> 接口名</li>
<li><code>JSON</code> 指定<code>runner</code>方式</li>
</ul>
<p>格式：<code>&#39;{&quot;runner&quot;: {&quot;name&quot;: &quot;METHOD&quot;}}&#39;</code></p>
<ul>
<li>METHOD 可以是<code>broadcast</code>, <code>roundrobin</code>,<code>activebackup</code>, <code>loadbalance</code>, <code>lacp</code></li>
</ul>
<p><strong>添加从属接口：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con add type team-slave con-name CNAME ifname INAME master TEAM<br></code></pre></td></tr></table></figure>

<ul>
<li><code>CNAME</code> 连接名</li>
<li><code>INAME</code> 网络接口名</li>
<li><code>TEAM</code> 网络组接口名<br>连接名若不指定，默认为team-slave-IFACE<br><a href="http://www.yulongjun.com/images/14986208642184.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826224135.jpg" alt="img"></a><br><a href="http://www.yulongjun.com/images/14986208743072.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826224151.jpg" alt="img"></a></li>
</ul>
<p><strong>查看team状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">teamdctl team0 state<br></code></pre></td></tr></table></figure>

<p><strong>down team</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli connect down team0<br></code></pre></td></tr></table></figure>

<p><strong>up team</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli connect up team0<br>nmcli conect up team-slave-eth0<br>nmcli connect up team-slave-eth1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>down掉team，连slave也down掉。<br>up的时候，只启动team，要手动启动各个slave。</p>
</blockquote>
<p><strong>实验：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nmcli con add type team con-name team0 ifname team0 config ‘&#123;&quot;runner&quot;: &#123;&quot;name&quot;: &quot;loadbalance&quot;&#125;&#125;&#39;<br><br>nmcli con mod team0 ipv4.addresses 192.168.1.100&#x2F;24<br><br>nmcli con mod team0 ipv4.method manual<br><br>nmcli con add con-name team0-eth1 type team-slave ifname eth1 master team0<br><br>nmcli con add con-name team0-eth2 type team-slave ifname eth2 master team0<br><br>nmcli con up team0<br><br>nmcli con up team0-eth1<br><br>nmcli con up team0-eth2<br><br>teamdctl team0 state; # nmcli dev dis eth1<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络linux操作</title>
    <url>/%E7%BD%91%E7%BB%9Clinux%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载：<a href="https://blog.csdn.net/weixin_34049948/article/details/92724568" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34049948/article/details/92724568</a></p>
<p>本章内容</p>
<p>​     IP地址配置</p>
<p>​     路由管理</p>
<p>​     配置文件管理</p>
<p>​     DNS配置</p>
<p>​     </p>
<p>基本网络配置</p>
<p>​        将linux主机接入到网络，需要配置网络相关设置。</p>
<p>​        一般包括如下操作：</p>
<p>​           主机名</p>
<p>​           IP/netmask</p>
<p>​           路由：默认网关</p>
<p>​           DNS服务器</p>
<p>​              主DNS服务器</p>
<p>​              次DNS服务器</p>
<p>​              第三DNS服务器</p>
<p>​        </p>
<p>centos6网卡名称：</p>
<p>​        接口命名方式：centos 6</p>
<p>​           以太网：eth[0,1,2,…]</p>
<p>​           ppp: ppp[0,1,2,…]</p>
<p>​        网络接口识别并命名相关的udev配置文件：</p>
<p>​            /etc/udev/rules.d/70-persistent-net.rules</p>
<p>​        查看网卡驱动：</p>
<p>dmesg      dmesg | grep -i eth      </p>
<p>ethtool      ethtool -i eth0</p>
<p>​        卸载网卡驱动：</p>
<p>modprobe    modprobe -r e1000</p>
<p>rmmod     rmmod e1000</p>
<p>​        装载网卡驱动：</p>
<p>​           modprobe e1000</p>
<p>​          </p>
<p>网络配置方式：</p>
<p>​        静态指定：</p>
<p>​           ifconfig，route，netstat</p>
<p>​           ip：object{link,addr.route},ss,rc</p>
<p>system-config-network-tui,setup</p>
<p>​           配置文件</p>
<p>​        动态分配：</p>
<p>​           DHCP：Dynamic Host Configuration Protlcol</p>
<p>​          </p>
<p>ifconfig：</p>
<p>​        ifconfig [interface] 查看网络接口</p>
<p>​           ifconfig -a          显示所有网络接口（包含状态为down）</p>
<p>​           ifconfig InterFace  [up|down]    启用、关闭网络接口（网卡）</p>
<p>​        ifconfig interface [aftype] options | address</p>
<p>​           ifconfig IFACE IP/netmask  [up]</p>
<p>​           ifconfig IFACE IP netmask  NETMASK 配置IP地址</p>
<p>​        注意：</p>
<p>​           修改立即生效</p>
<p>​        启用混杂模式：[-]promisc</p>
<p>route:</p>
<p>​        路由记录类型：</p>
<p>​           主机路由 -host</p>
<p>​           网络路由 -net  netmask</p>
<p>​           默认路由</p>
<p>​        查看：</p>
<p>​           route -n</p>
<p>​        添加路由：route add</p>
<p>​           route add [-host|-net]  target [netmask NM] [gw GW] [dev IFACE]</p>
<p>​        </p>
<p>​           添加主机路由：</p>
<p>​              目标192.168.1.3 网关 172.16.0.1</p>
<p>​                  route add  -host 192.168.1.3 gw 172.16.0.1 [dev eth0]</p>
<p>​          </p>
<p>​           添加网络路由：  </p>
<p>​              目标：192.168.0.0 网关 172.16.0.1  </p>
<p>​                  route add  -net 192.168.0.0/24 gw 172.16.0.1</p>
<p>​                  route add  -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1</p>
<p>​                 </p>
<p>​           添加默认路由：</p>
<p>​              默认路由网关：172.16.0.1</p>
<p>​                  route add  -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1</p>
<p>​                  route add  default gw 172.16.0.1</p>
<p>​        </p>
<p>​        删除路由：route del</p>
<p>​              route del  [-host|-net] target [gw GW] [netmask NM] [dev IF]</p>
<p>​           删除主机路由：</p>
<p>​              目标：192.168.1.3 网关 172.16.0.1</p>
<p>​                  route del  -hos 192.168.1.3 gw 172.16.0.1</p>
<p>​           删除网路路由：</p>
<p>​              目标：192.168.0.0 网关 172.16.0.1</p>
<p>​                  route -net  192.168.0.0 netmask 255.255.255.0</p>
<p>​           删除默认路由：</p>
<p>​                  route del  default gw 172.16.0.1</p>
<p>​        </p>
<p>​        ###配置动态路由：</p>
<p>​           通过守护进程获取动态路由</p>
<p>​        ###    安装quagga包</p>
<p>​        ###    主持多种路由协议：rip，ospf。bgp</p>
<p>​        ###    命令vtysh配置</p>
<p>​     </p>
<p>netstat：</p>
<p>​        print network connections，routing  tables,interface statistics,</p>
<p>​        masquerade connections,and multicast  memberships</p>
<p>​        显示网路连接：</p>
<p>​        netstat [–tcp|-t][–udp|-u][–raw|-w][–listening|-l][–all|-a]</p>
<p>​              [–numeric|-n][–extend|-e][–program|-p]</p>
<p>​           -t|–tcp     tcp协议</p>
<p>​           -u|–udp    udp协议</p>
<p>​           -w|–raw       raw socket相关</p>
<p>​           -l|–listen       处于监听状态</p>
<p>​           -a|–all     所有状态</p>
<p>​           -n|–numeric    以数字显示IP和端口</p>
<p>​           -e|–extend 扩展格式</p>
<p>​           -p|–program    显示相关进程及PID</p>
<p>​        常用组合：</p>
<p>​           -tan ，-uan，-tnl -unl</p>
<p>​        显示路由表：</p>
<p>​           netstat {–route|-r}[–numeric|-n]</p>
<p>​              -r  显示内核路由表</p>
<p>​              -n  数字格式</p>
<p>​        显示接口统计数据：</p>
<p>​           netstat {–interface|-l}[iface][–all|-a][–extend|-e]</p>
<p>​                   [–program|-p][–numeric|-n]</p>
<p>​              netstat  -i</p>
<p>​              netstat  -I=IFACE</p>
<p>​              ifconfig -s  iface</p>
<p>​        </p>
<p>ip:</p>
<p>​        配置Linux网络属性：ip命令</p>
<p>​           ip - show / manipulate  routing,devices,policy routing and tunnels</p>
<p>​              显示/操作路由、设备、策略路由和隧道</p>
<p>​        格式：</p>
<p>​           ip [options] objecet  {command|help}</p>
<p>​              object:  {link|addr|route..}</p>
<p>​          </p>
<p>​        PS:  centos6 默认不支持ip等命令补全，需安装辅助包 epel源中</p>
<p>​              yum install  bash-completion</p>
<p>​          </p>
<p>​        </p>
<p>​        ip link：  </p>
<p>​           ip link -network  device configuration 网络设备配置</p>
<p>​              ip link set IFACE  up|down  == ifconfig IFACE  up|down</p>
<p>​                   down掉之后ifconfig 需要加-a选项查看，ip a, ip link 可直接看到状态down</p>
<p>ifup/ifdown:</p>
<p>​                   需要由配置文件，且down掉之后ifconfig可以查看网卡</p>
<p>​                  ip link  状态也依然up</p>
<p>​                 </p>
<p>​              ip link show  iface  单独查看某一网卡</p>
<p>​        ip addr：</p>
<p>​              address|ad|a…：</p>
<p>​           ip addr {add | del} IFADDR  dev STRING</p>
<p>​              [label LABEL]            添加地址时指明网卡别名如（:#）</p>
<p>​               [scope{global,link,host}]     指明作用域</p>
<p>​                   globel:全局可用</p>
<p>​                   link：仅链接可用</p>
<p>​                   host：本机可用</p>
<p>​              </p>
<p>​           ip addr show|flush dev  IFACE   查看清空IP地址</p>
<p>​     </p>
<p>​        ip route:</p>
<p>​            ip route add     添加路由</p>
<p>​              ip route add TARGET  via GW dev IFACE src SOURCE-IP</p>
<p>​                      TARGET:</p>
<p>​                          主机路由：IP</p>
<p>​                          网络路由：NET/MASK</p>
<p>​              ip route add  192.168.0.0/24 via 172.16.0.1</p>
<p>​              ip route add  192.168.6.6   via 172.16.0.1</p>
<p>​              添加网关：</p>
<p>​                  ip route add  default via GW</p>
<p>​              ip route add default  via 172.16.0.1</p>
<p>​          </p>
<p>​           ip route delete       删除路由</p>
<p>​              ip route delete  TARGET</p>
<p>​          </p>
<p>​           ip route show|list 显示路由</p>
<p>​              </p>
<p>​           ip route flush [dev IFACE][via PREFIX]</p>
<p>​                             清除路由</p>
<p>​        </p>
<p>ss：命令</p>
<p>​        格式：ss [option]…[FILTER]</p>
<p>​        netstat 通过遍历proc来获取socket信息，ss使用netlink与内核tcp_diag模块</p>
<p>​           通信获取socket信息</p>
<p>​        选项：</p>
<p>​              -t      tcp协议先关</p>
<p>​              -u     udp协议相关</p>
<p>​              -w     裸套接字相关</p>
<p>​              -l      listen状态的连接</p>
<p>​              -a      所有</p>
<p>​              -n      数字格式</p>
<p>​              -p      相关的程序及PID</p>
<p>​              -e      扩展的信息</p>
<p>​              -m     内存用量</p>
<p>​              -o      计时器信息</p>
<p>​              -s      列出当前socket的详细信息</p>
<p>​              </p>
<p>​        FILTER：[state TCP-STATE][EXPRESSION]</p>
<p>​           TCP 的常见状态：</p>
<p>​              tcp finite state  machine：</p>
<p>​                  LISTEN:     监听</p>
<p>​                   ESTABLISHED:已建立的链接</p>
<p>​                   FIN_WAIT_1 </p>
<p>​                   FIN_WAIT_2</p>
<p>​                   SYN_SENT</p>
<p>​                   SYN_RECV</p>
<p>​                   CLOSED</p>
<p>​           EXPRESSION:</p>
<p>​              dport=</p>
<p>​              sport=</p>
<p>​              示例：  ‘(dport =  :ssh or sport = :ssh)’</p>
<p>​                     ss  state ESTABLISHED sport = :ssh</p>
<p>​        常用组合：   </p>
<p>​           -tan ，-tanl， -tanlp，-uan</p>
<p>​          </p>
<p>​        常见用法：</p>
<p>​           ss -l        显示本地打开的所有端口</p>
<p>​           ss -pl       显示每个进程具体打开的socket</p>
<p>​           ss -ta       显示所有的tcp  socket</p>
<p>​           ss -ua      显示所有的udp  socket</p>
<p>​           ss -o state established  ‘( dport = :ssh or sport = :ssh )’</p>
<p>​                      显示所有已建立的ssh连接</p>
<p>​           ss -o state established  ‘( dport = :http or spout = :http )’</p>
<p>​                      显示所有已建立的http连接</p>
<p>​           ss -s       列出当前socket的详细信息</p>
<p>网络配置文件：</p>
<p>​        ip，mask，gw，dns相关配置文件：</p>
<p>​            /etc/sysconfig/network-scripts/ifcfg-IFACE</p>
<p>​        路由相关的配置文件：</p>
<p>​            /etc/sysconfig/network-scripts/route-IFACE</p>
<p>​        NDS配置文件：</p>
<p>​           /etc/resolv.conf</p>
<p>​        参考说明：</p>
<p>​           centos6.9  /usr/share/doc/initscripts-9.03.58/sysconfig.txt</p>
<p>​           centos7.4  /usr/share/doc/initscripts-9.49.39/sysconfig.txt</p>
<p>​          </p>
<p>​     ifcfg-IFACE:</p>
<p>​           DEVICE     此配置文件应用到的设备</p>
<p>​           HWADDR       对应的设备的MAC地址，如修改，可改为MACADDR=</p>
<p>​           BOOTPROTO 激活此设备时使用的地址配置协议，常用的dhcp，static，none，bootp</p>
<p>​           NM_CONTROLLED:   NM为：NetworkManager的简写，此网卡是否接受NM控制</p>
<p>​           ONBOOT       在系统引导时是否激活此设备</p>
<p>​           TYPE       接口类型；常见的有Ethernet，Bridge</p>
<p>​           UUID       uuid</p>
<p>​           IPADDR     ip地址</p>
<p>​           NETMASK       子网掩码</p>
<p>​           PREFIX      netmask 使用/24  写法</p>
<p>​           GATEWAY      默认网关</p>
<p>​           DNS1       第一个DNS服务器指向</p>
<p>​           DNS2       第二个DNS服务器指向</p>
<p>​           USERCTL    普通用户是否可控制此设备</p>
<p>​           PEERDNS       如果BOOTPROTO的值为dhcp ，是否允许dhcp server分配的dns</p>
<p>​                      服务器指向信息直接覆盖/etc/resolv.conf</p>
<p>​           DEFROUTE   是否把这个eth设置为默认路由       </p>
<p>​           PEERROUTES 是否从DHCP服务器获取用于定义接口的默认网关的信息的路由表条目</p>
<p>​           IPV6INIT 是否启用IPv6接口</p>
<p>​           IPV4_FAILURE_FATAL=yes      如果ipv4配置失败禁用设备</p>
<p>​           IPV6_FAILURE_FATAL=yes      如果ipv6配置失败禁用设备   </p>
<p>​          </p>
<p>​     route-IFACE:</p>
<p>​        两种书写风格：</p>
<p>​           \1.   TARGET via GW  </p>
<p>​           如：192.167.10.0/24 via 192.168.65.1</p>
<p>​              192.168.8.8 via  192.168.65.1</p>
<p>​          </p>
<p>​           \2.   每三行定义一条路由</p>
<p>​               ADDRESS#=ip</p>
<p>​               NETMASK#=mask</p>
<p>​              GATEWAY#=gw  </p>
<p>​           PS: #：为数字 必须从0开始</p>
<p>​              如需添加主机路由 mask 255.255.255.255</p>
<p>​              如需添加默认路由 ip 和mask 都为  0.0.0.0  </p>
<p>​     </p>
<p>​     配置文件修改之后生效：</p>
<p>​        service network restart      centos6</p>
<p>​        systemctl restart network    centos7</p>
<p>​        </p>
<p>​        </p>
<p>主机名和本地解析器：</p>
<p>​        配置当前主机的主机名：</p>
<p>hostname HOSTNAME</p>
<p>​            立即生效，如果想要提示符修改需重新登录，重启失效</p>
<p>​            /etc/sysconfig/network</p>
<p>​           重启生效</p>
<p>​          </p>
<p>​        解析器执行正向和逆向查询</p>
<p>​        /etc/hosts</p>
<p>​           本地主机名数据库和ip地址的映像</p>
<p>​           对小型独立网络有用</p>
<p>​           通常，在使用DNS前检查</p>
<p>​           getent hosts     查看/etc/hosts内容</p>
<p>​          </p>
<p>dns名字解析：</p>
<p>​        /etc/resolv.conf    DNS记录配置文件</p>
<p>​           nameserver  DNS-SERVER-ip1</p>
<p>​           nameserver  DNS-SERVER-ip2</p>
<p>​           nameserver  DNS-SERVER-ip3</p>
<p>​          </p>
<p>​        /etc/nsswitch.conf</p>
<p>​           优先于/etc/hosts 且可以设置/etc/hosts 优先级</p>
<p>​            38 hosts:    files dns  </p>
<p>​                  将files 和 dns  跟换顺序即可降低hosts优先级</p>
<p>​     </p>
<p>​        正向解析：name–&gt; ip</p>
<p>dig        dig [-t A] name  [+trace]</p>
<p>host     host -t A name</p>
<p>​        反向解析：ip–&gt; name</p>
<p>​           dig -x ip</p>
<p>​           host -t PTR ip</p>
<p>网卡别名：</p>
<p>​        对虚拟主机有用</p>
<p>​        将多个IP地址绑定到一个网卡（NIC）上</p>
<p>​           eth0:1 ， eth0:2 ，eth0:3</p>
<p>​        </p>
<p>​        使用ifconfig添加：</p>
<p>​           ifconfig eth0:1  192.168.8.8/24   </p>
<p>​           ifconfig eth0:1  down</p>
<p>​        </p>
<p>​        使用ip命令添加：</p>
<p>​           ip add add 172.16.1.2/24  dev eth0</p>
<p>​           ip a a 172.16.1.3/16 dev eth0 label eth0:1</p>
<p>​           ip addr del 172.16.1.2/24  dev eth0</p>
<p>​           ip a flush dev eth0 label  eth0:0</p>
<p>​          </p>
<p>设备别名：</p>
<p>​        为每个设备别名生成独立的接口配置文件：</p>
<p>​           关闭NetworkManager服务</p>
<p>​           ifcfg-ethX:xxx</p>
<p>​           必须使用静态联网</p>
<p>​              DEVICE=eth0:xxx</p>
<p>​              IPADDR=ip</p>
<p>​               NETMASK=mask</p>
<p>​                   PREFIX=</p>
<p>​              ONPARENT=yes 表明从属关系</p>
<p>网络接口配置-bonding</p>
<p>​        bonding</p>
<p>​           将多块网卡绑定同一IP地址对外提供服务，可以实现高可用或者负载均衡。</p>
<p>​           直接给两块网卡设置同一IP地址是不可以的。通过bonding，虚拟一块网卡对</p>
<p>​           外提供连接，物理网卡被修改为相同的MAC地址</p>
<p>​        </p>
<p>​        bonding工作模式：</p>
<p>​           Mode 0 （balance-rr）</p>
<p>​              轮转（round-robin）策略：从头到尾顺序的在每一个slave</p>
<p>​               接口上面发送数据包。本模式提供负载均衡和容错的能力</p>
<p>​           Mode 1 （active-backup）</p>
<p>​              活动-备份（主备）策略：只有一个slave被激活，当且仅当活动的slave</p>
<p>​               接口失败时才会激活其他slave。为了避免交换机发生混乱，此时绑定的</p>
<p>​               MAC地址只有一个外部端口上可见</p>
<p>​           Mode 3（broadcast）</p>
<p>​               广播策略：在所有的slave接口上传送所有的报文，提供容错能力</p>
<p>​          </p>
<p>​           active-backup、balance-tlb和balance-alb模式不需要交换机的任何特殊配置。</p>
<p>​            其他绑定模式需要配置交换机以便整合链接。如：</p>
<p>​               Cisco交换机需要在模式0、2、3中使用EtherChannel，但在模式4中需要LACP</p>
<p>​              和EtherChannel</p>
<p>​              </p>
<p>​        创建bonding设备的配置文件：</p>
<p>​            /etc/sysconfig/network-scripts/ifcfg-bond0</p>
<p>​               DEVICE=bond0</p>
<p>​               BOOTPROTO=none</p>
<p>​               BONDING_OPTS=”miimon=100 mode=0”</p>
<p>​            /etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>​               DEVICE=eht0</p>
<p>​               BOOTPROTO=none</p>
<p>​               MASTE=bond0</p>
<p>​              SLAVE=yes</p>
<p>​               USERCTL=no</p>
<p>​           查看bond0状态： /proc/net/bonding/bond0</p>
<p>​          </p>
<p>​        miimon是用来进行链路监测的。如果miimon=100，那么系统每100ms监测一次链路</p>
<p>​        状态，如果一条线路不通就转入另一条线路</p>
<p>​        </p>
<p>​        删除bond0</p>
<p>​           ifconfig bond0  down</p>
<p>rmmod     rmmod bonding</p>
<p>​        </p>
<p>​        详细帮助：</p>
<p>​            <a href="https://www.kernel.org/doc/Documentation/networking/bonding.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/networking/bonding.txt</a></p>
<p>​          </p>
<p>CentOS 7 网络属性配置</p>
<p>​        Centos 6之前，网络接口使用连续号码命名:eth0、eth1等，当增加或删除网卡时，名称</p>
<p>​        可能会发生变化</p>
<p>​        CentOS7使用基于硬件，设备拓扑和设置类型命名</p>
<p>​           1 网卡命名机制：</p>
<p>​               systemd对网络设备的命名方式：</p>
<p>​              a   如果Fireware或BIOS为主板上集成的设备提供的索引信息可用，且</p>
<p>​                   且可预测，则根据此索引进行命名，例如eno1</p>
<p>​              b   如果Fireware或BIOS 为PCI-E扩展槽提供的索引信息可用，且可预测，则</p>
<p>​                   根据此索引进行命名，例如ens1</p>
<p>​              c   如果硬件接口的物理位置信息可用，则根据此信息进行命名，例如enp2s0</p>
<p>​              d   如果用户显示启动，也可根据MAC地址进行命名，如enx2387…</p>
<p>​              e   上述均不可用时，则使用传统命名机制</p>
<p>​        </p>
<p>​              基于BIOS支持启用biosdevname软件：</p>
<p>​                   内置网卡：   em1，em2</p>
<p>​                   pci卡：      pYpX   Y：slot，X：port        </p>
<p>​          </p>
<p>​           2   名称组成格式：</p>
<p>​                   en：     Ethernet 有限局域网</p>
<p>​                   wl： wlan 无限局域网</p>
<p>​                   ww：    wwan   无线广域网</p>
<p>​              名称类型：</p>
<p>​                  o  <index>:   集成设备的设备索引号</p>
<p>​                  s  <soft>: 扩展槽的索引号</p>
<p>​                  x  <MAC>:   基于MAC地址的命名</p>
<p>​                   p<bus>s<slot>:   enp2s1</p>
<p>​          </p>
<p>​        采用传统命名方式：</p>
<p>​           1   编辑/etc/default/grub配置文件</p>
<p>​               GRUB_CMDLINE_LINUX=”crashkernel=auto rhgb  quiet net.ifnames=0</p>
<p>​           2   为grub2生成其配置文件</p>
<p>​              grub2-mkconfig -o  /etc/grub2.cfg</p>
<p>​           3   重启系统</p>
<p>​          </p>
<p>​           或者直接修改/boot/grub2/grub.cfg</p>
<p>​              在linux16.* 行尾添加 net.ifnames=0</p>
<p>​          </p>
<p>Centos 7修改主机名：</p>
<p>​        配置文件：/etc/hostname,默认没有此文件，通过DNS反向解析获取主机名，</p>
<p>​           默认为：localhost.localdomain</p>
<p>​        显示主机名信息：</p>
<p>​           hostname</p>
<p>​           hostamectl  status</p>
<p>​        设置主机名：</p>
<p>​           hostnamectl set-hostname  centos7.4</p>
<p>​              </p>
<p>Centos7网络配置工具：</p>
<p>nm-connection-editor    图形工具：nm-connection-editor</p>
<p>nmtui                     字符配置tui工具：nmtui  </p>
<p>nmcli                      命令行工具：nmcli</p>
<p>​          </p>
<p>nmcli：</p>
<p>​        由NetworkManager 提供的地址配置工具，必须开启NM服务</p>
<p>​        设备（device）即网络接口</p>
<p>​        连接（connection）是对网络接口的配置。</p>
<p>​        添加连接（nmcli con  add）使一个网络接口可有多个连接配置，但同时只有一个连接配置生效</p>
<p>​     </p>
<p>​        格式：   </p>
<p>​        nmcli []options] object  {command|help}</p>
<p>​              device - show and  manage network interface</p>
<p>​              connection - start,stop,and manager network connections</p>
<p>​           nmcli device help | show |  modify|..</p>
<p>​               配置网卡属性，现在进行</p>
<p>​           nmcil connection help  | show |add |modify |del|up|down|..</p>
<p>​     </p>
<p>​        PS：使用nmcli dev status 查看之后最后一项 CONNECTION 值，即为连接的</p>
<p>​           connection名称，</p>
<p>​              使用nmcli con modify CONNECTION</p>
<p>​                   或者 nmcli con show CONNECTION</p>
<p>​              需注意</p>
<p>​          </p>
<p>​        修改ip地址等属性：</p>
<p>​           nmcli connection|device  modify CONNECTION [+|-]setting.property  value</p>
<p>​              setting.property</p>
<p>​                   ipv4.addresses</p>
<p>​                   ipv4.gateway</p>
<p>​                   ipv4.dns1|2</p>
<p>​                  ipv4.method  值为：manual（静态）|auto（dhcp）</p>
<p>​              +|- 用于多条记录情况</p>
<p>​                 </p>
<p>​        直接修改配置文件之后执行生效：</p>
<p>​              systemctl restart  network</p>
<p>​              nmcli con|connection  reload   </p>
<p>​          </p>
<p>​           nmcli命令生效：</p>
<p>​              nmcli con down  eth0；nmcli con up eth0</p>
<p>​              </p>
<p>​           显示所有连接：</p>
<p>​              nmcli connection  show</p>
<p>​           显示所有活动连接：</p>
<p>​              nmcli con show  –active</p>
<p>​           显示网络连接配置：</p>
<p>​              nmcli con show  “System eth0” | CONNECTION</p>
<p>​           显示设备状态：</p>
<p>​              nmcli dev  status</p>
<p>​           显示网络接口属性：</p>
<p>​              nmcli dev show  IFACE</p>
<p>​        </p>
<p>​        创建新连接：</p>
<p>​              nmcli con add  con-name NAME type Ethernet ifname ens37</p>
<p>​                   添加连接NAME，ip自动通过dhcp获取，配置在ens37网卡接口下</p>
<p>​              </p>
<p>​              nmcli con add  con-name STATIC ifname ens37 autoconnect no type</p>
<p>​           Ethernet ipv4.addresses  IP/MASK ipv4.gateway GW</p>
<p>​                  添加新连接STATIC ，指定静态ip 不自动连接</p>
<p>​          </p>
<p>​           删除连接：</p>
<p>​              nmcli con del  NAME</p>
<p>​              </p>
<p>​           切换连接：</p>
<p>​              nmcli con up  STATIC|NAME</p>
<p>​          </p>
<p>​           DNS和路由相关setting.property</p>
<p>​              ipv6.ignore-auto-dns  yes      相当于PEERDNS</p>
<p>​               ipv6.ignore-auto-routes yes        相当于PEERROUTES</p>
<p>​        网络配置文件：   </p>
<p>​           使用nmcli con add 添加连接会生成新的网卡配置文件：</p>
<p>​               ifcfg-<ifname></p>
<p>​            修改连接配置文件之后，需要重新加载配置：</p>
<p>​              nmcli con  reload</p>
<p>​              nmcli con down/up  CONNECTION 可被自动激活</p>
<p>​              nmcli dev  dis|diconnect eth0    禁用网卡，防止被自动激活</p>
<p>​                                           然而实测无效，还是可以被up激活</p>
<p>​        </p>
<p>​        nmcli实现bonding： </p>
<p>​           添加bonding接口：</p>
<p>​              nmcli con add type  bond con-name mybond0 ifname mybond0 mode active-backup、balance-tlb和balance-alb模式不需要交换机的任何特殊配置。</p>
<p>​           添加从属接口：</p>
<p>​              nmcli con add type  bond-slave ifname ens33 master mybond0</p>
<p>​              nmcli con add type  bond-slave ifname ens37 master mybond0</p>
<p>​            要启动绑定，则必须首先启动从属接口</p>
<p>​              nmcli con up  bond-slave-ens33</p>
<p>​              nmcli con up  bond-slave-ens37</p>
<p>​           启动绑定：</p>
<p>​              nmcli con up  mybond0</p>
<p>​              </p>
<p>网络组Networking Teaming</p>
<p>​        网络组：是将多个网卡聚合在一起的方式，从而实现容错和提供吞吐量</p>
<p>​        网络组不同于旧版中bonding技术，提供更好的性能和扩展性</p>
<p>​        网络组由内核驱动和teamd守护进程实现</p>
<p>​        多种方式runner</p>
<p>​              broadcast</p>
<p>​               roundrobin</p>
<p>​               activebackup</p>
<p>​               loadbalance</p>
<p>​              lacp(implements the 802.3ad Link Aggregation Control  Protocol)</p>
<p>​              </p>
<p>​        网络组：</p>
<p>​              启动网络组接口（team0）不会自动启动网络组中的port接口（team0-ens37）</p>
<p>​               启动网络组接口中的port接口总会自动启动网络组接口</p>
<p>​               禁用网络组接口会自动禁用网络组中的port接口</p>
<p>​              没有port接口的网络组接口可以启动静态ip链接</p>
<p>​              启用dhcp连接时，没有port接口的网络组会等待port接口的加入</p>
<p>​          </p>
<p>​        创建网络组接口：</p>
<p>​              nmcli con add type  team con-name CNAME ifname INAME [config JSON]</p>
<p>​                  CNAME  连接名，INAME 接口名</p>
<p>​                   JOSN:指定runner方式</p>
<p>​                      格式 ‘{“runner”:{“name”:”METHOD”}}’</p>
<p>​                   METHOD：broadcast, roundrobin,activebackup, loadbalance, lacp</p>
<p>​          </p>
<p>​              nmcli con add type  team con-name team0 ipv4.addresses</p>
<p>​                   185.170.161.160/16 ipv4.method manual config ‘{“runner”:{“name”:”activebackup”}}’</p>
<p>​                 </p>
<p>​        创建port接口：</p>
<p>​              nmcli con type  team-slave con-name CNAME ifname INAME master TEAM</p>
<p>​                  CNAME: 连接名（如team0-ens37）</p>
<p>​                  INAME:  接口名（指明网卡如  ens37）</p>
<p>​                  TEAM:   组接口名 （如team0）</p>
<p>​          </p>
<p>​           例：nmcli connection add type team-slave con-name team0-ens37</p>
<p>​              ifname ens37 master  team0</p>
<p>​              nmcli connection add  type team-slave con-name team0-ens38</p>
<p>​              ifname ens38 master  team0</p>
<p>​                 </p>
<p>​           连接名若不指定，默认为team-slave-IFACE</p>
<p>​          </p>
<p>​        启动网络组：</p>
<p>​              nmcli con up  team0</p>
<p>​              nmcli con up  team0-ens37</p>
<p>​              nmcli con up  team0-ens38</p>
<p>​        </p>
<p>​        查看网络组：</p>
<p>teamdctl        teamdctl team0 state</p>
<p>​          </p>
<p>​        关闭网络组：</p>
<p>​              nmcli con down  team0 可再次开启</p>
<p>​              </p>
<p>​        删除网络组</p>
<p>​              先down</p>
<p>​              nmcli con del  team0</p>
<p>​              nmcli con del  team0-ens37</p>
<p>​              nmcli con del  team0-ens38</p>
<p>​              </p>
<p>​        PS:   创建或删除，会自动生成或删除配置文件       </p>
<p>​              </p>
<p>nmcli-实现网桥：</p>
<p>​        此小段为复制粘贴内容，以便后期查找，没有操作复现。</p>
<p>​        桥接：</p>
<p>​           把一台机器上的若干个网络接口“连接”起来。其结果是，其中一个网</p>
<p>​            口收到的报文会被复制给其他网口并发送出去。以使得网口之间的报文能够互</p>
<p>​            相转发。网桥就是这样一个设备，它有若干个网口，并且这些网口是桥接起来</p>
<p>​            的。与网桥相连的主机就能通过交换机的报文转发而互相通信。</p>
<p>​            主机A发送的报文被送到交换机S1的eth0口，由于eth0与eth1、eth2桥接在一</p>
<p>​           起，故而报文被复制到eth1和eth2，并且发送出去，然后被主机B和交换机S2</p>
<p>​           接收到。而S2又会将报文转发给主机C、D。              </p>
<p>​                      </p>
<p>​        配置实现网桥</p>
<p>​         创建软件网桥</p>
<p>​           nmcli con add type bridge  con-name br0 ifname br0</p>
<p>​           nmcli connection modify br0  ipv4.addresses 192.168.74.100/24</p>
<p>​           ipv4.method  manuall</p>
<p>​           nmcli con add type  bridge-slave con-name br0-port0 ifname eth0 master</p>
<p>​           br0</p>
<p>​        查看网桥</p>
<p>​           cat /etc/sysconfig/network  -scripts/ifcfg-br0</p>
<p>​           cat /etc/sysconfig/network  -scripts/ifcfg-br0-port0</p>
<p>​           brctl show</p>
<p>​        删除网桥 brctl delbr br0</p>
<p>​        删除网桥中网卡 brctl delif eth0</p>
<p>​        注意：NetworkManager只支持以太网接口接口连接到网桥，不支持聚合接口</p>
<p>​              </p>
<p>​              </p>
<p>测试网络工具：</p>
<p>​        </p>
<p>hostname          显示主机名         </p>
<p>ping               测试网络连通性</p>
<p>​        -s 65507         最大包</p>
<p>​        -f              强制发送，不等回复包</p>
<p>​        -c 5        几次</p>
<p>​        -w 5            指定时间</p>
<p>mtr               测试网路连通性</p>
<p>​        </p>
<p>nslookup       确定名称服务器使用</p>
<p>host</p>
<p>dig        </p>
<p>traceroute          跟踪路由</p>
<p>tracepath</p>
<p>tcmdump icmp -nn   抓包</p>
<p>tcpdump -i eth1</p>
<p>网络客户端工具：</p>
<p>ftp         默认账号ftp  或者anonymous</p>
<p>lftp        子命令：get（下载）、put 、mget（同时下载多个）、ls、cd、help  </p>
<p>​                  !cmd表示执行本机命令</p>
<p>lftpget    URL    下载ftp资源</p>
<p>wget[options] URL</p>
<p>​     -q     静默模式</p>
<p>​     -c      断点续传</p>
<p>​     -P      保存在指定目录</p>
<p>​     -O     保存为指定的文件名</p>
<p>​     –limit-rate=      指定传输速率,K,M 默认为Byte</p>
<p>​     </p>
<p>links URL    字符版浏览器</p>
<p>​     –dump     查看文字</p>
<p>​     –source 查看源码   </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型</title>
    <url>/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="OSI七层模型（理论）"><a href="#OSI七层模型（理论）" class="headerlink" title="OSI七层模型（理论）"></a>OSI七层模型（理论）</h2><p><a href="http://www.yulongjun.com/images/14980166860691.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213449.jpg" alt="alt">详细</a></p>
<h2 id="TCP-IP模型（现实）"><a href="#TCP-IP模型（现实）" class="headerlink" title="TCP/IP模型（现实）"></a>TCP/IP模型（现实）</h2><p><a href="http://www.yulongjun.com/images/14981038561761.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213441.jpg" alt="img"></a></p>
<p><a href="http://www.yulongjun.com/images/14981038812568.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20200826213422.jpg" alt="img"></a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊BOSS战设计(一)：从《只狼》的樱龙战开始</title>
    <url>/%E8%81%8A%E8%81%8ABOSS%E6%88%98%E8%AE%BE%E8%AE%A1(%E4%B8%80)%EF%BC%9A%E4%BB%8E%E3%80%8A%E5%8F%AA%E7%8B%BC%E3%80%8B%E7%9A%84%E6%A8%B1%E9%BE%99%E6%88%98%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于收藏，转载<a href="https://www.gcores.com/articles/128741" target="_blank" rel="noopener">https://www.gcores.com/articles/128741</a></p>
<p>这篇鸽了很久的文章，不过暂时还是打算分2-3篇，多了也写不太清楚，把几个比较有代表性的boss战拎出来先说说。选樱龙战这场作为开篇，是因为这是一场特殊但是又很有代表性，虽然是《只狼》所有boss里最简单的一个，但是整体演出效果和体验非常出色。</p>
<h1 id="通过控制难度来实现的仪式感"><a href="#通过控制难度来实现的仪式感" class="headerlink" title="通过控制难度来实现的仪式感"></a><strong>通过控制难度来实现的仪式感</strong></h1><p>仪式感在于区别日常，不可轻易得到，也不能轻易往复，重复体验则会破坏这种仪式感。樱龙难了，打得多了就会有种师傅教徒弟的感觉，像初期蝴蝶奶奶或弦一郎。所以樱龙注定不能多打，最好的难度就是一次能过的难度，但整体又不能设计得太过简单，这里的拿捏就比较微妙了，太简单没有压迫感；太难则需要打好几次，重复体验则会削弱仪式感。这里值得强调的是：控制难度，而不是降低难度。</p>
<p><a href="https://image.gcores.com/913e9a66-32da-45a2-a7a7-60281e9e6750.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/913e9a66-32da-45a2-a7a7-60281e9e6750.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="没有暴血，只是轻轻取了一颗龙泪，你杀蛇可不是这样的~"></a></p>
<p>没有暴血，只是轻轻取了一颗龙泪，你杀蛇可不是这样的~</p>
<p>控制难度的一些手段：</p>
<ul>
<li>樱龙只有一管血，过关只需要6次雷反，每次雷反后被吹飞，在爬树，在雷反，再被吹飞，这六次雷反就像六次叩拜，完成后即拜泪。</li>
<li>虽然每招看似伤害挺高的，但基本就是一个葫芦的血量，招式有较大时间前摇，并且攻击方式及其明确.</li>
<li>没有连段，被击中后，第二下的间隔时间比较久，也很容易躲开，而且打到这里普遍应该有8-9个葫芦，容错几率非常高.</li>
<li>深怕你是不知道树枝出现的含义，白木翁作为对于高树枝钩爪的提醒，后面看到了樱龙前面出现树枝估计每个人都会潜意识地地上去挂树枝，挂上去就能雷反。</li>
</ul>
<h1 id="大型boss战：谨慎的距离控制"><a href="#大型boss战：谨慎的距离控制" class="headerlink" title="大型boss战：谨慎的距离控制"></a><strong>大型boss战：谨慎的距离控制</strong></h1><p>狼本身没有远距离的攻击招式，为了鼓励拼刀，《只狼》里除了手里剑中距离的攻击方式，是没有远距离攻击模式的。但如果没有远距离攻击模式那么打樱龙会是什么样呢？ </p>
<p>不是在满地打滚，就是在修脚趾甲，或者攻击人家的下三路。打《血源诅咒》的时候，很多时候只能看到boss的一撮毛，我到底在打毛还是在打boss，反正观感极其难受。</p>
<p><a href="https://image.gcores.com/5683bcc5-16d8-4c4a-a55f-2d4638f1c5e9.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/5683bcc5-16d8-4c4a-a55f-2d4638f1c5e9.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="满地打滚"></a></p>
<p>满地打滚</p>
<p><a href="https://image.gcores.com/46135a7a-1ecc-464b-8a99-b0ca8f9d8bd5.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/46135a7a-1ecc-464b-8a99-b0ca8f9d8bd5.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="攻击下三路"></a></p>
<p>攻击下三路</p>
<p>那没有远程怎么办？敌人有就好了呀，在没有改变玩法的情况下，限制了玩家的距离和攻击方式，用弹反就能进行远距离攻击，也能获得全新的游戏体验。很多时候体验的变化并不和自身相关，和外部的改变相关，像《糖豆人》只是操作移动跳跃但每个关卡都能有不同的游戏体验。</p>
<p><a href="https://image.gcores.com/b847723a-69e7-4008-b073-f348338363b7.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b847723a-69e7-4008-b073-f348338363b7.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>除了远距离的攻击模式外，boss会主动拉开和玩家距离，在和樱龙有一定距离或者其他影响因素的时候，会直接将玩家吹飞控制距离。然后再次爬树进行雷反，一次一次又一次。</p>
<p><a href="https://image.gcores.com/08f0e67e-99d5-42c5-b5ae-16e50886fc78.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/08f0e67e-99d5-42c5-b5ae-16e50886fc78.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>再例如《幻痛》的第一章boss，需要攻击特定部位才能造成伤害，这就需要玩家和boss需要有相当的距离才能够进行瞄准。这样简单的设计，就逼迫玩家需要通过不停地奔跑和走位与boss拉开距离才能更好的瞄准打击点。</p>
<p>玩家本身也拥有足够的机动性，关卡本身有足够丰富的空间，小岛秀夫对于大型boss的设计思路也一直延续到了《死亡搁浅》。</p>
<p><a href="https://image.gcores.com/7afd53a4-5493-4d29-a23f-3ddf4d972a35.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/7afd53a4-5493-4d29-a23f-3ddf4d972a35.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>《死亡搁浅》的希格斯战中，玩家的机动性被黑泥和身上负重限制，空间也有所限制，不如上面有更多的操作空间和角度进行瞄准攻击。  </p>
<p><a href="https://image.gcores.com/2a6aace2-8944-435f-b14e-b393c9d21980.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/2a6aace2-8944-435f-b14e-b393c9d21980.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>《旺达与巨像》将boss本身作为一整体个关卡进行设计，玩家也没有远距离的攻击方式，但是通过攀爬攻击boss身上局部的某个点便可以造成伤害。15年前的游戏至今看来都是非常超前的设计。</p>
<p><a href="https://image.gcores.com/eef78d26-a8fd-45b2-b8c0-de8c8873668f.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/eef78d26-a8fd-45b2-b8c0-de8c8873668f.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<h1 id="情绪渲染：不同阶段的音乐表现"><a href="#情绪渲染：不同阶段的音乐表现" class="headerlink" title="情绪渲染：不同阶段的音乐表现"></a><strong>情绪渲染：不同阶段的音乐表现</strong></h1><iframe frameborder="no" framespacing="0" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1356109763&amp;auto=0&amp;height=66" style="box-sizing: border-box; display: inline-block; max-width: 100%; margin: 0px;"></iframe>

<p>打樱龙的时候一共要雷电返还6次，音乐开场，比较急促，对应第一次碰到樱龙，但第一次雷电奉还后，音乐开始变得非常舒缓悠远。等到5次雷电奉还结束后整体音乐变得非常急促直到最后拜泪，通过血量来控制进度，并且同时变化音乐，让最后的雷电奉还非常震撼。</p>
<p>《只狼》的流程中，这种音乐的情绪变化在狮子猿里表现得也很突出，特别是第一次击杀狮子猿后，音乐骤停，然后几秒后复活，阴乐重新响起，整个气氛变得诡异了起来。并且音乐对氛围对限制有着极其重要的渲染与欺骗作用。 </p>
<h1 id="震撼的场景表现：通过镜头控制"><a href="#震撼的场景表现：通过镜头控制" class="headerlink" title="震撼的场景表现：通过镜头控制"></a><strong>震撼的场景表现：通过镜头控制</strong></h1><p>第一次吹飞时，镜头被拉远，人物屏占比变小。</p>
<p><a href="https://image.gcores.com/1d73684a-5686-4a54-bc08-487d38e0dad3.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/1d73684a-5686-4a54-bc08-487d38e0dad3.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>靠近树干部分的时候，镜头降低，与人物的相对距离似乎还是一样的，因为屏占比没什么变化，这种降低镜头高度的手法很常用。</p>
<p><a href="https://image.gcores.com/57782dda-02a4-4039-a531-3db7d16ab49a.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/57782dda-02a4-4039-a531-3db7d16ab49a.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>表现主城高耸是，则是靠近楼梯后镜头自动下降。</p>
<p><a href="https://image.gcores.com/abd0469c-fbb3-4f94-b1d8-9d0ccda70911.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/abd0469c-fbb3-4f94-b1d8-9d0ccda70911.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>《死亡搁浅》同样有这样的手法，“爸爸风暴”发生时，在上坡过程中镜头也会自动下降并靠近，第一次看到这个风暴也是非常震撼。</p>
<p><a href="https://image.gcores.com/939051aa-9a97-4f3f-9fd7-f2d3799d1713.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/939051aa-9a97-4f3f-9fd7-f2d3799d1713.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>最后的雷电奉还之前会出现三棵树，并且只有勾中中间那棵树的时候才会触发上升气流，然后触发最后的雷电返还。只有这次的雷电返还是特殊的，一个是你和樱龙的相对位置，一个是镜头拉近后的雷电返还。</p>
<p><a href="https://image.gcores.com/17cbe53b-c9ea-4cd4-ad0d-3650019bfe3b.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/17cbe53b-c9ea-4cd4-ad0d-3650019bfe3b.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>宫崎英高只对最后这下雷电奉还进行了镜头和位置的双重处理，因为就算你前面真的手残失败了几次，他也能保证你最后一次雷电奉还的体验是唯一的。感受宫崎英高最后的恩赐吧，你的灵魂在这里得到了升华。</p>
<p><a href="https://image.gcores.com/094d6579-9104-4407-8450-fa6217d126b6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener">
  </a></p>
]]></content>
  </entry>
  <entry>
    <title>聊聊Boss战设计（二）：从弦一郎说开去</title>
    <url>/%E8%81%8A%E8%81%8ABoss%E6%88%98%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%BC%A6%E4%B8%80%E9%83%8E%E8%AF%B4%E5%BC%80%E5%8E%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于收藏，转载<a href="https://www.gcores.com/articles/130478" target="_blank" rel="noopener">https://www.gcores.com/articles/130478</a></p>
<p>上次分析了<a href="https://www.gcores.com/articles/128741" target="_blank" rel="noopener">樱龙的boss战设计</a>，樱龙的boss战设计属于大型boss类型设计，弦一郎属于常规boss里面设计得非常出色的一类，并且这种体型boss在各类动作游戏里都比较常见。大部分《只狼》的普通怪物、精英怪、boss都是这种类人体型大小的，所以就以弦一郎为代表聊聊这类boss的设计相关。 </p>
<h1 id="不同阶段下的招式规划：体验层次的变化"><a href="#不同阶段下的招式规划：体验层次的变化" class="headerlink" title="不同阶段下的招式规划：体验层次的变化"></a><strong>不同阶段下的招式规划：体验层次的变化</strong></h1><p>宫崎英高每个boss都有分了不同的阶段，越重要的boss就会设计更多阶段，并且每个阶段的难度都不尽相同，不是越难越好，也不是越简单越好，而是这个难度体验在整个游戏流程中是否合适。这种关系是比较难掌握。</p>
<p>弦一郎虽然有点难，但又不是难到让人觉得完全没法打；樱龙的难度是难度很低的平稳水平线。我以弦一郎为例，把boss分成三个阶段，可以看看这几个阶段的一些特点。 </p>
<p>一阶段：这阶段主要是熟悉boss的出招方式， 不至于难度太高，过于劝退。 </p>
<p><a href="https://image.gcores.com/bb836396-758c-47b1-9ffd-f3fad96eed6a.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/bb836396-758c-47b1-9ffd-f3fad96eed6a.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="弦一郎的一阶段：以熟悉boss的攻击模式为主，会比较控制攻击范围与攻击距离，这阶段容错会比较高能至少打得有来有回，不至于直接惨死。"></a></p>
<p>弦一郎的一阶段：以熟悉boss的攻击模式为主，会比较控制攻击范围与攻击距离，这阶段容错会比较高能至少打得有来有回，不至于直接惨死。</p>
<p><a href="https://image.gcores.com/7eccbaa4-d1b4-4703-92aa-810773d33b5f.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/7eccbaa4-d1b4-4703-92aa-810773d33b5f.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="类似还有师姐的一阶段，包括剑圣一心的第一阶段都有这个特点，和后续阶段的招式相比，第一阶段的招式普遍以较小范围，较近攻击距离为主，属于可以比较好的熟悉boss的阶段。"></a></p>
<p>类似还有师姐的一阶段，包括剑圣一心的第一阶段都有这个特点，和后续阶段的招式相比，第一阶段的招式普遍以较小范围，较近攻击距离为主，属于可以比较好的熟悉boss的阶段。</p>
<p>二阶段：这个阶段难度会变高一些，boss的招式会变得更加难躲。弦一郎在在这一阶段会多一个横斩，和第一阶段只会用突刺不同，这个时候要避危，就需要思考和判断了，该跳还是踩，很容易判断失误然后被一顿毒打。但比起剑圣弦一郎的二阶段难度和招式变化并不算增加太多。 </p>
<p><a href="https://image.gcores.com/64651431-2129-45f6-b85b-d8d033959e85.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/64651431-2129-45f6-b85b-d8d033959e85.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="和剑圣一阶段相比，招式范围和距离开始大幅度提升，容错率开始降低，难度提升，玩家需要打得更加小心翼翼，《血源》的玛利亚在二阶段也是，攻击范围和攻击距离开始大幅提升，很容易失误。"></a></p>
<p>和剑圣一阶段相比，招式范围和距离开始大幅度提升，容错率开始降低，难度提升，玩家需要打得更加小心翼翼，《血源》的玛利亚在二阶段也是，攻击范围和攻击距离开始大幅提升，很容易失误。</p>
<p>三阶段：可能会有点反直觉，但《只狼》的大部分boss的第三阶段难度都在降低。</p>
<p><a href="https://image.gcores.com/b8fb49e6-ef7d-4c53-98fc-c0db986f5eb7.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b8fb49e6-ef7d-4c53-98fc-c0db986f5eb7.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="第三阶段的弦一郎的反雷设定直接降低了boss难度，包括后面第三阶段的剑圣。"></a></p>
<p>第三阶段的弦一郎的反雷设定直接降低了boss难度，包括后面第三阶段的剑圣。</p>
<p><a href="https://image.gcores.com/b79365a7-0c04-45ba-b7be-a562da5d167d.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b79365a7-0c04-45ba-b7be-a562da5d167d.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="也包括玛利亚师姐，三阶段时的血量几乎都已经快见底了，虽然招式范围和伤害很夸张，但集中精神抓几次破绽就能结束战斗了，宫崎英高选择让师姐在这个血量放出第三阶段是不想让玩家在这个阶段花费太多时间。"></a></p>
<p>也包括玛利亚师姐，三阶段时的血量几乎都已经快见底了，虽然招式范围和伤害很夸张，但集中精神抓几次破绽就能结束战斗了，宫崎英高选择让师姐在这个血量放出第三阶段是不想让玩家在这个阶段花费太多时间。</p>
<p><a href="https://image.gcores.com/d5282825-6549-4a03-9820-47a881025b35.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/d5282825-6549-4a03-9820-47a881025b35.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="第一阶段是无头狮子猿，第二阶段就是双猿，双猿难度会提升非常多，但杀过雌猿后，难度又会变得非常简单，其实雌猿死后，白猿如果能在多一两个唬人的招式我觉得会更有意思呢~"></a></p>
<p>第一阶段是无头狮子猿，第二阶段就是双猿，双猿难度会提升非常多，但杀过雌猿后，难度又会变得非常简单，其实雌猿死后，白猿如果能在多一两个唬人的招式我觉得会更有意思呢~</p>
<p>这样的每个阶段的难度明显是控制过，很多游戏容易在设计boss的时候根据每个阶段不断地增加难度，并不想着在合适的阶段去降低难度。或者直接boss难度基本上毫无变化，像前段时间出的致命躯壳的boss基本上是没有考虑过这样的难度设计，整体体验非常糟糕。</p>
<p>在增加难度后，在适当的第三阶段反而降低一些难度，这样的难度曲线设计其实要比一味的难上加难要更有意思些，他让boss的各个阶段都有各自特色，让你感受到震撼的同时又不至于打太多遍，至于为什么不能打太多遍我在上一篇樱龙的文章里有提到过，感兴趣的后续可以在去翻看下。</p>
<h1 id="人物招式与形态变化：游戏叙事的一部分"><a href="#人物招式与形态变化：游戏叙事的一部分" class="headerlink" title="人物招式与形态变化：游戏叙事的一部分"></a><strong>人物招式与形态变化：游戏叙事的一部分</strong></h1><p>整个boss战下来的人物的形态变化：也分别对应了弦一郎作为苇名继承者，巴流落雷研习者，喝下变若水后不做人了的弦一郎三个阶段，一场战斗直接贯穿了弦一郎的过去的大部分经历，是《只狼》所有boss里信息密度最大，推进剧情向前的非常关键的节点。</p>
<p><a href="https://image.gcores.com/804f0f9f-e8a2-4215-a2cf-274f4cabaa95.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/804f0f9f-e8a2-4215-a2cf-274f4cabaa95.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>关于脱衣服的设定方面，弦一郎的这个变身播片实在太帅了，与前面拥有华丽装饰的苇名继承者身份不同，脱下衣服后弦一郎是一位想要保护苇名而刻苦练习落雷的巴流弦一郎，前后对比反差及其强烈，因为长时间以身体承接落雷而焦黑的双手。这些都在暗示弦一郎的过去，与剧情的一些分支线，让人感觉事情并不简单。</p>
<p>这类形态变化通知暗示剧情的还有狮子猿。</p>
<p><a href="https://image.gcores.com/d5d3a11e-c194-4953-8a50-ac6795fc9963.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/d5d3a11e-c194-4953-8a50-ac6795fc9963.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>招式对于人物关系的暗示在别的boss战里也能看出来。即使你会跳过剧情，但战斗时相同的投技也说明了永真和剑圣两人的师徒关系 </p>
<p><a href="https://image.gcores.com/9549f4bb-09e5-49f5-b35a-dc58160cb0f6.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/9549f4bb-09e5-49f5-b35a-dc58160cb0f6.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>只狼与枭的落影归还，两人的父慈子孝在处决中展现的淋漓尽致。</p>
<p><a href="https://image.gcores.com/c1fb2deb-dce7-4378-a3ef-c3a0f33e8ad8.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/c1fb2deb-dce7-4378-a3ef-c3a0f33e8ad8.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<h1 id="场景变化：给人感觉事情似乎并不简单"><a href="#场景变化：给人感觉事情似乎并不简单" class="headerlink" title="场景变化：给人感觉事情似乎并不简单"></a><strong>场景变化：给人感觉事情似乎并不简单</strong></h1><p>音乐变化和场景变化都会带来这样的感觉，这里不对劲~</p>
<p>可以看下弦一郎场景上的前后变化是非常剧烈的，从夕阳直接变成落雷雪天，再加上会打雷的弦一郎，我到第三阶段就是“wc，这我怎么打得过，这也太猛了”的感觉。但实际上第三阶段打了几次就过了。</p>
<p><a href="https://image.gcores.com/bfdebf78-823a-4f3d-bb72-8ee2fcf35cac.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/bfdebf78-823a-4f3d-bb72-8ee2fcf35cac.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>类似的还有《死亡搁浅》的天气设定。把bt设定在下雨的时候出现、消失的时候就雨过天晴这个真的太棒了，直接无缝从送货到紧张躲避bt之间的切换。其场景光影变化和音乐变化迅速就将人转换到另外一种状态，阴天下雨就开始精神紧张，放晴的时候精神也为之放松。</p>
<p><a href="https://image.gcores.com/e846b865-16d2-46f1-b1a6-d901194d2f46.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/e846b865-16d2-46f1-b1a6-d901194d2f46.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>破戒僧的二阶段，从阳光明朗的枫叶场景久瞬间变成黑白水墨只剩下剪影的特效，前后对比反差很剧烈，也和前面水生村的幻术相互呼应。</p>
<p><a href="https://image.gcores.com/67c64e12-cb0c-402a-89f8-8e8234b56354.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/67c64e12-cb0c-402a-89f8-8e8234b56354.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<h1 id="场景芦苇：速度感的呈现"><a href="#场景芦苇：速度感的呈现" class="headerlink" title="场景芦苇：速度感的呈现"></a><strong>场景芦苇：速度感的呈现</strong></h1><p>经常看我文章的朋友大概知道，我其实并不太满意最后一场芦苇地这个场景的一些设计，因为可以做得更好。但不得不说场景里的这片芦苇设计的非常妙，最后一场有不管是弦一郎还是剑圣都有大量的大范围的攻击招式，玩家需要大量进行奔跑躲避，低矮的芦苇可以在奔跑的时候体现速度感。如果没有这些芦苇，奔跑时的速度感会感觉弱很多。</p>
<p><a href="https://image.gcores.com/668fd85b-7713-4ee5-9a7b-987c2e22141b.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/668fd85b-7713-4ee5-9a7b-987c2e22141b.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/f3b69cc0-e268-49df-9b16-b3d074c5332b.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/f3b69cc0-e268-49df-9b16-b3d074c5332b.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="前景与场地中的野草位移让整个动画非常夸张的速度感，包括镜头z轴抖动，让整个奔跑显得非常有力。"></a></p>
<p>前景与场地中的野草位移让整个动画非常夸张的速度感，包括镜头z轴抖动，让整个奔跑显得非常有力。</p>
<p>下面这段视频中可以看到周边近景参照物的位移速度，这是我们判断运动速度主要依据。并且在快速位移的时候摄像机会不可避免的产生z轴方向的抖动，《合金装备 幻痛》的奔跑就利用了这样的抖动效果，力量感十足。</p>
<p><a href="https://image.gcores.com/21feea41-f54f-4b22-9a3c-222e5e18f7d4.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/21feea41-f54f-4b22-9a3c-222e5e18f7d4.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>UE5的宣传视频靠大量的近景和碎石来体现的速度感，以前的游戏因为数据吞吐量和优化问题是根本做不了这样的设计的，只能依靠播片，但未来不久我们能在游戏真正玩到这样的玩法了。</p>
<p><a href="https://image.gcores.com/46377fd1-8581-4ce2-a5a4-441535a665ff.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/46377fd1-8581-4ce2-a5a4-441535a665ff.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>《对马岛》的这个镜头其实我很喜欢，从一片郁郁葱葱的树林奔跑到一望无际白茫茫一片芦苇地里然后配合音乐响起整体感觉非常震撼。但缺点也不少，跑的时候没感觉，但停下来芦苇抽筋一样的抖动总是让人有点儿出戏，整个镜头设计的速度感和力量感都差点儿，不过那飞鸟的设计还不错啦。</p>
<p>《对马岛》的场景设计同质化蛮严重的，很多设计非常油腻，我个人不太喜欢。有关《对马岛》的讨论有想法的可以在下面讨论。</p>
<p><a href="https://image.gcores.com/d92d1888-ba00-4cbb-92b7-bc10dfe1a0f2.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/d92d1888-ba00-4cbb-92b7-bc10dfe1a0f2.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<h1 id="入画成景：真正的电影感"><a href="#入画成景：真正的电影感" class="headerlink" title="入画成景：真正的电影感"></a><strong>入画成景：真正的电影感</strong></h1><p>我在一年前的<a href="https://www.gcores.com/articles/118473" target="_blank" rel="noopener">《只狼》与中国园林</a>这篇文章里有比较详细的解释，动态入画的前提是需要有准确的距离控制，boss的招式设计与场景设计共同考虑才能完成，做好了能把整个游戏战斗做得像电影一般。</p>
<p><a href="https://image.gcores.com/d8728113-5a6b-41c8-9dae-4c2585acb000.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/d8728113-5a6b-41c8-9dae-4c2585acb000.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/e1a1aeb9-e860-4b67-a285-cdb14825442e.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/e1a1aeb9-e860-4b67-a285-cdb14825442e.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/1be3e31d-506a-44e4-adf2-7bb73c4bca96.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/1be3e31d-506a-44e4-adf2-7bb73c4bca96.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<h1 id="相关后续"><a href="#相关后续" class="headerlink" title="相关后续"></a><strong>相关后续</strong></h1><p>这次写完就大概对几类boss有了个大致的理解，后续可能还会有两篇有关的boss战设计，但应该不会以只狼的boss战为主了，大概率会是《战神》和《最后生还者2》</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTc4Mzc4Ng==&amp;mid=2247484074&amp;idx=1&amp;sn=6758cb68ecd77ee95e0268b069a627eb&amp;chksm=90fc47afa78bceb997a7987837c35ab46db4b263926ab142821aa681384c69be21e0747c4acf&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA5OTc4Mzc4Ng==&amp;mid=2247484074&amp;idx=1&amp;sn=6758cb68ecd77ee95e0268b069a627eb&amp;chksm=90fc47afa78bceb997a7987837c35ab46db4b263926ab142821aa681384c69be21e0747c4acf&amp;scene=21#wechat_redirect</a>)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><p><a href="https://www.bilibili.com/video/BV1xb411J71Vfrom=search&seid=14467762349115941379" target="_blank" rel="noopener">弦一郎战斗视频</a></p>
<p><a href="https://www.bilibili.com/video/BV1iJ411T7fp/?spm_id_from=333.788.videocard.5" target="_blank" rel="noopener">曼岛TT</a></p>
<p><a href="https://www.bilibili.com/video/BV1Hb411M7brfrom=search&seid=1869117738499068082" target="_blank" rel="noopener">《只狼》各角色处决投技</a></p>
<p><a href="https://www.bilibili.com/video/BV1ib411s7dU/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">处决角色终结技</a></p>
]]></content>
  </entry>
  <entry>
    <title>聊聊Linux 五种IO模型</title>
    <url>/%E8%81%8A%E8%81%8ALinux-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概念说明"><a href="#1-概念说明" class="headerlink" title="1 概念说明#"></a>1 概念说明#</h1><p>在进行解释之前，首先要说明几个概念：</p>
<blockquote>
<p>用户空间和内核空间</p>
<p>进程切换</p>
<p>进程的阻塞</p>
<p>文件描述符</p>
<p>缓存 IO</p>
</blockquote>
<h2 id="1-1-用户空间与内核空间"><a href="#1-1-用户空间与内核空间" class="headerlink" title="1.1 用户空间与内核空间##"></a>1.1 用户空间与内核空间##</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<code>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限</code>。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，<code>操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间</code>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h2 id="1-2-进程切换"><a href="#1-2-进程切换" class="headerlink" title="1.2 进程切换##"></a>1.2 进程切换##</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<blockquote>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
</blockquote>
<p>注：总而言之就是很耗资源，具体的可以参考这篇文章：<a href="https://link.jianshu.com?t=http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a>。</p>
<h2 id="1-3-进程的阻塞"><a href="#1-3-进程的阻塞" class="headerlink" title="1.3 进程的阻塞##"></a>1.3 进程的阻塞##</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>
<h2 id="1-4-文件描述符fd"><a href="#1-4-文件描述符fd" class="headerlink" title="1.4 文件描述符fd##"></a>1.4 文件描述符fd##</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，<code>是一个用于表述指向文件的引用的抽象化概念</code>。</p>
<p>文件描述符在形式上是一个非负整数。实际上，<code>它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</code>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h2 id="1-5-缓存-IO"><a href="#1-5-缓存-IO" class="headerlink" title="1.5 缓存 IO##"></a>1.5 缓存 IO##</h2><p><code>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO</code>。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<code>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</code>。</p>
<p><strong>缓存 IO 的缺点：</strong></p>
<p><code>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作</code>，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h1 id="2-Linux-IO模型"><a href="#2-Linux-IO模型" class="headerlink" title="2 Linux IO模型#"></a>2 Linux IO模型#</h1><p><code>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作</code>。刚才说了，对于一次IO访问（以read举例），<code>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</code>。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<blockquote>
<ol>
<li>第一阶段：等待数据准备 (Waiting for the data to be ready)。</li>
<li>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</li>
</ol>
</blockquote>
<p>对于socket流而言，</p>
<blockquote>
<ol>
<li>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>
<li>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</li>
</ol>
</blockquote>
<p>网络应用需要处理的无非就是两大类问题，<code>网络IO，数据计算</code>。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。网络IO的模型大致有如下几种：</p>
<blockquote>
<ul>
<li><strong>同步模型（synchronous IO）</strong></li>
<li>阻塞IO（bloking IO）</li>
<li>非阻塞IO（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li><strong>异步IO（asynchronous IO）</strong></li>
</ul>
</blockquote>
<p><strong><code>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</code></strong></p>
<p>在深入介绍Linux IO各种模型之前，让我们先来探索一下基本 Linux IO 模型的简单矩阵。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231750.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<p>每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。<code>常见的IO模型有阻塞、非阻塞、IO多路复用，异步</code>。以一个生动形象的例子来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案。</p>
<h2 id="2-1-同步阻塞-IO（blocking-IO）"><a href="#2-1-同步阻塞-IO（blocking-IO）" class="headerlink" title="2.1 同步阻塞 IO（blocking IO）##"></a>2.1 同步阻塞 IO（blocking IO）##</h2><h3 id="2-1-1-场景描述"><a href="#2-1-1-场景描述" class="headerlink" title="2.1.1 场景描述###"></a>2.1.1 场景描述###</h3><blockquote>
<p>我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。<code>这就是典型的阻塞</code>。</p>
</blockquote>
<h3 id="2-1-2-网络模型"><a href="#2-1-2-网络模型" class="headerlink" title="2.1.2 网络模型###"></a>2.1.2 网络模型###</h3><p><code>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型</code>。在linux中，<code>默认情况下所有的socket都是blocking</code>。它符合人们最常见的思考逻辑。<code>阻塞就是进程 &quot;被&quot; 休息, CPU处理其它进程去了</code>。</p>
<p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，<code>在等待数据到处理数据的两个阶段</code>，整个进程都被阻塞。不能处理别的网络IO。<code>调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态</code>，因此从处理的角度来看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231751.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<h3 id="2-1-3-流程描述"><a href="#2-1-3-流程描述" class="headerlink" title="2.1.3 流程描述###"></a>2.1.3 流程描述###</h3><p>当用户进程调用了recv()/recvfrom()这个系统调用，<code>kernel就开始了IO的第一个阶段：准备数据</code>（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。<code>第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存</code>，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<blockquote>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<ol>
<li>能够及时返回数据，无延迟；</li>
<li>对内核开发者来说这是省事了；</li>
</ol>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ol>
<li>对用户来说处于等待就要付出性能的代价了；</li>
</ol>
</blockquote>
<h2 id="2-2-同步非阻塞-IO（nonblocking-IO）"><a href="#2-2-同步非阻塞-IO（nonblocking-IO）" class="headerlink" title="2.2 同步非阻塞 IO（nonblocking IO）##"></a>2.2 同步非阻塞 IO（nonblocking IO）##</h2><h3 id="2-2-1-场景描述"><a href="#2-2-1-场景描述" class="headerlink" title="2.2.1 场景描述###"></a>2.2.1 场景描述###</h3><blockquote>
<p>我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。<code>这就是非阻塞</code>。需要不断的询问，是否准备好了。</p>
</blockquote>
<h3 id="2-2-2-网络模型"><a href="#2-2-2-网络模型" class="headerlink" title="2.2.2 网络模型###"></a>2.2.2 网络模型###</h3><p><code>同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式</code>。在这种模型中，<code>设备是以非阻塞的形式打开的</code>。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。</p>
<p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p>
<p><code>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error</code>。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。<code>这个过程通常被称之为轮询</code>。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。<strong><code>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</code></strong>。</p>
<p>在linux下，可以通过设置socket使其变为non-blocking。<code>当对一个non-blocking socket执行读操作时</code>，流程如图所示：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231752.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<h3 id="2-2-3-流程描述"><a href="#2-2-3-流程描述" class="headerlink" title="2.2.3 流程描述###"></a>2.2.3 流程描述###</h3><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<p><strong>同步非阻塞方式相比同步阻塞方式：</strong></p>
<blockquote>
<p>优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>
<p>缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
</blockquote>
<h2 id="2-3-IO-多路复用（-IO-multiplexing）"><a href="#2-3-IO-多路复用（-IO-multiplexing）" class="headerlink" title="2.3 IO 多路复用（ IO multiplexing）##"></a>2.3 IO 多路复用（ IO multiplexing）##</h2><h3 id="2-3-1-场景描述"><a href="#2-3-1-场景描述" class="headerlink" title="2.3.1 场景描述###"></a>2.3.1 场景描述###</h3><blockquote>
<p>与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，<code>这就是典型的IO多路复用</code>。</p>
</blockquote>
<h3 id="2-3-2-网络模型"><a href="#2-3-2-网络模型" class="headerlink" title="2.3.2 网络模型###"></a>2.3.2 网络模型###</h3><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。<code>那么这就是所谓的 “IO 多路复用”</code>。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。</p>
<p><code>IO多路复用有两个特别的系统调用select、poll、epoll函数</code>。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—<code>前者可以等待多个socket，能实现同时对多个IO端口进行监听</code>，当其中任何一个socket的数据准好了，<code>就能返回进行可读</code>，<code>然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的</code>。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，<code>此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理</code>。如何知道有一部分数据到达了呢？<code>监视的事情交给了内核，内核负责数据到达的处理。也可以理解为&quot;非阻塞&quot;吧</code>。</p>
<p><code>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</code>。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p>
<p>对于多路复用，也就是轮询多个socket。<code>多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了</code>，当然也可以针对不同的编号。具体流程，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231753.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<h3 id="2-3-3-流程描述"><a href="#2-3-3-流程描述" class="headerlink" title="2.3.3 流程描述###"></a>2.3.3 流程描述###</h3><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。<code>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO</code>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，<code>当任何一个socket中的数据准备好了，select就会返回</code>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<blockquote>
<p>多路复用的特点是<code>通过一种机制一个进程能同时等待IO文件描述符</code>，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p>
</blockquote>
<p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<code>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)</code>。但是，<code>用select的优势在于它可以同时处理多个connection</code>。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，<code>实际中，对于每一个socket，一般都设置成为non-blocking</code>，但是，如上图所示，整个用户的process其实是一直被block的。<code>只不过process是被select这个函数block，而不是被socket IO给block</code>。所以<strong><code>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</code></strong></p>
<p>在I/O编程过程中，<code>当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理</code>。I/O多路复用技术<code>通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</code>。与传统的多线程/多进程模型比，<code>I/O多路复用的最大优势是系统开销小</code>，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p>
<blockquote>
<p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>
<p>服务器需要同时处理多种网络协议的套接字。</p>
</blockquote>
<p>了解了前面三种IO模式，在用户进程进行系统调用的时候，<strong><code>他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询</code></strong>，两个阶段过程：</p>
<blockquote>
<p>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</p>
<p>第二个阶段都是阻塞的。</p>
</blockquote>
<p><strong><code>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。【此句很重要！！！】</code></strong></p>
<p><code>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式</code>。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，<code>办事大厅里的人数就是并发数，而窗口个数就是并行度</code>。也就是说<code>并发数是指同时进行的任务数（如同时服务的 HTTP 请求）</code>，而<code>并行数是可以同时工作的物理资源数量（如 CPU 核数）</code>。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。<code>而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求</code>。</p>
<p><strong>注意：IO多路复用是同步阻塞模型还是异步阻塞模型，在此给大家分析下：</strong></p>
<blockquote>
<p>此处仍然不太清楚的，强烈建议大家在细究<a href="https://link.jianshu.com?t=http://my.oschina.net/xianggao/blog/661085" target="_blank" rel="noopener">《聊聊同步、异步、阻塞与非阻塞》</a>中讲同步与异步的根本性区别，<code>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息</code>。<code>IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞</code>。所以，<code>把IO多路复用归为同步阻塞模式</code>。</p>
</blockquote>
<h2 id="2-4-信号驱动式IO（signal-driven-IO）"><a href="#2-4-信号驱动式IO（signal-driven-IO）" class="headerlink" title="2.4 信号驱动式IO（signal-driven IO）##"></a>2.4 信号驱动式IO（signal-driven IO）##</h2><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231754.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<h2 id="2-5-异步非阻塞-IO（asynchronous-IO）"><a href="#2-5-异步非阻塞-IO（asynchronous-IO）" class="headerlink" title="2.5 异步非阻塞 IO（asynchronous IO）##"></a>2.5 异步非阻塞 IO（asynchronous IO）##</h2><h3 id="2-5-1-场景描述"><a href="#2-5-1-场景描述" class="headerlink" title="2.5.1 场景描述###"></a>2.5.1 场景描述###</h3><blockquote>
<p>女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。</p>
</blockquote>
<h3 id="2-5-2-网络模型"><a href="#2-5-2-网络模型" class="headerlink" title="2.5.2 网络模型###"></a>2.5.2 网络模型###</h3><p>相对于同步IO，异步IO不是顺序执行。<code>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情</code>。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。</p>
<p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231755.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<h3 id="2-5-3-流程描述"><a href="#2-5-3-流程描述" class="headerlink" title="2.5.3 流程描述###"></a>2.5.3 流程描述###</h3><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，<code>首先它会立刻返回，所以不会对用户进程产生任何block</code>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<code>当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程</code>，告诉它read操作完成了。</p>
<p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p>
<blockquote>
<p><code>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数</code>，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<code>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</code>。</p>
<p><code>如果这个进程正在内核态忙着做别的事</code>，例如以同步阻塞方式读写磁盘，<code>那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知</code>。</p>
<p><code>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒</code>，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p>
</blockquote>
<p>异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，<code>因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制</code>。</p>
<p><strong><code>很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。</code></strong>需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。</p>
<p>从前面 IO 模型的分类中，我们可以看出 AIO 的动机：</p>
<blockquote>
<p>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</p>
<p>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</p>
<p>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。</p>
</blockquote>
<p>IO多路复用除了需要阻塞之外，<code>select 函数所提供的功能（异步阻塞 IO）与 AIO 类似</code>。不过，<code>它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞</code>。</p>
<h2 id="2-6-关于异步阻塞"><a href="#2-6-关于异步阻塞" class="headerlink" title="2.6 关于异步阻塞##"></a>2.6 关于异步阻塞##</h2><p>有时我们的 API 只提供异步通知方式，例如在 node.js 里，<code>但业务逻辑需要的是做完一件事后做另一件事</code>，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。<code>这样的业务逻辑就需要调用者是以阻塞方式来工作</code>。</p>
<p><code>为了在异步环境里模拟 “顺序执行” 的效果，就需要把同步代码转换成异步形式，这称为 CPS（Continuation Passing Style）变换</code>。BYVoid 大神的 <a href="https://link.jianshu.com?t=https://github.com/BYVoid/continuation" target="_blank" rel="noopener">continuation.js</a> 库就是一个 CPS 变换的工具。<code>用户只需用比较符合人类常理的同步方式书写代码，CPS 变换器会把它转换成层层嵌套的异步回调形式</code>。</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231756.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231757.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<p><code>另外一种使用阻塞方式的理由是降低响应延迟</code>。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。<code>因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好</code>。</p>
<h1 id="3-五种IO模型总结"><a href="#3-五种IO模型总结" class="headerlink" title="3 五种IO模型总结#"></a>3 五种IO模型总结#</h1><h2 id="3-1-blocking和non-blocking区别"><a href="#3-1-blocking和non-blocking区别" class="headerlink" title="3.1 blocking和non-blocking区别##"></a>3.1 blocking和non-blocking区别##</h2><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h2 id="3-2-synchronous-IO和asynchronous-IO区别"><a href="#3-2-synchronous-IO和asynchronous-IO区别" class="headerlink" title="3.2 synchronous IO和asynchronous IO区别##"></a>3.2 synchronous IO和asynchronous IO区别##</h2><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</p>
<p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>
</blockquote>
<p><code>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞</code>。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，<code>定义中所指的”IO operation”是指真实的IO操作</code>，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，<code>当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了</code>，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，<code>当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成</code>。在这整个过程中，进程完全没有被block。</p>
<p><strong>各个IO Model的比较如图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201201231758.png" alt="输入图片说明"></p>
<p>输入图片说明</p>
<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。<code>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check</code>，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。<code>它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知</code>。在此期间，<code>用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据</code>。</p>
<p><a href="">40_聊聊远程通信</a></p>
]]></content>
  </entry>
  <entry>
    <title>聊聊《只狼》中的场景设计规划</title>
    <url>/%E8%81%8A%E8%81%8A%E3%80%8A%E5%8F%AA%E7%8B%BC%E3%80%8B%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于个人收藏，转载：<a href="https://www.gcores.com/articles/116167" target="_blank" rel="noopener">https://www.gcores.com/articles/116167</a></p>
<p><strong>未来有计划或者想玩只狼的强烈不建议观看本文章，因为几乎剧透了所有场景和 Boss</strong></p>
<p>从看过预告后我就一直在期待《只狼》，但我还是想说只狼超过我的期待太多了。借龙马的话说，只狼已经是忍者武士类题材游戏的一杆旗帜了。这次先聊聊《只狼》中一些场景设计，这次宫崎英高和以往的处理都不太一样，并且也是我比较喜欢的处理方式。</p>
<p>《只狼》的游戏场景设计规划我大概分为下面这几个部分，应该也符合大部分游戏的场景设计，只是 3D 的表现力会更强一些。</p>
<ol>
<li>大场景的色调以及地形区分</li>
<li>单个关卡连续空间设计</li>
<li>场景关键帧设计（场景单体设计，氛围设计等等）</li>
</ol>
<p>下面我们一个个聊。</p>
<h1 id="大场景的色调以及地形区分"><a href="#大场景的色调以及地形区分" class="headerlink" title="大场景的色调以及地形区分"></a><strong>大场景的色调以及地形区分</strong></h1><p><strong>大场景的主色调</strong></p>
<p>不同于《血源诅咒》和黑暗之魂系列统一的灰暗沉重的色调只狼在不同大关卡的主色调上是明显做过区分的。下面图片排列依照关卡前进的顺序，可以仔细看看场景色调上的变化规律，先看三组之间的差别，在观察单组之间图片的节奏变化。</p>
<p><a href="https://image.gcores.com/c3f20807-105b-4725-9eff-5c497559f997.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/c3f20807-105b-4725-9eff-5c497559f997.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="平田宅邸（图4,5为遇见义父，最后一张是boss战）"></a></p>
<p>平田宅邸（图4,5为遇见义父，最后一张是boss战）</p>
<p><a href="https://image.gcores.com/85a7d6db-0850-4543-84c7-0b691289c5a9.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/85a7d6db-0850-4543-84c7-0b691289c5a9.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="坠落之谷（图3为精英怪蛇眼白藤，图11为boss战）"></a></p>
<p>坠落之谷（图3为精英怪蛇眼白藤，图11为boss战）</p>
<p><a href="https://image.gcores.com/a977392e-41ec-4a13-941b-b160036bf418.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/a977392e-41ec-4a13-941b-b160036bf418.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="源之宫（图2boss战破戒僧，最后一张boss战樱龙）"></a></p>
<p>源之宫（图2boss战破戒僧，最后一张boss战樱龙）</p>
<p>如果只看单组图，你会发现除了 Boss 战和遇见重要 NPC 之外，场景的色调的变化做的非常克制。如果从整体看每组图之间的不同，你会发现大关卡之间的色调被大范围的拉开，这样的好处是不容易产生视觉疲劳。因为《只狼》在初期对于场景的探索很开放，不必一直在某关卡打完这个 Boss 才能进入下一个关卡，在某个关卡卡住了，换个关卡或许能找到通关的线索，可以换个地方换种心情。我没事就经常逛逛仙峰寺，体验下这里的风土人情。 </p>
<p><a href="https://image.gcores.com/7a9732af-2b44-42c8-b739-5ccea4c87fe4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7a9732af-2b44-42c8-b739-5ccea4c87fe4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺景区底下留言"></a></p>
<p>仙峰寺景区底下留言</p>
<p>这里想说的就是主色调的控制。</p>
<p>其实色调可以通过滤镜，光照，调色这些手段进行达到你想要的色调，但这样存在的问题就是很强的风格化，换句话说看多了容易腻。色调最直接的控制手段就是控制物件的本身的固有色，想要用什么色调就让整个场景以这个颜色的物件为主，也就是场景单体设计上最重要的部分，所以分析场景色调其实要分析的是他用了什么固有色的物件，并且同一类型的物件固有色可以怎么去变化。</p>
<p><strong>大场景的主色调的物件构成</strong></p>
<p><a href="https://image.gcores.com/c08f0213-5553-4110-8c5d-e210be37deaa.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/c08f0213-5553-4110-8c5d-e210be37deaa.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="苇名城城邑：山体，松散的建筑布置，植物，天空，黄昏"></a></p>
<p>苇名城城邑：山体，松散的建筑布置，植物，天空，黄昏</p>
<p><a href="https://image.gcores.com/551b2422-ed0a-4b30-93ef-5eef00d8bd39.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/551b2422-ed0a-4b30-93ef-5eef00d8bd39.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="苇名城：密集建筑，灰色的天空，黄昏"></a></p>
<p>苇名城：密集建筑，灰色的天空，黄昏</p>
<p><a href="https://image.gcores.com/5ad07db5-8785-4507-aa7b-b71bb838cc2c.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/5ad07db5-8785-4507-aa7b-b71bb838cc2c.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="平田宅邸：建筑，竹林，山体，火，夜晚"></a></p>
<p>平田宅邸：建筑，竹林，山体，火，夜晚</p>
<p><a href="https://image.gcores.com/6839c832-318b-48d9-bc8d-1205328ef7a3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6839c832-318b-48d9-bc8d-1205328ef7a3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺：红黄颜色的植物，蓝天，建筑，山体，晴天"></a></p>
<p>仙峰寺：红黄颜色的植物，蓝天，建筑，山体，晴天</p>
<p><a href="https://image.gcores.com/78e47b11-4b31-4785-a272-41d596f9b84f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/78e47b11-4b31-4785-a272-41d596f9b84f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫：樱树，蓝天，湖水，建筑，阴天"></a></p>
<p>源之宫：樱树，蓝天，湖水，建筑，阴天</p>
<p><a href="https://image.gcores.com/109a8598-4ca7-409a-930d-7bdd25477817.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/109a8598-4ca7-409a-930d-7bdd25477817.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="坠落之谷：铺满雪的山体，石刻雕像，雪，植物"></a></p>
<p>坠落之谷：铺满雪的山体，石刻雕像，雪，植物</p>
<p>粗略地分了下几种物件类型，在最初规划场景的时候能够定下场景里建筑，山体，天空，植被和光照环境的主色调可以比较好的控制整个大场景之间的色调关系，这样就会有一个具体的色调印象可以更好在未来的去控制和细化单体。</p>
<p><strong>大场景的地形区分</strong></p>
<p>《只狼》里面是可以立体移动的环境，因此除了视觉上需求也是场景和玩法的配合，类似像菩萨谷，苇名城主城屋顶部分，坠落之谷，这些地形都非常好的体现了忍义手的垂直方向移动的特性。</p>
<p>我们把场景按移动方式进行区分：</p>
<ol>
<li>只能水平移动的；</li>
<li>水平移动+垂直移动的；</li>
<li>只能垂直移动的；</li>
<li>游泳。</li>
</ol>
<p><strong>水平移动</strong></p>
<p>这类地形比较少，主要是一些特殊的场景或者快到 Boss 战的时候。</p>
<p><a href="https://image.gcores.com/6500bc15-ad87-48ed-a562-4b0606023102.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/6500bc15-ad87-48ed-a562-4b0606023102.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="水生村"></a></p>
<p>水生村</p>
<p><a href="https://image.gcores.com/b49caa58-e13a-4a6d-a860-bad284c14cad.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b49caa58-e13a-4a6d-a860-bad284c14cad.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="蝴蝶夫人"></a></p>
<p>蝴蝶夫人</p>
<p><strong>垂直+水平移动</strong></p>
<p>苇名城城邑，苇名城，源之宫，平田宅邸，金刚山仙峰寺，《只狼》场景里最主要的地形类型，以平地为主，加上许多可以勾爪的固定点起到垂直移动的作用。</p>
<p><a href="https://image.gcores.com/c1a5848e-2175-4f58-aace-6d0532139f5e.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/c1a5848e-2175-4f58-aace-6d0532139f5e.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="平田宅邸"></a></p>
<p>平田宅邸</p>
<p><a href="https://image.gcores.com/55355fa5-bf96-432c-ab2f-42c96b8fe00f.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/55355fa5-bf96-432c-ab2f-42c96b8fe00f.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="苇名城城邑"></a></p>
<p>苇名城城邑</p>
<p><a href="https://image.gcores.com/b1afc869-3e98-478c-9e78-e9afd2647688.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b1afc869-3e98-478c-9e78-e9afd2647688.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="苇名城城邑"></a></p>
<p>苇名城城邑</p>
<p>这类地形几乎可以都可以在平地上进行移动，勾爪的垂直方向的移动只是选择使用。</p>
<p><strong>垂直移动</strong></p>
<p>坠落之谷，苇名城主城。</p>
<p><a href="https://image.gcores.com/7fa106e8-5518-4390-a4ea-16733ba47b94.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/7fa106e8-5518-4390-a4ea-16733ba47b94.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="菩萨谷"></a></p>
<p>菩萨谷</p>
<p><a href="https://image.gcores.com/4ec5974a-f470-4c86-b434-44495d1cf993.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/4ec5974a-f470-4c86-b434-44495d1cf993.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="苇名城主城屋顶"></a></p>
<p>苇名城主城屋顶</p>
<p>这类地形几乎只在垂直方向上移动，存在的关卡也比较少，可以在整体上起到调节节奏的作用。</p>
<p><strong>湖泊（游泳）</strong></p>
<p>龙泉河畔平田宅邸，源之宫水生宅邸，苇名城下水道。</p>
<p>《只狼》的游戏场景地形大部分的移动方式会偏向垂直和水平相互结合，这种移动方式其实就是奔跑+忍义手结合，整体移动的节奏上的变化也是最丰富的。</p>
<p>但大关卡里会设置几个小关卡是需要以忍义手移动为主的：像苇名之底的毒沼，苇名城主城的屋顶，苇名城城邑的桥下山谷（第一次碰到大蛇的地方），金刚山仙峰寺的修炼道，源之宫的赏花舞台。整个大关卡里以忍义手移动为主的只有坠落之谷.</p>
<p><strong>除坠落之谷外整个关卡上的分配比例如下：</strong></p>
<ol>
<li>65-80%左右的场景可以用忍义手和奔跑移动</li>
<li>15-25%的场景以使用忍义手移动为主</li>
<li>5-10%的场景使用游泳的方式。</li>
</ol>
<p>这是《只狼》通对地形的规划来对移动方式的节奏进行控制。</p>
<h1 id="单个关卡连续空间设计"><a href="#单个关卡连续空间设计" class="headerlink" title="单个关卡连续空间设计"></a>单个关卡连续空间设计</h1><p>先简单定义下空间类型和尺度和比例。</p>
<p>空间的类型方面三种空间类型的相互变化就可以产生非常丰富的空间体验了。</p>
<p><a href="https://image.gcores.com/589a3e62-b045-411f-ae9a-7a9e0afbf6a2.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/589a3e62-b045-411f-ae9a-7a9e0afbf6a2.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="室内空间：四周有维护结构和屋顶"></a></p>
<p>室内空间：四周有维护结构和屋顶</p>
<p><a href="https://image.gcores.com/83dbfd07-6661-4e37-9eaf-0faee0c74965.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/83dbfd07-6661-4e37-9eaf-0faee0c74965.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="灰空间：只有顶没有或者只有部分维护结构"></a></p>
<p>灰空间：只有顶没有或者只有部分维护结构</p>
<p><a href="https://image.gcores.com/dfcb8b1a-72b3-41d1-9645-92a8da3a6f95.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/dfcb8b1a-72b3-41d1-9645-92a8da3a6f95.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="室外空间：没有墙体和屋顶维护"></a></p>
<p>室外空间：没有墙体和屋顶维护</p>
<p>空间的尺度方面能看到的景别上的区别。</p>
<p><a href="https://image.gcores.com/d6938ef3-aabd-4d60-860d-b26bf8e90d7b.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/d6938ef3-aabd-4d60-860d-b26bf8e90d7b.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="大尺度空间：基本上场景可以看得比较远，中景较少，以近景和远景为主，因为离得比较远，所以物件都会显得比较小。"></a></p>
<p>大尺度空间：基本上场景可以看得比较远，中景较少，以近景和远景为主，因为离得比较远，所以物件都会显得比较小。</p>
<p><a href="https://image.gcores.com/c150ea54-5e0c-4086-b08e-6d24c33ff481.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/c150ea54-5e0c-4086-b08e-6d24c33ff481.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="一般尺度空间：中近景都会有存在，景别丰富。"></a></p>
<p>一般尺度空间：中近景都会有存在，景别丰富。</p>
<p><a href="https://image.gcores.com/b660c0cf-6588-495d-b805-b349307f294f.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b660c0cf-6588-495d-b805-b349307f294f.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="小尺度空间：一般在室内，没有远景和中景。"></a></p>
<p>小尺度空间：一般在室内，没有远景和中景。</p>
<p>空间的比例的变化会让心理也产生一些变化。</p>
<p><a href="https://image.gcores.com/bae68a6e-1016-4aa3-bd62-fb33a8b4a114.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/bae68a6e-1016-4aa3-bd62-fb33a8b4a114.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="进深方向会比较大，会有明显的前进的方向感。"></a></p>
<p>进深方向会比较大，会有明显的前进的方向感。</p>
<p><a href="https://image.gcores.com/e6ae5fd9-3361-4522-8c5f-5ced949c99e1.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/e6ae5fd9-3361-4522-8c5f-5ced949c99e1.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="长宽的比例偏向1:1，没有明显的方向感，所以会有停留的感觉。"></a></p>
<p>长宽的比例偏向1:1，没有明显的方向感，所以会有停留的感觉。</p>
<p><a href="https://image.gcores.com/7696d20e-911a-424a-84ce-4b6e5fdef4a5.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/7696d20e-911a-424a-84ce-4b6e5fdef4a5.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="z轴方向会有较大的深度，容易出现压迫和危险的感觉。"></a></p>
<p>z轴方向会有较大的深度，容易出现压迫和危险的感觉。</p>
<p>以上是一个空间的三种基本属性，类型，尺度和比例，在设计的时候会要考虑这些，因为游戏是连续场景，就要考虑空间的这些属性的连续变化，因此不是单单设计好一个场景空间就好了，要考虑彼此间的联系。简单来说连续空间设计就是：不同的空间类型和不同的空间尺度不断组合变化形成连续空间。</p>
<p>然后具体是怎么空间是怎么变化的，变化的规律我认为最主要的就是对比，需要让前后的场景产生对比，才能凸显你前进方向上所遇到的变化。</p>
<p>《只狼》里我大概分类三种场景空间变化的类型：</p>
<ol>
<li><strong>BOSS战：场景空间和场景色调都有剧烈的变化</strong></li>
<li><strong>重要NPC/精英怪/重要物件：空间类型和空间尺度的变化</strong></li>
<li><strong>普通NPC：较弱的空间变化</strong></li>
</ol>
<p>我们来具体看下几个 Boss 战。</p>
<p><strong>苇名弦一郎：</strong>   </p>
<p><a href="https://image.gcores.com/bae8da79-d8ad-46e4-add9-b77f7c91305e.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/bae8da79-d8ad-46e4-add9-b77f7c91305e.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>空间类型的变化：苇名道场室内-室外屋顶-天守阁望楼（灰空间）。</p>
<p>打弦一郎这段路径其实比较有意思，其实完全可以设计成从楼梯上去，但这样会少一个空间类型的变化并且比较重要的是色调上不能产生强烈的变化，少点意思。</p>
<p>色调上的变化:</p>
<p><a href="https://image.gcores.com/b07c53fa-11b1-4e6a-acd6-5e58c50f22b1.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b07c53fa-11b1-4e6a-acd6-5e58c50f22b1.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><strong>蝴蝶夫人</strong></p>
<p><a href="https://image.gcores.com/68eccf7a-2254-478f-b459-5884afa35c19.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/68eccf7a-2254-478f-b459-5884afa35c19.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="              蝴蝶夫人boss战途径"></a></p>
<p>​              蝴蝶夫人boss战途径</p>
<p>空间类型和尺度的变化：室内房间-半室外的长廊-狭小室内-地下长廊-着火的隐藏佛堂其实整体体验上是你需要通过很狭长的空间进入 Boss 战，非常经典的 Boss 战前的一种空间设计。</p>
<p><a href="https://image.gcores.com/03ae03d9-a792-4e63-8d90-f1a53d8acc50.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/03ae03d9-a792-4e63-8d90-f1a53d8acc50.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="平面"></a></p>
<p>平面</p>
<p>这里其实很有意思，你发现前面前田宅邸室内这部分没有一点着火的痕迹，只有隐藏佛堂这里出现了超大的火势，当然也会有很多剧情上的解释，但我想如果从视觉设计上考虑的话，火焰可以让场景从色调上瞬间和前面的场景进行区分。并且平田宅邸这个关卡火势最旺的位置就只有义父和蝴蝶夫人两个地方，一个是重要 NPC 一个关卡 Boss。</p>
<p><strong>樱龙</strong></p>
<p><a href="https://image.gcores.com/356ab323-15c5-4606-b4b5-2f3760a1f388.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/356ab323-15c5-4606-b4b5-2f3760a1f388.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>平面图：</p>
<p><a href="https://image.gcores.com/a13c1826-1c9b-4b48-b175-09dff746762b.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/a13c1826-1c9b-4b48-b175-09dff746762b.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/42897ead-0f72-4336-bf0d-5e2b05f03438.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/42897ead-0f72-4336-bf0d-5e2b05f03438.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="色调的变化:"></a></p>
<p>色调的变化:</p>
<p>空间与色调：神域石阶-石窟-樱龙。</p>
<p>这样看下来我们会发现几乎所有遇见所有的 Boss 前空间的色调会出现剧烈的变化。</p>
<p><strong>苇名弦一郎/苇名一心</strong></p>
<p><a href="https://image.gcores.com/b2395ee0-a166-40f0-b702-f0c4cff397a2.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b2395ee0-a166-40f0-b702-f0c4cff397a2.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="弦一郎/苇名一心途径"></a></p>
<p>弦一郎/苇名一心途径</p>
<p><a href="https://image.gcores.com/809c7276-3ff9-4b67-9d53-0ff66fbe651d.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/809c7276-3ff9-4b67-9d53-0ff66fbe651d.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="这个空间类型和蝴蝶夫人很很相似的，也是从一个狭长的室内空间过渡到另外一个大空间里面，可以注意色调的变化。"></a></p>
<p>这个空间类型和蝴蝶夫人很很相似的，也是从一个狭长的室内空间过渡到另外一个大空间里面，可以注意色调的变化。</p>
<p>Boss 战几乎是每个关卡里的高潮，因此变化也是最剧烈的，空间的尺度，类型，比例，色调四个维度都会产生变化。</p>
<p><strong>重要物件的空间变化</strong></p>
<p><strong>结宿之石</strong></p>
<p><a href="https://image.gcores.com/20d4c8f7-25be-4c36-b32a-aa1fc5d505c5.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/20d4c8f7-25be-4c36-b32a-aa1fc5d505c5.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="慢慢撒下来的天光对这个环境产生的色调变化"></a></p>
<p>慢慢撒下来的天光对这个环境产生的色调变化</p>
<p><a href="https://image.gcores.com/43de404f-8ce6-45cb-9f14-b841701469e3.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/43de404f-8ce6-45cb-9f14-b841701469e3.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="结宿之石平面"></a></p>
<p>结宿之石平面</p>
<p><strong>废弃佛堂</strong></p>
<p><a href="https://image.gcores.com/8325f411-3e9c-4843-90bf-0b8423d5dd61.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/8325f411-3e9c-4843-90bf-0b8423d5dd61.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="可以关注下佛堂内院稀稀落落的光影"></a></p>
<p>可以关注下佛堂内院稀稀落落的光影</p>
<p><a href="https://image.gcores.com/3275b78f-0478-43eb-b60e-87a7e3aa639d.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/3275b78f-0478-43eb-b60e-87a7e3aa639d.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="废弃佛堂平面"></a></p>
<p>废弃佛堂平面</p>
<p>重要场景或者物件会在空间尺度，空间比例，和色调上进行一定区分。</p>
<p><strong>精英怪的空间变化</strong></p>
<p>下面我们看下在遭遇几个精英怪前的空间变化，配有动态 gif 和平面图，可以对照着看。</p>
<p><strong>苇名城主城大将</strong></p>
<p><a href="https://image.gcores.com/b1ffd82e-127b-4edf-bb42-6197499d0314.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/b1ffd82e-127b-4edf-bb42-6197499d0314.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/9a0e7e31-54c6-4238-9ff1-6a193bf1d7a8.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/9a0e7e31-54c6-4238-9ff1-6a193bf1d7a8.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="主城前大台阶平面"></a></p>
<p>主城前大台阶平面</p>
<p><strong>贮水城七本枪</strong></p>
<p><a href="https://image.gcores.com/3d5d75ed-4d09-4289-91b4-1d52f09d1e68.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/3d5d75ed-4d09-4289-91b4-1d52f09d1e68.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/58c82b9b-a27e-47bf-a51f-53b9c7ad228e.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/58c82b9b-a27e-47bf-a51f-53b9c7ad228e.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="七本枪平面"></a></p>
<p>七本枪平面</p>
<p><strong>赤鬼</strong></p>
<p><a href="https://image.gcores.com/c8f4b2b0-63c2-4821-8504-923c22f3ea42.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/c8f4b2b0-63c2-4821-8504-923c22f3ea42.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/7374b402-7d42-4b35-a102-58efeb38c24a.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/7374b402-7d42-4b35-a102-58efeb38c24a.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="赤鬼平面"></a></p>
<p>赤鬼平面</p>
<p>精英怪主要是在遭遇前会做一些空间尺度上做些比较大的变化，可能会将精英怪放在某个台阶前或者某个门前大空间，不会有色调上的强烈变化，也不会有空间类型上的变化。</p>
<p>一般会置于某些空间节点（较大的空场，或者有某些标志物在的地方，像平田宅邸前的蚺蛇重藏或者坠落之谷的蛇眼白藤）或者空间的终点（类似楼梯终点，像赤鬼或七本枪）。</p>
<p><strong>重要NPC的空间安排</strong></p>
<p><strong>佛雕师</strong></p>
<p><a href="https://image.gcores.com/08d36aae-e94d-4a17-81ab-20e53ec6c4a3.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/08d36aae-e94d-4a17-81ab-20e53ec6c4a3.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/0291c451-97ab-471c-9618-d94cfff4ccd9.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/0291c451-97ab-471c-9618-d94cfff4ccd9.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="佛雕师平面"></a></p>
<p>佛雕师平面</p>
<p><strong>天狗</strong></p>
<p><a href="https://image.gcores.com/081885ac-3cbc-475d-b8a2-706edd309801.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/081885ac-3cbc-475d-b8a2-706edd309801.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/96ac01f5-0b6a-4015-97f7-b3f2f839a6ed.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/96ac01f5-0b6a-4015-97f7-b3f2f839a6ed.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="佛雕师平面"></a></p>
<p>佛雕师平面</p>
<p><strong>变若之子</strong></p>
<p><a href="https://image.gcores.com/86330cf1-8948-4e5e-b99f-33df00920fb0.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/86330cf1-8948-4e5e-b99f-33df00920fb0.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p><a href="https://image.gcores.com/e8960ccc-06c1-49c5-aec7-4923f5191e08.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/e8960ccc-06c1-49c5-aec7-4923f5191e08.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>重要 npc 基本上都在室内，这样就会有在<strong>空间类型上有室外-灰空间-室内的变化</strong>，也是让你觉得空间变化了，那么碰到的内容上肯定也会有变化。</p>
<p><strong>固定普通NPC的空间变化</strong></p>
<p><a href="https://image.gcores.com/981bc631-da92-44a7-a19d-cfae15480ee8.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/981bc631-da92-44a7-a19d-cfae15480ee8.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="仙峰寺修炼道商人"></a></p>
<p>仙峰寺修炼道商人</p>
<p><a href="https://image.gcores.com/f27182b7-4fa7-4e43-a99a-35062f471d02.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/f27182b7-4fa7-4e43-a99a-35062f471d02.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="天狗旁边的祭奠帮商人"></a></p>
<p>天狗旁边的祭奠帮商人</p>
<p>这类普通 NPC，遇见前或者在高差上有点变化或者空间的比例产生变化，但相对来说变化的程度都比较小。</p>
<p>空间的类型、比例、尺度、色调就是场景设计时候一个工具，掌握使用时候的度很重要，让重要的场景产生强烈的对比。</p>
<p>场景空间的前后对比的强烈程度：boss战=重要NPC＞精英怪＞重要物件=普通NPC=杂兵。</p>
<p>《只狼》在整个地图设计上的行径路线几乎都是精心设计过的，虽然也有探索的部分，但是整个路线也都是设计过的。换句话说，你的行动范围其实是被严格限制在一整条行径路线上的，这样可以角色的站位几乎都是在控制之中。</p>
<p>这也是通过宫崎英高对角色的机动能力的严格控制的结果，《血源诅咒》几乎连跳跃都没用，只有平面上的移动，《只狼》虽然有了竖向的跳跃和勾爪能力，但也都是定点的位置才能使用。控制了移动范围也就控制了玩家的站位和视角，站位和视角定了那么关键帧的位置安排也就比较有理有据了，能更容易让你看到创作者想让你看到的东西。</p>
<h1 id="场景关键帧设计（场景单体设计，氛围设计）"><a href="#场景关键帧设计（场景单体设计，氛围设计）" class="headerlink" title="场景关键帧设计（场景单体设计，氛围设计）"></a><strong>场景关键帧设计（场景单体设计，氛围设计）</strong></h1><p>这部分就不展开聊了，因为大部分场景原画设计都在考虑这部分，研究得也比较透彻了，我自己对于场景设计的理解也几乎都是在网络中学习到的，游戏场景也是由无数关键帧链接而成，是基础和底层，LIN 食铺里未来有关场景的文章应该大部分都是场景关键帧的设计。</p>
<p>但游戏不是静止画面或者动态电影，游戏的空间是连续的，前面空间上的规划和设计也是尤为重要。</p>
<p><strong>后记</strong></p>
<p>上面说的更像是创作中的一种套路，能够被总结和使用，但即使知道或者理解这些每个人来做其实还是会做出截然不同的东西，如果说让横尾太郎来做只狼，估计又是另外的面貌了，因为每个人都拥有主观的记忆和阅历，还有潜意识，感兴趣的话可以看看后续另外一篇的<strong>空间潜意识</strong>。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>只狼</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊同步、异步、阻塞与非阻塞</title>
    <url>/%E8%81%8A%E8%81%8A%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近来遇到了一些常见的概念，尤其是网络编程方面的概念，如：阻塞、非阻塞、异步I/O等等，对于这些概念自己也没有太清晰的认识，只是很模糊的概念，说了解吧也了解，但是要让自己准确的描述概念方面的具体细节，却说的不那么准确，这也是自己在这几个方面也没有细细考究过的原因吧。经过看了些这几个概念的资料，发现同步、异步、阻塞、非阻塞的概念其实也并不难以理解，在此写下此文，欢迎拍砖，希望多多交流。</p>
<h1 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1 同步与异步#"></a>1 同步与异步#</h1><p><strong><code>首先来解释同步和异步的概念，这两个概念与消息的通知机制有关。也就是同步与异步主要是从消息通知机制角度来说的。</code></strong></p>
<h2 id="1-1-概念描述"><a href="#1-1-概念描述" class="headerlink" title="1.1 概念描述##"></a>1.1 概念描述##</h2><p><code>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列</code>。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<p><code>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</code>。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，<code>所以它是不可靠的任务序列</code>。</p>
<h2 id="1-2-消息通知"><a href="#1-2-消息通知" class="headerlink" title="1.2 消息通知##"></a>1.2 消息通知##</h2><p><code>异步的概念和同步相对</code>。当一个同步调用发出后，<code>调用者要一直等待返回消息（结果）通知后</code>，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。<code>实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</code>。</p>
<p>这里提到执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。使用哪一种通知机制，<code>依赖于执行部件的实现</code>，除非执行部件提供多种选择，<code>否则不受调用者控制</code>。</p>
<blockquote>
<ol>
<li>如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）；</li>
<li>如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</li>
</ol>
</blockquote>
<h2 id="1-2-场景比喻"><a href="#1-2-场景比喻" class="headerlink" title="1.2 场景比喻##"></a>1.2 场景比喻##</h2><p>举个例子，比如我去银行办理业务，可能会有两种方式：</p>
<blockquote>
<ol>
<li>选择排队等候；</li>
<li>另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</li>
</ol>
</blockquote>
<p>第一种：<code>前者(排队等候)就是同步等待消息通知</code>，也就是我要一直在等待银行办理业务情况；</p>
<p>第二种：<code>后者(等待别人通知)就是异步等待消息通知</code>。在异步消息处理中，<code>等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制</code>，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。</p>
<h1 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2 阻塞与非阻塞#"></a>2 阻塞与非阻塞#</h1><p><strong><code>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</code></strong></p>
<h2 id="2-1-概念描述"><a href="#2-1-概念描述" class="headerlink" title="2.1 概念描述##"></a>2.1 概念描述##</h2><p><code>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务</code>。函数只有在得到结果之后才会返回。</p>
<p><strong>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</strong></p>
<ol>
<li><code>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息</code>。还有一点，在这里先扩展下：</li>
</ol>
<blockquote>
<p>(a) 如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；</p>
<p>(b) 如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；</p>
</blockquote>
<p><strong><code>所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞；</code></strong></p>
<ol>
<li>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回；</li>
</ol>
<p>非阻塞和阻塞的概念相对应，<code>指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回</code>。虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，<code>但是也带了另外一种后果就是系统的线程切换增加</code>。<code>增加的CPU执行时间能不能补偿系统的切换成本需要好好评估</code>。</p>
<h2 id="2-2-场景比喻"><a href="#2-2-场景比喻" class="headerlink" title="2.2 场景比喻##"></a>2.2 场景比喻##</h2><p>继续上面的那个例子，不论是排队还是使用号码等待通知，<code>如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的</code>，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p>
<p>相反，<code>有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的</code>，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p>
<p>但是需要注意了，<code>同步非阻塞形式实际上是效率低下的</code>，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而<code>异步非阻塞形式却没有这样的问题</code>，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p>
<h1 id="3-同步-异步与阻塞-非阻塞"><a href="#3-同步-异步与阻塞-非阻塞" class="headerlink" title="3 同步/异步与阻塞/非阻塞#"></a>3 同步/异步与阻塞/非阻塞#</h1><ol>
<li><strong>同步阻塞形式</strong></li>
</ol>
<p>效率是最低的，</p>
<p>拿上面的例子来说，就是你专心排队，什么别的事都不做。</p>
<p><strong>实际程序中：</strong>就是未对fd 设置O_NONBLOCK标志位的read/write 操作；</p>
<ol>
<li><strong>异步阻塞形式</strong></li>
</ol>
<p>如果在银行等待办理业务的人<code>采用的是异步的方式去等待消息被触发（通知）</code>，也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p><strong><code>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</code></strong></p>
<p>比如select 函数，假如传入的最后一个timeout参数为NULL，<code>那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select 调用处</code>。</p>
<ol>
<li><strong>同步非阻塞形式</strong></li>
</ol>
<p>实际上是效率低下的，</p>
<p>想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，<code>这个程序需要在这两种不同的行为之间来回的切换</code>，效率可想而知是低下的。</p>
<p>很多人会写阻塞的read/write 操作，<code>但是别忘了可以对fd设置O_NONBLOCK 标志位，这样就可以将同步操作变成非阻塞的了</code>。</p>
<ol>
<li><strong>异步非阻塞形式</strong></li>
</ol>
<p>效率更高，</p>
<p>因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，<code>程序没有在两种不同的操作中来回切换</code>。</p>
<p>比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p>
<p>如果使用异步非阻塞的情况，比如aio_*组的操作，当发起一个aio_read操作时，<code>函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理</code>。</p>
<p>很多人会把同步和阻塞混淆，我想是<code>因为很多时候同步操作会以阻塞的形式表现出来</code>，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了。<code>但最根本是因为没有区分这两个概念</code>，比如阻塞的read/write操作中，<code>其实是把消息通知机制和等待消息通知的状态结合在了一起</code>，在这里<code>所关注的消息就是fd是否可读/写</code>，而<code>等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态</code>。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。</p>
<p>同样的，很多人也会把异步和非阻塞混淆，<code>因为异步操作一般都不会在真正的IO操作处被阻塞</code>，比如如果用select函数，<code>当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞</code>。</p>
<h1 id="4-小明的故事"><a href="#4-小明的故事" class="headerlink" title="4 小明的故事#"></a>4 小明的故事#</h1><p>对上面所讲的概念再次进行一个场景梳理，上面已经明确说明，<strong><code>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态</code></strong>。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能够更好的促进大家的理解。</p>
<ol>
<li><strong>同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。</strong></li>
</ol>
<blockquote>
<p>同步体现在：等待下载完成通知；</p>
<p>阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</p>
</blockquote>
<ol>
<li><strong>同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。</strong></li>
</ol>
<blockquote>
<p>同步体现在：等待下载完成通知；</p>
<p>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】</p>
</blockquote>
<ol>
<li><strong>异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗）。</strong></li>
</ol>
<blockquote>
<p>异步体现在：下载完成“叮”一声通知；</p>
<p>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</p>
</blockquote>
<ol>
<li><strong>异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</strong></li>
</ol>
<blockquote>
<p>异步体现在：下载完成“叮”一声通知；</p>
<p>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</p>
</blockquote>
<p>也就是说，<strong><code>同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务）</code></strong>，在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。</p>
<p>所以，综上所述，<code>同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态</code>。也就是说，<code>同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者</code>，所以在异步机制中，<code>处理消息者和触发机制之间就需要一个连接的桥梁</code>：</p>
<blockquote>
<p>在银行的例子中，这个桥梁就是小纸条上面的号码。</p>
<p>在小明的例子中，这个桥梁就是软件“叮”的声音。</p>
</blockquote>
<p><strong><code>最后，请大家注意理解“消息通知机制”和“等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。</code></strong></p>
]]></content>
  </entry>
  <entry>
    <title>聊聊场景设计中距离感的设计</title>
    <url>/%E8%81%8A%E8%81%8A%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E4%B8%AD%E8%B7%9D%E7%A6%BB%E6%84%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于收藏，转载<a href="https://www.gcores.com/articles/128208" target="_blank" rel="noopener">https://www.gcores.com/articles/128208</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>好久没写和绘画相关的文章了，自己不太确定的东西不太想写，但绘画里关于场景设计的东西还是可以讲讲。这个主题研究了蛮久的，大概是去年11月份写完<a href="https://www.gcores.com/articles/116167" target="_blank" rel="noopener">《只狼》的文章</a>就打算些这样一篇关于场景距离感的研究，断断续续有些新的发现，前两天才把东西理好，在做场景设计的时候挺有帮助的，这次算是阶段性的总结。 </p>
<h1 id="明度变化"><a href="#明度变化" class="headerlink" title="明度变化"></a><strong>明度变化</strong></h1><p>大场景区分距离的主要手段，分前中后三景明度。受室外水汽灰尘折射产生的明度变化，距离越远，空气中的水汽灰尘越厚，明度随之产生变化，大多3d软件用fog来表达这一属性，我也用这个好了，用fog的浓度和颜色来表示明度与色相变化。</p>
<p>比较大的场景中会经常用到大气透视（fog），但很多中小型场景其实除了一些特殊天气其实没办法使用大气透视.</p>
<p><a href="https://image.gcores.com/059be59c-8e28-47da-b84e-8508806bbc73.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/059be59c-8e28-47da-b84e-8508806bbc73.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>2d横版类游戏在明度上会有会有很好区分，并且也是横版游戏的优势，通过明度变化就能很好的展现纵深感。</p>
<p><a href="https://image.gcores.com/02c90f68-70c4-4e17-9b0f-862513b7b42a.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/02c90f68-70c4-4e17-9b0f-862513b7b42a.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<h1 id="与地面的关系"><a href="#与地面的关系" class="headerlink" title="与地面的关系"></a><strong>与地面的关系</strong></h1><p>因为地面，自带透视关系，因此只要露出物体与地面的关系我们就能直观地判断两者的相关距离。这是所有因素里唯一可以直接判断距离的依据，即使没有遮挡，没有明度变化，即使是完全不同的物体，也可以根据其地面关系来直接判断距离和前后关系。 </p>
<p>可以用手把地平线以下部分遮住，你会发现左右两颗树的距离感变得模糊，你没办法判断。左右两棵树的相对距离，但中间那颗树会显得远是因为和左边的树形成近大远小的感觉</p>
<p><a href="https://image.gcores.com/73482fbb-f331-4138-b24f-1588565c7cc1.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/73482fbb-f331-4138-b24f-1588565c7cc1.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>中国园林设计里的经常看到这样的设计，因为地面狭小，索性故意遮挡地面，取消景物与地面的关系，设计遮挡与大小变化，造成距离感的模糊，只能判断前后而无法判断距离。这里地面部分除了正常的行径路线几乎已经全部被遮挡，但还是有不错层次关系，并且背后的植物，墙体，房子之间也许靠的很近，但因为地面关系无法看到也就无法正确判断，距离感也就被模糊了。</p>
<p><a href="https://image.gcores.com/5d56bb37-b970-4745-88bc-ec64ac81fee8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5d56bb37-b970-4745-88bc-ec64ac81fee8.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>寄畅园中通过高差来遮挡地面，模糊景物的实际距离，这种设计的方式可以在很小面积内就能形成及其丰富的层次。但如果把地面暴露出来，反而会因为知道了实际距离会让空间显得闭塞。</p>
<p><a href="https://image.gcores.com/ff9dc341-99d3-487e-9206-595d5513132b.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ff9dc341-99d3-487e-9206-595d5513132b.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<h1 id="相似物体的大小变化"><a href="#相似物体的大小变化" class="headerlink" title="相似物体的大小变化"></a><strong>相似物体的大小变化</strong></h1><p>远山无皴，远水无波，远人无目。非无也。如无耳。</p>
<p>近大远小是最基础的透视关系，但要注意的是只要相同和近似的物体才会产生这种距离感，即使没有遮挡，地面关系，没有明度变化，也能产生很强的距离感。很基础，但却有很多种用法。</p>
<p><a href="https://image.gcores.com/e47007ef-6604-466d-a917-506b2ba1b7ff.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e47007ef-6604-466d-a917-506b2ba1b7ff.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>创造距离的错觉也很常用，下图中两扇距离并不远的窗子，故意直接缩小远处的窗子来创造距离感的错觉，并且直接遮挡地面，模糊距离感。</p>
<p><a href="https://image.gcores.com/97a01613-cac9-4aa1-af2c-c5ef335fe2a7.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/97a01613-cac9-4aa1-af2c-c5ef335fe2a7.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>创造巨物是在地平线处放置大的物体，并在前景放置相似物体，前面都要放个小人儿和后面地平线出的怪物做大小对比。遮掉地平线以下的物体其实怪物的整体尺度就比较难判断了，但有云雾之类的东西做好对比还是能够判断大小。</p>
<p><a href="https://image.gcores.com/fd17ebe9-0a65-4f06-9a9e-13b91f0344fb.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fd17ebe9-0a65-4f06-9a9e-13b91f0344fb.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>云指点一下《黑神话：悟空》四大天王这个场景，前景和中景石头固有色脱节，减弱了前景中景相似联系，而且中景石块太大了，几乎和近景的看着差不多，不太能拉开距离，空中在搞点儿体积云作为参照物对比，遮挡下四大天王就能看起来非常大了。</p>
<p>对于开阔的大场景来说地平线遮挡蛮头疼的，因为所需要的模型量巨大，并且用大量模型即使堆出来效果也不一定好，不可避免会有大量重复。我自己觉得可以试一试的解决方案可以把摄像机高度降低，减少地面漏出的面积，这样地平线就很容易被近中景挡住，少量的模型就可以创造很深远的场景。</p>
<p><a href="https://image.gcores.com/58ecb06b-604f-4f55-84fa-f286edcac701.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/58ecb06b-604f-4f55-84fa-f286edcac701.png?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>像这张，摄像机高度降低后，地面面积减少，少量的前景中景，就能遮挡地平线，并且摄像机高度变低后前景人物和地平线处蛇的对比会显得更加强烈，并且模型压力也会小很多。</p>
<p><a href="https://image.gcores.com/28de13af-6a3a-4a1a-820c-65ec047698eb.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/28de13af-6a3a-4a1a-820c-65ec047698eb.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>相似物体在不同距离的点线面转化，概括来说就是相互遮挡使他们黏连成线或者黏连成面，大气透视又让他们的对比减弱，形成最后概括的线面。在中大型场景中被大量使用的技巧，叶子，花，人群，石头，这类大量存在且重复的物体在不同距离会呈现不同的特征，距离较远的时候一些物体细节将会被掩盖，并且同时会被组合在一起。远景画了细节和对比反而会显得近了。所以远景的细节并不是要不要显示的问题，而是需要对细节进行概括，有概括才能拉开距离。 </p>
<p>下面是CM的图，近景人单独的点，中景人连成线，远景就直接成面+部分点状来概括，包括中景的椰子树，其不同距离的点线面的变化</p>
<p><a href="https://image.gcores.com/bf66d1f6-b5d5-4ea5-8333-56ef3dbceef4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/bf66d1f6-b5d5-4ea5-8333-56ef3dbceef4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><a href="https://image.gcores.com/b8f10d1c-15a8-44ee-bda3-6f6d2f1bf9a0.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b8f10d1c-15a8-44ee-bda3-6f6d2f1bf9a0.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="男鹿和雄：灯因为距离变化近景的点到中景线的变化"></a></p>
<p>男鹿和雄：灯因为距离变化近景的点到中景线的变化</p>
<p><a href="https://image.gcores.com/1e91e57b-6225-4d99-9229-dbc8d842a43f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1e91e57b-6225-4d99-9229-dbc8d842a43f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="远景部分几乎看不到树干了，已经和树丛基本上分不清出了"></a></p>
<p>远景部分几乎看不到树干了，已经和树丛基本上分不清出了</p>
<p><a href="https://image.gcores.com/78a1d1d7-87da-4360-8f74-c24627bcf8a8.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/78a1d1d7-87da-4360-8f74-c24627bcf8a8.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="云和红草，在铺的距离足够远的情况下，根据距离不同，由点到线，在由线到面，需要注意其外轮廓和内部光影细节距离不同都在变化，大部分能铺到地平线位置的物体都会有这个变化特征。"></a></p>
<p>云和红草，在铺的距离足够远的情况下，根据距离不同，由点到线，在由线到面，需要注意其外轮廓和内部光影细节距离不同都在变化，大部分能铺到地平线位置的物体都会有这个变化特征。</p>
<p><a href="https://image.gcores.com/e7907a8f-6ef0-4f2d-89b8-a2836ce09fad.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e7907a8f-6ef0-4f2d-89b8-a2836ce09fad.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水波纹近中远距离的变化"></a></p>
<p>水波纹近中远距离的变化</p>
<p><a href="https://image.gcores.com/9f88e339-0733-4c0e-a9f2-8e365d49a286.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9f88e339-0733-4c0e-a9f2-8e365d49a286.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="远景的房子已经变成密密麻麻的小色块所形成的面了。"></a></p>
<p>远景的房子已经变成密密麻麻的小色块所形成的面了。</p>
<h1 id="遮挡就是high-level"><a href="#遮挡就是high-level" class="headerlink" title="遮挡就是high level"></a><strong>遮挡就是high level</strong></h1><p>最易用的技巧，在很多时候其实是要故意去制造遮挡关系来营造，前后的距离感，特别在物体空间和物体不大的时候，遮挡就更加重要了。绘画时很多时候我在处理遮挡关系的时候会觉得麻烦，但这真的很重要，所有场景里几乎都会出现遮挡关系。</p>
<p><a href="https://image.gcores.com/28db3b6e-fcba-45d5-bd24-cbc4ca28eaa0.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/28db3b6e-fcba-45d5-bd24-cbc4ca28eaa0.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="在楼下拍了张，没有明度变化，没有相似物件，没有地面，只有遮挡，你发现还是能够很好的判断距离，很多插画凸显层次感都会使用的技巧。"></a></p>
<p>在楼下拍了张，没有明度变化，没有相似物件，没有地面，只有遮挡，你发现还是能够很好的判断距离，很多插画凸显层次感都会使用的技巧。</p>
<p>穆夏表达距离的主要手段就是遮挡，疯狂地使用遮挡，大量的装饰图框来构成遮挡关系来丰富层次，没有地面关系，没有大气透视，没有相似物体在距离上的大小变化，只使用遮挡，会让人只能分前后，而无法判断距离远近。其人物塑造也刻意平面化，以和他整个画面能够匹配，但还是能切切实实地创造了非常丰富的层次感。用遮挡来表示前后关系，当然图好看更多的是构成和颜色。</p>
<p><a href="https://image.gcores.com/234186c0-65de-44c8-95f8-df1a98e9bf35.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/234186c0-65de-44c8-95f8-df1a98e9bf35.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>场景中超级high level 的用法：摄影机高度下降的仰视视角。</p>
<p>何园的月近亭，和穆夏的图类似这种层次关系就是没有没有地面关系，没有明度明度变化，没有相似物体的大小变化，在极小的面积里只通过遮挡来创造及其丰富的层次，人在低处的时候在高点设置视觉中心，人的视点自然会向上抬。下面两张图去掉体积光影的话其层次关系依旧非常丰富。</p>
<p><a href="https://image.gcores.com/74b3e526-4c28-4c1f-b557-5c46ee26ea84.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/74b3e526-4c28-4c1f-b557-5c46ee26ea84.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>《只狼》在主城这里的摄像机降低了，看截图我原来以为是自己控制的。</p>
<p><a href="https://image.gcores.com/107c19a0-0262-4a35-b386-29c42b65a2ec.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/107c19a0-0262-4a35-b386-29c42b65a2ec.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>然后我去游戏里验证了下，这里的摄像机高度强制下降了。注意脚步和画面底部的距离，我没有手动转动摄像机，是摄像机自动降低并且视角还往上转了，感兴趣可以自己去游戏里验证下。通过控制摄像机高度与整个场景相互配合让整个场景气势恢宏，这是普通相机高度无法做到的，并且通过不同物件的遮挡产生如此丰富的层次，和上面的月近亭有异曲同工之妙。</p>
<p><a href="https://image.gcores.com/19ec93cf-5cbe-437a-9f15-ebf7d10b8f32.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/19ec93cf-5cbe-437a-9f15-ebf7d10b8f32.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="img"></a></p>
<p>当然啦，场景设计里能设计好距离感这个东西才只是开始，因为游戏里你大部分时候是没办法控制玩家站位的，而我们画的或者思考氛围图的时候，平面的时候却是固定视角的，这个就是很矛盾的地方。但也是游戏区别于影视的地方，感兴趣的可以留意下《只狼》的几张地图：苇名城城邑，源之宫，平田宅邸，仙峰寺，这四张地图，可以看到很具体的解决方案，这个下次有机会聊吧。 </p>
<p><a href="https://image.gcores.com/32efd01f-8a2f-49b2-8abb-69f70df91d12.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/32efd01f-8a2f-49b2-8abb-69f70df91d12.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_875,h_2500/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<ol>
<li><em>参考资料：</em></li>
<li><em>中国古典园林与现代转译十五讲</em></li>
<li><em>豆瓣相册：曼殊君的相册</em></li>
<li><em>豆瓣相册：十万错的相册-无锡寄畅园</em></li>
<li><em>只狼实际游戏截图</em></li>
<li><em>黑神话：悟空演示视频</em></li>
<li><em>其他网络图片</em></li>
<li><em>封面我也不知道出处~</em></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>走了的人就像照片挂在墙上</title>
    <url>/%E8%B5%B0%E4%BA%86%E7%9A%84%E4%BA%BA%E5%B0%B1%E5%83%8F%E7%85%A7%E7%89%87%E6%8C%82%E5%9C%A8%E5%A2%99%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>身份不同，心怀不同</title>
    <url>/%E8%BA%AB%E4%BB%BD%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%BF%83%E6%80%80%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个做游戏设计突然脑光，灵感来了，打电话給远方的老大，巴拉巴拉地说这角色设计应该怎样。<br>这时如果老大和懂皇这类高级人物在一起，高谈金融经济影响世界等高格局的事情，就可能不爽，你这小格局的东西就别打扰高格局的事情。<br>游戏设计工作就是很可能和这些不在同一个格局的上级打交道的。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>感叹</tag>
      </tags>
  </entry>
  <entry>
    <title>防火墙iptables</title>
    <url>/%E9%98%B2%E7%81%AB%E5%A2%99iptables/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="etfilter-iptables原理"><a href="#etfilter-iptables原理" class="headerlink" title="etfilter/iptables原理"></a>etfilter/iptables原理</h2><p><a href="http://www.yulongjun.com/images/15027993532050.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150548.jpg" alt="img"></a></p>
<p>Netfilter组件：</p>
<ul>
<li>内核空间，集成在linux内核中</li>
<li>扩展各种网络服务的结构化底层框架</li>
<li>内核中选取五个位置放了五个hook function（勾子函数）(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)， 而这五个hook function向用户开放，用户可以通过一个命令工 具（iptables）向其写入规则。</li>
<li>由信息过滤表（table）组成，包含控制IP包处理的规则集（ rules），规则被分组放在链（chain）上</li>
</ul>
<p>三种报文流向：</p>
<ul>
<li>流入本机：PREROUTING –&gt; INPUT–&gt;用户空间进程</li>
<li>流出本机：用户空间进程 –&gt;OUTPUT–&gt; POSTROUTING</li>
<li>转发：PREROUTING –&gt; FORWARD –&gt; POSTROUTING</li>
</ul>
<p><a href="http://www.yulongjun.com/images/15027592816718.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150557.png" alt="img"></a></p>
<p>iptables由<strong>四个表和五个链</strong>以及一些规则组成:</p>
<ul>
<li>四个表(table)：<ul>
<li><code>filter</code>:过滤规则表，根据预定义的规则过滤符合条件的数据包</li>
<li><code>nat</code>:network address translation 地址转换规则表</li>
<li><code>mangle</code>:修改数据标记位规则表</li>
<li><code>Raw</code>:关闭NAT表上启用的连接跟踪机制，加快封包穿越防火墙速度</li>
</ul>
</li>
</ul>
<blockquote>
<p>优先级由高到低的顺序为:<strong>raw–&gt;mangle–&gt;nat–&gt;filter</strong></p>
</blockquote>
<ul>
<li>五个内置链(chain)：<ul>
<li><code>INPUT</code></li>
<li><code>OUTPUT</code></li>
<li><code>FORWARD</code></li>
<li><code>PREROUTING</code></li>
<li><code>POSTROUTING</code></li>
</ul>
</li>
</ul>
<p>Netfilter/iptables Packet Flow：</p>
<p><a href="http://www.yulongjun.com/images/15027599296033.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150602.png" alt="img"></a></p>
<h2 id="内核中数据包的传输过程"><a href="#内核中数据包的传输过程" class="headerlink" title="内核中数据包的传输过程"></a>内核中数据包的传输过程</h2><ul>
<li>当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去</li>
<li>如果数据包就是进入本机的，数据包就会沿着图向下移动，到达INPUT链。数据包到达INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包经过OUTPUT链 ，然后到达POSTROTING链输出</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出</li>
</ul>
<p><a href="http://www.yulongjun.com/images/15027999506363.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150606.jpg" alt="img"></a></p>
<h2 id="防火墙工具"><a href="#防火墙工具" class="headerlink" title="防火墙工具"></a>防火墙工具</h2><ul>
<li>iptables</li>
<li>firewalld工具集<ul>
<li>firewall-cmd 命令行工具</li>
<li>firewall-config 图形工具</li>
</ul>
</li>
</ul>
<p>我们主要以实验的方式介绍iptables的使用,firewalld的工具集自行了解下。</p>
<p><a href="http://www.yulongjun.com/images/15027996752314.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150611.jpg" alt="img"></a></p>
<p>上图加粗部分是重点实验内容，包括：</p>
<ul>
<li><strong>filter</strong>表中的<code>INPUT</code>和<code>OUTPUT</code></li>
<li><strong>filter</strong>表中的<code>FORWARD</code></li>
<li><strong>nat</strong>表中的<code>PREROUTING</code>和<code>POSTROUTING</code></li>
</ul>
<p>实验前要关闭防火墙自带的服务，来自行配置防火墙，而不是系统定义的防火墙策略。</p>
<p>CentOS6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">service iptables stop<br>chkconfig iptables off<br></code></pre></td></tr></table></figure>

<p>CentOS7:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">systemctl stop firewalld.service <br>systemctl disable firewalld. service<br></code></pre></td></tr></table></figure>

<h2 id="iptables命令语法格式"><a href="#iptables命令语法格式" class="headerlink" title="iptables命令语法格式"></a>iptables命令语法格式</h2><p><a href="http://www.yulongjun.com/images/15028007369001.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/ashjian/picBed/master/20201130150616.jpg" alt="img"></a></p>
<h3 id="t-table"><a href="#t-table" class="headerlink" title="-t table"></a><code>-t table</code></h3><p>指的是chain表，默认不写为<code>filter</code>表，还可以指定<code>nat</code>、<code>mangle</code>、<code>raw</code>等表。</p>
<h3 id="COMMANDS"><a href="#COMMANDS" class="headerlink" title="-COMMANDS"></a><code>-COMMANDS</code></h3><h4 id="1-查看防火墙规则参数"><a href="#1-查看防火墙规则参数" class="headerlink" title="1. 查看防火墙规则参数"></a>1. 查看防火墙规则参数</h4><p>常用选项：<code>-vnL</code></p>
<ul>
<li><code>-v</code>：verbose,详细信息。如果要更详细信息，<code>-vv</code>。</li>
<li><code>-n</code>：numberic，以数字格式显示地址和端口号</li>
<li><code>-L</code>：List列出指定链上所有规则，不指定链的话，只输出filter表上的链。此参数要写在最后。</li>
<li><code>-x</code>：exactly，显示计数器结果的精确值,而非单位转换后的易读值。</li>
<li><code>--line-numbers</code>：显示规则的序号。</li>
</ul>
<p>常用组合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">-vnL<br>-vnL --line-numbers<br>-vvnxL --line-numbers<br></code></pre></td></tr></table></figure>

<h4 id="2-规则管理的参数"><a href="#2-规则管理的参数" class="headerlink" title="2. 规则管理的参数"></a>2. 规则管理的参数</h4><ul>
<li><p><code>-A chain</code>：Append，添加某chain的规则。</p>
</li>
<li><p><code>-C chain</code>：Check，检查某chain的规则。</p>
</li>
<li><p><code>-D chain rulenum</code>：Delete，删除某chian指定序号位置的规则。</p>
</li>
<li><p><code>-I chain [rulenum]</code>：Insert，在某chain的指定序号位置插入规则，不写默认插在开头（第一个）。</p>
</li>
<li><p><code>-R chain rulenum</code>：Replace，替换指定链上的指定规则编号。</p>
</li>
<li><p><code>-F [chain]</code>：Flush，清空指定的链的所有规则，如果不指定链，默认清空所有链的所有规则。</p>
</li>
<li><p>```<br>-Z</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>  ：Zero，计数器置零。iptables的每条规则都有两个计数器：<br><br>  - 匹配到的报文的个数。<br>  - 匹配到的所有报文的大小之和。<br><br>这里的**chain**指的是以下几种链：PREROUTING，INPUT，FORWARD，OUTPUT， POSTROUTING<br><br>#### 3. 链管理的参数<br><br>- &#96;-N chain&#96; ：New,自定义一条新的规则链。<br><br>- &#96;-X [chain]&#96;：delete，删除自定义的空的规则链。如果不指定链，默认删除所有非内置链（所有自定义的链）。<br><br>-<br></code></pre></td></tr></table></figure>
<p>-P [chain] target</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>  ：Policy，设置指定链的默认策略（target），不写链的话默认指定表中所有的链。对filter表中的链而言，其默认策略（target）有：<br><br>  - &#96;ACCEPT&#96;：接受<br>  - &#96;DROP&#96;：丢弃<br>  - &#96;REJECT&#96;：拒绝<br><br>- &#96;-E old-chain new-chain&#96;：重命名自定义链。引用计数不为0的自定义链不能够被重命名，也不能被删除<br><br>### 规则定义（rule-specification）<br></code></pre></td></tr></table></figure>
<p>rule-specification = [matches…] [target]<br>match = -m matchname [per-match-options]<br>target = -j targetname [per-target-options]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>先说匹配条件（match），分为两种：<br><br>- 一种是基本匹配条件，无需加载模块，由iptables&#x2F;netfilter自行提供。CentOS6和7都是通过&#96;man iptables&#96;可以查看匹配条件使用说明。<br>- 扩展匹配条件：需要加载扩展模块（&#x2F;usr&#x2F;lib64&#x2F;xtables&#x2F;*.so） ，方可生效。CentOS6还是在&#96;man iptables&#96;里查看模块的匹配条件使用说明，CentOS7可以通过&#96;man iptables-extensions&#96;来查看。<br><br>处理动作(target)，target可以是&#96;ACCEPT&#96;、&#96;DROP&#96;、&#96;REJECT&#96;、&#96;RETURN&#96;等内置target，也可以是自定义的链。<br><br>#### 1. 匹配条件（match）<br><br>**基本匹配条件**<br><br>- &#96;[!] -s&#96;：source，源IP地址或范围。<br>- &#96;[!] -d&#96;：destination，目标IP地址或范围。<br>- &#96;[!] -p&#96;：protocol，指定协议。<br>- &#96;[!] -i name&#96;：in-interface， 报文流入的接口名字；只能应用于数据报文流入环节，只应用于INPUT、FORWARD、PREROUTING链。<br>- &#96;[!] -o name&#96;：out-interface，报文流出的接口名字；只能应用于数据报文流出的环节，只应用于FORWARD、OUTPUT、POSTROUTING链。<br><br>**扩展匹配条件**<br><br>(1)**隐式扩展**：<br><br>隐式扩展，在使用-p选项指明了特定的协议时，无需再用-m选项 指明扩展模块的扩展机制，不需要手动加载扩展模块。例如&#96;-t tcp&#96;、&#96;-t udp&#96;、&#96;-t icmp&#96;等等。<br><br>- tcp<br><br>  协议的扩展选项<br><br>  - &#96;[!] -sport PORT&#96;：匹配报文源端口,例如&#96;-sport 22&#96; 可为端口范围，例如&#96;20:23&#96;<br><br>  - &#96;[!] -dport PORT&#96;：匹配报文目标端口,例如&#96;-dport 22&#96;可为范围，例如&#96;22:23&#96;<br><br>  -<br></code></pre></td></tr></table></figure>
<p>  [!] -tcp-flag mask comp</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>    ：tcp标志位（flag），在mask列表中必须为1的标志位列表，无指定则必须为0。例子：<br><br>    - &#96;--tcp-flags SYN,ACK,FIN,RST SYN&#96;： 表示要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0。<br>    - &#96;--tcp-flags SYN,ACK,FIN,RST SYN,ACK&#96;<br>    - &#96;--tcp-flags ALL ALL&#96; 表示要检查的标志位为所有，所有的都要为1。<br>    - &#96;--tcp_flags ALL NONE&#96;表示要检查的标志位为所有，所有的都要为0。<br><br>  - &#96;[!] --syn&#96;：用于匹配第一次握手。相当于：&#96;--tcp-flags SYN,ACK,FIN,RST SYN&#96;<br><br>&gt; Wireshark抓到的&#96;TCP&#96;的flags：<br>&gt; [![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130150653.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15028056584740.jpg)<br><br>- udp<br><br>  协议的扩展选项：<br><br>  - &#96;[!] -sport&#96;：匹配报文源端口,可为端口范围<br>  - &#96;[!] -dport&#96;：匹配报文源端口,可为端口范围<br><br>&gt; Wireshark抓到的&#96;UDP&#96;的port：<br>&gt; [![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130150642.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15028066555495.jpg)<br><br>- icmp<br><br>  协议的扩展选项：<br><br>  - &#96;[!] --icmp-type type[&#x2F;code]&#96;<br><br>  -<br></code></pre></td></tr></table></figure>
<p>  type/code</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>    为：<br><br>    - &#96;8&#x2F;0&#96;：echo-request icmp请求<br>    - &#96;0&#x2F;0&#96;：echo-reply icmp应答<br><br>&gt; Wireshark抓到的&#96;icmp&#96;的request&#x2F;replay：<br>&gt; [![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130150711.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15028064785181.jpg)<br>&gt; [![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130150717.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15028065470973.jpg)<br>&gt; [![img](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ashjian&#x2F;picBed&#x2F;master&#x2F;20201130150729.jpg)](http:&#x2F;&#x2F;www.yulongjun.com&#x2F;images&#x2F;15028065777704.jpg)<br><br>(2)**显式扩展**：<br><br>必须使用-m选项指明要调用的扩展模块的扩展机制，要手动加载扩展模块：<br></code></pre></td></tr></table></figure>
<p>[-m matchname [per-match-options]]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- **multiport**扩展<br>- **iprange**扩展<br>- **string**扩展<br>- **time**扩展<br>- **connlimit**扩展<br>- **limit**扩展<br>- **state**扩展<br><br>#### 2. 处理动作<br></code></pre></td></tr></table></figure></li>
<li><p>j targetname [per-target-options]</p>
<pre><code></code></pre></li>
</ul>
<p>简单：</p>
<ul>
<li><code>ACCEPT</code></li>
<li><code>DROP</code></li>
</ul>
<p>扩展：</p>
<ul>
<li><code>REJECT</code>：<code>--reject-with:icmp-port-unreachable</code>默认动作选项</li>
<li><code>RETURN</code>：返回调用链</li>
<li><code>REDIRECT</code>：端口重定向</li>
<li><code>LOG</code>：记录日志，dmesg</li>
<li><code>MARK</code>：做防火墙标记</li>
<li><code>DNAT</code>：目标地址转换</li>
<li><code>SNAT</code>：源地址转换</li>
<li><code>MASQUERADE</code>：地址伪装</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>露西亚(深淵ノ紅)-荒魂神祭</title>
    <url>/%E9%9C%B2%E8%A5%BF%E4%BA%9A-%E6%B7%B1%E6%B7%B5%E3%83%8E%E7%B4%85-%E8%8D%92%E9%AD%82%E7%A5%9E%E7%A5%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/09/%E9%9C%B2%E8%A5%BF%E4%BA%9A%E6%B7%B1%E7%BA%A2%E8%8D%92%E9%AD%82%E7%A5%9E%E7%A5%AD.jpg" alt="露西亚深红荒魂神祭"></p>
<a id="more"></a> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/videoBed/09/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>


<p><img src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/09/%E9%9C%B2%E8%A5%BF%E4%BA%9A%E6%B7%B1%E7%BA%A2%E8%8D%92%E9%AD%82%E7%A5%9E%E7%A5%AD%E8%AE%BE%E5%AE%9A%E5%9B%BE01.jpg" alt="露西亚深红荒魂神祭"><br><img src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/09/%E9%9C%B2%E8%A5%BF%E4%BA%9A%E6%B7%B1%E7%BA%A2%E8%8D%92%E9%AD%82%E7%A5%9E%E7%A5%AD%E8%AE%BE%E5%AE%9A%E5%9B%BE02.jpg" alt="露西亚深红荒魂神祭"><br><img src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/09/%E9%9C%B2%E8%A5%BF%E4%BA%9A%E6%B7%B1%E7%BA%A2%E8%8D%92%E9%AD%82%E7%A5%9E%E7%A5%AD%E8%AE%BE%E5%AE%9A%E5%9B%BE03.jpg" alt="露西亚深红荒魂神祭"></p>
]]></content>
      <categories>
        <category>封面</category>
      </categories>
      <tags>
        <tag>封面</tag>
      </tags>
  </entry>
  <entry>
    <title>《只狼：影逝二度》原型浅考：神之篇</title>
    <url>/%E3%80%8A%E5%8F%AA%E7%8B%BC%EF%BC%9A%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6%E3%80%8B%E5%8E%9F%E5%9E%8B%E6%B5%85%E8%80%83%EF%BC%9A%E7%A5%9E%E4%B9%8B%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于个人收藏，转载：<a href="https://www.gcores.com/articles/109450" target="_blank" rel="noopener">https://www.gcores.com/articles/109450</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要对《只狼：影逝二度》（简称《只狼》）中可能采用的原型进行考证，以个人的观点解读《只狼》剧情世界观的创作动机和故事内核，不会过多对游戏内已提供的剧情细节推理分析。</p>
<p>游戏创作时往往会根据需要将多个原型叠加在一起，所以假定的取材原型一般不会和游戏中的形象完全对应，也不试图以原型为论据对游戏内的剧情内容下定论。</p>
<p>脱离游戏所提供信息的限制，在历史、神话、民俗中寻找原型难免会过度联想，本文尽可能采用多重对应的假定取材原型，保证一定说服力的同时，提高文章的营养和可读性。</p>
<p>本文中一些切入点（比如藤原秀乡的百足退治物语），来源于日本狼学家Harvey的<a href="http://souls-seed.blogspot.com/" target="_blank" rel="noopener">博客</a>，这位狼学家知识面广泛又有深度，同时对母语日语有外国人所不及的语感和理解，在此基础上本人进行了进一步的调查、考据联系和总结，尽力保持本文的原创性。文章中引用游戏内对话和物品描述的日文文本也来自于此狼学家的汇总。</p>
<p>日本神话传说版本繁多，同一个神明的名字也有多种读法和写法，文章中不会全部一一列举请见谅。</p>
<p>日语、历史、神话传说、民俗方面的知识水平有限，如果有错误的地方希望可以耐心指出。</p>
<h1 id="神之篇"><a href="#神之篇" class="headerlink" title="神之篇"></a>神之篇</h1><p>《只狼》的故事分为两条主线：<strong>苇名线</strong>和<strong>神明线</strong>。</p>
<p>苇名线讲了北方之雄苇名一心创建的苇名国即将灭亡之际，玩家控制的主角狼作为一个忍者保护主人御子九郎的故事。</p>
<p>神明线则揭示了御子不死力量来源于一条从西方漂泊流浪至此的神龙，以及因此导致苇名本地出现种种怪事，甚至影响国运。</p>
<p>此考察计划分为<strong>神之篇</strong>和<strong>国之篇</strong>上下两部分，分别考证以樱龙和苇名国为中心的两个故事线里引用了哪些原型，揭示出一条把所有原型联系在一起的重要线索，解读宫崎英高以及他的创作团队是如何巧妙利用国家和信仰两种形式编写一曲名为日本的历史二重奏。</p>
<p>那么，我们就从神明线最重要的存在<strong>樱龙</strong>说起吧。</p>
<h1 id="苇原中国平定-天津神和国津神的对抗"><a href="#苇原中国平定-天津神和国津神的对抗" class="headerlink" title="苇原中国平定 天津神和国津神的对抗"></a>苇原中国平定 天津神和国津神的对抗</h1><p>可考的日本神话主要来源于《古事记》<em>、</em>《日本书纪》以及各地的地方风土志，不同出处的同一人物事件可能会有差别，我们可以结合着看。因为本文不是日本神话的科普文，这里尽可能仅介绍与主题相关的神话传说。</p>
<p>在日本创世神话中，世界分为三部分，高天原<em>、</em>苇原中国以及根之国（有根之国与黄泉国为同一处的说法）。</p>
<p>高天原是以<strong>天照大御神</strong>为首的<strong>天津神</strong>（津表“之”意，也就是天之神）统治的天界，苇原中国指的是人间大地，统治人间的神被称为<strong>国津神</strong>（国之神），国津神的领导者是<strong>大国主神</strong>。</p>
<p>直到有一天，天照大御神让大国主神交出苇原中国的统治权，并表示这片神州大地属于天神子孙。大国主神自然不愿意，高天原先后派出了两位神明去苇原中国都失败了，第三次天照大御神问众天神应该派谁去，选出了勇猛的<strong>建御雷神</strong>。</p>
<p>建御雷神下凡后来到出云国的小滨，把十握剑插在海滩上，问大国主神对于苇原中国是我等天津神神圣不可分割领土的一部分有何看法。大国主神娴熟运用了领导踢皮球的功夫，回答道：“问我儿子<strong>八重言代主神（事代主神）</strong>吧，但是他现在出门不在家。”</p>
<p>八重言代神被叫回来后，不仅同意把苇原中国还给天神子孙，还弄沉了自己的船，向下拍手隐没于神篱之中。八重言代神是渔业之神，可以想象沉船的含义，后人对向下拍手解读有逆天拍手咒愿之意，就此隐去可能暗示八重言代神的死亡和失去权力。</p>
<p>建御雷神继续问大国主神是否还有其他儿子不同意，此时大国主神另外一个儿子<strong>建御名方神</strong>举着石头过来，质问是谁来我国窃窃私语，顺势抓起建御雷神的手臂。<strong>建御雷神的手变得像剑一样锋利，反抓建御名方神的手臂像芦苇一样扯断。</strong>二神抓手腕摔跤也被认为是日本国粹相扑的起源。</p>
<p><a href="https://image.gcores.com/2b79665b-6b89-4376-8086-c6c9c84589e7.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2b79665b-6b89-4376-8086-c6c9c84589e7.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="天津神暴力执法场景还原"></a></p>
<p>天津神暴力执法场景还原</p>
<p>建御名方神感觉打不过决定跑路，被建御雷神一路从日本西边的出云追到了东边的科野国洲羽海，也就是现在的长野县诹访湖一带。建御名方神感觉自己命数已尽，求饶到：<strong>“不要杀我，我发誓再也不会离开此地，苇原中国就献给天神子孙吧。”</strong></p>
<p>神话时代的科野国在令制国划分中属于东山道的信浓国，过去很长一段时间日本的中心都在西侧，所以建御名方神可以被看作是流放至东了。</p>
<p>还有一个有趣的对照，建御名方神的神格之一是<strong>风神</strong>，正好对应樱龙战斗中挥动七支刀的空气波。而建御雷神是<strong>雷神</strong>，樱龙最后是被雷击制服的。</p>
<p><a href="https://image.gcores.com/f2f97f9e-ac7e-4375-b748-daea21964407.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f2f97f9e-ac7e-4375-b748-daea21964407.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="建御名方神的流亡方向"></a></p>
<p>建御名方神的流亡方向</p>
<p>大国主神看到自己两个儿子的处境，于是交出了苇原中国的统治权，并向天神提出了一个愿望，请为自己修一个和天神子孙同等待遇的宏伟宫殿，便隐去了。此宫殿即是<strong>出云大社</strong>，日本最古老的神社之一。</p>
<p><a href="https://image.gcores.com/a7310fcc-2564-42ec-beba-39676ef1b8f7.JPG?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a7310fcc-2564-42ec-beba-39676ef1b8f7.JPG?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="出云大社现在的拜殿（1959）"></a></p>
<p>出云大社现在的拜殿（1959）</p>
<p><a href="https://image.gcores.com/eac35060-7c74-4826-8725-6b90bb7b637e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/eac35060-7c74-4826-8725-6b90bb7b637e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="出云大社现在的本殿（1744）"></a></p>
<p>出云大社现在的本殿（1744）</p>
<p>根据直径超过一米的残留巨柱还原制作的模型，可以感受到古代出云大社的宏伟，不知道《只狼》未来的DLC或者续作会不会做一个类似场景，然后在阶梯上放几十个银武士。</p>
<p><a href="https://image.gcores.com/8e4599ed-b77f-4e00-bae1-4812b6376766.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8e4599ed-b77f-4e00-bae1-4812b6376766.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="古代出云大社本殿模型，实际高达48米"></a></p>
<p>古代出云大社本殿模型，实际高达48米</p>
<p>这次天下易主的神战被称为<strong>苇原中国平定</strong>，又叫让国神话。平定以后天孙降临，从此往后日本这片土地理所应当属于天神子孙也就是天皇为首的大和朝廷，从官方的角度编写这些神话也是用来证明大和朝廷统治权的正当性。出云神话的主神大国主神在《古事记》和《日本书纪》中也被描述成了天照大御神弟弟须佐之男命的后裔。</p>
<p><strong>最后这位反抗高天原的国津神建御名方神，断手后从西向东一路流亡，并被囚禁在一个叫诹访的地方，永远无法离开。</strong>虽然游戏中没有表示为什么樱龙会流落到苇名之地，我们从日本神话传说中似乎可以找到类似的答案。</p>
<p>以上的让国神话采用的是《古事记》版本，而《日本书纪》让国过程中并没有提及建御名方神的名字，抵抗天神的是另外一位神明，猛如建御雷神都拿他没办法，这里暂时卖个关子，神之篇的结尾会聊到他。</p>
<p><a href="https://image.gcores.com/97267199-a89c-47b9-a4fc-4b08b116e642.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/97267199-a89c-47b9-a4fc-4b08b116e642.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Amatsu-Mikaboshi"></a></p>
<p>Amatsu-Mikaboshi</p>
<p>《古事记》中对建御名方神的描述只有这么多，然而这位断手流亡神明的故事并没有结束，我们接着说。</p>
<h1 id="明神入诹"><a href="#明神入诹" class="headerlink" title="明神入诹"></a>明神入诹</h1><p>在诹访当地的神话传说中，建御名方神作为外来神明，击败了当地大大小小的本地神，其中最著名的是泄矢神（洩矢神）。《诹访信重解状》是记录入诹神话最早的文献，根据记载建御名方神战胜了守屋大臣（泄矢神的别称），获得了诹访的统治权。《诹方大明神画词》中，双方战斗时，诹访明神手持<strong>藤条</strong>，而泄矢神手持<strong>铁轮</strong>。</p>
<p>还有记载称二者大战于<strong>天龙川</strong>，天龙川是诹访湖的下游流出河，两岸的藤岛神社和泄矢神社被认为是双方的阵地。《只狼》中龙泉川的名字可能来源于天龙川。</p>
<p><a href="https://image.gcores.com/233c82a9-3e27-4d4f-919c-382ff495d6f5.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/233c82a9-3e27-4d4f-919c-382ff495d6f5.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="藤岛神社和泄矢神社，中间的河流为天龙川"></a></p>
<p>藤岛神社和泄矢神社，中间的河流为天龙川</p>
<p>击败土地神的建御名方神从此被称为<strong>诹访大明神</strong>。和让国神话一样，入诹神话也是基于古代氏族争斗产生的。守矢氏在外来氏族进入诹访之前掌管当地，建立了以<strong>ミシャグジ神</strong>为中心的祭政体制，外来的出云氏族击败守矢氏夺取祭政权，也就是后来者居上的诹访氏。</p>
<p>ミシャグジ信仰广泛存在于东日本，早在绳文时代就出现，与大和民族相比更早的先民所信奉的神，<strong>普遍被认为是依附在树木和石头上像精灵一样的存在。</strong>经过反复传播，不仅形象不定，读音也各式各样，标为汉字后有200个以上版本的名字，这也很符合古老民俗的特征，信仰传说全靠口口相传，因此衍生出无数个版本。</p>
<p>守矢氏失去统治权后，转而辅佐诹访氏，负责新祭政体系的神长等职务，ミシャグジ信仰虽然不再明面提及，依然隐藏在流传至今的诹访传统仪式中。</p>
<p>守矢氏的神长会使用金银花等药草以及<strong>鹿</strong>、<strong>猿</strong>、<strong>蛇</strong>、<strong>香灰</strong>，来制作一种名为“<strong>诹访药</strong>”的万能秘药，此药现已失传。《只狼》中除了不确定是否有金银花以外，鹿、猿、蛇、香灰都有所表现。</p>
<p><a href="https://image.gcores.com/53f89087-2abb-4697-a261-e1bcb43e5bb4.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/53f89087-2abb-4697-a261-e1bcb43e5bb4.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城中随处可见的鹿角"></a></p>
<p>苇名城中随处可见的鹿角</p>
<p>拥有ミシャグジ信仰的守矢氏神长制作的诹访秘药对应游戏中出现的<strong>丸药</strong>和<strong>黄金大力丸</strong>：</p>
<blockquote>
<p>丸薬 HPをゆっくりと回復させる丸薬 <strong>この地に古くより伝わる秘薬</strong> いにしえの戦でも使われた記録があり 葦名の不倒を世に知らしめたという 丸薬を入れた印籠は、 戦勝の御守り代わりでもある</p>
</blockquote>
<blockquote>
<p>神食み HPを完全に回復させる、いにしえの<strong>秘薬</strong> 全ての状態異常も、併せて回復する 葦名のひと際古い土地に生える<strong>草木</strong>には、 <strong>名も無き小さな神々</strong>が寄っていたという これは、そうした草木を練り上げ作られる 神々を食み、ありがたく戴く秘薬である だが、神なる竜が根付いたのちは、 そうした小さな神々は、姿を潜めてしまった…</p>
</blockquote>
<h1 id="诹访的龙蛇神"><a href="#诹访的龙蛇神" class="headerlink" title="诹访的龙蛇神"></a>诹访的龙蛇神</h1><p>日本在受到中国影响之前就有古老的蛇神信仰，ミシャグジ神也有蛇神的形象，在诹访地区通常用<strong>ソソウ神</strong>来称呼，这两个神是不是同一神在经过复杂的民俗信仰演变后，目前也没有统一的说法。蛇神信仰在《只狼》中具像化成了山谷里的大蛇。</p>
<p>龙的形象从中国传入日本后，当时的天皇考虑到保持自己的独立性，继续用太阳作为皇族的象征，没有模仿中国自称“龙之天子”。龙的形象在日本更接近掌管雨水的四海龙王，并与原有的蛇神信仰混杂在一起形成了龙蛇神信仰，龙和蛇也就分得不太清楚了。</p>
<p>诹访大明神拥有<strong>龙蛇神</strong>的神格，在当地民间传说中，诹访大明神常以龙蛇神的形象出现，其中有一个众神开会的故事，可能与《只狼》的设定有关。</p>
<p>日本传统的十月被称为“<strong>神无月</strong>”，因为全国各地的八百万神明都出差去出云大社开会了，出云本地则称十月为“<strong>神在月（或神有月）</strong>”。诹访大明神作为大国主神的儿子，也化作巨龙来开会，众神们问诹访大明神为什么在出云大社只能看到你的头啊，身体和尾巴在哪里，其实诹访大明神只把头伸到了出云，龙尾盘在诹访湖的一颗大树上，此树被称为“<strong>尾挂松</strong>”。尾巴留在家里只伸出头是为了不打破前面让国神话中建御名方神对建御雷神许下的神誓吧。<strong>樱龙的形象可能来源于诹访大明神把尾巴盘在尾挂松上的设定。</strong></p>
<p><a href="https://image.gcores.com/64424bc4-8e47-4723-a3a1-1ec39e552591.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/64424bc4-8e47-4723-a3a1-1ec39e552591.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="尾挂松根部"></a></p>
<p>尾挂松根部</p>
<p>尾挂松是诹访湖边的一处景点，据说此树有300余年的树龄，现已枯死白化，为了确保安全只保留了根部。从留下的纪念照片中我们可以看到没被砍伐之前尾挂松的样子。</p>
<p><a href="https://image.gcores.com/68272e5e-3258-4c4f-afb3-cc349897864b.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/68272e5e-3258-4c4f-afb3-cc349897864b.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="尾挂松遗照"></a></p>
<p>尾挂松遗照</p>
<p>也许是因为出云神话远比大和神话古老，普遍存在蛇神信仰，并不只有建御名方神是龙蛇神。日本神道教中，神的灵魂呈现出荒魂与和魂两个侧面，分别体现神强硬的一面与和善的一面。建御名方神其父大国主神的和魂是<strong>大物主神</strong>，被供奉在大神神社，其背后的神体山叫三轮山，大物主神也被成为三轮明神。大物主神的神格之一是蛇神，可以看作<strong>大国主神同样拥有蛇神的属性</strong>。本文中有时说蛇神，有时说龙蛇神，当只提及蛇神时，强调其信仰相比混杂后的龙蛇神信仰更古老一些。</p>
<h1 id="神社中不一定会饲养的神使"><a href="#神社中不一定会饲养的神使" class="headerlink" title="神社中不一定会饲养的神使"></a>神社中不一定会饲养的神使</h1><p>一些神社用动物代表神的使者，称其“<strong>神使</strong>”。比如伊势神宫（天照大御神）的神使是鸡。典故来源于为了引出躲藏在天岩户里不出来的天照大御神，让鸡放在木架子上面鸣叫，这也是鸟居的起源说法之一。</p>
<p><a href="https://image.gcores.com/e55cef5d-5369-4fd5-8860-a8d17ef4ee3b.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e55cef5d-5369-4fd5-8860-a8d17ef4ee3b.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="当神使怎么也得长这么大吧"></a></p>
<p>当神使怎么也得长这么大吧</p>
<p>诹访大社的神使是鹤，然而泛指诹访神社的神使却是<strong>白蛇</strong>，出云大社（大国主神）的神使是<strong>海蛇</strong>，大神神社（大物主神）的神使也是<strong>蛇</strong>，不是蛇都不好意思说自己是出云出身。</p>
<p>诹访大社有一项传统祭祀活动叫做“<strong>御头祭</strong>”，祭祀时为神献上鹿头，保佑狩猎顺利，诹访大明神也是当地的狩猎之神。根据史料记载，过去的御头祭最多要为神献上75个鹿头，其中必须要有一只裂耳鹿。进入文明社会后，现在只使用鹿头标本进行祭事了。</p>
<p><a href="https://image.gcores.com/3d8bbdf6-5655-4362-b8da-2f30b1e051e5.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3d8bbdf6-5655-4362-b8da-2f30b1e051e5.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="御头祭"></a></p>
<p>御头祭</p>
<p>说起来有点巧，春日大社和鹿岛神宫的神使都是鹿，这两个神社供奉的主神正是<strong>建御雷神</strong>，建御名方神的死对头。我们常说去奈良看鹿，去的就是奈良公园和里面的春日大社。</p>
<p><a href="https://image.gcores.com/1d3f4ac0-51c0-4974-8ada-df0ffe072c66.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1d3f4ac0-51c0-4974-8ada-df0ffe072c66.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="努力一辈子不如投个好胎"></a></p>
<p>努力一辈子不如投个好胎</p>
<p><a href="https://image.gcores.com/43634511-afab-40f9-8795-2a365752b296.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/43634511-afab-40f9-8795-2a365752b296.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="哪来的？有奈良户口吗？"></a></p>
<p>哪来的？有奈良户口吗？</p>
<h1 id="与众不同的诹访大社"><a href="#与众不同的诹访大社" class="headerlink" title="与众不同的诹访大社"></a>与众不同的诹访大社</h1><p>明神入诹后自然就有属于自己的神社<strong>诹访大社</strong>。诹访大社是日本全国上万个诹访神社的总本社，信浓国一之宫，由长野县诹访湖周围两社四宫共计四个神社组成。两社分别是上社和下社，二者之间没有任何从属关系，相当于不同老板开的两家同名企业，<strong>上和下代表神社分别位于诹访湖水域的上游和下游。</strong>上社一直属于诹访氏，而下社早期属于金刺氏，室町时代因为和诹访氏争夺领导权被赶出诹访，换成了武居氏。</p>
<p><a href="https://image.gcores.com/fc0697ca-f48e-4cf2-a738-117f489e165c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fc0697ca-f48e-4cf2-a738-117f489e165c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="诹访大社各神社位置"></a></p>
<p>诹访大社各神社位置</p>
<p>诹访大社下社分为<strong>春宫</strong>和<strong>秋宫</strong>，两宫是平行关系，位于诹访湖的北岸。下社除了和上社一样供奉建御名方神和八坂刀卖神夫妻二神以外，还供奉让国神话里弄沉船的兄神八重事代主神。</p>
<p><a href="https://image.gcores.com/b6f9e574-1c68-4d9e-8cc7-f4cbc212e034.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b6f9e574-1c68-4d9e-8cc7-f4cbc212e034.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="下社秋宫神乐殿"></a></p>
<p>下社秋宫神乐殿</p>
<p><strong>作为诹访大社的特色之一，春宫和秋宫的神乐殿前面都挂着形状像大麻花一样数吨重的巨型注连绳。</strong>出云大社也有这种巨型注连绳（参见文章前面出云大社拜殿的图片），民间有种颇为阴谋论的戏说，认为悬挂巨型注连绳是为了把大国主神和建御名方神父子封印在神社之中。《只狼》中白蛇神社也挂着这种巨型注连绳，因为年久失修已经破烂不堪了。白蛇神社位于源之水的下游也正好对应了诹访大社下社的概念。</p>
<p><a href="https://image.gcores.com/c0b0e600-3e20-41b0-b3fd-d359dbe7b983.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c0b0e600-3e20-41b0-b3fd-d359dbe7b983.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="白蛇神社悬挂的注连绳"></a></p>
<p>白蛇神社悬挂的注连绳</p>
<p>据说站在注连绳下面往上丢硬币，夹在注连绳里会带来好运，于是人们纷纷丢硬币上去，后来这种行为被认为对神不敬明令禁止，虽然没有向飞机涡轮里丢硬币那么危险，夹了太多硬币可能会导致注连绳太重掉下来。《只狼》中负责传送源之宫的稻草人手臂造型也酷似这种巨型注连绳的末端，狼像硬币一样被夹到了源之宫。</p>
<p><a href="https://image.gcores.com/d30dfc09-9d8b-45c1-b74c-c7fa08050e1c.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d30dfc09-9d8b-45c1-b74c-c7fa08050e1c.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫的稻草人"></a></p>
<p>源之宫的稻草人</p>
<p><strong>诹访大社第二个特点，无论上下社四宫，每宫都立着四根高大的御柱。</strong>御柱看上去就是光秃秃的木头柱子，每根重10吨左右。从最少10公里以外靠人力运到神社内，这项数年举行一次的搬运活动也是诹访大社最著名的行事“<strong>御柱祭</strong>”。御柱祭经常会出人命，诹访人民依然乐此不疲地搬柱子上下山过河。</p>
<p><a href="https://image.gcores.com/e409d6b3-c1f5-4fde-b3ac-733629e1016f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e409d6b3-c1f5-4fde-b3ac-733629e1016f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="上社本宫的御柱之一"></a></p>
<p>上社本宫的御柱之一</p>
<p>樱龙所在的岩洞周围也立着四根“电线杆”，与诹访大社的御柱略有不同的是，柱子之间距离比较近，上面挂了注连绳，比御柱要细小很多。</p>
<p><a href="https://image.gcores.com/ffcd25a7-72ef-4d2f-b926-eef41d307b9c.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ffcd25a7-72ef-4d2f-b926-eef41d307b9c.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="踩在鸟居上观察可以看出是四根柱子"></a></p>
<p>踩在鸟居上观察可以看出是四根柱子</p>
<p>诹访上社分为<strong>本宫</strong>和<strong>前宫</strong>，不同于下社两宫同等地位，前宫曾是入诹之前守矢氏祭政体系的中心，后来成为诹访氏<strong>大祝</strong>的居住地，被尊称为“<strong>神殿</strong>”，神殿的周围叫做“<strong>神原</strong>”。</p>
<p>在介绍大祝这个重要的存在之前，我们先来看看诹访大社另外一个与大部分神社不同之处，<strong>诹访大社没有常规意义上的本殿</strong>。</p>
<p>作为一个神社的标准配置，入口一定要有鸟居。神社境内属于<strong>神域</strong>，穿过鸟居等于从人界来到神的领域，所以《只狼》在樱龙战之前的鬼佛叫做“神域”，代表我们踏入了神社。樱龙神社比较特殊，没有任何建筑，更接近崇拜自然的古神道。前面那个吃人的宫殿在鸟居之外，因此不属于此神社的一部分。</p>
<p><a href="https://image.gcores.com/bad8d1f3-8c14-4735-a950-4b094826d3f9.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/bad8d1f3-8c14-4735-a950-4b094826d3f9.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="吃人宫殿在鸟居之外"></a></p>
<p>吃人宫殿在鸟居之外</p>
<p>上图中用注连绳连接在一起的两块石头，造型有些像日本各地的“<strong>夫妇岩</strong>”，也是一种自然崇拜。</p>
<p><a href="https://image.gcores.com/89392a51-1130-4d6e-9f75-1070c4292c78.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/89392a51-1130-4d6e-9f75-1070c4292c78.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="夫妇岩"></a></p>
<p>夫妇岩</p>
<p>神社境内最重要的两个建筑是<strong>本殿</strong>和<strong>拜殿</strong>。拜殿是神社最显眼的地方，供人参拜以及举行神事，一般都是神社中修得最漂亮最显眼的建筑。本殿是神明的居所，供奉御神体比如神镜或者神岩，是不允许普通人进去的，所以修得相对小一些，隐藏在拜殿后面。</p>
<p><a href="https://image.gcores.com/249bec56-b352-4672-95b1-9eb52f4b7da4.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/249bec56-b352-4672-95b1-9eb52f4b7da4.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="诹访大社下社秋宫拜殿"></a></p>
<p>诹访大社下社秋宫拜殿</p>
<p>本殿又被称为神殿，结合诹访大社前宫大祝居所的设定应该就懂了，<strong>诹访大社的御神体是诹访氏大祝本人</strong>，这种神以人的姿态现世的形式被称为<strong>现人神，</strong>也叫现御神和现世神。</p>
<h1 id="现人神-大祝"><a href="#现人神-大祝" class="headerlink" title="现人神 大祝"></a>现人神 大祝</h1><blockquote>
<p>朕与尔等国民之间的纽带，始终由互相之信赖和敬爱所结成，而非单依神话和传说而生；也不是基于“认为天皇是现世神、同时日本国民比其他民族更加优越，从而延及支配世界的命运”这种架空的概念。 — 《关于新日本建设的诏书》节选</p>
</blockquote>
<p>我们更熟悉的现人神是日本天皇，天皇作为天孙，同时兼有人和神的双重身份。在二战结束天皇发布《人间宣言》否认自己是神之前，日本民众真的一直认为天皇是神。</p>
<p>根据《诹方大明神画词》中的记载，<strong>初代大祝是一名叫作有员的八岁男童，是桓武天皇的皇子</strong>，但是从天皇的族谱记载里并没有发现有员的名字，他是否是皇子一直处于争议状态。</p>
<p>关于大祝的传承方式，有说法认为早期的大祝采用<strong>转生制</strong>延续，从诹访大社上社周边的氏族中选取下一位大祝。后来学习下社金刺氏改为了<strong>世袭制</strong>。可以看出转生制时期的新大祝上任时很可能都是男童，到一定年龄后让位给下一任大祝，而到了世袭制后子承父业，大祝的年龄也就不固定了。</p>
<p>新大祝要在诹访大社上社前宫的<strong>内御玉殿</strong>中举办即位仪式，殿内摆放着诹访大明神的宝器。仪式必须由神长守矢氏执行，所以很难判断诹访氏和守矢氏双方谁真正控制了诹访的祭祀权。</p>
<p>如果大祝就任期间死亡，遗体要放置在内御玉殿前，下一任大祝在死去大祝的遗体前继承其位，历代大祝去世后都会被葬在同一颗樱花树下。</p>
<p><a href="https://image.gcores.com/c18f7eb5-4f55-4dd6-bffe-4e902533b994.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c18f7eb5-4f55-4dd6-bffe-4e902533b994.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="葬在樱花树下的大祝们"></a></p>
<p>葬在樱花树下的大祝们</p>
<p>《只狼》中没有解释龙胤的御子是如何传承的，如果参考诹访大社的大祝体系，有可能是上一任御子丈去世时选出了年幼的九郎继承，不知道九郎年幼不懂事的时候是否见过丈。</p>
<p><strong>大祝就任期间，有一条必须遵守的神誓：绝对不可以离开诹访，否则会受到神罚。</strong>《诹方大明神画词》中记载过因此被神罚的事件。</p>
<p>平安时代后期的<strong>前九年之役</strong>，诹访氏协助源赖义征战奥州，当时的大祝<strong>为信</strong>因为不能离开诹访，让自己的儿子<strong>为仲</strong>作为总大将，由守矢氏神长陪同出战，打了胜仗回来。</p>
<p>过了二十余年后又发生了<strong>后三年之役</strong>，为仲此时已经接替为信成为大祝。他和源赖义的长男源义家关系很好，源义家奥州苦战需要援助，于是大祝为仲不顾父亲和族人反对，执意要亲自出战奥州，又打了胜仗。源义家的弟弟源义光设庆功酒席招待为仲，没想到喝着喝着双方部下产生摩擦，互殴闹出了人命，因为惧怕得罪源氏，为仲就自杀了。</p>
<p>为信听说自己的儿子死了，心想这一定是神罚，拒绝把大祝继续传给孙子，让自己的二儿子<strong>为继</strong>接替大祝之位，为继仅过三天就暴毙，三儿子<strong>为次</strong>当上大祝过了七天也挂了，到了四儿子<strong>为贞</strong>才成功把大祝延续下去，不知道当时为贞心理压力有多大。</p>
<p>就像尾挂松的传说一样，大祝的这条神誓可能也是传承于上面提到的《古事记》让国神话中建御名方神对建御雷神许下永世不离开诹访的誓言。<strong>《只狼》的故事开始和结束，九郎前后两次试图逃离苇名，阻止他的正是掌握雷电之力的苇名弦一郎。在四个结局中九郎以人的姿态离开了苇名只有回归凡人结局，通过狼的牺牲斩断龙胤，九郎失去了御子的身份。</strong></p>
<p>《只狼》中的御子和诹访大社的大祝还有一些微妙的不同，大祝代表的是诹访大明神本身，龙胤的御子没有明确表示与樱龙是什么具体关系，从龙之返乡结局来看，御子似乎也代表了樱龙本体。</p>
<h1 id="御子们的原型"><a href="#御子们的原型" class="headerlink" title="御子们的原型"></a>御子们的原型</h1><p>《只狼》2018年E3首次公开详细信息的时候，在官网介绍中使用了皇子一词，后来成品中刻意改为御子，个人认为是有意避开天皇血脉的设定，也许早期的故事主线涉及到大和朝廷，成品版剧情去掉了朝廷的部分就改成了御子。</p>
<p>天皇是现人神，天皇的皇子是神的孩子。御子一词在《古事记》和一些早期的记载中专指皇子，现在泛指各种神的<strong>御子神</strong>，所以可以把皇子看作是御子的子集，神社中常见的御子社，就是为主祭神的御子神设置的摄末社。</p>
<p><a href="https://image.gcores.com/6ff7d463-4f29-471b-92f3-f0d60009ec31.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6ff7d463-4f29-471b-92f3-f0d60009ec31.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="诹访大社上社前宫 若御子社"></a></p>
<p>诹访大社上社前宫 若御子社</p>
<p>诹访大社上社前宫的<strong>若御子社</strong>，一共祭祀建御名方神的十二位御子神。</p>
<p><a href="https://image.gcores.com/68c77ab8-e030-4dc5-a271-3efe4e437e45.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/68c77ab8-e030-4dc5-a271-3efe4e437e45.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="若御子社的介绍"></a></p>
<p>若御子社的介绍</p>
<p>苇名城天守阁御子居室里，摆放了一个源之宫风格造型的末社。源之宫中心建筑里有五个同款末社和一个空位，可能天守阁这个就是被搬走的末社。</p>
<p><a href="https://image.gcores.com/56c628b1-08ce-4843-880a-c3be5a71223e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/56c628b1-08ce-4843-880a-c3be5a71223e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="御子居室内的末社被武士盔甲挡住了"></a></p>
<p>御子居室内的末社被武士盔甲挡住了</p>
<p><a href="https://image.gcores.com/13e607ad-f0b5-4745-bcd0-11f37bd75fda.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/13e607ad-f0b5-4745-bcd0-11f37bd75fda.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫中缺少了一个末社"></a></p>
<p>源之宫中缺少了一个末社</p>
<p>现实中天守阁作为标志建筑大部分没有居住功能，《只狼》中把天守阁最高处设置成御子居室，也许是暗示曾经的御子在苇名城有极高的地位，到了九郎担任御子的时代信仰衰败，于是被送到了平田氏作养子。</p>
<p>游戏中出现的几位御子，我们分别说说他们的原型。</p>
<p>九郎先鸽掉，放在国之篇里讲。他的原型与苇名线剧情的关系更大，而且个人认为从九郎的原型中可以解读出一些创作早期与天皇相关设定的痕迹。</p>
<h2 id="丈"><a href="#丈" class="headerlink" title="丈"></a>丈</h2><p>丈的原型对于了解日本神话传说的朋友应该比较熟悉，那就是勇猛的悲剧英雄<strong>日本武尊</strong>。</p>
<p>丈（タケル）的读音对应日本武尊（ヤマトタケル），如果把日本武尊名字从中间拆开，可以读成“大和 丈”。日本武尊是景行天皇的皇子，仲哀天皇的父亲，但是英年早逝没能成为天皇，本名叫做小碓命（《日本书纪》是小碓尊）。《古事记》中日本武尊对应的名字是倭建命，为了保持统一，文中都用日本武尊。</p>
<p><a href="https://image.gcores.com/55d5f811-18c3-4ffd-8f45-95278a26eff1.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/55d5f811-18c3-4ffd-8f45-95278a26eff1.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="日本武尊的漫画"></a></p>
<p>日本武尊的漫画</p>
<p>日本武尊是个能力非常强的狠人，讲三个他西征的故事就能体会到有多狠。</p>
<p>他有个同母的哥哥叫大碓命，大碓命非常不厚道，偷偷把本来准备给父皇的妃子调包自己独占，天皇也没好说什么。有一天景行天皇让小碓命去看看他哥哥为什么不出来吃饭（前后这两件事没有明说是否有关系），小碓命就去照办了，过了好几天大碓命也没出现，天皇问小碓命什么情况，<strong>小碓命表示已经帮父亲教育了哥哥，趁大碓命上厕所的时候折断其手脚，把尸首包好处理掉了</strong>，吓得景行天皇安排16岁的小碓命去西征熊袭。</p>
<p>小碓命到了西边的九州后，<strong>熊袭建</strong>兄弟在办宴席，小碓命换<strong>女装</strong>混了进去，先砍死了熊袭建大哥，二弟眼看自己也要死，感慨西国没有人比我熊袭建兄弟猛，没想到大倭国有更猛的人啊，把自己的称号タケル给了小碓命（クマソタケル到ヤマトタケル），说完也被砍死了，小碓命因此得到了日本武尊的称号。能顺利女装刺杀，要么日本武尊是个美男子，要么熊袭建兄弟口味比较重。</p>
<p><a href="https://image.gcores.com/42075fc1-40e3-42bf-aa2a-18b509793caa.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/42075fc1-40e3-42bf-aa2a-18b509793caa.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="建部大社日本武尊物语插图"></a></p>
<p>建部大社日本武尊物语插图</p>
<p>接着去出云地区讨伐<strong>出云建</strong>，日本武尊先和出云建搞好关系，自己准备了一把劣质的刀，某天找到好机会邀请出云建切磋武艺，要求两人先交换武器，出云建换了武器后发现刀拔不出来，于是被砍死了，然后日本武尊还唱歌嘲讽出云建的愚蠢。</p>
<p>西征归来后，景行天皇让他立即东征，武尊心里清楚父亲什么意思，又伤心离开故乡。向西一路战到伊吹山，遇到当地的白野猪山神（《日本书纪》里是白蛇山神）因为轻敌被冰雨袭击生病，<strong>喝了当地的泉水</strong>后返程，身体越来越差最后客死他乡，英年早逝。</p>
<p><a href="https://image.gcores.com/5b41ce7a-d0c1-48b6-9842-a3cbd8a006cd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5b41ce7a-d0c1-48b6-9842-a3cbd8a006cd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="建部大社日本武尊物语插图"></a></p>
<p>建部大社日本武尊物语插图</p>
<p>《只狼》中关于丈的信息少的可怜，无法得知他的具体形象和性格，背井离乡、英年早逝和愿望始终没有实现的悲剧命运却和日本武尊非常相似。苇名城中种下从故乡带来的常樱树也对应了日本武尊在东征途中因思念故乡种下日本五大樱之一<strong>神代樱</strong>的传说。</p>
<p>日本武尊和诹访大明神之间还有一个颇为有趣的民间故事。日本武尊征战途中，在森林里遇到一个居住于此的老人，借宿的夜晚听到外面有声响，原来是老人拉弓的声音，日本武尊拿来此弓试了一下，发现比自己的弓厉害三倍，向老人借来神弓制服了当地的恶贼。回来后日本武尊请求把弓让给他，老人让他跟着进入深山，山中有一个景色优美的大湖，此时老人的身影消失，湖中出现一条<strong>双头大蛇</strong>，不知哪里传来声音让日本武尊用带子绑在大蛇身上。照做后大蛇拉紧了带子变成能将湖面分割的巨大弓形，原来大蛇就是神弓的本体，空中发出声音的正是诹访大明神。</p>
<h2 id="变若御子"><a href="#变若御子" class="headerlink" title="变若御子"></a>变若御子</h2><p>第三位则是仙峰寺的变若御子，如果说九郎和丈的身世成谜，无法判断是否有皇子背景，那变若御子就和天皇几乎没什么关系了。个人推测《只狼》在初次公布皇子这个词时，变若御子还没被创作出来。</p>
<p>变若御子的原型，来自于另外一位日本历史名人<strong>藤原秀乡</strong>，以及他的百足退治传说。</p>
<p>藤原秀乡是平安中期著名的武将，相传他来到濑田的唐桥上时，遇到了一条拦路的大蛇，其他路人都不敢接近，狠人藤原秀乡二话不说跨过大蛇继续赶路。晚上一位漂亮女子找到藤原秀乡，表示自己是附近琵琶湖里的龙女，白天桥上大蛇由她所变，估计是想找个胆大的勇士，这里也能看出前文提到的日本龙蛇混杂的现象。她恳求藤原秀乡帮龙神族讨伐三上山的大蜈蚣。</p>
<p><a href="https://image.gcores.com/439b149f-cce9-4097-802e-3c18b050c0ff.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/439b149f-cce9-4097-802e-3c18b050c0ff.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="藤原秀乡与龙女"></a></p>
<p>藤原秀乡与龙女</p>
<p>藤原秀乡废了九牛二虎之力击败了大蜈蚣，回到龙宫领赏，在众多的宝贝里有两样东西和《只狼》有关，一件是<strong>永远用不尽的米桶</strong>，对应变若御子源源不断给我们米吃，一件是宝刀<strong>蜈蚣切丸</strong>，对应红色不死斩，实际游戏中不死斩除了剧情需要，主要就是切切蜈蚣。</p>
<p><a href="https://image.gcores.com/724643c8-1256-4d4c-87fa-ebc2b48f30d7.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/724643c8-1256-4d4c-87fa-ebc2b48f30d7.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="俵藤太秀乡绘卷"></a></p>
<p>俵藤太秀乡绘卷</p>
<p><a href="https://image.gcores.com/616cffc2-336a-484c-9486-cdc889646f31.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/616cffc2-336a-484c-9486-cdc889646f31.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="蜈蚣切丸后世仿品"></a></p>
<p>蜈蚣切丸后世仿品</p>
<p>赏品里还有一个宝物引起我的注意，是件叫做“<strong>避来矢</strong>”的铠甲，穿上后可以闪避一切射过来的箭矢。这个设定感觉很适合做到游戏里面，比如技能或者状态道具，也许《只狼》的DLC会有类似的东西也说不定。（每个过王城双弓的不死人都想要这样的装备）</p>
<p>顺便说说另外一把黑色不死斩。黑色不死斩除了显眼的莲花装饰以外，仔细观察可以发现它是一把双刃刀。双刃造型在日语中叫做<strong>两刃造</strong>，是极其罕见的日本刀款式，大部分都是短刀，两刃造的刀更适合刺击。</p>
<p><a href="https://image.gcores.com/3b19808d-c7a6-4095-ab7e-4e2a748eb4d5.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3b19808d-c7a6-4095-ab7e-4e2a748eb4d5.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="通过拆包提取的黑色不死斩贴图"></a></p>
<p>通过拆包提取的黑色不死斩贴图</p>
<p>历史上有一把著名的双刃太刀叫<strong>小乌丸</strong>，小乌丸与黑色不死斩的区别在于它是<strong>锋两刃造</strong>，上侧只有前半段有刀刃。平安时期，平贞盛讨伐造反的平将门后获得天皇赏赐的小乌丸，这把宝刀成为了平家的传家宝。</p>
<p><a href="https://image.gcores.com/0b1d6012-83ba-4ba9-91aa-cc05b64ac7a6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0b1d6012-83ba-4ba9-91aa-cc05b64ac7a6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="伊势贞丈家藏小乌丸太刀图"></a></p>
<p>伊势贞丈家藏小乌丸太刀图</p>
<p>上面提到的藤原秀乡也是讨伐平将门的功臣之一，相传他讨伐成功是受了龙女的点拨。平将门作为历史上著名的怨魂，涉及到日本独特的御灵信仰，我们会在国之篇继续聊这方面的内容。</p>
<p>关于蛇与蜈蚣多说几句，在《日光山缘起》中有一个著名的日光山神大战赤城山神的故事。日光山的山神是大蛇，而赤城山的山神是大蜈蚣，两个山神因为<strong>争夺两山之间的湖泊</strong>打了起来。</p>
<p>鹿岛神（建御雷神）让日光神去<strong>奥州</strong>寻找擅长用弓的日光神后裔<strong>猿丸</strong>助战，日光神变成白鹿出现在猿丸前面，把他引到日光山并告知猿丸是自己的子孙，击败赤城山神后这片山林可以随意打猎，于是猿丸协助日光山蛇神击败了赤城山大蜈蚣。日光山猴子很多，这段故事也许是把猴子拟人化了，这可能也是《只狼》菩萨谷猴子为什么会守着白蛇神社对抗孤影众的典故吧。</p>
<h1 id="源之宫的阴霾"><a href="#源之宫的阴霾" class="headerlink" title="源之宫的阴霾"></a>源之宫的阴霾</h1><p>《只狼》几乎所有神秘事物都来源于源之宫。源之宫是如何建立的，发生过什么事件，以及宫内的人是什么身份，先给出我个人的答案：</p>
<p><strong>没有答案</strong>。本文的结尾会用一个故事来解释为什么我认为没有明确的答案。</p>
<p>先说源之宫的名字，源字取<strong>水源</strong>和现实中拥有皇室血统的<strong>源氏</strong>双关之意。宫字就很奇怪了，如果把源之宫理解成宫殿，日本只有皇族住的地方才有资格叫宫；如果把源之宫理解为神社，社号是神宫或宫也必须与皇族以及朝廷重要人物相关，比如皇室的伊势神宫和德川家康的日光东照宫，何况源之宫的绝大部分区域都不属于神社。</p>
<blockquote>
<p><strong>京</strong>の水 杯に注がれた、宮の貴族が嗜む御神水 源の宮に輿入れした者は、 まずこれを頂戴する 　宮の貴族の嗜みぞ さあさ、ぐぐいと召し上がるが良い</p>
</blockquote>
<p>在源之宫，我们能找到一个叫“<strong>京城水</strong>”的东西，京即为首都。敢在东北大乡下独立于天皇和大和朝廷自称宫和京城，这是不折不扣的<strong>朝敌</strong>。前文提到的平将门叛乱，做的就是这种事情，平将门到关东自称“新皇”，试图东国独立对抗当时京都的朱雀天皇，被判为朝敌并讨伐。</p>
<p>还有一种解释是取龙宫之意，根据废除数据中的信息，游戏开发阶段源之宫叫水没都，樱龙叫人鱼龙，与龙宫确实有些微妙的关系，但我个人不太能接受这种解释。</p>
<p>源之宫从建筑风格来看，可以看出有两次修建工程，一期先修建樱龙的神社和神社前的木屋，二期修建外侧的整个宫殿和住宅区，是不是同一群人修的就不清楚了。</p>
<p>因为鸟居是神社通往外界的出入口，我们可以通过鸟居的摆放大概推测神社的范围。鸟居的造型一般可以分为两大类：<strong>神明鸟居</strong>和<strong>明神鸟居</strong>。神明鸟居代表天照大御神相关的神社，而其他神的神社使用不同款式的明神鸟居。</p>
<p><a href="https://image.gcores.com/395fd2ee-51c1-4721-abcc-a4f003618195.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/395fd2ee-51c1-4721-abcc-a4f003618195.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="神明鸟居和明神鸟居"></a></p>
<p>神明鸟居和明神鸟居</p>
<p>简单描述鸟居的结构：有两根横梁，上面的叫<strong>笠木</strong>，下面的叫<strong>贯</strong>；两根竖柱叫<strong>柱</strong>；中间像门牌一样的竖板叫<strong>额束</strong>。</p>
<p>神明鸟居的笠木是直的（无反增），贯的两侧不从柱延伸出去，大部分没有额束，鸟居常为原木色和比较素的颜色。</p>
<p>明神鸟居的笠木是弯的（有反增），常见是双层结构，笠木下面贴着岛木，贯的两侧顶出头，有额束。红色是明神鸟居常见的颜色。</p>
<p>神明鸟居相对简洁和原生一些，日本受到中国传来佛教建筑的影响后，衍化出多种多样的明神鸟居。</p>
<p><a href="https://image.gcores.com/3ac9e0ab-faeb-4d94-ab38-ae07cecdda05.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3ac9e0ab-faeb-4d94-ab38-ae07cecdda05.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鸟居的简单分类"></a></p>
<p>鸟居的简单分类</p>
<p>落实到《只狼》中，苇名国全境我们大致可以遇见五种鸟居，代表五类不同的神社，不同的神社可能供奉同一位神明却由不同的人修建而成的。</p>
<h2 id="源之宫一期神社"><a href="#源之宫一期神社" class="headerlink" title="源之宫一期神社"></a>源之宫一期神社</h2><p><a href="https://image.gcores.com/08b3b27c-a7d6-48cb-8714-8a54fa536ace.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/08b3b27c-a7d6-48cb-8714-8a54fa536ace.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="樱龙前的鸟居"></a></p>
<p>樱龙前的鸟居</p>
<p>源之宫最高处的无名神社，摆放的是方笠木、圆贯、圆柱、无额束的神明鸟居。整个神社由上坡路的数个鸟居和岩洞岩山构成。神明鸟居、岩洞、巫女的组合不禁会联想到日本神话中非常著名的场景，<strong>天岩户</strong>。</p>
<p>天照大御神的弟弟须佐之男命在高天原不断捣乱，摧毁天照大御神的田地，在神殿里拉屎，还把马剥皮丢到屋子里，吓得织女被梭戳到下体而丧命。天照大御神非常生气，躲到了高天原一处叫天岩户的山洞里并堵住洞口，世界瞬间变得黑暗，灾祸四起。</p>
<p>八百万神明心急如焚，凑在一起商量如何让天照大御神离开岩洞，最后决定让天宇受卖命（天钿女命）在洞口跳舞。天宇受卖命露着胸部和下体卖力舞蹈，惹得众神哈哈大笑，天照大御神好奇外面为何如此热闹就把头伸出去看，被在旁边待命的大力士天手力男神拉到洞外，世界恢复了光明，布刀玉命<strong>在洞口挂上注连绳防止天照大御神回到岩洞中</strong>。</p>
<p>这个故事貌似和樱龙完全不搭边，我们试着换个角度，反转所有条件，把樱龙岩洞看作宫崎英高版天岩户最后失败的IF版本。</p>
<p><a href="https://image.gcores.com/df013f55-a5cc-46e0-abd7-fa7ef98571bf.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/df013f55-a5cc-46e0-abd7-fa7ef98571bf.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="沉睡的巫女"></a></p>
<p>沉睡的巫女</p>
<p>因为某些原因，樱龙躲在洞里，外界开始发生不好的事情。没有任何神明在洞口等待，最热闹的舞者换成了最安静的沉睡巫女，直到最后樱龙也没“显灵”，洞口挂着的注连绳反而阻止神明离开这里。</p>
<p>而且沉睡巫女与天宇受卖命的经典形象有一定程度相似，比如藤冠、领巾、勾玉项链。</p>
<p><a href="https://image.gcores.com/54451a0b-e82f-4885-862a-78f1c05d7b11.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/54451a0b-e82f-4885-862a-78f1c05d7b11.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="衝立絵馬 岩戸神楽乃祖天鈿女命"></a></p>
<p>衝立絵馬 岩戸神楽乃祖天鈿女命</p>
<p>作为御神体的岩石面前，围绕着的玉桓已经破损，摆放神馔的三方倒在一旁，上面长满了苔藓，这表明已经很久没人来参拜供奉了。游戏流程中上山会遭遇三个紫衣精英淤加美人，丝毫感受不到她们对神的敬畏，可能只是为了阻止外人接近岩洞。</p>
<h2 id="源之宫二期神社"><a href="#源之宫二期神社" class="headerlink" title="源之宫二期神社"></a>源之宫二期神社</h2><p><a href="https://image.gcores.com/2ebf26b9-eb14-4c89-8640-e68a3ef499e9.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2ebf26b9-eb14-4c89-8640-e68a3ef499e9.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="与樱龙神社风格截然不同"></a></p>
<p>与樱龙神社风格截然不同</p>
<p>源之宫中还存在另外一个神社，我们在赏花平台附近下方能找到一个被樱花树枝破坏的小型摄末社，以及方笠木、方贯、圆柱、有额束的朱红色明神鸟居，以此可以判断这应该是有别于樱龙神域的神社，与源之宫的大部分建筑同属于平安时代风格，前文提到被搬到苇名城的摄末社，也应该是这个神社的一部分。此神社面前也有两个紫衣精英淤加美人看守。同款鸟居还存在于源之宫湖中鱼王洞穴的入口，以及苇名城投身处的悬崖前。</p>
<p><a href="https://image.gcores.com/4db1b3b2-e54a-4df5-9acf-433225a89b56.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4db1b3b2-e54a-4df5-9acf-433225a89b56.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鱼王巢穴入口附近的鸟居"></a></p>
<p>鱼王巢穴入口附近的鸟居</p>
<p>水中的鸟居和石梯依稀可以看出是神社的参道石段，也许在源之宫变故之前，神社的主体位于中心湖的附近或者现在鱼王洞穴的山洞之中。</p>
<p><a href="https://image.gcores.com/737d122a-0572-4857-8d20-c18de01a6984.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/737d122a-0572-4857-8d20-c18de01a6984.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="废弃地牢投身处鸟居"></a></p>
<p>废弃地牢投身处鸟居</p>
<p>投身处的鸟居就有意思了，这表示<strong>源之宫的人曾经占领过苇名城</strong>。投身处鸟居的腐烂程度高于源之宫，有三种可能：</p>
<ul>
<li><p>这里修建时间比源之宫早，源之宫的人先到达苇名城地区，然后去了源之宫。</p>
</li>
<li><p>自然环境问题，洞穴里潮湿比较容易腐蚀。</p>
</li>
<li><p>源之宫和外界的时间规则不同，类似时间停滞的罗德兰，如果源之宫真的有几百年历史，木制建筑无人维护很难保持现在这么好的成色。</p>
</li>
</ul>
<p>这个鸟居的摆放位置似乎散发着剧情被砍的气息。废弃地牢在传送界面作为一个独立的区域，只有两个鬼佛以及贫瘠的内容，非常不自然。</p>
<p>苇名城的地下本来可能存在一个只狼版的小隆德遗迹。从投身处跳下去到达毒沼显得有些唐突，如果连接到拿蛇心那个黑暗洞穴也许更合理一些，还记得洞穴墙壁上的敌人吗？与其说是白蛇的祭品，更像是类似无头和七面武士的怨灵。</p>
<p><a href="https://image.gcores.com/c0069dfb-b779-4a11-8ca3-1ae16d1a1c42.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c0069dfb-b779-4a11-8ca3-1ae16d1a1c42.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="官方攻略中的潜岩者"></a></p>
<p>官方攻略中的潜岩者</p>
<p>这种敌人在官方攻略书中被称为<strong>潜岩者（岩もぐり）</strong>，被其攻击会积累恐惧值，说明他们是死灵一类的敌人。</p>
<p><a href="https://image.gcores.com/4d8964bf-2ca0-4d15-b3ef-61e09dc1439b.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4d8964bf-2ca0-4d15-b3ef-61e09dc1439b.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="潜岩者的白模"></a></p>
<p>潜岩者的白模</p>
<p>在拆包的数据中我找到了这种敌人的模型。他们使用原始的长矛，服装和配饰的风格与《只狼》中已知的所有势力都不一样。从五官分布和修长的身材来看，似乎和百足众有些关联，与崩落峡谷的百足众掉落相同，是消毒粉和铁屑。不过游戏中百足众也是谜团重重交代得不清不楚，除了佛珠中的描述就没什么像样的信息了。</p>
<p>说到“岩もぐり”，日本岐阜县有一个鬼岩公园，据说800多年前这里居住着一个叫关之太郎的鬼人，四处作恶被当时的白河天皇派人讨伐，因为是鬼住过的地方被称为鬼岩。每年会有一次为期两天的活动叫“<strong>岩穴くぐり</strong>”。这个活动实际就是钻漆黑的岩洞，在洞中最深处放着关之太郎的石像。</p>
<p>“もぐり”和“くぐり”在日语中都写作“潜り”，前者是潜水的意思，而后者是伏下身子钻过去的意思。</p>
<p><a href="https://image.gcores.com/5655d488-87cb-4b89-90ef-09955a9a5ff3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5655d488-87cb-4b89-90ef-09955a9a5ff3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鬼岩洞穴"></a></p>
<p>鬼岩洞穴</p>
<p><a href="https://image.gcores.com/2bf8fe60-2529-4b17-8df6-b1530b698013.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2bf8fe60-2529-4b17-8df6-b1530b698013.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="关之太郎"></a></p>
<p>关之太郎</p>
<p>苇名城附近的两个无首和一个七面武士都被藏在地下也可以验证苇名城之下必有蹊跷。根据御灵信仰的特点，我们可知镇压御灵的人并不是苇名众，在国之篇里将要继续考察苇名城地下，目前还留了一个更大的秘密没放在这里讲（你们肯定猜不到是什么）。</p>
<h2 id="白蛇神社"><a href="#白蛇神社" class="headerlink" title="白蛇神社"></a>白蛇神社</h2><p><a href="https://image.gcores.com/02177aa9-dc33-404e-9b83-de878b52c037.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/02177aa9-dc33-404e-9b83-de878b52c037.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="做工明显不如源之宫"></a></p>
<p>做工明显不如源之宫</p>
<p>苇名城外白蛇神社前的鸟居是圆笠木、圆贯、圆柱、有额束的明神鸟居造型，根据其社名和所在位置，此神社应该是苇名城内的人修建并用于供奉白蛇的。神社面前挂着和出云大社诹访大社同款的巨型注连绳，悬崖对面的建筑不确定是否为本殿，因为没有发现御神体（记得只摆了个鳗胆）。</p>
<h2 id="铁炮堡垒神社"><a href="#铁炮堡垒神社" class="headerlink" title="铁炮堡垒神社"></a>铁炮堡垒神社</h2><p><a href="https://image.gcores.com/8a50573b-0f25-4dfe-add7-76163cdcdcbe.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8a50573b-0f25-4dfe-add7-76163cdcdcbe.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="白蛇皮与观音像"></a></p>
<p>白蛇皮与观音像</p>
<p>铁炮堡垒后方通往绝命吊桥的神社同样也供奉白蛇，不确定是谁修建的，看建筑水平可能是以前的苇名众修后被铁炮众占领，现在又成了百足众的地盘。与神社本体相比，前面铁炮众建筑水平的鸟居就太粗糙了，甚至很难判断算不算鸟居。</p>
<p><a href="https://image.gcores.com/2ff24470-c53b-44fe-a1e8-315ef6f09958.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2ff24470-c53b-44fe-a1e8-315ef6f09958.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="隐约可以看出鸟居的形状"></a></p>
<p>隐约可以看出鸟居的形状</p>
<p>通过铁炮堡垒神社钥匙的描述，我们只知道这个神社被称为铁炮堡垒神社，无法判断这是否此神社的本名。把神明和佛像组合在一起，体现了日本过去很长一段时间，神佛习合甚至神佛混淆的宗教现象，直到明治维新颁布神佛判然令，全国各地开始大规模神佛分离。</p>
<blockquote>
<p><strong>鉄砲砦の社</strong>の鍵 鉄砲砦の奥にある社の鍵 社の<strong>仏像</strong>裏にある扉を、開くためのもの 鉄砲砦の落ち谷衆は、 異敵と見れば、撃ち殺す 中でも、蛇の目の石火矢は、恐ろしい かの女衆は、いにしえの淤加美の一族の末裔 稀な目を持ち、遙か彼方を容易く射抜く</p>
</blockquote>
<p>值得注意的是，《只狼》的日文版中所有神社都没有使用神社（じんじゃ）一词，取而代之用了一个更生僻的“社”字，读作やしろ，可能是宫崎英高惯用的文字游戏爱好吧。</p>
<p><a href="https://image.gcores.com/ee7b94d7-a71a-4f00-aae8-dfad525c5827.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ee7b94d7-a71a-4f00-aae8-dfad525c5827.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="供养众的描述"></a></p>
<p>供养众的描述</p>
<p>山谷深处阴暗山洞里的神社，被供养众称为“<strong>古いお社</strong>”。根据干蛇柿的描述，此蛇心即是御神体，并且信徒是铁炮众。菩萨谷中零散的注连绳，可能表示整个山谷都是铁炮堡垒神社的领域。</p>
<blockquote>
<p>乾き蛇柿 柿の様に赤く染まった、ぬしの白蛇の心包 その乾いたもの ぬしとは、土地神 心包とは、神たる御魂を宿す臓である 姿かたちこそ柿によく似るが、 蛇柿は、赤く実った神の臓だ <strong>落ち谷の衆</strong>は、ぬしの白蛇を崇め、 乾いた蛇柿を<strong>御神体</strong>として祀ったという</p>
</blockquote>
<p>日本确实有把白蛇和观音放在一起的组合，<strong>白蛇观音</strong>会带来财运。这个不禁联想到《黑暗之魂》中的贪婪银蛇戒指，《只狼》中招财却换成了生气的皮球（误）。</p>
<p><a href="https://image.gcores.com/3abddfbc-7d4a-4ace-8bff-2ad184a5e25e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3abddfbc-7d4a-4ace-8bff-2ad184a5e25e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="白蛇观音"></a></p>
<p>白蛇观音</p>
<h2 id="水生村神社"><a href="#水生村神社" class="headerlink" title="水生村神社"></a>水生村神社</h2><p><a href="https://image.gcores.com/a355bcb8-6ba7-4c7a-82b4-d1d59d6467c4.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a355bcb8-6ba7-4c7a-82b4-d1d59d6467c4.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="幻影破戒僧前的鸟居"></a></p>
<p>幻影破戒僧前的鸟居</p>
<p>水生村的鸟居更加简陋，一方面是生产力低下，另一方面，这里曾经发生了信仰变化，根据附近被雾隐贵人占领并摧毁的寺庙、神官家里无头佛像和二楼供奉的樱花树枝，这里过去佛教信仰被废除，转而信仰源之宫。在佛教传来之前，本地人拥有朴素的自然崇拜，信仰源之水，参考现实中日本神佛习合的历史，神道教与佛教之间关系应该比较融洽，废佛元凶看来就是极端的源之宫了。</p>
<p><a href="https://image.gcores.com/b17e44a3-fcd0-4e12-b214-c71382a4fa9c.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b17e44a3-fcd0-4e12-b214-c71382a4fa9c.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="三方上的蛞蝓"></a></p>
<p>三方上的蛞蝓</p>
<p><strong>三方</strong>是神道教中用来摆放神馔的用具，下面有三个孔所以叫作三方，摆放时无孔的一侧对着神明。水生村和苇名城天守阁的御子居室的三方似乎都摆错方向了……</p>
<p>村内石祠前的三方上摆满了蛞蝓，根据神道教的“<strong>人神共食</strong>”，作为神馔的供品撤下后要被信徒吃掉。吃同样的食物，视为与神更加亲近，所以这些蛞蝓最后应该都被村民吃了。</p>
<p>通过神社的细节，我们可以大致推测出《只狼》中各个势力的情况。</p>
<ul>
<li><p>修建源之宫一期神社的人是最先来到这里，信奉佛教影响之前的古神道。</p>
</li>
<li><p>修建源之宫二期神社的人开始受佛教影响，从鸟居的材质来看他们很重视信仰，经济文化水平和生产力都比较高。</p>
</li>
<li><p>修建白蛇神社的人，因为生活在战国乱世，优先修建自己的城池，留一些余力来满足信仰的需求。</p>
</li>
<li><p>铁炮堡垒和水生村的人缺乏生产力，没有什么能力修建像样的神社，生活也很贫苦。</p>
</li>
</ul>
<h2 id="源之宫人民的精神生活"><a href="#源之宫人民的精神生活" class="headerlink" title="源之宫人民的精神生活"></a>源之宫人民的精神生活</h2><p>让我们回到源之宫，宫殿前面平台上摆放着几对显眼的太鼓，这种太鼓被称为<strong>鼉太鼓</strong>，外侧由火焰宝珠包围，也被称为<strong>火焰太鼓</strong>，是演奏<strong>雅乐</strong>的乐器。</p>
<p><a href="https://image.gcores.com/fe801407-f39f-406e-9ab3-7f6f8150c15a.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fe801407-f39f-406e-9ab3-7f6f8150c15a.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫的鼉太鼓"></a></p>
<p>源之宫的鼉太鼓</p>
<p>鼉太鼓由一对太鼓组成，左龙右凤，左侧上方金轮代表太阳，右侧上方银轮代表月亮。雅乐有左方舞和右方舞之分，左方舞从唐朝传来，伴奏音乐被称为唐乐，舞蹈服装以赤色为主，右方舞从朝鲜半岛传来，伴奏音乐被称为高丽乐，舞蹈服装以青色为主，所以鼉太鼓左侧巴纹为赤轮，右侧巴纹为青轮。</p>
<p><a href="https://image.gcores.com/c94fcf3d-f2f4-4869-8a8d-5c2ca1259fff.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c94fcf3d-f2f4-4869-8a8d-5c2ca1259fff.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="春日大社国宝殿 鼉太鼓"></a></p>
<p>春日大社国宝殿 鼉太鼓</p>
<p>游戏中的鼉太鼓可以确定是取材于<strong>春日大社</strong>国宝殿中的真品，镰仓时代由<strong>源赖朝</strong>献上，至今已有800多年的历史。右侧巴纹的磨损痕迹和游戏中的贴图都几乎一模一样，龙头做了小幅度修改更接近樱龙的形象，而凤头几乎没改动。这对鼉太鼓从2015年开始修复，今年已经重新出展，有机会去奈良玩的朋友可以去看看。</p>
<p>此太鼓还有一个特点是左右两侧皆为三巴纹，而现在的新品右侧使用二巴纹。</p>
<p><a href="https://image.gcores.com/beab435f-aca5-4561-8c3c-f3cbbea21605.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/beab435f-aca5-4561-8c3c-f3cbbea21605.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="新品总感觉缺少一些庄严"></a></p>
<p>新品总感觉缺少一些庄严</p>
<p>雅乐是日本的传统宫廷音乐，由中国和朝鲜半岛等地传来的音乐演变而成，通过雅乐我们可以感受一下源之宫人民的精神生活。</p>
<p><a href="https://image.gcores.com/8fea5125-b358-4281-ba6b-3fc6514d9f8d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8fea5125-b358-4281-ba6b-3fc6514d9f8d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="雅乐《陵王》"></a></p>
<p>雅乐《陵王》</p>
<p>淤加美人在赏花平台的雅乐台上表演的舞蹈原型是雅乐《<strong>陵王</strong>》，雅乐中经典的左方舞唐乐，为一人独舞。舞者穿着华丽舞服，头戴金龙面具，手持一根叫作“桴”的金色细棒。此雅乐又叫作《兰陵王入阵曲》，《兰陵王入阵曲》作为中国史籍中记载最早的戏剧已经失传千年，有幸我们还能通过日本传承至今的雅乐了解到中国古代的戏剧是什么样的。</p>
<p>唐代论著《教坊记》中对《兰陵王入阵曲》有这样的记载：</p>
<blockquote>
<p>大面出北齊。蘭陵王長恭性膽勇，而貌若婦人。自嫌不足以威敵，乃刻木爲假面，臨陣著之。因爲此戲，亦入歌曲。</p>
</blockquote>
<p>兰陵王高长恭是北齐名将，在与北周进行邙山之战时，高长恭率领五百骑兵迎战北周十万大军。因为他长得过于俊美，带上凶恶的面具威吓敌人，成功替齐军解围后摘下面具以表身份，为了纪念兰陵王勇猛的事迹创作了《兰陵王入阵曲》。兰陵王因为功高震主最后被昏庸的皇帝以毒酒赐死，离开人世时只有三十多岁，兰陵王死后北齐再无大将，四年后就灭国了。</p>
<p><a href="https://image.gcores.com/5b4da55a-2032-4e68-9a43-2d8e74982b9b.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5b4da55a-2032-4e68-9a43-2d8e74982b9b.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="竜の舞い面"></a></p>
<p>竜の舞い面</p>
<p>游戏中的龙之舞面同样来自雅乐《陵王》的舞乐面。个人感觉这首雅乐选得非常巧妙，一方面表现淤加美人跳舞求神力用于战斗和鼓舞士气，另一方面源之宫中腐败的贵族蚕食淤加美战士又与兰陵王的故事有些微妙的联系。</p>
<p><a href="https://image.gcores.com/ee76170e-baaa-44b1-8720-6341c18fb0a2.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ee76170e-baaa-44b1-8720-6341c18fb0a2.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="舞楽面 陵王"></a></p>
<p>舞楽面 陵王</p>
<p>宫中贵族使用的横笛是雅乐常用乐器<strong>龙笛</strong>。雾隐贵人吹奏的曲子是雅乐《陵王》的龙笛独奏。下面这段视频从3分20秒开始对应雾隐贵人的旋律。</p>
<p><a href="https://www.bilibili.com/video/av18433678" target="_blank" rel="noopener">【日本雅乐】蘭陵王 龙笛独奏</a></p>
<p>仔细听的话会发现源之宫的背景音乐其实也融合了雅乐的元素。</p>
<p><a href="https://image.gcores.com/653932e1-e542-491e-abde-af17540176af.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/653932e1-e542-491e-abde-af17540176af.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="前天冠"></a></p>
<p>前天冠</p>
<p>淤加美一族的头饰被称为<strong>前天冠</strong>，来自于雅乐《迦陵频》，同样是经典左方舞唐乐之一。《迦陵频》为四人童舞，常由儿童或者少女表演。此头饰也是巫女常用的物品。淤加美一族戴着这个头饰可能是暗示现在残留的淤加美人在源之宫兴盛的时候还都是孩子吧。</p>
<p><a href="https://image.gcores.com/4e115755-ee52-4eca-b5ef-c430a73839c0.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4e115755-ee52-4eca-b5ef-c430a73839c0.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="雅乐《迦陵频》"></a></p>
<p>雅乐《迦陵频》</p>
<p>雅乐的舞者是女性或者儿童时，戴着前天冠同时会把脸涂白。虽然淤加美人的面具很像日本能乐中的假面，个人更倾向于是用白色面具代表涂白的脸。</p>
<h2 id="淤加美与蛇眼"><a href="#淤加美与蛇眼" class="headerlink" title="淤加美与蛇眼"></a>淤加美与蛇眼</h2><p>虽然游戏中没有为淤加美这个神秘的氏族提供太多信息，从名字和符号上还是能看出一些奥妙。</p>
<p><strong>淤加美神</strong>出自于《古事记》和《日本书纪》，是掌管雨水和灌溉的龙神，很容易向樱龙的方向联想。如果根据本文前面的考察，把樱龙看作是落败的国津神建御名方神，淤加美神有一个容易被忽视之处，那就是这位神的出身。</p>
<p>日本神话中著名的伊邪那岐，是天照大御神的父神。伊邪那岐和伊邪那美为兄妹和夫妻，伊邪那美在生火神迦具土时被烧死，伊邪那岐用十握剑愤怒斩杀了迦具土后，从剑上流下的血诞生了几个神明，其中就有淤加美神和建御雷神，这两位神都是伊邪那岐的御子。</p>
<p>所以<strong>淤加美神和建御雷神算是亲兄弟</strong>，同属于天津神。游戏中的淤加美一族寻找仙乡的目的，以及是否有信仰变化就耐人寻味了。不过也有可能只是创作时把诹访大明神和淤加美神的形象捏在一起了。</p>
<p><a href="https://image.gcores.com/e1126bf8-60bd-40f1-9f42-3b8c5cde7802.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e1126bf8-60bd-40f1-9f42-3b8c5cde7802.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="淤加美一族的家纹或神纹"></a></p>
<p>淤加美一族的家纹或神纹</p>
<p>源之宫中旗帜上的符号也值得关注，这种原创的<strong>巴纹</strong>应该是淤加美一族的家纹或神纹。无法确定淤加美究竟指的是一个氏族还是对一个神明的信仰，难以判断是家纹还是神纹。围绕巴纹的外圈图案可能代表水流，目前没有找到类似的原型。</p>
<p><a href="https://image.gcores.com/73d5cac1-c9cd-4715-9faa-d1907a6b545e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/73d5cac1-c9cd-4715-9faa-d1907a6b545e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="顺时针的右三巴纹"></a></p>
<p>顺时针的右三巴纹</p>
<p>巴纹由旋转的勾玉构成，<strong>巴纹的三种主要含义完美对应了淤加美一族的特点</strong>：</p>
<p>代表<strong>水</strong>的水漩涡，对应淤加美一族信仰源之水。日本房瓦上的巴纹表示以水防火。在《只狼》中各种建筑上也能看到大量的巴瓦。巴纹还是淤加美神贵船神社的神纹。</p>
<p><a href="https://image.gcores.com/7ff25ab2-0329-44c1-886a-54216c3ce5b6.JPG?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7ff25ab2-0329-44c1-886a-54216c3ce5b6.JPG?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="轩巴瓦"></a></p>
<p>轩巴瓦</p>
<p>代表<strong>雷</strong>的雷云，对应淤加美一族掌控雷电。太鼓敲打起来如同雷声，所以太鼓上常见巴纹，游戏中飞渡漩涡云技能和英麻喝了龙泉的对话都提到了源之水源头方向的漩涡云。</p>
<p><a href="https://image.gcores.com/673b4d59-89b4-4889-9e9a-fde4ff277819.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/673b4d59-89b4-4889-9e9a-fde4ff277819.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="巴纹太鼓"></a></p>
<p>巴纹太鼓</p>
<p>代表<strong>弓</strong>的鞆，鞆是日本古代使弓时戴在左手上用来缓冲回弹的防具，对应淤加美一族擅长射击。苇名弦一郎战斗时掺杂弓箭射击应该是他的师傅巴教授的。</p>
<p><a href="https://image.gcores.com/5c144d3f-7eee-4386-a52f-97f1e77e2891.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/5c144d3f-7eee-4386-a52f-97f1e77e2891.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="鞆和弦卷"></a></p>
<p>鞆和弦卷</p>
<p>巴的名字，除了出自著名人物巴御前以外，也可能暗示了她在淤加美一族中的地位，毕竟名字中的巴（ともえ）就是巴纹的巴。</p>
<p>作为淤加美一族后裔的<strong>蛇眼</strong>，其名字的双重含义也对应了蛇眼一族的特点：</p>
<p>从字面意义上看，蛇眼顾名思义<strong>信仰蛇神</strong>，认为自己受到蛇神的眷顾。可蛇的视力很差，神射手为什么要自称蛇眼呢？</p>
<p><a href="https://image.gcores.com/07376db7-f5e1-48b1-b7c4-da7a0c4f43cd.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/07376db7-f5e1-48b1-b7c4-da7a0c4f43cd.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="弦卷纹 蛇之目"></a></p>
<p>弦卷纹 蛇之目</p>
<p>在日文中蛇眼写作<strong>蛇之目</strong>，是日本家纹中<strong>弦卷纹</strong>的一种。</p>
<p><a href="https://image.gcores.com/230af77d-d44f-43e8-a689-50666e95052e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/230af77d-d44f-43e8-a689-50666e95052e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="弦卷"></a></p>
<p>弦卷</p>
<p>弦卷是用来把弓弦卷起来的用具，弦卷纹和巴纹异曲同工表示了蛇眼一族也擅长射击，上文射箭图里同时出现了鞆和弦卷，都是弓的用具，暗示淤加美一族和蛇眼一族二者同源。</p>
<h1 id="宗教信仰的传承与遗失"><a href="#宗教信仰的传承与遗失" class="headerlink" title="宗教信仰的传承与遗失"></a>宗教信仰的传承与遗失</h1><p>本文最后要讲一个与《只狼》游戏内容没什么关系的故事，来自于2016年由新海诚导演的动画《你的名字。》。</p>
<p><a href="https://image.gcores.com/3be2861d-a5da-47ba-aa46-1c5a65f08b6b.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3be2861d-a5da-47ba-aa46-1c5a65f08b6b.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《你的名字。》"></a></p>
<p>《你的名字。》</p>
<p>《你的名字。》讲述了一个Boy meets girl的爱情故事。东京的男主角立花泷与糸守町宫水神社神职世家的女主角宫水三叶，某天开始两人早晨醒来后会偶尔交换灵魂，不得不体验并改变了彼此的生活。有一天三叶留下流星的信息后再也没有出现灵魂交换，泷试图寻找三叶，却发现两人的时间线相差三年，糸守町三年前被天降陨石摧毁，三叶也因此遇难。泷来到宫水神社的御神体喝下口嚼酒再次与三叶灵魂交换，回到三年前组织糸守町提前避难，改变历史拯救了宫水一家和当地人的生命。</p>
<p><a href="https://image.gcores.com/9e148f19-e426-417f-8ae1-5ba1a2dd3292.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9e148f19-e426-417f-8ae1-5ba1a2dd3292.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《君の名は。 Another Side:Earthbound》"></a></p>
<p>《君の名は。 Another Side:Earthbound》</p>
<p>除了描写少男少女的邂逅以外，这个故事还有一条关于宫水神社历史和信仰变化的暗线，在外传小说《你的名字 Another Side：Earthbound》中进一步描述了这条暗线。</p>
<p><a href="https://image.gcores.com/f770509c-21c6-470d-9177-fbe9c9972292.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f770509c-21c6-470d-9177-fbe9c9972292.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="为了和二叶在一起，俊树放弃了民俗学者身份，入赘宫水家"></a></p>
<p>为了和二叶在一起，俊树放弃了民俗学者身份，入赘宫水家</p>
<p>小说的第四章讲了三叶的父亲宫水俊树和母亲宫水二叶的故事。两人相遇的契机是曾为民俗学者的俊树去糸守町宫水神社调查研究当地的民俗信仰。这一章的前半部以采访者俊树和被访者二叶一问一答的对话展开，出现了很多动画本篇中没有提及的信息。</p>
<p>宫水神社没有任何摄末社，唯一祭神是<strong>倭文神建叶槌命</strong>，倭文是一种布的名字，倭文神是教授人类纺织的神。奇怪的是，<strong>宫水神社传承下来的是编织组纽而不是织布</strong>，而且二叶表示宫水神社与葛城倭文坐天羽雷命神社和大甕神社无任何交流，后二者是真实存在祭祀倭文神的神社。</p>
<p><a href="https://image.gcores.com/3b972115-9f10-41c2-9908-1afe36b3661a.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3b972115-9f10-41c2-9908-1afe36b3661a.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="组纽"></a></p>
<p>组纽</p>
<p>宫水神社中建叶槌命的功绩是<strong>制服了当地的恶龙</strong>，本文前面让国神话部分提到《古事记》中最后一个抵抗天津神的国津神是建御名方神，<strong>《日本书纪》中代替建御名方神出场的正是被建叶槌命制服的星之恶神天香香背男（天津甕星）</strong>。他虽然属于天津神，因为反抗天神强夺苇原中国被视作是国津神，天津神中的武神建御雷神对他都束手无策，为什么倭文神建叶槌名能制服天香香背男一直是个谜团，至今尚无定论。</p>
<p>宫水神社与其他祭祀倭文神的神社传统不同，俊树认为可能会考察出珍贵的古代资料解释历史留下的谜团。接着问宫水神社的记载中倭文神是如何制服恶龙的，二叶认为可能是倭文神织大量的绳子把恶龙绑起来了吧，回答显得很随意的原因是<strong>宫水神社的文献资料已经遗失了</strong>。</p>
<p>公元1803年，神社附近的一家草鞋店失火导致整个糸守町受灾，宫水神社也付之一炬。不仅大量文字资料被烧毁，当时的神主和继承人也因火灾丧命。</p>
<p>过去的神社流行<strong>代代单传</strong>，祭祀仪式和祝词仅传授给一位后继者，原因很复杂，一方面防止神社的信息泄露给同行，另一方面家族会留有一些当权者的把柄和秘密用来自保。这种传承体系弊端非常明显，万一掌握秘密的人突然死亡，传承就断掉了。</p>
<p>可以预料在上千年的历史之中这种断传的事情不会是少数，传承也就变得千疮百孔。不同于拥有大量经书的佛教，神道教缺乏古志记载，随着时间流逝损失更为严重。后人在修复整理还原仪式和祝词的过程中难免会偏离本意。</p>
<p>落实到宫水神社，现在使用的祝词（宫水神社称之为申立）与出云大社的祝词有大量相同的部分，属于出云系祝词。出云系是国津神的源头，与倭文神建叶槌名的天津神立场不符，二叶无法解释矛盾的原因，记载祝词由来的文献可能已经在200年前的大火中烧毁了。</p>
<p>两人又讨论了恶龙和绳结的隐喻，二叶猜测可能是象征过去残暴的统治者和团结一心的民众，并回问俊树有什么看法，俊树给出了一个逻辑严谨并且很有趣的假设：<strong>宫水神社曾经可能发生过信仰变化</strong>。</p>
<p><a href="https://image.gcores.com/3a9afd8a-2a6f-4fb3-b99f-f240c95fc079.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3a9afd8a-2a6f-4fb3-b99f-f240c95fc079.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="天香香背男名字的推测"></a></p>
<p>天香香背男名字的推测</p>
<p>天香香背男读作あめのかがせお。あめ是天的一种特殊读法，在古日语中蛇读作かがし，天香香背男的名字可以看成<strong>天之蛇</strong>，かが也被认为有輝く（かがやく）之意。古人有把流星当成天蛇的说法，结合日本信仰中龙蛇相通的习惯，宫水神社的制服本地恶龙的神明功德对应的应该就是制服天香香背男，也就是流星。</p>
<p>糸守湖是陨石落下产生的陨石湖。假设这里之前的居民信奉星神天香香背男，村落却被天降陨石摧毁，人们不得不承受陨石造成死亡和毁灭带来的污秽，活下来的信徒们也许就会认为<strong>自己被神背叛</strong>，为了净化污秽，转而信仰天香香背男的天敌倭文神建叶槌命。曾经编织代表蛇的组纽，因为适用于新的信仰，被重新解释成了捆绑蛇的绳索。国津神体系仪式和祝词随之延续了下来，这也解释了为什么宫水神社传承的是组纽而不是织布。</p>
<p>对话的最后，二叶并没有否认俊树的假设，只是委婉表示凭自己直觉相信宫水一族信仰的是编织这种行为本身。过去究竟都发生过什么，这个故事没有给我们明确的答案。</p>
<p>在正篇动画中，也有一些细节暗示信仰变化，比如三叶和四叶跳神乐舞时使用的金龙纹头饰和神乐铃。</p>
<p><a href="https://image.gcores.com/6f5b324f-01e7-4e98-88f1-ccce659a47e5.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6f5b324f-01e7-4e98-88f1-ccce659a47e5.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="龙纹头饰"></a></p>
<p>龙纹头饰</p>
<p><a href="https://image.gcores.com/e2b94fef-dbc4-446d-acea-23cd07bfe404.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e2b94fef-dbc4-446d-acea-23cd07bfe404.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="龙纹神乐铃"></a></p>
<p>龙纹神乐铃</p>
<p>《你的名字。》和本文讨论的《只狼》原型其实也有一些微妙的联系。星神在日本神话传说中极为罕见，可能是曾经信仰星辰的氏族被大和氏族击败后遗留下来的信仰。作为《日本书纪》中让国神话最后一位抵抗天神的国津神，<strong>有些观点认为天香香背男和建御名方神是同一神</strong>。</p>
<p>天香香背男为什么被认为是星之恶神，还有很多值得讨论的事情，打算放在国之篇里结合神国两条线一起说（又鸽了）。</p>
<p><a href="https://image.gcores.com/8b4e3ff3-3361-48e5-a591-519b281bba09.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8b4e3ff3-3361-48e5-a591-519b281bba09.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="诹访湖"></a></p>
<p>诹访湖</p>
<p>《你的名字。》中虚构的糸守湖，原型来源于本文提到过的诹访湖，虽然现实中诹访湖是断层湖而不是陨石湖。一些狼学家（比如Harvey）认为源之宫的湖也是远古时代落下的陨石形成的，陨石带来了金刚屑。</p>
<p><a href="https://image.gcores.com/d4d0aa43-5c03-48dd-85a3-5c0ecc256492.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d4d0aa43-5c03-48dd-85a3-5c0ecc256492.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="前往御神体"></a></p>
<p>前往御神体</p>
<p>宫水神社的御神体所在之地，也是大树加岩洞的组合。在现实的<strong>大甕倭文神社</strong>，天香香背男的荒魂镇压在<strong>宿魂石</strong>之中。宿魂石指的不只是这块石头，而是石头背后整个岩山。</p>
<p><a href="https://image.gcores.com/1c46a576-98a5-4d16-8587-e93fcffa5daa.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1c46a576-98a5-4d16-8587-e93fcffa5daa.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="宿魂石"></a></p>
<p>宿魂石</p>
<p>扯了这么多不相关的内容，反正我是不相信宫崎英高会去看《你的名字。》。</p>
<p><a href="https://image.gcores.com/c4ef1ddd-4c7f-4237-9e33-c0af15b117be.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c4ef1ddd-4c7f-4237-9e33-c0af15b117be.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="出自《只狼》亚太地区发布会宫崎英高的机核专访"></a></p>
<p>出自《只狼》亚太地区发布会宫崎英高的机核专访</p>
<p>回到《只狼》的世界，我们试图挖开苇名国每一寸土来了解过去究竟都发生过什么，宫水神社这个故事提供了一个可以参考的答案。<strong>当创作者不打算给玩家上帝视角时，无法知晓一切成为一种理所应当的状态</strong>。</p>
<p>源之宫是谁起的名字？宫里住的是谁？他们什么时候来的？他们也把此地叫作源之宫吗？淤加美一族为什么叫淤加美？她们信仰樱龙吗？沉睡的巫女是谁？</p>
<p>诸如此类这种问题无法得到明确的答案，因为游戏没有提供信息，可这些事情却实实在在发生于过去。我们以游戏内人物的视角观察这个战乱的世界，古籍大量遗失，神职人员所剩无几，建筑无人修缮，很多传统都断传和扭曲了。被剥夺游戏中知晓所有细节的权力后，除了猎奇心驱使的求知欲，迫使我思考了更多似乎与游戏没太大关系的问题，现实中又有多少传统文化不断地遗失在历史之中。在查询资料的过程中发现，哪怕是日本这样重视保护传统文化的国家，依然面临很多传统文化无人继承的困境。作为曾经是日本老师的中国，又该如何看待这个问题呢？</p>
<h1 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h1><p>非常感谢有耐心看完这篇拙文，文章中零零散散提出并介绍了若干假定取材原型，却始终没有解释一个更重要的问题：<strong>为什么</strong>要在《只狼》中放入这样一条神明线，是否仅仅是为了呈现日本和风与鬼神之力带来的视觉冲击。</p>
<p>在接下来的国之篇中会尝试把所有的碎片拼凑起来，将神与国两条线并为一条贯穿日本历史的主线，宫崎英高在《只狼》中到底夹了什么“私货”，让我们来一探究竟。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://ja.wikipedia.org/" target="_blank" rel="noopener">日文维基百科</a></p>
<p><a href="http://souls-seed.blogspot.com/" target="_blank" rel="noopener">ソウルの種</a></p>
<p><a href="http://inbksk.hatenadiary.com/" target="_blank" rel="noopener">クズ底</a></p>
<p><a href="http://www.genbu.net/" target="_blank" rel="noopener">玄松子的记忆</a></p>
<p><a href="http://yatsu-genjin.jp/suwataisya/index.htm" target="_blank" rel="noopener">諏訪大社と諏訪神社</a></p>
<p><a href="http://suwaarea-examine.com/okakematu.html" target="_blank" rel="noopener">まほろば諏訪圏 尾掛松</a></p>
<p><a href="http://rarememory.justhpbs.jp/kama/na.htm" target="_blank" rel="noopener">源氏御家人としての諏訪氏</a></p>
<p><a href="https://ameblo.jp/taishi6764/entry-12408630830.html" target="_blank" rel="noopener">神旅 仏旅 むすび旅</a></p>
<p><a href="https://shinto-bukkyo.net/shinto/kamisama/龍神/" target="_blank" rel="noopener">龍神とは｜龍神様の種類・意味、日本の龍神信仰/伝説・祀る神社をご紹介</a></p>
<p><a href="http://takebetaisha.jp/yamatotakeru/" target="_blank" rel="noopener">建部大社 日本武尊物语</a></p>
<p><a href="http://www.hunterslog.net/dragonology/DS/20361b.html" target="_blank" rel="noopener">大蛇之弓</a></p>
<p><a href="http://dl.ndl.go.jp/info:ndljp/pid/1288349" target="_blank" rel="noopener">俵藤太秀乡绘卷</a></p>
<p><a href="https://ameblo.jp/hana-to-kawa/entry-12387795558.html" target="_blank" rel="noopener">龍蛇神 赤城の大百足VS日光の大蛇</a></p>
<p><a href="http://www.st.rim.or.jp/~success/mukade_ye.html" target="_blank" rel="noopener">ムカデとサルの話 -いったい猿丸とは誰なのか？-</a></p>
<p><a href="http://xn--w0w51m.com/oniiwa/" target="_blank" rel="noopener">鬼岩 岩穴くぐり</a></p>
<p><a href="https://www.lmaga.jp/news/2019/04/66179/" target="_blank" rel="noopener">奈良・春日大社の鼉太鼓に国宝の数々展示</a></p>
<p><a href="https://www.tnm.jp/modules/rblog/index.php/1/2017/02/03/春日＿鼉太鼓/" target="_blank" rel="noopener">【春日大社展】巨大楽器・鼉太鼓を展示する</a></p>
<p><a href="https://costume.iz2.or.jp/" target="_blank" rel="noopener">日本服饰史</a></p>
<p><a href="http://www.kinzoku-yane.or.jp/glossary/index.html" target="_blank" rel="noopener">一般社団法人 日本金属屋根協会｜用語集</a></p>
<p><a href="http://www.meijijingu.or.jp/qa/jingu/08.html" target="_blank" rel="noopener">明治神宫 巴纹解释</a></p>
<p><a href="http://www.anitama.cn/article/87e599ff2d4911c0" target="_blank" rel="noopener">《你的名字。》中神社的三两事</a></p>
<p><a href="https://www.gcores.com/articles/103447" target="_blank" rel="noopener">方块游戏《只狼 影逝二度》亚太地区发布会宫崎英高机核专访</a></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>只狼</tag>
      </tags>
  </entry>
  <entry>
    <title>《只狼：影逝二度》原型浅考：国之篇</title>
    <url>/%E3%80%8A%E5%8F%AA%E7%8B%BC%EF%BC%9A%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6%E3%80%8B%E5%8E%9F%E5%9E%8B%E6%B5%85%E8%80%83%EF%BC%9A%E5%9B%BD%E4%B9%8B%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>非本人原创，用于个人收藏，转载：<a href="https://www.gcores.com/articles/110129" target="_blank" rel="noopener">https://www.gcores.com/articles/110129</a></p>
<p>作为《只狼》原型浅考的第二部分，国之篇会出现一些与神之篇交叉重叠的内容，推荐没看过神之篇的朋友可以先去了解一下其中提及的原型和典故。</p>
<p><a href="https://www.gcores.com/articles/109450" target="_blank" rel="noopener">《只狼：影逝二度》原型浅考 神之篇</a></p>
<p>本文默认读者了解《只狼》的基础设定和大体剧情，故不会对游戏内信息进行大段落的复述。如果没有实际玩过游戏，或者玩过游戏但不太清楚剧情的朋友，可考虑阅读观看一些梳理剧情的文章和视频，网上有不少狼学家认真创作的优秀作品。</p>
<p>考据的基本原则是<strong>不采纳完全被确认是伪论的观点</strong>，如果说到历史疑论，文中会指出并列举一些有代表性的观点，由读者自行判断是否具有参考价值。个人认为这些不确定的疑论也是历史考据的魅力之一。</p>
<h1 id="国之篇-从苇名国到日本国"><a href="#国之篇-从苇名国到日本国" class="headerlink" title="国之篇 从苇名国到日本国"></a>国之篇 从苇名国到日本国</h1><p><a href="https://image.gcores.com/fb1a5195-5e06-4779-910a-499bde37bcd2.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fb1a5195-5e06-4779-910a-499bde37bcd2.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="官网故事背景介绍"></a></p>
<p>官网故事背景介绍</p>
<p>战国时代，剑圣苇名一心仅靠一代人便夺回国家，成为北方霸主。如今苇名到了危急存亡之时，苇名之将被告知拯救苇名的关键是御子。</p>
<p>战国时代、北国之雄、苇名。</p>
<p>结合这三个条件很容易想到战国时代的<strong>会津芦名氏</strong>，这个大名曾占据日本东北陆奥的会津地区，符合游戏中的地理位置，芦名和苇名在日语中同音，都读作あしな。</p>
<p><a href="https://image.gcores.com/d1777115-6ce7-4efe-bab1-c58ec0e42538.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d1777115-6ce7-4efe-bab1-c58ec0e42538.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>《只狼》中出现的人名，很多都来自于会津芦名氏的关系者，比如苇名氏的庶家平田氏，对应芦名四天的平田氏。但是游戏中的苇名氏与会津芦名氏的对应关系止步于名字对应的程度，接着考据下去毫无收获。</p>
<p>那这个游戏的人物和故事完全没有借鉴具体的历史原型吗？宫崎英高当被问到这个问题时，回答得很巧妙。以下内容来自于<a href="https://www.gcores.com/articles/103447" target="_blank" rel="noopener">方块游戏《只狼 影逝二度》亚太地区发布会宫崎英高机核专访</a>，精彩的提问和回答提供了很多有价值的信息，本文将会多次引用其中的内容。</p>
<blockquote>
<p>《只狼》选择了日本战国时代作为背景，但游戏中的“苇名之国”并非是真实历史中存在的地点。游戏故事是以某些历史为基础改编的，还是完全是架空的呢？是否会有被大众所熟知的战国人物登场的可能？ 宫崎英高：确实，虽然是战国时代，但是“苇名之国”在日本的历史是不存在的，是一个架空国家。里面出现的人物、地点等等，也都是虚构的，因此也不会有大家熟知的战国时代的武将登场。</p>
</blockquote>
<p>宫崎英高明确表示不会出现熟知的战国武将，但是游戏故事是否以某段历史为基础改编，他的回答很含糊。顺着思维惯性，玩家可能会以为《只狼》的故事改编于日本战国的某个历史片段，就像市面上大部分战国题材的游戏一样。</p>
<p>其实还存在另外一种答案，《只狼》确实借鉴了现实历史，但这段历史并不是发生于战国时代。苇名国灭亡的故事原型其实来自于平安时代，平安时代一系列的历史事件导致幕府的诞生，而大名割据的战国乱世则是幕府时代中的一个“小插曲”。宫崎英高这回玩了一个把戏，<strong>《只狼》实际上讲的不是战国的故事，而是与战国有关的故事。</strong></p>
<p>平安时代开始于公元794年，第50代天皇桓武天皇迁都平安京，结束于公元1192年，武家出身的源赖朝一统天下，被封为征夷大将军并建立镰仓幕府。整个平安时代的兴起和衰落，都被塞进这个以战国时代为背景的微观架空世界中。</p>
<p>为什么要用这种手法来构建《只狼》的世界观，是本文最后要探讨的核心问题，当所有零散的线索串联在一起，答案将浮出水面。《只狼》不只是一款好玩的游戏，还隐藏了许多难以想象的深刻思想，并且呈现了FromSoftware逐渐成熟的重构美学。</p>
<p>这里还要多说一句，文中的考据和分析仅出于个人对游戏的理解，没有办法核实制作者真正的想法。无论是脑洞，还是过度解读，都诞生于挖掘游戏丰富内涵的过程之中，希望可以通过本文让更多玩家体会到《只狼》不同层面的魅力。</p>
<p>让我们从游戏中一个微小的细节开始对苇名之地的考据。</p>
<h1 id="日本国名之谜"><a href="#日本国名之谜" class="headerlink" title="日本国名之谜"></a>日本国名之谜</h1><p>如果你玩的不是日文版本，很可能会错过这个细节，游戏中至少有五处提示这个虚构世界的名称：</p>
<p>一、开场动画中的第一段话，说故事发生在战国末期的日本（ひのもと）。</p>
<p><a href="https://image.gcores.com/f63f92f4-5c52-4676-9bcd-c0c9e39e9cb8.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/f63f92f4-5c52-4676-9bcd-c0c9e39e9cb8.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p><a href="https://image.gcores.com/857f824b-b6e9-4674-a6de-edef59e2f32d.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/857f824b-b6e9-4674-a6de-edef59e2f32d.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p><a href="https://image.gcores.com/6ed97211-12e7-4ba2-ba8c-b4eb2adecac0.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/6ed97211-12e7-4ba2-ba8c-b4eb2adecac0.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p><a href="https://image.gcores.com/f63f92f4-5c52-4676-9bcd-c0c9e39e9cb8.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/f63f92f4-5c52-4676-9bcd-c0c9e39e9cb8.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p><a href="https://image.gcores.com/857f824b-b6e9-4674-a6de-edef59e2f32d.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/857f824b-b6e9-4674-a6de-edef59e2f32d.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p><a href="https://image.gcores.com/6ed97211-12e7-4ba2-ba8c-b4eb2adecac0.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/6ed97211-12e7-4ba2-ba8c-b4eb2adecac0.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p><a href="https://image.gcores.com/f63f92f4-5c52-4676-9bcd-c0c9e39e9cb8.png?x-oss-process=image/quality,q_90" target="_blank" rel="noopener"><img src="https://image.gcores.com/f63f92f4-5c52-4676-9bcd-c0c9e39e9cb8.png?x-oss-process=style/content_watermark" alt="img"></a></p>
<p>1 / 3</p>
<p>二、罗伯特的爆竹，在物品描述中提到罗伯特和父亲来到了日之本。</p>
<p><a href="https://image.gcores.com/4a4496ec-5c37-4cf1-9ddd-c246f002ab27.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4a4496ec-5c37-4cf1-9ddd-c246f002ab27.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>三、交给苇名一心苇名酒的对话，也提到被战乱的日本（ひのもと）。</p>
<p><a href="https://image.gcores.com/bdf2ead8-c278-4882-8c67-e5994d1002bb.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/bdf2ead8-c278-4882-8c67-e5994d1002bb.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>四、在幻廊中与变若御子的对话，提到神龙从故乡来到日本（ひのもと）。</p>
<blockquote>
<p>隻狼：竜胤を、返す？ 変若：そうです 竜胤は…　故郷を放たれ、この<strong>日本（ひのもと）</strong>に流れ着いたもの あるべきではない場所に、あるべきではないものがある ゆえに、我らのような歪んだ命を生み出そうとする者が 絶えぬのでしょう 竜胤や、竜胤に連なる我らは…　きっと、帰るべきなのです 西へ…。神なる竜の故郷へと… ただ、如何にしてたどり着くか… それが、まだ分かりません</p>
</blockquote>
<p>五、枭的战斗残渣，物品描述中提到枭的目的是扬名于日之本。</p>
<blockquote>
<p>戦いの残滓・大忍び　梟 心中に息づく、類稀な強者との戦いの記憶 今はその残滓のみが残り、 記憶は確かに狼の糧となった 大忍びの梟は、 身に余る野心を抱き、竜胤の力を欲した さあ、己の真の名を、<strong>日の本</strong>に轟かせるのだ 全てはそのための謀であった</p>
</blockquote>
<p>游戏中凡是出现日本国名的对话语音，字幕写着“日本”，读音是“ひのもと”；出现日本国名的物品描述，文本写着“日の本”。可以推测对话字幕和物品文本不是由同一批人负责，最后没有统一校对。</p>
<p><strong>ひのもと（hinomoto）</strong>，直接写成汉字即“<strong>日の本</strong>”，比较官方的解释是平安时期对日本一词的古典训读，不同于现在把“日本”读作“霓虹”或者“泥碰”。ひのもと的读音应该是出现于“日本”这两个汉字从中国传入日本之前。</p>
<p>日之本作为日本的异称，在一些影视游戏作品中代表了架空世界的日本，比如《甲铁城的卡巴内瑞》和《战国Basara》。但是作为考据文章，不会满足于这种程度的理由，我们默认宫崎英高作品中出现的典故都不是敷衍随意添加的，接着挖一挖“日之本”这个词的来历。</p>
<p>这得先从“日本”这个国名的来历说起。</p>
<p>日本国名的来历至今都没有统一定论，主要原因是<strong>日本过去很长时间都没有文字</strong>。汉字从中国传入日本后，日本人才有能力用文字记载历史，文盲时代发生过什么事情，只能通过日本人流传的口述故事或者其他国家的史料中寻找线索了。</p>
<p>西晋陈寿在《三国志 魏书 倭人传》中记载，中国东面海岛上一个叫“<strong>邪马台</strong>”的国家，统一周围的小国，邪马台女王叫“<strong>卑弥呼</strong>”，被魏帝封为“<strong>亲魏倭王</strong>”。</p>
<p>这是我国对日本比较早的记载，《后汉书》也提了几句倭奴国，不确定和邪马台是不是同一个国家，日本人到现在也没弄清楚邪马台国和女王卑弥呼具体是日本历史中的哪群人。总之我们中国最初称呼日本为<strong>倭国</strong>或<strong>倭奴国</strong>。</p>
<p>后来日本一个强大的氏族占据了现在的关西奈良一带，自称<strong>やまと（yamato）</strong>。随着势力扩张，やまと变成整个国家的名字。汉字传入日本后，日本人选择“<strong>倭</strong>”字来表示やまと，之后奈良时代的元明天皇给やまと换了两个意义更好的汉字“<strong>大和</strong>”，大和主要是国内使用，在外面还是被别的国家叫作倭国。</p>
<p>《晋书》、《宋书》、《隋书》等中国史籍上陆陆续续记载着倭国来天朝进贡的事件，直到《旧唐书》和《新唐书》发生了一件有意思的事情。</p>
<blockquote>
<p>倭国者，古倭奴国也。 日本国者，倭国之别种也。以其国在日边，故以日本为名。或曰：倭国自恶其名不雅，改为日本。或云：日本旧小国，并倭国之地。 ——《旧唐书 列传第一百四十九 东夷》</p>
</blockquote>
<blockquote>
<p>日本，古倭奴也。 后稍习夏音，恶倭名，更号日本。使者自言，国近日所出，以为名。或云日本乃小国，为倭所并，故冒其号。 ——《新唐书 列传第一百四十五 东夷》</p>
</blockquote>
<p>倭国向大唐报告要更改国名，理由是觉得倭字不雅，国家靠近日出所以改名为日本。两个版本的唐史却出现了一些矛盾：《旧唐书》中说<strong>日本是倭国分出去的一个小国，然后吞并了倭国</strong>；《新唐书》中说<strong>倭国吞并了一个叫日本的小国，冒用其名</strong>。</p>
<p>据推测，倭改名日本发生于7世纪初，早于《古事记》和《日本书纪》这两部日本最早的史籍，所以日本方面没有明确的史料记录来解释国名的来历。中国方面则可能是进贡使者语言交流时出现偏差；或是史籍编撰时弄错了，著史书的往往都是后朝人，出现错误不是个例。</p>
<p>日本的国名到底的是怎么来的，出现了许多观点：有人坚持日本这个名字由大和朝廷原创，有人认为是武则天赐予倭国日本之名，还有人怀疑大和朝廷确实盗用了他国的国名。日本东北古代史研究学者<strong>高桥富雄</strong>是最后一种观点的拥护者，他认为“日本”这个名字来自于日本东北地区一个叫<strong>日高见国</strong>的古代国家，大和政权曾击败此国，盗用其名。</p>
<p>神之篇中曾提到过丈的原型是日本武尊。《日本书纪》的景行天皇章节中，景行天皇让日本武尊征讨不服从统治的部落，这段记载中出现了日高见国的名字：</p>
<blockquote>
<p>廿七年春二月辛丑朔壬子、武內宿禰、自東國還之奏言「東夷之中、有<strong>日高見國</strong>、其國人男女、並椎結文身、爲人勇悍、是總曰<strong>蝦夷</strong>。亦土地沃壤而曠之、擊可取也。」秋八月、熊襲亦反之、侵邊境不止。</p>
</blockquote>
<p>日本东北的部落被大和朝廷称为<strong>虾夷</strong>，虾夷建立了日高见国，人人纹身，民风彪悍，土地肥沃。紧接着下面一段是《日本书纪》中日本武尊讨伐虾夷的具体描述。</p>
<blockquote>
<p>爰日本武尊、則從上總轉、入<strong>陸奧國</strong>。時、大鏡懸於王船、從海路������於葦浦、横渡玉浦、至蝦夷境。<strong>蝦夷賊首嶋津神・國津神</strong>等、屯於竹水門而欲距、然遙視王船、豫怖其威勢而心裏知之不可勝、悉捨弓矢、望拜之曰「仰視君容、秀於人倫、若神之乎。欲知姓名。」王對之曰「<strong>吾是現人神之子也。</strong>」於是、蝦夷等悉慄、則褰裳披浪、自扶王船而着岸。仍面縛服罪、故免其罪、因以、俘其首帥而令從身也。蝦夷既平、自<strong>日高見國</strong>還之、西南歷常陸、至甲斐國、居于酒折宮。</p>
</blockquote>
<p>这段描述信息很多，讲日本武尊来到<strong>陆奥国</strong>，也就是后文将会反复提及的<strong>奥州</strong>，位于现在日本的东北地区。虾夷的首领被视为<strong>国津神</strong>，所以当我们拨开神话的外衣，所谓的国津神和恶神，指代的是不服从统治的人。日本武尊征服虾夷的方法是公开了自己的身份，现人神指的是天皇，现人神之子即皇子，皇子在最早的史书中写作御子。平定虾夷后，日本武尊离开了日高见国。</p>
<p>总结成一句话：在不知道具体时间的过去，日本武尊（丈）来到陆奥（苇名），自曝天皇之子（御子）的身份，使当地人折服。</p>
<p>虽然无法确定日本的国名是否源于日高见国，以及该国是否真实存在，但是在日本的东北地区确实有把日本读作ひのもと的旧俗，这个读音比にほん（霓虹）和にっぽん（泥碰）古老得多。</p>
<p>平安时代末期的歌学书《袖中抄》中记载，坂上田村麻吕在东北征夷途中，用弓箭箭尾在一块石碑上刻下“日本中央”四个字，这块石碑被称为<strong>壶之碑（つぼのいしぶみ）</strong>，此碑一直是未被找到的传说之物。1949年青森县发现了一块刻有“日本中央”的石碑，位置与史料记载有所矛盾，坂上田村麻吕东北征夷最北到过志波城（现在的岩手县），而青森县位于日本本州的最北端，这块碑被认为也有可能出自其他征夷将领之手。</p>
<p><a href="https://image.gcores.com/4b2b3479-b263-4904-983d-f22a677cecb4.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4b2b3479-b263-4904-983d-f22a677cecb4.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><strong>日本中央之碑</strong>现在被保存在青森县的日本中央之碑纪念馆中，学界无法鉴定此碑是否是《袖中抄》中所记载的壶之碑。如果此碑不是后世伪造之物，说明“日本”的地理概念可能发生过变化，过去指代东北地区，区别于西南的大和朝廷。不考虑真伪，单看这段故事本身也很蹊跷，当时的政治中心在京都一带，难以解释为什么会留下坂上田村麻吕在东北刻碑标记日本中央的事迹。</p>
<p><a href="https://image.gcores.com/c4d38152-21d1-4c55-852a-28c348c09191.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c4d38152-21d1-4c55-852a-28c348c09191.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="日本中央之碑"></a></p>
<p>日本中央之碑</p>
<p>室町时代，东北地区的陆奥豪族安东氏<strong>安藤康季</strong>，被称为<strong>奥州十三湊日之本将军</strong>，并且得到了当时天皇的认可。</p>
<p><a href="https://image.gcores.com/e55373b7-f062-49fe-b7e9-87ce9ebfc3e3.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e55373b7-f062-49fe-b7e9-87ce9ebfc3e3.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="奥州十三湊日之本将军 安倍安藤氏"></a></p>
<p>奥州十三湊日之本将军 安倍安藤氏</p>
<p>《诹方大明神绘词》也有相关记载，14世纪初北海道的虾夷分为三个团体，分别为<strong>渡党虾夷</strong>、<strong>唐子虾夷</strong>和<strong>日之本虾夷</strong>。此时南边相邻的日本本州东北是安东氏的管辖范围。</p>
<p><a href="https://image.gcores.com/1acfd4d2-1872-42fa-86f9-926742e9abfa.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1acfd4d2-1872-42fa-86f9-926742e9abfa.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>到了战国时代，丰臣秀吉在信件中曾多次使用日之本的字样，信中一起出现的奥州、出羽和津轻皆是日本东北的地名。</p>
<blockquote>
<p>出羽・奥州・<strong>日ノ本</strong>之果迄モ被相攻、御仕置等堅可被仰付候 ——《武家事纪》  </p>
</blockquote>
<blockquote>
<p>奥州・津軽・<strong>日の本</strong>まで、さしつかわされ、そのうへ、国々御検地 ——《太阁样军记之内》</p>
</blockquote>
<p>日本的东北地区与日之本这个名字存在着微妙的联系，而《只狼》的故事发生在东北，架空世界的名字是日之本，这就很有意思了。</p>
<p><a href="https://image.gcores.com/91348e83-7bf5-4a0c-a275-116e84a63c04.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/91348e83-7bf5-4a0c-a275-116e84a63c04.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="日本国旗 日之丸"></a></p>
<p>日本国旗 日之丸</p>
<p>存在争议的不仅是国名，日本的国旗日之丸也可能起源于东北。普遍认为日之丸的原型是曾经代表大和朝廷的锦之御旗，以及平安末期源平合战中双方所用的红旗和白旗。</p>
<p><a href="https://image.gcores.com/468c3708-5a43-4c06-a77e-c7d86de49330.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/468c3708-5a43-4c06-a77e-c7d86de49330.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="锦之御旗"></a></p>
<p>锦之御旗</p>
<p>历史记载中出现最早的锦之御旗是1221年承久之乱时后鸟羽上皇赐予将领的赤底金日银月锦旗，代表天皇和朝廷，朝廷举兵反抗北条氏掌权的镰仓幕府最后以兵败告终。下文会提到这个北条氏即是这段历史里成了新“鱼王”的平氏后人。</p>
<p><a href="https://image.gcores.com/af8f3f32-3ec9-436e-ad91-0df2b36a2f74.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/af8f3f32-3ec9-436e-ad91-0df2b36a2f74.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鼉太鼓"></a></p>
<p>鼉太鼓</p>
<p>《只狼》中源之宫的<strong>鼉太鼓</strong>上出现过金日和银月，此太鼓的原型由镰仓时代源赖朝献给朝廷，而源赖朝一家的短命血脉则是被上面提到的北条氏掐断的。</p>
<p>朝廷沦落成起兵反抗的一方，并被武家镇压，其直接原因是平安末期源氏和平氏席卷全国的战乱，最后源氏获得胜利掌握了实权。在源平合战中，源氏持白旗，平氏持红旗。</p>
<p><a href="https://image.gcores.com/5fa7649d-a949-46ba-aac8-1881eb3a5210.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5fa7649d-a949-46ba-aac8-1881eb3a5210.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源平合战图屏风 一之谷·屋岛合战"></a></p>
<p>源平合战图屏风 一之谷·屋岛合战</p>
<p>但无论是朝廷的锦之御旗，还是源平的白旗红旗，都与现在日本国旗上的日之丸有所差别。</p>
<p>一个更接近现在日之丸的线索出现在京都清水寺的《清水寺缘起绘卷》上，该绘卷记载了平安初期（公元800年左右）坂上田村麻吕讨伐虾夷的过程，虽然绘卷创作于1517年，坂上田村麻吕征夷的事迹却早于源平合战和承久之乱。</p>
<p><a href="https://image.gcores.com/7e126bf6-ac8f-437b-8002-5beaa616fc4a.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7e126bf6-ac8f-437b-8002-5beaa616fc4a.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="清水寺缘起绘卷 中卷"></a></p>
<p>清水寺缘起绘卷 中卷</p>
<p>这幅画的右侧是代表朝廷的坂上田村麻吕军，左侧被击溃逃跑的是虾夷军，注意看虾夷战船上的标志，和现在日本国旗的日之丸基本一样。虽然绘卷创作时距离坂上田村麻吕征夷的时代已经过去700多年，但是搞错标志这种低级错误应该是不会发生的。</p>
<p>这张图中另外一个有趣的细节是<strong>乌云中的雷神协助朝廷军队战胜了虾夷</strong>。游戏中苇名城天守阁道场中挂着一副类似的画，古代苇名将士依水而战，侵略者伴随着乌云和雷电而来，双方都穿着平安时代的大铠。</p>
<p><a href="https://image.gcores.com/4a1bc30f-a617-44c5-966a-f4821cb3bed6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4a1bc30f-a617-44c5-966a-f4821cb3bed6.png?x-oss-process=image/resize,limit_1,m_lfit,w_1500,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城天守阁道场挂画"></a></p>
<p>苇名城天守阁道场挂画</p>
<p>国名“日本”和国旗“日之丸”是不是“借用”的呢？本文仅从游戏考据的角度粗浅查阅了一些资料，无法给出答案。如果日本的国名和国旗确实来源于异族，显而易见这将有损于民族自尊心，不如将这些问题永久搁置，反而还增添了几分神秘感。</p>
<p>用较长的篇幅来解释这些看似与游戏关系不大的事情，主要有两个原因：</p>
<p>一是有助于我们重新审视《只狼》世界的地理位置，游戏中提到的日之本不一定完全对应现实中的日本国境。龙之返乡所提到的西方，也就不一定要离开现实中的日本本土，也许只是到关西或者九州等日本西侧地区。</p>
<p>二是想更自然地过渡到苇名人民的历史原型，那些曾经生活在日本东北的虾夷人，他们不断抵抗大和朝廷的侵略，最终还是未能避免从历史上消失的命运。</p>
<h1 id="虾夷-不肯被朝廷招降的“异端”"><a href="#虾夷-不肯被朝廷招降的“异端”" class="headerlink" title="虾夷 不肯被朝廷招降的“异端”"></a>虾夷 不肯被朝廷招降的“异端”</h1><blockquote>
<p>天處乎上，地處乎下。居天地之中者曰中國，居天地之偏者曰四夷。</p>
</blockquote>
<p>大和民族在“如何与其他民族相处”这个问题上，受到了邻邦中国的华夷观念影响。中华民族认为华夏为文明礼仪之邦，立于世界中心，华夏之外皆为蛮夷。根据方位，给四周的外族起了不同的称呼，东夷、南蛮、西戎、北狄，统称四夷。</p>
<p><a href="https://image.gcores.com/9332d394-a361-41ca-b296-6e8f5d6b4b4e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9332d394-a361-41ca-b296-6e8f5d6b4b4e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="华夷观念"></a></p>
<p>华夷观念</p>
<p>作为中国的学生，日本也认同了这套观念，视大和朝廷为文明开化，南北两侧为化外之地，东北的夷人则被称为虾夷。游戏中罗伯特爆竹的物品描述中提到的南蛮，指的是战国时代从南洋渡海而来进行贸易活动的西洋人。</p>
<p>夷人尚未王化，从朝廷的角度开疆扩土自然是名正言顺的事情。无论是神话时代平定苇原中国、日本武尊征熊袭征陆奥，无非做得都是类似的事情。东北地区距离关西的大和朝廷较远，所以虾夷一直都没被完全征服，这种状态一直持续到平安时代。</p>
<p>根据读音不同，虾夷分为<strong>えみし（emishi）</strong>和<strong>えぞ（ezo）</strong>两种，二者都写作虾夷，所代表的群体却不一样。</p>
<p>虾夷（えみし）是我们上面说的<strong>古代虾夷</strong>，汉字也可写作“毛人”，虾夷生活在关东和东北地区，从上古时代开始，古代虾夷一直没有被大和朝廷完全征服，直到平安时代初期，坂上田村麻吕击败虾夷首领阿弖流为（アテルイ），朝廷开始建立军事驻地加强对东北的控制。虾夷名字的由来据说是因为他们毛发浓密如虾须。虾夷与大和民族主要区别不在于民族差异，而是政治立场不同，他们不肯服从朝廷统治，根据记载虾夷部落的人种混杂，也有来自大和的移民。</p>
<p>虾夷（えぞ）是指平安时代结束到现代，生活在北海道的<strong>阿依努族</strong>原居民，阿依努族是目前唯一被日本政府承认的本土少数民族，他们所居住的北海道以前一直被称为虾夷地。</p>
<p><a href="https://image.gcores.com/a89eda88-f6a9-4b5c-a87c-15e4d039b2f1.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a89eda88-f6a9-4b5c-a87c-15e4d039b2f1.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="阿依努人"></a></p>
<p>阿依努人</p>
<p>前后两者之间的关系目前没有权威的定论，有的观点认为东北古代虾夷被夺去家园后逃到北海道，变成了现代的阿依努人；有的观点认为古代东北虾夷和北海道虾夷是完全不同的种族，二者在某个时代共存，还有观点认为两种情况兼有，不是绝对的继承或者共存关系。本文暂且假定古代虾夷和北海道虾夷存在模糊的承接关系，都遭遇了大和朝廷的侵略和统治。</p>
<p>本文主要讨论对象是古代虾夷えみし，如果不特别指出，下文中出现的虾夷皆指えみし，而北海道虾夷えぞ直接用阿依努人表示。</p>
<p>想知道虾夷的来历，需要追溯到一个更根本的问题：日本人是从哪里来的？</p>
<p><a href="https://image.gcores.com/c63ce12e-9e8e-4779-b742-9035e23789b3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c63ce12e-9e8e-4779-b742-9035e23789b3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="绳文人"></a></p>
<p>绳文人</p>
<p>公元前12000年左右，日本进入<strong>绳文时代</strong>，绳文人以打猎和采集为主。之所以叫作绳文时代，是因为当时出现了花纹复杂的绳文土器。《塞尔达传说 旷野之息》中席卡古代科技的风格借鉴了这些绳文土器，让新手闻风丧胆的守护者实际上是倒置的火焰土器。</p>
<p><a href="https://image.gcores.com/1366aacb-3e27-423b-878d-87056fcc6316.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1366aacb-3e27-423b-878d-87056fcc6316.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="嘀嘀嘀嘀嘀"></a></p>
<p>嘀嘀嘀嘀嘀</p>
<p>公元前3000年左右，日本从绳文时代过渡到<strong>弥生时代</strong>，人们开始大面积耕作田地，形成农耕社会。相比狩猎和采集，农业大幅度提升了生产效率，村庄可以容纳更多人口，部族也更加强大。</p>
<p><a href="https://image.gcores.com/554504ac-c60a-451c-8e3b-dceeb45528ed.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/554504ac-c60a-451c-8e3b-dceeb45528ed.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="弥生时代"></a></p>
<p>弥生时代</p>
<p>日本是如何从狩猎采集社会转变成农耕社会的，也是说法各异。一种观点是绳文时代的日本人自学成才，形成农耕文化自然过渡到弥生时代。</p>
<p>另一种观点认为科技进步源于“抄作业”。日本公元前3000年左右才形成农耕社会，而此时中国人已经种了4000多年地，携带成熟耕种技术的新移民从大陆来到日本导致日本科技跳级。弥生时代的这些新移民被称为弥生人，他们淘汰并同化了冰河期从大陆踏冰而来的第一批移民，也就是原住民绳文人。</p>
<p><a href="https://image.gcores.com/1394dafe-df01-457d-8d20-b92a8a699f7a.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1394dafe-df01-457d-8d20-b92a8a699f7a.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>现代日本人被认为是绳文系和渡来系融合的后代。有些日本人呈现出鲜明的绳文人外貌特征，毛发茂盛，浓眉大眼，有悖于我们对日本人的刻板印象，通过对比图片能体会到具体的差别。</p>
<p><a href="https://image.gcores.com/7263da47-745b-46a4-bc0a-18b22bdb2a41.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7263da47-745b-46a4-bc0a-18b22bdb2a41.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><a href="https://image.gcores.com/4a016ee4-5952-49b0-87ad-6733b71d6ac3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4a016ee4-5952-49b0-87ad-6733b71d6ac3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><a href="https://image.gcores.com/402a68f4-daaf-44cd-93dd-af4e49cfc558.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/402a68f4-daaf-44cd-93dd-af4e49cfc558.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><a href="https://image.gcores.com/3e33b8b2-d29d-4f82-ac4a-519291c017f4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3e33b8b2-d29d-4f82-ac4a-519291c017f4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="误"></a></p>
<p>误</p>
<p>《只狼》中的角色形象也有这种外貌特征上的差异。男性角色中，佛师、枭和鬼形部等人有明显的绳文人特征，毛发重眼窝深，而狼、弦一郎和一心等人的面貌更倾向于弥生人，永真、阿蝶、变若御子等女性不太好判断。</p>
<p><a href="https://image.gcores.com/d3b34640-96ef-4b06-92df-713658d5ea90.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d3b34640-96ef-4b06-92df-713658d5ea90.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="当然也有可能只是正派脸和反派脸的区别……"></a></p>
<p>当然也有可能只是正派脸和反派脸的区别……</p>
<p>大部分渡来系移民从日本西侧登陆，将先进文化自西向东扩散，以关西为中心诞生了大和政权。而在偏远的日本东侧，原住民与渡来者交集较少，保留了绳文的文化和习俗，以狩猎采集为生，文明程度和生产力都不如蓬勃发展的西方大和。</p>
<p>中央政权和土著之间的摩擦延续到平安时代，大和朝廷终于完成了统一日本的愿景，然而没过多久，天皇的朝廷被武士阶级取代，进入了长达700年的幕府时代。《只狼》让玩家通过弱势的虾夷人视角见证这段曲折的历史。</p>
<h1 id="桓武天皇与平安时代的开启"><a href="#桓武天皇与平安时代的开启" class="headerlink" title="桓武天皇与平安时代的开启"></a>桓武天皇与平安时代的开启</h1><p>首先我们需要重新定位一下游戏世界的时间轴。从故事原型的角度，《只狼》世界的“现在”对应平安时代的最后一刻，而没有直接表现的“过去”对应平安时代的初期和中期。在保持战国题材外皮的前提下，实际上《只狼》的时间轴应该向前挪四百年左右。</p>
<p>游戏中大部分古老事物的原型，都与开启平安时代的桓武天皇有关。</p>
<p><a href="https://image.gcores.com/ca94ae09-8d44-4278-b608-c684cf54c39d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ca94ae09-8d44-4278-b608-c684cf54c39d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="坐在龙椅上的桓武天皇"></a></p>
<p>坐在龙椅上的桓武天皇</p>
<p><strong>桓武天皇</strong>是日本第五十代天皇，<strong>生母高野新笠是百济武宁王的后代</strong>，说到这里可能已经有朋友察觉得到，这特殊的出身与游戏中何物相关，关于这点下文会细说。</p>
<blockquote>
<p>此国山河襟帯、自然作城。因斯勝、可制新号。宜改山背国、為山城国。又子来之民、謳歌之輩、異口同辞、号曰平安京。</p>
</blockquote>
<p>平安时代开始的标志是桓武天皇迁都<strong>平安京</strong>，通过游戏和官方设定集的信息，可以确定平安京的宫城<strong>平安宫</strong>就是源之宫的原型。在“再访源之宫”章节会罗列出一系列线索，说明北方高山上这座神秘的宫殿与日本曾经的政治中心有何关系。</p>
<p><a href="https://image.gcores.com/d9698866-ac6b-4a9f-b1a5-2ef534eed4cd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d9698866-ac6b-4a9f-b1a5-2ef534eed4cd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平安京模型"></a></p>
<p>平安京模型</p>
<p>迁都平安京，最主要的目的是摆脱奈良政治势力和奈良佛教的影响，当时佛教与政治关系紧密，新的皇都需要以平安京为中心的新派佛教，桓武天皇派遣<strong>最澄</strong>和<strong>空海</strong>入唐求法，两位大师返回日本后，分别创建了<strong>天台宗</strong>和<strong>真言宗</strong>，此二宗后来成为平安佛教的核心。游戏中的仙峰寺与平安二宗关系紧密，在“仙峰寺与佛教”章节，让我们拆解仙峰寺层层重叠的原型组合，探讨佛教在《只狼》中的现实意义。</p>
<p>神之篇考据了樱龙原型之一是<strong>诹访大明神</strong>，也就是日本神话中的建御名方神。掌管诹访大社的诹访氏拥有特殊的大祝传承，现人神大祝代表了神明本身。初代大祝<strong>诹访有员</strong>在一些文献中记载是桓武天皇的皇子，对应了游戏中御子的起源。</p>
<p>平安时代初期，皇室的变动埋下了一个伏笔：<strong>臣籍降下</strong>。从桓武天皇开始，由于皇族人数太多，给朝廷造成不小的经济压力和权力交接时的隐患，于是一些没有机会继承皇权的皇子们被降为臣籍，他们失去了名义上的皇族身份，而实际上同皇族血脉相同，在某些需要的时刻，屡次出现恢复皇籍的例子，比如宇多天皇和醍醐天皇。</p>
<p>降籍的皇族中最著名的氏族，当属平安末期对抗的<strong>源氏</strong>和<strong>平氏</strong>。值得注意的是，这里所说的源氏和平氏，指的是<strong>桓武平氏</strong>分支<strong>伊势平氏</strong>和<strong>清和源氏</strong>分支<strong>河内源氏</strong>，因为这两个分支实在太有出息了，后世被直接以源平称呼，桓武平氏来自于桓武天皇的五皇子，而清和源氏来自于第56代天皇清和天皇。相同的赐姓不代表一定有比皇室更深的血缘关系，比如清和源氏与村上源氏，但是他们一定都来自于皇室。源平合战的源氏和平氏，分别对应游戏中的<strong>淤加美一族</strong>和<strong>壶之贵人</strong>。</p>
<p>平安时代初期的这些重要事件，几乎构成了《只狼》架空世界中一切古老事物的起源：</p>
<ul>
<li>源之宫的起源</li>
<li>仙峰寺的起源</li>
<li>龙胤和御子的起源</li>
<li>淤加美一族和壶中一族的起源</li>
</ul>
<p>本章节的最后，还要再讲一件桓武天皇的丰功伟绩：派遣征夷大将军<strong>坂上田村麻吕</strong>讨伐东北虾夷，对应了<strong>苇名之地被镇压的历史</strong>。</p>
<p>大和朝廷先是派纪古佐美去讨伐镇压虾夷，结果在东北屡吃败仗，虾夷首领<strong>阿弖流为</strong>以少胜多，战胜了纪古佐美的朝廷军队。</p>
<p>坂上田村麻吕接替纪古佐美出征，一步步将战线向北推移，最后成功击败并劝降了阿弖流为，将其押送至京城。坂上田村麻吕认为东北是虾夷之地，应该以夷治夷，有利于当地的统治和稳定，这种看法却遭到了宫中贵族的反对，贵族们认为夷人不可信，不能留下后患，于是阿弖流为被斩首。</p>
<p>游戏中没有明说苇名之地最初是如何被侵略的，也没有出现一个以坂上田村麻吕为原型的角色，但他对推动整个故事有极其重要的作用，文章末尾对DLC猜测部分会进一步分析以坂上田村麻吕为原型的BOSS出现的可能性。</p>
<p><a href="https://image.gcores.com/4132bc1d-6869-4284-b4e2-15266af3aee4.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/4132bc1d-6869-4284-b4e2-15266af3aee4.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="东北领土收复进度"></a></p>
<p>东北领土收复进度</p>
<p>随着虾夷被瓦解，大和朝廷在东北逐步建立镇守的城寨，归顺的虾夷被称为<strong>俘囚</strong>。天高皇帝远，只靠远在西侧的中央朝廷派遣官吏和军队难以有效统治北方，朝廷要求一些氏族移居至此地管理俘囚，这些俘囚之主在东北生根发芽形同军阀，于是北方又出现了新的威胁。</p>
<h1 id="中央与地方的角逐"><a href="#中央与地方的角逐" class="headerlink" title="中央与地方的角逐"></a>中央与地方的角逐</h1><p>距离坂上田村麻吕征夷大约过去了二百年，当时东北最强大的氏族是<strong>安倍氏</strong>。看到这个姓氏你可能会想到当今某位大人物……的小弟。</p>
<p><a href="https://image.gcores.com/3effc6d8-9190-4090-a68b-2cd0f9f13aa6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3effc6d8-9190-4090-a68b-2cd0f9f13aa6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="恭喜猜对了，安倍晋三就是安倍氏的后裔"></a></p>
<p>恭喜猜对了，安倍晋三就是安倍氏的后裔</p>
<p><a href="https://image.gcores.com/740e5c8c-3e5c-4f49-b9ed-a5813ac1c0da.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/740e5c8c-3e5c-4f49-b9ed-a5813ac1c0da.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="安倍晋三族谱"></a></p>
<p>安倍晋三族谱</p>
<p>安倍氏在自己的领地修建防守用的军事要塞，对朝廷的上贡也开始怠慢，大和朝廷怀疑安倍氏可能会造反，命令东国的源氏去讨伐安倍氏。</p>
<p>东北看似不毛之地，为什么会被朝廷如此忌惮？一是<strong>军事优势</strong>，虾夷民风彪悍，以打猎为生，从小受到充分的训练，即便归顺也比普通大和士兵善战；二是<strong>经济优势</strong>，东北地区矿藏丰富，尤其盛产黄金，《宋史》对此有所记载：</p>
<blockquote>
<p>其地東西南北各數千里，西南至海，東北隅隔以大山，山外即<strong>毛人國</strong>。 國之東境接海島，<strong>夷人所居，身面皆有毛。東奧州產黃金</strong>，西別島出白銀，以爲貢賦。 ——《宋史 卷四百九十一 列傳第二百五十 外國七 日本國》</p>
</blockquote>
<p>源氏讨伐安倍氏的这场战役，名为<strong>前九年之役</strong>，政府侧主力是河内源氏<strong>源赖义</strong>，源赖义的盟军之中有一个我们很熟悉的名字，<strong>诹访氏</strong>。</p>
<p>神之篇中诹访大祝受到神罚的故事前半段就是这场前九年之役。<strong>诹访为信</strong>身为当时的大祝不能离开诹访，为了协助源赖义他让自己的儿子<strong>诹访为仲</strong>出征奥州，让我们看看奥州这边都发生了什么。</p>
<p>源赖义联合东北出羽地区的<strong>清原氏</strong>击败了陆奥地区的<strong>安倍氏</strong>，并将安倍氏一族赶尽杀绝，被牵连的同党<strong>奥州藤原氏</strong>即是苇名氏的原型。奥州藤原氏的祖先是平安中期的<strong>藤原秀乡</strong>，在神之篇中讲了他帮助龙女退治百足获得蜈蚣切，也就是狼从变若御子取不死斩的原型。此时的奥州藤原氏还只是寄人篱下，初代目<strong>藤原清衡</strong>的父亲<strong>藤原经清</strong>是朝廷派到东北的官吏，因为迎娶<strong>安倍赖时</strong>之女，站错了队伍。</p>
<p>源赖义对藤原经清有超过一般人的仇恨，责备经清的氏族曾经效忠于源氏，如今却变成叛徒，为了加剧经清死亡的痛苦，行刑时使用的是一把<strong>锈刀</strong>。</p>
<p><a href="https://image.gcores.com/b4e4e25e-9e22-439f-bd2f-fa2c2e05681f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b4e4e25e-9e22-439f-bd2f-fa2c2e05681f.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="锈丸"></a></p>
<p>锈丸</p>
<p>前九年之役从结构上来看，与《只狼》中上古时代淤加美一族对苇名的侵略战有一定的相似之处。根据龙之舞面道具上的描述，淤加美一族借助神龙之力，而前九年之役源氏得到了诹访氏的协助。苇名众为了对抗淤加美一族铸造了对其有奇效的锈丸，历史上正好相反，源赖义用锈刀杀死了奥州藤原氏之祖藤原经清。</p>
<p>前九年之役的结果是安倍氏覆灭，藤原经清被处死。经清之子<strong>藤原清衡</strong>逃过一劫，他的母亲改嫁出羽清原氏<strong>清原武贞</strong>，藤原清衡也随之改姓清原。清原氏协助源赖义讨伐安倍氏有功，继承了奥州六郡的领土，源氏离开奥州返回东国，诹访氏也返回了诹访。</p>
<p>清衡的母亲改嫁清原家后，与清原武贞生了一个同母异父的弟弟<strong>清原家衡</strong>，清原武贞原来还有一个叫<strong>清原真衡</strong>的儿子，到这里也许有人已经分不清谁是谁了，可以参照下面这张关系图，红框中的五个人是下一场斗争的参与者：</p>
<p><a href="https://image.gcores.com/3c388808-237e-4df6-8711-996eb8ec9dcd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3c388808-237e-4df6-8711-996eb8ec9dcd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="此图右下画错了，泰衡和国衡同父异母"></a></p>
<p>此图右下画错了，泰衡和国衡同父异母</p>
<p>二十年后奥州再次发生战事，史称<strong>后三年之役</strong>。事情起因是清原武贞去世，族内开始争夺清原氏的继承权。后三年之役也是神之篇中诹访大祝被神罚故事的后半段，诹访为仲此时已经继承了大祝之位，按规矩是不能离开诹访的，但他执意要亲自跟随源赖义之子<strong>源义家</strong>再次出征奥州，虽然打了胜仗却落得悲惨的下场。</p>
<p>在这场清原氏的内斗中，源氏本来打算协助第一继承人清原真衡，不料真衡突然病死。奥州六郡领土遗产准备平分给清衡和家衡各三郡，但是家衡以血缘原因不满分配结果，偷袭清衡的住所，清衡再次逃过一劫，然而他的家人都死于这次偷袭。</p>
<p>此时走投无路的清衡求助了二十年前的灭族仇人源氏，在源氏的帮助下，后三年之役以清衡淘汰了清原氏其他所有继承者而告终。</p>
<p>朝廷以内斗为由，没有对源义家和清衡封赏，然而二者在前九年之役和后三年之役中得到的好处，给一百年后两大家族最终决战留下伏笔。源氏两战成名，源义家用自己的财产分赏将士，进一步巩固源氏在东国的地位和声望。清原清衡收回奥州全部的领地并改回原姓藤原，奥州藤原氏从此成为北方霸主，统治日本东北长达百年。</p>
<p><a href="https://image.gcores.com/49efd66d-81cb-455d-a318-7245b361bdfc.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/49efd66d-81cb-455d-a318-7245b361bdfc.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="历史原型的时间轴对照"></a></p>
<p>历史原型的时间轴对照</p>
<p>《只狼》的架空世界可以看作是平安时代的简化版本，游戏中出现大量收养设定代替了复杂的家族血缘，使人物关系变得简单。</p>
<p>后三年之役存在一个转折，因为清原氏第一继承人暴毙，源氏向藤原清衡伸出援手助其复兴氏族，然而百年之后奥州藤原氏所创造的一切又都被源氏后人收回。《只狼》中是否曾经存在这样的伏笔呢？苇名一心二十年前夺回自己的国家，临终前却坦然接受了苇名必将灭亡的命运，从故事因果循环的角度，或许他曾经借助某种力量，料到了将来要付出什么代价。</p>
<p>苇名一心为什么藏有黑色不死斩，以及盗国之战中他为什么需要使用黑色不死斩，游戏没有明确的交代，在此做一些猜想，可当作二次创作来看。</p>
<p>不死斩最主要的用处是斩杀不死之力衍生出的不死之物，二十年前使用不死斩也许是为了针对前统治者势力的御子或者契约者。一心在某处求得黑色不死斩后，斩杀了龙胤相关者，因此引发了两件事情。一是让他意识到维系一个国家不能依赖龙胤，二是樱龙和龙胤因此受到不良的影响，导致苇名之地的衰败。这两件事照应了苇名最后的灭国，也解释了为什么一心坚持保护现任御子九郎但不依赖他的力量。</p>
<p>在讲奥州藤原氏是如何灭亡之前，先看看平泉这个城市，和游戏中的苇名城有什么样的对应关系。</p>
<h1 id="黄金之国-奥州平泉"><a href="#黄金之国-奥州平泉" class="headerlink" title="黄金之国 奥州平泉"></a>黄金之国 奥州平泉</h1><p>藤清衡把根据地定在奥州的<strong>平泉</strong>（现在岩手县一关市北侧）。通过前后三代人接近一百年的努力，平泉成为平安后期日本第二大的城市，据推测当时平安京人口约10-15万，平泉人口约5万，不过看平泉的还原图似乎城市规模不算大。</p>
<p><a href="https://image.gcores.com/c8d28769-5ab6-41f5-93fc-9f0cfb2ee688.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c8d28769-5ab6-41f5-93fc-9f0cfb2ee688.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平泉"></a></p>
<p>平泉</p>
<p>苇名城具体在哪里呢？游戏中的道具描述中提供了一些线索。</p>
<blockquote>
<p>霧がらすの羽 霧がらすの羽を、束ねたもの 忍義手に仕込めば、忍義手となる <strong>葦名より北に離れた薄井の森</strong>には、 正体掴めぬ猛禽が棲む 中でも霧がらすは、 確かにいるが捕えた者はおらぬ 掴まえたとして、羽を残して消えてしまうのだ</p>
</blockquote>
<blockquote>
<p>まぼろしクナイ まぼろしお蝶の使ったクナイ 「手裏剣」の強化義手忍具の作成に使える 投げると音が鳴り、 クナイを追ってまぼろしの蝶々が飛ぶ うら若き頃、お蝶は、<strong>葦名より北に離れた 薄井の森</strong>にて修行を積んだ 彼の森は、霧とまぼろしで満ちている 幻術を修めるには、またとない場所だ</p>
</blockquote>
<p>雾璃鸦之羽和幻之苦无的物品描述中提到一个叫<strong>薄井森林</strong>的地方，并且二者都强调薄井森林位于离苇名稍微远一些的北方。</p>
<p>根据薄井这条线索，试着寻找一下是否有符合条件的地点。虽然没有找到薄井森林，通过《旧高旧领取调帐》数据库（只能追溯到江户时代的记录），可以查到日本东北曾经有两个叫薄井村的村庄，二者都位于现在的秋田县。</p>
<p><a href="https://image.gcores.com/709b0e94-27d9-4462-93bc-2c9755bc24d3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/709b0e94-27d9-4462-93bc-2c9755bc24d3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《旧高旧领取调帐》中薄井村的记录"></a></p>
<p>《旧高旧领取调帐》中薄井村的记录</p>
<p>平鹿郡的薄井村（一号）1889年与宫田村合并为馆合村，在现在的横手市雄物川町薄井一带。</p>
<p>山本郡的薄井村（二号）1876年与比井野村合并为二井村，1902年二井村改称为二井町，经过反复合并，2006年并入能代市。</p>
<p><a href="https://image.gcores.com/806b950f-db96-4305-9c2e-3bdc094e8b6e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/806b950f-db96-4305-9c2e-3bdc094e8b6e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平泉与薄井村的地理位置"></a></p>
<p>平泉与薄井村的地理位置</p>
<p>这两个薄井村都在平泉的西北侧，其中薄井村一号的所在地更符合游戏中描述的位置，距离平泉约50公里。</p>
<p>《只狼》中另一处出现薄井的地方是枭在修罗结局里说出了自己的姓氏是薄井，但是薄井森林和薄井姓氏在游戏中没有表示出直接的相关性，所以本文将二者分开考据，枭的章节再讲他的姓氏有什么典故。</p>
<p>第二个与苇名城有明显地理位置关系的地方是<strong>金刚山仙峰寺</strong>。默认游戏中地图是上北下南的话，仙峰寺位于苇名城北方的金刚山上。最后苇名城被内府入侵烧毁时，大火没有波及到仙峰寺。</p>
<p><a href="https://image.gcores.com/dfe5f440-c4ea-4b45-ae89-9a0e9882057c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/dfe5f440-c4ea-4b45-ae89-9a0e9882057c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="中尊寺 金色堂"></a></p>
<p>中尊寺 金色堂</p>
<p>平泉最著名的寺庙是平泉以北的<strong>关山中尊寺</strong>，由藤原清衡修建。随后二代目基衡、基衡夫人和三代目秀衡也分别修建了毛越寺（后重建）、观自在王院（现遗迹）和无量光院（现遗迹），可惜平泉覆灭时这些寺院都被大火烧毁，唯独中尊寺得以幸存。</p>
<p>游戏一开始的目标是去苇名城的望月楼解救被软禁的九郎。</p>
<p><a href="https://image.gcores.com/ad62348e-c819-4255-81ab-8fc8c018c6d3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ad62348e-c819-4255-81ab-8fc8c018c6d3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="望月楼阁"></a></p>
<p>望月楼阁</p>
<blockquote>
<p>花菖蒲の文 何者かによって井戸底に投げられた文 　九郎殿の狼殿へ 　貴殿の宿命、今は<strong>月見櫓</strong>にあり 井戸底を脱し向かわれたし 　刃が無くとも、貴殿ならば 忍び行けば辿り着けましょう</p>
</blockquote>
<p>通过花菖蒲之信和偷听看守士兵的对话，可知软禁九郎的地方叫<strong>望月楼</strong>，日文写作“<strong>月見櫓</strong>”。月见橹是战国时代天守用于赏月的阁楼，窗户打开后视野宽阔，用于吃喝玩乐欣赏月亮。月见橹一般都在天守的东侧，这一点也验证了仙峰寺位于苇名城北侧。</p>
<p>比较典型的是松本城的月见橹，一看就知道是宴会用的建筑。</p>
<p><a href="https://image.gcores.com/8b98c36d-cc93-43c0-9430-501d7cb79644.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8b98c36d-cc93-43c0-9430-501d7cb79644.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="松本城 月见橹"></a></p>
<p>松本城 月见橹</p>
<p>冈山城的月见橹是独立结构，不与其他建筑相连。</p>
<p><a href="https://image.gcores.com/2f0ccad8-9ba9-470d-9c5a-7697ea9bcf81.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2f0ccad8-9ba9-470d-9c5a-7697ea9bcf81.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="冈山城 月见橹"></a></p>
<p>冈山城 月见橹</p>
<p>高松城的月见橹比较特殊，原来是用来瞭望远方的着见橹，后改为月见橹，所以窗户窄小。</p>
<p><a href="https://image.gcores.com/48261847-d8a3-4e30-832c-4531e5f9c881.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/48261847-d8a3-4e30-832c-4531e5f9c881.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="高松城 月见橹"></a></p>
<p>高松城 月见橹</p>
<p>九郎被软禁的地方，类似冈山城独立结构的月见橹，同时有一些仓库的感觉。为什么九郎要被软禁在月见橹之中，也许借用了平泉的一个典故，中尊寺上下山的参道叫作“<strong>月见坂</strong>”。</p>
<p><a href="https://image.gcores.com/93acf694-c1a4-416e-8cb8-5857c9ecfd7e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/93acf694-c1a4-416e-8cb8-5857c9ecfd7e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="中尊寺 月见坂"></a></p>
<p>中尊寺 月见坂</p>
<p>游戏中九郎至少住过两个地方：平田宅邸和苇名城的望月楼。三年前平田宅邸被山贼和内府的忍者袭击后，九郎被转移到苇名城的望月楼，具体过程游戏并没有告诉我们。</p>
<p>九郎的原型是平安时代最著名的悲剧英雄<strong>源九郎义经</strong>。源义经前后两次得到奥州藤原氏的庇护，居住在平泉。</p>
<p>第一次是源义经16岁时投靠三代目秀衡，可惜并没有查到源义经当时具体居住在平泉何处。</p>
<p>几年后源义经离开平泉，协助兄长源赖朝剿灭平氏。不料兄弟反目成仇，被源赖朝讨伐的源义经走投无路，再次寻求秀衡的帮助。回到平泉后源义经和家属部下住在高馆，这里也是源义经最后丧命的地方。从中尊寺顺着月见坂下山，尽头就是高馆的义经堂。</p>
<p><a href="https://image.gcores.com/1984aa07-cd67-4cc7-81f1-7eced7936b6d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1984aa07-cd67-4cc7-81f1-7eced7936b6d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="月见坂（Tsukimizaka）"></a></p>
<p>月见坂（Tsukimizaka）</p>
<p><a href="https://image.gcores.com/5145b340-7026-4415-8590-5b4a9ac309c0.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5145b340-7026-4415-8590-5b4a9ac309c0.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苇名城、月见橹、仙峰寺的地理位置"></a></p>
<p>苇名城、月见橹、仙峰寺的地理位置</p>
<h1 id="苇名国出现的家纹"><a href="#苇名国出现的家纹" class="headerlink" title="苇名国出现的家纹"></a>苇名国出现的家纹</h1><p>《只狼》的官方设定集确定了苇名城出现的两个原创家纹分别是苇名氏家纹和平田氏家纹。</p>
<p><a href="https://image.gcores.com/ef37eb86-8545-48ff-b075-cdc92b7d3bf3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ef37eb86-8545-48ff-b075-cdc92b7d3bf3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>苇名氏家纹的构图来自于现实存在的<strong>杜若纹</strong>，杜若纹是公家专用的家纹。</p>
<p><a href="https://image.gcores.com/9315169f-474a-41f0-bb98-b23b06398bb5.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9315169f-474a-41f0-bb98-b23b06398bb5.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="立ち杜若の丸"></a></p>
<p>立ち杜若の丸</p>
<p>游戏开始时，永真向井中丢下一封名为“花菖蒲之文”的信，有玩家对此表示疑惑，花菖蒲是谁？为什么游戏通关了也没遇到过名叫花菖蒲的角色？</p>
<p><a href="https://image.gcores.com/ef55d564-376d-4556-a9c0-3734f1fe3feb.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ef55d564-376d-4556-a9c0-3734f1fe3feb.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="花菖蒲之文"></a></p>
<p>花菖蒲之文</p>
<p>花菖蒲其实是一种花的名字，这封信之所以叫做“花菖蒲之文”，是因为上面印着苇名氏的家纹，也就是花菖蒲纹，而平田氏的家纹是花菖蒲的花蕾，对应平田氏是苇名氏庶家的设定。</p>
<p><a href="https://image.gcores.com/16d14d21-b727-4a41-91e7-7bec621f40c3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/16d14d21-b727-4a41-91e7-7bec621f40c3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="花菖蒲的花与花蕾"></a></p>
<p>花菖蒲的花与花蕾</p>
<p><strong>花菖蒲（ハナショウブ）</strong>是野生品种挑选培育的观赏性植物，日本东北地区从战国时代开始人工培育多种颜色品种的花菖蒲。花菖蒲生长在湿地之中，水生村神轿处和源之宫湖边的大量花菖蒲暗示了苇名之地的丰富水源，可见制作团队在场景设计上的用心。</p>
<p><a href="https://image.gcores.com/035c0205-8414-4424-98e2-baf2c1afcb61.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/035c0205-8414-4424-98e2-baf2c1afcb61.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水生村的花菖蒲"></a></p>
<p>水生村的花菖蒲</p>
<p><a href="https://image.gcores.com/04b42a3c-ac67-4199-bc7e-ad771e5747ab.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/04b42a3c-ac67-4199-bc7e-ad771e5747ab.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫的花菖蒲"></a></p>
<p>源之宫的花菖蒲</p>
<p>为什么游戏中原创的花菖蒲纹要采用杜若纹的构图呢？这其中隐含了一个源于平安时代的典故，先来观察一下杜若花的样子。</p>
<p><a href="https://image.gcores.com/8f8e59ed-7d13-4624-b10f-e0d3a749ad4f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8f8e59ed-7d13-4624-b10f-e0d3a749ad4f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="杜若花"></a></p>
<p>杜若花</p>
<p>看出杜若与花菖蒲有什么关系了吗？</p>
<p>没看出来就对了，上图的花是中文的杜若花，与日文的杜若花并不是同一种花。</p>
<p>中文的杜若花在日语中叫做ヤブミョウガ（薮茗荷）。日本人学习汉字时把杜若花的名字错给了另外一种叫カキツバタ的花，这种花的中文名是燕子花。</p>
<p><a href="https://image.gcores.com/cc7a3ea9-c03e-4000-8d9a-d4c1334265e6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cc7a3ea9-c03e-4000-8d9a-d4c1334265e6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="燕子花（カキツバタ、杜若）"></a></p>
<p>燕子花（カキツバタ、杜若）</p>
<p><a href="https://image.gcores.com/5100c09e-4fd7-488d-969c-c48fc0957172.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5100c09e-4fd7-488d-969c-c48fc0957172.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="5000日元钞票背面的燕子花"></a></p>
<p>5000日元钞票背面的燕子花</p>
<p>花菖蒲和杜若花同为鸢尾科鸢尾属，外观十分相像，日语中有一个惯用语：“何れ菖蒲か杜若”，用来表示两个美好的事物难以选择，通常用于在两名女性之间犹豫不决。（大人的答案当然是……）</p>
<p>这里需要指出，如果细分的话菖蒲和花菖蒲也是不同的细分品种，但是日常中通常不做具体区别，本文也暂且把菖蒲和花菖蒲当成同一种类讨论。</p>
<p><a href="https://image.gcores.com/1dbba2c7-393b-4e6e-a31b-3ca27cfe0551.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1dbba2c7-393b-4e6e-a31b-3ca27cfe0551.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="何れ菖蒲か杜若 feat. 初音ミク / millstones"></a></p>
<p>何れ菖蒲か杜若 feat. 初音ミク / millstones</p>
<p>“何れ菖蒲か杜若”的典故来自《太平记》，平安时代末期的<strong>源赖政</strong>退治了怪鸟“鵺”，朝廷赏赐给他一名叫作菖蒲前的美女，菖蒲前被混在十二名美女之中，让源赖政从中找出菖蒲前，源赖政感慨道：“五月雨に沢べのまこも水たへて いづれあやめと引きぞわづらふ”，大概意思是五月下雨涨水，实在难以区分混在茭白之中的菖蒲啊。</p>
<p><a href="https://image.gcores.com/8d09913c-ba31-4446-b8e9-7f49e6b86380.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8d09913c-ba31-4446-b8e9-7f49e6b86380.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="茭白（マコモ）"></a></p>
<p>茭白（マコモ）</p>
<p>平安时代末期社会动荡不安，平氏掌权时源赖政是位阶最高的源氏朝臣，后来因为对平氏不满与后白河天皇的皇子<strong>以仁王</strong>起兵反抗，战败切腹。</p>
<p>此时大和朝廷已经摇摇欲坠，源氏与平氏之间的战火烧遍除了东北以外的日本全境，北方的奥州藤原氏虽然没有插手，但也在准备应对不可知的形势变化。</p>
<h1 id="平安末期-皇权衰落和武士阶层崛起"><a href="#平安末期-皇权衰落和武士阶层崛起" class="headerlink" title="平安末期 皇权衰落和武士阶层崛起"></a>平安末期 皇权衰落和武士阶层崛起</h1><p>平安末期日本全国的乱世虽然没有直接表现在《只狼》的故事中，从游戏的一些细节可以发现争斗的痕迹。</p>
<p>平安时代开始皇族陆陆续续被赐姓降为臣籍，到了平安末期，清和源氏的分支<strong>河内源氏</strong>和桓武平氏的分支<strong>伊势平氏</strong>，成为最有实力的两家。</p>
<p>1156年朝廷内部分裂爆发<strong>保元之乱</strong>，<strong>后白河天皇</strong>和<strong>崇德天皇</strong>争夺皇位并拉拢武家，最后后白河天皇战胜崇德天皇继承皇位，这也是武家干涉朝政的开端。</p>
<p>支持后白河天皇的主要有河内源氏<strong>源义朝</strong>、伊势平氏<strong>平清盛</strong>和摄津源氏<strong>源赖政</strong>等人，源义朝是源义经和源赖朝的父亲，平清盛是平氏的核心人物，源赖政上文刚刚提到。</p>
<p>后白河天皇上位没几年又爆发<strong>平治之乱</strong>，源义朝等人不满于平氏的得势，趁平氏离开平安京时软禁后白河上皇（第一次，此时已退位为上皇）。平清盛回京平乱，源义朝战败被斩首，相关族人也随着被肃清，源赖朝流放伊豆，源义经送往鞍马寺生活。</p>
<p>河内源氏失势后平氏控制朝廷。1179年平清盛发动<strong>治承政变</strong>，软禁后白河法皇（第二次，此时出家为法皇），逼迫高仓天皇退位，推自己的外孙安德天皇上位。</p>
<p>后白河法皇的皇子以仁王和源赖政起兵，并向全国源氏下达讨伐平氏的令旨。虽然以仁王和源赖政兵败，两股源氏势力响应号召起兵反平。一边是伊豆的<strong>源赖朝</strong>，另一边是信浓的<strong>源义仲（木曾义仲）</strong>，源赖朝和源义仲是堂兄弟，但二者关系恶劣。源义仲曾在诹访大社修行，掌管诹访大社下社的金刺氏是他的心腹。</p>
<p>源义仲最著名反平战役是<strong>俱利伽罗峠之战</strong>，《源平盛衰记》中记载，源义仲摆<strong>火牛阵</strong>战胜<strong>平维盛</strong>，使其率领的十万军队损失过半。跟随源义仲参战的还有他的部下<strong>巴御前</strong>。</p>
<p><a href="https://image.gcores.com/5ff0d383-4af3-4059-a473-256dde13c2b9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5ff0d383-4af3-4059-a473-256dde13c2b9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="火牛之计"></a></p>
<p>火牛之计</p>
<p><a href="https://image.gcores.com/c1804bbf-b8be-42fc-aec2-83a6931e79e3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c1804bbf-b8be-42fc-aec2-83a6931e79e3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="游戏中的火牛"></a></p>
<p>游戏中的火牛</p>
<p>俱利伽罗峠之战让平氏元气大伤，带着后白河法皇、安德天皇和三神器逃离京都。源平最终决战于<strong>坛之浦之战</strong>，败势已定后大部分平氏族人和携带三神器的安德天皇投海，平氏势力几乎全灭。据说三神器只找回了镜和勾玉，天丛云剑消失在大海之中。</p>
<p>打赢了俱利伽罗峠之战的源义仲先于源赖朝入京，不料与朝廷发生摩擦，把逃回京城的后白河法皇软禁于法住寺（第三次），自封“征东大将军”。源赖朝派兵讨伐造反的源义仲，最后源义仲在<strong>宇治川之战</strong>战败，死于逃亡。</p>
<p>有能力一统天下的武家此时只剩下两家：源平合战的胜利者源赖朝，和北方一直没有插手的藤原秀衡。源赖朝和藤原秀衡心中都清楚，彼此必有一战，这场战役即是《只狼》最后苇名灭国的原型，导火索是寻求藤原秀衡庇护的源九郎义经。</p>
<h1 id="北方霸主奥州藤原氏的陨落"><a href="#北方霸主奥州藤原氏的陨落" class="headerlink" title="北方霸主奥州藤原氏的陨落"></a>北方霸主奥州藤原氏的陨落</h1><p>因为父亲在政治上的落败，源义经儿时被送到京都<strong>鞍马寺</strong>生活学习。鞍马山传说有大天狗出没，源义经晚上偷偷跑出去和大天狗学习武术。游戏中苇名一心带着天狗假面外出清除刺客，也许就是来自于天狗保护源义经的典故。</p>
<p><a href="https://image.gcores.com/a6ba8dda-b181-4982-b9c2-1c164fbae389.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a6ba8dda-b181-4982-b9c2-1c164fbae389.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源义经和天狗学习武术"></a></p>
<p>源义经和天狗学习武术</p>
<p>1174年，16岁的源义经拒绝出家并离开鞍马寺。通过一个来自奥州的黄金商人帮助，源义经投靠了奥州平泉的<strong>藤原秀衡</strong>。</p>
<p><a href="https://image.gcores.com/084b2921-dd88-4c27-ac45-9c2ad0a85e10.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/084b2921-dd88-4c27-ac45-9c2ad0a85e10.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="藤原秀衡"></a></p>
<p>藤原秀衡</p>
<p><a href="https://image.gcores.com/a2178c3b-2150-4b13-bd41-10fa63a114e2.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a2178c3b-2150-4b13-bd41-10fa63a114e2.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="藤原秀衡：老子就是黄金多（怪物弹珠）"></a></p>
<p>藤原秀衡：老子就是黄金多（怪物弹珠）</p>
<p>奥州藤原氏三代目藤原秀衡极具政治头脑和领导才能，苇名一心在领导者方面的形象，可以看作是融合了初代目清衡的气量和三代目秀衡的智慧。</p>
<p>1180年源赖朝伊豆起兵，在平泉生活了6年的源义经听到兄长的消息，决定追随源赖朝讨伐平氏。这一举动却遭到了秀衡反对，秀衡料到源氏兄弟二人可能会反目。在源义经的坚持下，秀衡只好派人护送其离开奥州。</p>
<p>源义经在宇治川之战灭义仲，在坛之浦之战灭平，屡立战功后私受朝廷封赏引起了源赖朝的猜疑，兄弟二人果然开始对立，源赖朝迫使后白河法皇下旨讨伐源义经。1187年2月，走投无路的源义经带着家臣再次投靠秀衡。</p>
<p>源赖朝畏惧秀衡的能力，不敢轻举妄动，一边向朝廷告状秀衡包庇源义经试图谋反，一边派人到平泉刺探秀衡和源义经的情报。这一阶段对应了游戏中苇名国被内府入侵之前，孤影众早已渗透进苇名城，等待苇名一心的生命燃尽。</p>
<p><a href="https://image.gcores.com/37253aff-6fb8-402f-9b77-4153389c0c93.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/37253aff-6fb8-402f-9b77-4153389c0c93.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="一心病死"></a></p>
<p>一心病死</p>
<p>不幸的是，源义经投靠平泉仅过去九个月，秀衡病死。局势急转，对抗源赖朝的重担转移到秀衡的继承人身上。苇名弦一郎这个矛盾的人物形象，极有可能参考了藤原秀衡的两个儿子<strong>藤原国衡</strong>和<strong>藤原泰衡</strong>。</p>
<p><a href="https://image.gcores.com/f7176f64-004c-4797-8dcd-e61747c4076d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f7176f64-004c-4797-8dcd-e61747c4076d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="官网上弦一郎的设定"></a></p>
<p>官网上弦一郎的设定</p>
<p>藤原国衡虽为长男却是庶出，母亲是虾夷人。国衡具有大将的气概而且父母都有东北血统，受到众人期待，国衡对应弦一郎的出身和武士风范。</p>
<p>藤原泰衡的母亲是来自京城的贵族，一直以来都被当作贵公子对待，后来作为一个不称职的领袖亲手葬送了平泉的未来，泰衡对应弦一郎的偏执和作为。</p>
<p>藤原秀衡为了防止两个儿子被源赖朝挑拨离间内斗消耗，做了一件我们现代人难以理解的事情：<strong>将泰衡京都出身的母亲改嫁给国衡</strong>。这样泰衡和国衡既是同父异母的兄弟，又是义父子，也就是说，泰衡既是秀衡的儿子，又可以看作是秀衡的孙子（国衡的义子）。这可能是把弦一郎设定成一心孙子的典故。</p>
<p>秀衡死前留下遗嘱让泰衡继承自己的位置，并叮嘱国衡和泰衡一定要拥护源义经，三人合力对抗源赖朝。</p>
<p>得知秀衡病死后，源赖朝开始行动不断对泰衡施压，威胁泰衡如果不交出源义经就讨伐奥州。泰衡无视父亲的遗嘱，派兵突袭了源义经的住所高馆。逃跑无望的源义经了结正妻乡御前和女儿的性命后自杀。泰衡把源义经的首级泡在酒里献给源赖朝，源赖朝反而以杀害源义经为理由正式进军奥州。</p>
<p>泰衡与父亲意见相左私通源赖朝，以为满足源赖朝的要求就能保住平泉。对应游戏中弦一郎试图以异端之雷拯救苇名，而降雷之术来自于淤加美一族，淤加美一族又是源氏的原型。泰衡逼迫源义经自杀，对应弦一郎在苇名被入侵时不顾城池，追到芒草原上抢夺龙胤之力，最后导致九郎因斩断不死而牺牲。</p>
<p>藤原国衡作为平泉军总大将，在阿津贺志山迎战源赖朝的镰仓大军。国衡战败后泰衡火烧平泉逃之夭夭，逃亡途中被抓住斩首，奥州藤原氏的灭亡距离秀衡去世仅仅过去两年。平泉的大火烧了几天几夜，源赖朝兵临城下时已是一片灰烬。</p>
<p>泰衡逃跑时还给源赖朝写信，表示自己不知道父亲秀衡包庇源义经之事，已经奉命将源义经讨伐，为什么不封赏反而出兵。这段史料记录在镰仓幕府编撰的史书《吾妻镜》中，是不是伪造丑化就不清楚了。</p>
<p>游戏中入侵苇名城的内府军，明示了其原型是统一战国的德川家康军。内府是内大臣的别称，德川家康曾担任此职位。内府军的家纹也来自德川家康的葵纹。在苇名灭国的原型奥州合战中，内府军也指代了源赖朝的军队。虽然源赖朝没有上任过内大臣的职位，他的儿子源实朝当过内大臣。</p>
<p>从镰仓幕府开始到江户幕府结束，真正掌管国家实权的官职是<strong>征夷大将军</strong>。幕府将军指的就是征夷大将军，这原本是为讨伐虾夷专设的军职，最早由平安初期的坂上田村麻吕实际担任。后来武士阶层上位，征夷大将军失去了征夷的本意，成为武家政权最高实权者的职位，比如镰仓幕府初代征夷大将军源赖朝、室町幕府初代征夷大将军足利尊氏、江户幕府初代征夷大将军德川家康。</p>
<p>随着奥州藤原氏灭亡再无其他威胁，后白河法皇驾崩后征夷大将军源赖朝正式建立了镰仓幕府。武士阶层接替天皇统治国家，进入了漫长的幕府时代，而日本战国是幕府统治期间众多武士大名混战的一段历史。<strong>《只狼》实际上偷偷讲了武士崛起和幕府起源，说这是一个阐述日本战国时代根源的故事也不为过。</strong></p>
<h1 id="苇名之地的人与鬼"><a href="#苇名之地的人与鬼" class="headerlink" title="苇名之地的人与鬼"></a>苇名之地的人与鬼</h1><p>《只狼》的故事原型讲完后，再看看受苦的苇名众们又都来自于什么历史典故。</p>
<p>游戏中反复出现了“<strong>鬼</strong>”这个概念，比如游戏初期的拦路虎精英怪<strong>赤鬼</strong>、标准流程首个BOSS<strong>形部鬼庭雅孝</strong>、隐藏BOSS<strong>怨恨之鬼</strong>、永真说自己的剑术不斩人只斩鬼、孤影众说苇名之地有鬼等等，为什么在这个游戏中要屡次提及鬼，这得说到日本文化中鬼的形象。</p>
<p>中国文化中的鬼，多指人死后的亡灵，常用于鬼屋、闹鬼这类词。日语中的おに虽然借用汉字中的鬼字，概念却与中国的鬼不太一样，形象更接近野人，红皮肤、浓密的毛发、头上长着角、半裸着身体。</p>
<p><a href="https://image.gcores.com/ed9e51e9-eedd-43fa-9716-8289354b1bc6.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ed9e51e9-eedd-43fa-9716-8289354b1bc6.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="赤鬼"></a></p>
<p>赤鬼</p>
<p>日本神话传说中最著名的鬼当属鬼首领<strong>酒吞童子</strong>（托某些游戏的福，想找一张正经图片实在是困难），传说平安时代的源赖光和赖光四天王退治了酒吞童子，广为流传。</p>
<p><a href="https://image.gcores.com/39cd42ad-eac7-42a6-9964-979463586fdd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/39cd42ad-eac7-42a6-9964-979463586fdd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="酒吞童子"></a></p>
<p>酒吞童子</p>
<p>民间还流传着源赖光退治土蜘蛛的传说，土蜘蛛原指上古时代不愿意归顺朝廷的山贼，后来被艺术创作成妖怪，同理酒吞童子等鬼的形象也可能来自于大和民族对蛮夷的记忆。</p>
<p><a href="https://image.gcores.com/c2daca74-26d5-4b87-8145-fc5ae4fbadaa.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c2daca74-26d5-4b87-8145-fc5ae4fbadaa.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源赖光退治土蜘蛛"></a></p>
<p>源赖光退治土蜘蛛</p>
<p>鬼的本体究竟是什么，说法众多。有人认为鬼是古代先民或者从大陆渡来的其他人种。这些人生活在深山中，身材高大毛发浓密，这其中包括了虾夷人。</p>
<p>与鬼类似的形象还有<strong>山男</strong>，又被叫作山人或大人，他们同样生活在山中，有的场合也被当成是鬼。</p>
<p><a href="https://image.gcores.com/fe872407-28d6-4788-8b40-702669dbb903.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fe872407-28d6-4788-8b40-702669dbb903.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="山男"></a></p>
<p>山男</p>
<p>日本东北曾经是虾夷人的领地，存在着很多与鬼有关的民间故事。在青森县弘前市鬼沢地区就流传着这样一个故事：古代有个农民叫弥十郎，与深山中高大的鬼关系很好，二者经常以<strong>相扑</strong>为乐，鬼要求弥十郎不要告诉别人关于他的存在，并在夜里偷偷帮助村子修建堤坝，弥十郎的妻子忍不住去偷窥，之后鬼就再也没有出现过，当地人把鬼留下的锄头和蓑衣供奉在鬼神社之中。</p>
<p><a href="https://image.gcores.com/3d509ab1-8973-40a4-afee-5c46792a71e9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3d509ab1-8973-40a4-afee-5c46792a71e9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鬼神社"></a></p>
<p>鬼神社</p>
<p>可见在日本东北，鬼的形象相对比较正面，东北人民也并不抗拒使用鬼字来命名，比如前九年之役中，安倍氏首次击败朝廷军的战场叫作<strong>鬼切部</strong>。</p>
<p><a href="https://image.gcores.com/1f2a7c94-98eb-4916-9626-9587d1ee1bdb.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1f2a7c94-98eb-4916-9626-9587d1ee1bdb.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鬼切部城址"></a></p>
<p>鬼切部城址</p>
<p>游戏中红皮的山贼、重藏、赤鬼明显借鉴了鬼的形象，重藏是山贼们的头领，曾经是相扑，喜欢饮酒，对应的原型应该是酒吞童子。赤鬼可能是从山中被抓来的大男，不幸遭遇了残忍的实验。</p>
<p><a href="https://image.gcores.com/d8eeac66-f9c2-418b-9c5a-98d0fe09f594.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d8eeac66-f9c2-418b-9c5a-98d0fe09f594.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="红皮三宝"></a></p>
<p>红皮三宝</p>
<p>这些面目狰狞的野蛮人可能才是此地真正的原住民，依山而生变成流寇，三年前被枭和内府利用袭击了平田宅邸。还有一个可疑的细节，袭击平田的山贼穿着的胸甲上有平田氏的家纹，也许这些装备是他们抢来的，或者有其他我们不知道的原因。</p>
<p><a href="https://image.gcores.com/b07ba477-30a6-4d02-8a2d-580cbbe60b38.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b07ba477-30a6-4d02-8a2d-580cbbe60b38.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="红皮大哥"></a></p>
<p>红皮大哥</p>
<p>游戏里还有一个出身于山贼并且名字里带鬼字的角色，<strong>鬼庭形部雅孝</strong>。他曾经是苇名一带有名的山贼，败给一心后归顺苇名成为弦一郎的师傅。他是否与袭击平田宅邸的山贼众有关，游戏中没有交代。</p>
<blockquote>
<p>戦いの残滓・鬼形部 心中に息づく、類稀な強者との戦いの記憶 今はその残滓のみが残り、 記憶は確かに狼の糧となった 鬼形部は、葦名に名を轟かす<strong>賊の頭目</strong>であった だが一心に敗れ、その強さに惚れ込み、 賊党ごと召抱えられた その後、葦名弦一郎の傅役まで努めた</p>
</blockquote>
<p>鬼形部的姓氏鬼庭也来源于平安时代的东北地区。藤原北家后裔<strong>斋藤实良</strong>平安末期来到奥州伊达郡的茂庭村，传说他退治当地的大蛇，成为茂庭村的领主，村子从茂庭村改名为鬼庭村，斋藤实良也改名为鬼庭实良。到了战国时代，鬼庭实良的后代<strong>鬼庭纲元</strong>是陆奥的战国大名，丰臣秀吉觉得鬼庭这个姓氏不祥，让他把姓氏改回茂庭，于是鬼庭这个姓氏就此消失了。</p>
<p><a href="https://image.gcores.com/1cfafd07-d4f5-44cd-90e9-a26fe27111b5.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1cfafd07-d4f5-44cd-90e9-a26fe27111b5.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="鬼庭氏家谱"></a></p>
<p>鬼庭氏家谱</p>
<h1 id="与神明一同前往遥远的西方"><a href="#与神明一同前往遥远的西方" class="headerlink" title="与神明一同前往遥远的西方"></a>与神明一同前往遥远的西方</h1><p><a href="https://image.gcores.com/2a3f8f88-f78e-4a12-9b61-5492881011b1.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2a3f8f88-f78e-4a12-9b61-5492881011b1.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《幽灵公主》"></a></p>
<p>《幽灵公主》</p>
<p>在游戏中我们会遇到两种非常讨厌的敌人，仙峰寺像老鼠一样跳来跳去的<strong>乱波众</strong>，和铁炮堡垒把玩家打成塞子的<strong>铁炮众</strong>，他们的原型都出自宫崎骏的经典作品《幽灵公主》。</p>
<p><a href="https://image.gcores.com/ab8a8680-1900-4977-83b4-5a482c0d3bd6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ab8a8680-1900-4977-83b4-5a482c0d3bd6.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>乱波众和铁炮众分别对应动画中的<strong>唐伞连</strong>和<strong>石火矢众</strong>，唐伞连和石火矢众试图夺取神明长生不老的力量，与幽灵公主和山神为敌。《只狼》除了借鉴了其形象以外，在故事和思想表达上也与《幽灵公主》有一些联系。</p>
<p><a href="https://image.gcores.com/8511be30-0477-4252-a03b-c7ed1c5ce8a3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8511be30-0477-4252-a03b-c7ed1c5ce8a3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="唐伞连和石火矢众"></a></p>
<p>唐伞连和石火矢众</p>
<p>不了解日本历史的朋友看了《幽灵公主》会以为这是一部主要表现人与自然如何相处的环保故事，实际上这个故事不仅讨论了人与自然的关系，还涉及到大和民族和虾夷等少数民族之间的摩擦与和解。</p>
<p><a href="https://image.gcores.com/47705289-b774-4928-bb28-f12d579ad086.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/47705289-b774-4928-bb28-f12d579ad086.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="阿席达卡"></a></p>
<p>阿席达卡</p>
<p>男主角<strong>阿席达卡</strong>（アシタカ）是一名古代虾夷部落少年，故事开始时告诉我们他的祖先阿弖流为（アテルイ）曾在五百年前败给坂上田村麻吕，也就是上文讲到平安初期发生的事情，阿席达卡的部落被迫躲进深山中隐居几百年，以此可以推测《幽灵公主》的故事大概发生在公元1300年左右的室町时代。</p>
<p>某日，一只失控的野猪山神袭击部落村庄，阿席达卡阻止山神时被迫杀死了神明。他受到山神作祟的诅咒，族人告诉他只有前往<strong>遥远西方的大和之国</strong>才能解除诅咒。本该将来成为族长的阿席达卡触犯弑神禁忌，按族规削发逐出部落永远不能回来，离开时也禁止任何族人送别。</p>
<p>被阿席达卡杀死的野猪神是来自出云国（神之篇提到过大国主神等国津神源于出云神话）的神明，产生的诅咒又要被阿席达卡一路西行带回到大和之地，这样的设定是不是和《只狼》中流离失所的樱龙有些类似呢？</p>
<p><a href="https://image.gcores.com/1d527ff7-cf4b-43de-9d75-483a72d72cd8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1d527ff7-cf4b-43de-9d75-483a72d72cd8.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="在长老和族人面前削发"></a></p>
<p>在长老和族人面前削发</p>
<p><a href="https://image.gcores.com/30b4fff4-2b04-44df-bfb8-afddecaab4ed.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/30b4fff4-2b04-44df-bfb8-afddecaab4ed.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="青梅竹马卡雅违反族规为阿席达卡送行"></a></p>
<p>青梅竹马卡雅违反族规为阿席达卡送行</p>
<p>阿席达卡来到大和之地后发现，不同于自己那些对神灵保持虔诚的族人，当地的大和民族已经不再敬畏神明，他们用先进的武器迫害和猎杀这些山神试图获得永生的能力。而他手臂上的诅咒便是来自于山神对人类的憎恨。</p>
<p><a href="https://image.gcores.com/3a2cbcc8-e030-4f89-80b9-484470cbd3f1.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3a2cbcc8-e030-4f89-80b9-484470cbd3f1.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="手臂上的诅咒"></a></p>
<p>手臂上的诅咒</p>
<p>神话是关于人的寓言，神和鬼的背后也都是人，《幽灵公主》中山神对人类的憎恨，可以理解为崇拜自然万灵的原住民对侵略者的憎恨，所以诅咒会选择阿席达卡这个古代虾夷部落的少年为其发声。</p>
<p>《只狼》中也有类似的内容，游戏剧情中反复提及了修罗和化身为鬼。除了指在杀戮中迷失以外，也包含了民族的仇恨和怨念，这种由迫害产生的愤恨哀叹，在枭和佛师这两个本地人身上分别以不同的形式体现，我们先从狼的义父枭这个饱受争议的人物说起。</p>
<h1 id="离群的无主忍者-枭"><a href="#离群的无主忍者-枭" class="headerlink" title="离群的无主忍者 枭"></a>离群的无主忍者 枭</h1><p>枭是我个人比较喜欢的一个角色，关于他存在很多可以考据的细节。也许是因为开发成本控制，最后在游戏中呈现出来的信息少得可怜。</p>
<p><a href="https://image.gcores.com/dba6d6e8-a45b-4c5a-8bab-a0188db30c9e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/dba6d6e8-a45b-4c5a-8bab-a0188db30c9e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="盗国战时的枭"></a></p>
<p>盗国战时的枭</p>
<blockquote>
<p>おはぎ 変若の御子がくれたお米で、 九郎がこしらえてくれた、おはぎ 一定時間、HPがゆっくりと中回復し、 加えて体幹が常に回復するようになる <strong>腹を空かせた狼に、 黙って義父は、おはぎをくれた あのおはぎは、とてもうまかった</strong> このおはぎも、きっと、とてもうまい</p>
</blockquote>
<p>九郎制作的<strong>萩饼</strong>让狼想起往事，沉默寡言的义父曾拿出好吃的萩饼给肚子饿了的狼吃，侧面表现了回忆中枭对养子的温柔。然而我们在游戏中实际接触到的义父，却是一个阴险狡诈的野心家，没有交代为什么会产生这样的落差。</p>
<p>我们对这个角色的了解相当有限，人物身世、内心矛盾、以及谋反的驱动力，几乎都是一片空白。他最后的所作所为，根据游戏提供的信息也只能理解成想要摆脱忍者卑微的命运。</p>
<p>游戏的创作者是不是真的设计了下面这些最后没有公开的内容，我没法给出一个肯定的答案，以下的考据分析仅基于我个人的理解和猜测。</p>
<p><a href="https://image.gcores.com/47b9e455-55d9-4b73-99bd-a97ea5537331.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/47b9e455-55d9-4b73-99bd-a97ea5537331.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="衰老的枭"></a></p>
<p>衰老的枭</p>
<p>枭拥有庞大的身躯，让人羡慕的发量，正常的日本人不太会长成这个样子，官方首次公布枭的形象时，机核曾有人质疑过枭是否为虾夷人。（或者是安德烈转世）</p>
<p><a href="https://image.gcores.com/7a139b5b-70e0-48f8-8cb6-dd6966f352a7.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7a139b5b-70e0-48f8-8cb6-dd6966f352a7.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="离群忍者枭是稀有的忍者，并没有侍奉的主人"></a></p>
<p>离群忍者枭是稀有的忍者，并没有侍奉的主人</p>
<p>官网的人物介绍用两个词形容枭：<strong>离群的忍者（はぐれ忍び）</strong>和<strong>稀有的忍者（類稀な忍び）</strong>。</p>
<p><a href="https://image.gcores.com/2f275157-ff69-4b10-a463-ed61cb7b12e7.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2f275157-ff69-4b10-a463-ed61cb7b12e7.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《黑暗之魂》中的离群恶魔"></a></p>
<p>《黑暗之魂》中的离群恶魔</p>
<p>离群（はぐれ）这个形容词在《黑暗之魂》中出现过，重返不死院时地面坍塌，玩家会发现下面的牢房里关着<strong>离群恶魔（はぐれデーモン）</strong>，这说明枭可能曾经属于某个氏族或者组织，因为一些原因脱离了组织。</p>
<p>稀有（類稀）在《只狼》中还出现在各个BOSS的<strong>战斗记忆</strong>以及<strong>七之念珠</strong>的道具描述中。</p>
<blockquote>
<p>心中に息づく、<strong>類稀</strong>な強者との戦いの記憶</p>
</blockquote>
<p>因为BOSS都是独特的存在，所以说他们是稀有的强者，这很好理解。</p>
<blockquote>
<p>七の念珠 ちぎれた数珠の玉を、鬼仏に供えて束ねた念珠 手に入れると、身体力が成長し、 HPと体幹の最大値が上昇する 念珠を成す数珠玉は、それを持つにふさわしい 強者たちが持っている ある大大名に仕える、<strong>類まれ</strong>な相撲取りがいた だが酒に溺れ、放逐され、野盗に落ちた その後の名は、うわばみの重蔵という</p>
</blockquote>
<p>七之念珠中描述<strong>重藏</strong>曾经是某位大大名门下稀有的相扑，可能有两种解释：形容相扑这个职业本身很稀有；或者是指作为相扑的重藏本人是稀有的，比如他是一个虾夷出身的相扑，同理枭是稀有的忍者可能指他是虾夷出身的忍者。</p>
<h1 id="枭与狼-不同文化的信仰差异"><a href="#枭与狼-不同文化的信仰差异" class="headerlink" title="枭与狼 不同文化的信仰差异"></a>枭与狼 不同文化的信仰差异</h1><p><a href="https://image.gcores.com/3bf34fb6-d614-4df3-811d-dcbc12b01a8b.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3bf34fb6-d614-4df3-811d-dcbc12b01a8b.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="枭和守护灵"></a></p>
<p>枭和守护灵</p>
<p>枭最显眼的特点是战斗时环绕在他身边的<strong>猫头鹰</strong>，这也许是他代号的由来，操纵猫头鹰的忍者。玩家与枭首次交战于天守阁，枭身边并没有猫头鹰，回到三年前的平田宅邸第二次与枭战斗时，进入第二阶段后猫头鹰出现配合枭的进攻，使用鸣种对其无效说明不是枭释放的幻术，根据时间线的先后顺序，可判断枭也许因为某种原因失去了猫头鹰守护。</p>
<p><a href="https://image.gcores.com/32fcc2d9-1eb2-4ee0-b284-50206a3533c5.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/32fcc2d9-1eb2-4ee0-b284-50206a3533c5.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="猫头鹰灵体"></a></p>
<p>猫头鹰灵体</p>
<p>猫头鹰在大和文化中的印象主要来自中国，有代表“死亡”的不详含义，并被认为是不孝鸟，不孝即背叛。后来因为フクロウ在日语里谐音是“不苦劳”，反而又变成吉祥的象征。（万能的谐音）</p>
<blockquote>
<p>枭，不孝鸟也。 ——《说文解字》</p>
</blockquote>
<p>日本神道教很少出现猫头鹰，而在北海道的阿依努文化中，猫头鹰是非常重要的存在。枭的原型可能是虾夷人，所以有必要顺着线索考据一下虾夷后世的北海道阿依努文化。</p>
<p>阿依努人的神话信仰与大和民族截然不同，阿依努的神灵被称为<strong>卡姆依（カムイ，kamuy）</strong>，存在于卡姆依世界。卡姆依们以动物等形态降临于现实世界，给人类带来肉和皮毛。动物死后灵魂返回卡姆依世界，然后根据人类的表现来决定下次何时降临。在阿依努人眼中动物都是神灵的化身，并认为吃肉和穿着鸟兽皮衣是神灵的庇护。</p>
<p><a href="https://image.gcores.com/f3783c08-9f91-4f6b-af62-ff2e11c9208f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f3783c08-9f91-4f6b-af62-ff2e11c9208f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="岛枭（シマフクロウ）"></a></p>
<p>岛枭（シマフクロウ）</p>
<p>卡姆依的至高神是<strong>部落守护神コタンコロカムイ（Kotan Kor Kamuy）</strong>，其动物形态为<strong>岛枭（シマフクロウ）</strong>，岛枭是日本特有的大型猫头鹰，双翅展开最长可达1.8米，头部拥有明显的耳状羽毛，这些特征都与义父的猫头鹰极其相似。除了从大陆误飞而来的少量雕鸮，日本本土的其他几种主流品种猫头鹰都没有耳羽，而且体型偏小。枭肩膀上猫头鹰羽毛制成的披肩，也对应了阿依努人穿鸟羽衣的习惯。</p>
<p><a href="https://image.gcores.com/d1a757c0-73b6-4f60-a8aa-d93ead4425ca.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d1a757c0-73b6-4f60-a8aa-d93ead4425ca.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="义父的猫头鹰"></a></p>
<p>义父的猫头鹰</p>
<p>岛枭之神コタンコロカムイ的神德是<strong>守护村庄部落</strong>，游戏中虽然没有说明枭在苇名国担任的具体任务是什么，狼作为枭的养子被命令保护居住在平田宅邸的御子九郎，那么枭至少要对平田宅邸的安保负有间接责任，三年前枭暗通内府和山贼导致平田宅邸被袭击，违背了岛枭之神コタンコロカムイ的神德，失去神灵的庇护也就说得通了。</p>
<p>狼的名字可能是枭在收养他的时候临时起的。</p>
<p>盗国之战后的战场上枭遇到了拾荒的主角，这一段剧情的对话非常有意思，我们来回顾一下枭都说了什么。</p>
<p><a href="https://image.gcores.com/cb5c6290-d7b5-4491-9006-a53c674e0134.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cb5c6290-d7b5-4491-9006-a53c674e0134.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<blockquote>
<p><strong>野良犬</strong>が、心すら亡くしたか（<strong>野狗</strong>连心都失去了吗？）</p>
</blockquote>
<p>枭第一次见到这个孩子的时候，用野狗来称呼他。</p>
<p>大和信仰中的狼神叫作<strong>大口真神</strong>，原型是日本狼，大口真神的神德是保护人类的庄稼，驱赶野猪等破坏农作物的野生动物，而且大口真神也被称为御神犬，可见这个农耕社会对狼的崇拜已经转移到了人类驯化的狗身上。</p>
<p><a href="https://image.gcores.com/692c2fcd-ff20-4c58-9e04-9ee73792d963.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/692c2fcd-ff20-4c58-9e04-9ee73792d963.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>比如供奉大口真神的<strong>武藏御岳神社</strong>，现在还提供为爱犬祈福的业务。</p>
<p><a href="https://image.gcores.com/1024b7e1-989a-4a07-84de-ddbf370a8422.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1024b7e1-989a-4a07-84de-ddbf370a8422.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<blockquote>
<p>共にくるか、餓えた<strong>狼</strong>よ（跟我走吗，饥饿的<strong>狼</strong>） そして、戦場で拾われた狼は、修行の末、熟達の忍びとなった （之后从战场上捡到的狼通过修行，成为了<strong>技艺精湛的忍者</strong>）</p>
</blockquote>
<p>然后孩子抓住了枭的刀，或许枭此时想到什么所以决定收养面前这个孩子。第二句话中的称呼从狗转为狼，拉近了二人的距离。</p>
<p><a href="https://image.gcores.com/7f82c6fe-c3f3-4adc-b1ab-6bba96cb0759.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7f82c6fe-c3f3-4adc-b1ab-6bba96cb0759.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《黄金神威》中对狼神ホロケウカムイ的介绍"></a></p>
<p>《黄金神威》中对狼神ホロケウカムイ的介绍</p>
<p>阿依努信仰中的狼神是<strong>狩猎之神ホロケウカムイ（</strong>Horkew Kamuy<strong>）</strong>，原型是北海道已经灭绝的虾夷狼，神德是把娴熟的狩猎技巧教给阿依努人，因为阿依努人还保留着狩猎文化，他们把狼神当作技艺高超的猎人崇拜。传说恶神降临时，其他卡姆依在战斗中陆续阵亡，只剩下狼神ホロケウカムイ坚持到最后。可惜的是阿依努神话的资料非常稀少，没有找到这段传说更详细的出处。</p>
<p>枭与狼父子二人关系的前后反差，正好反映了两个民族根据自身需求产生的信仰差异。</p>
<p><a href="https://image.gcores.com/2e06bf85-68f5-4166-bdb4-92e24da12383.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2e06bf85-68f5-4166-bdb4-92e24da12383.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>阿依努文化中，猫头鹰是保护家园的<strong>守护者</strong>，狼是娴熟的<strong>猎人</strong>。二十年前盗国成功，苇名众当家作主掌管自己的命运，义父枭有一颗慈父的心，收养了主角狼，并将他培育成技艺精湛的忍者。</p>
<p><a href="https://image.gcores.com/9c0c9140-c7ff-4e33-b575-2fb92cc89fb1.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9c0c9140-c7ff-4e33-b575-2fb92cc89fb1.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>大和文化中，猫头鹰是带来死亡的<strong>背叛者</strong>，狼是如同狗的<strong>忠诚卫士</strong>。当代表大和的内府压境，苇名国被绝望笼罩时，义父枭摇身一变成为阴险狡诈的野心家，而主角狼忠心耿耿守护着自己的主人御子九郎。</p>
<p><a href="https://image.gcores.com/1861d23f-d556-41f0-9a62-e7a226882f66.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1861d23f-d556-41f0-9a62-e7a226882f66.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="狼与香辛料 赫萝"></a></p>
<p>狼与香辛料 赫萝</p>
<p>同样以狼为主角的作品《狼与香辛料》也出现了类似的文化差异，女主角赫萝（ホロ）的名字可能取自阿依努狼神ホロケウカムイ，《狼与香辛料》的故事开始前，赫罗北方的故乡约伊兹很久以前被摧毁，她来到南方却被当成丰收之神供奉。</p>
<p><a href="https://image.gcores.com/316e3d92-114a-4536-91a4-936c4959beb3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/316e3d92-114a-4536-91a4-936c4959beb3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="オキクルミ和サマイクル"></a></p>
<p>オキクルミ和サマイクル</p>
<p>在另一款表现日本文化的经典游戏《大神》中，狼与猫头鹰的对手戏出现在游戏流程后半段。大神来到卡姆伊之地（即北海道），发现当地人都带着动物的面具，携带狼面的オキクルミ想凭借一己之力拯救村庄，携带鸟面的サマイクル是顽固保守的现任村长。虽然《大神》中猫头鹰的头饰分配给了另外角色，サマイクル村长的身份暗示了他与岛枭之神コタンコロカムイ的关系，オキクルミ和サマイクル二人最后握手言和，协力击败了魔神。这两个角色的名字也都取自于阿依努神话中的人类英雄。</p>
<h1 id="依水而行的阿依努恶神"><a href="#依水而行的阿依努恶神" class="headerlink" title="依水而行的阿依努恶神"></a>依水而行的阿依努恶神</h1><p>如果枭和狼代表阿依努神话中的神明，他们的对立面是什么呢？</p>
<p>阿依努的卡姆伊不全都是善神，也有象征灾难的恶神，其中一位可能与《只狼》有关的恶神卡姆伊是传播扩散疫病的<strong>痘疮之神パヨカカムイ（Payoka Kamuy）</strong>。パヨカカムイ的名字本意是行走的神，可能含有疫病会顺水传播的意思。素材道具<strong>脂蜡瘤</strong>和<strong>死蜡瘤</strong>的道具描述中，记载着把不死病人身上结成的黑瘤取下后放入水中漂流的习俗。</p>
<blockquote>
<p>死蝋の瘤 人の体内で黒々と育った死蝋の瘤 呪物にまつわる強化義手忍具を作成する筒薬 深い段階の作成に、使われる 長く長く、死なず病を患えば、 自ずと瘤も黒々と育つ <strong>瘤取りが済めば、水に流すが習わしだ</strong></p>
</blockquote>
<p>传说中痘疮之神パヨカカムイ如果与人类结合，会产生出一种<strong>死而复生的人形怪物カスンテ</strong>，唯一能将其彻底杀死的方法是把上下颚分开，阻止其复生。カスンテ很容易让人联想到水生村那些病态的村民。</p>
<p><a href="https://image.gcores.com/ed044053-c2c5-4fdd-a378-acde103e4a63.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ed044053-c2c5-4fdd-a378-acde103e4a63.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水生村村民"></a></p>
<p>水生村村民</p>
<p>パヨカカムイ的动物形象是白色的鸟，在阿依努文化中白鸟是不详的象征。</p>
<p>恰恰相反的是，大和文化中存在广泛的白鸟信仰，来自于丈的原型日本武尊。日本武尊在讨伐虾夷途中英年早逝，死后化作白鸟升天，人们在各地建立白鸟神社纪念日本武尊。</p>
<p>日本武尊征讨虾夷想必会被当地人视为灾难，大和人崇拜他，虾夷人惧怕他。阿依努信仰中白鸟被认为是不详的疾病之神，也许是日本武尊把大和的某种疾病带到了东北也说不定。</p>
<p><a href="https://image.gcores.com/b3d6de27-7f3a-4048-8f13-562f5718dadd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b3d6de27-7f3a-4048-8f13-562f5718dadd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="日本武尊 白鸟传说"></a></p>
<p>日本武尊 白鸟传说</p>
<p>据说痘疮之神パヨカカムイ以人的形态出现时身穿带有唐草纹样的衣服。《只狼》中恰好有一位重要角色的衣服上有类似的花纹，猜猜他是谁？</p>
<p><a href="https://image.gcores.com/61d86483-03a1-46f1-9541-a9430441a9bd.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/61d86483-03a1-46f1-9541-a9430441a9bd.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="没错，正是在下"></a></p>
<p>没错，正是在下</p>
<p>这个人就是我们保护的九郎，九郎蝉色外衣上的原创纹样，从整体结构和排列方式来看可能改编于<strong>辔唐草纹</strong>。辔唐草纹是平安时代公卿常用的有职文样，公卿指太政大臣、左大臣、右大臣、大纳言、中纳言等朝廷高官。</p>
<p><a href="https://image.gcores.com/7035ad50-2c05-47df-abe7-ee1d65cf16da.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7035ad50-2c05-47df-abe7-ee1d65cf16da.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="九郎衣服上的纹样与辔唐草纹对比"></a></p>
<p>九郎衣服上的纹样与辔唐草纹对比</p>
<h1 id="苇名国可能存在的隐患"><a href="#苇名国可能存在的隐患" class="headerlink" title="苇名国可能存在的隐患"></a>苇名国可能存在的隐患</h1><p>怎么理解枭的所作所为？以下是我个人的一些观点。</p>
<p>枭造反的主要原因可能是：<strong>他认为苇名氏已经没有资格统治这片古老的土地了。</strong></p>
<p>游戏中有个小细节，在修罗结局中狼杀死老年一心后枭拿着黑色不死斩回来汇合，枭镜头之外的另一只手提着<strong>弦一郎的头颅</strong>，并摆在了一心尸体的旁边。即便弦一郎有高纯度的变若水维持其不死，也不一定必须要把整个头砍下来，那么枭这么做的原因很大程度上是出于憎恨。</p>
<p>结合对苇名氏原型奥州藤原氏的考据，可得一个游戏中没有实际证据支撑的推测：<strong>苇名氏可能并不是原生的本地人。</strong></p>
<p>平安时代的奥州藤原氏作为陆奥的俘囚之主，一直被认为是虾夷血统，这样有利于维持在当地的声望。有一部名为<strong>《苍蓝虾夷之血 藤原四代》</strong>的长篇小说，描述奥州藤原氏清衡、基衡和秀衡三代人的故事。此书作者今东光的经历也很特别，他不仅是一名作家，32岁出家成为天台宗僧侣，他的祖上出身于津轻地区（现日本东北青森县），所以自称是虾夷末裔“东夷之沙门”，后来担任关山中尊寺的住持，晚年开始创作这部长篇历史小说，可惜去世前没有完成此书。</p>
<p><a href="https://image.gcores.com/83114106-afdc-443d-b470-45ce6a1a0290.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/83114106-afdc-443d-b470-45ce6a1a0290.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="苍蓝虾夷之血 藤原四代"></a></p>
<p>苍蓝虾夷之血 藤原四代</p>
<p>也许是出于虾夷的传统习俗，清衡、基衡、秀衡、泰衡四人死后被木乃伊化处理，存放在中尊寺金色堂中，泰衡逃离平泉时被斩首没有留下全尸，只保留了头颅。（图片有些重口味，有兴趣的朋友可以自行搜索）</p>
<p>有关学者在1950年和1987年两次对奥州藤原四代的遗体进行DNA鉴定等医学调查，确定了奥州藤原氏不是虾夷出身，容貌体态也没有虾夷人的特征，藤原氏祖孙四人都是典型的大和民族血统。我们现在知道，奥州藤原氏是平安时代中期藤原秀乡的后代，被派遣移居至东北，一步步成为奥州的统治者。</p>
<p>苇名一心二十年前夺回了苇名之地的统治权，可如今却坦然面对灭亡的命运，在一心喝苇名酒的对话中，表明了他对苇名现在形势的态度：</p>
<blockquote>
<p>一度は好機となり、国盗りを果たした だが…　今は、死地にある… …ハッ、皮肉なことよ</p>
</blockquote>
<p>曾经趁着好的机遇夺回国家，可如今又陷入了死局，事与愿啊。</p>
<p>一心没有明说苇名真正的危机是什么，但是已经沦落到无法挽回之势。这也许就是枭憎恨一心的理由，外来者始终是外来者，不能代表本地人的利益，枭需要力量和计谋重建属于本地人自己的势力。</p>
<h1 id="义父名字中的故事"><a href="#义父名字中的故事" class="headerlink" title="义父名字中的故事"></a>义父名字中的故事</h1><p>枭的战斗记忆上面写着，他背叛苇名的直接目的是<strong>让自己的名字响彻日本</strong>。下面将会考据枭的姓氏，以及虾夷和阿依努人的遭遇，挖掘“让名字响彻日本”这句话背后的含义。</p>
<p><a href="https://image.gcores.com/46a2c057-d431-4796-8a32-c7d2dd95627a.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/46a2c057-d431-4796-8a32-c7d2dd95627a.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>修罗结局在被孝子背刺之前，枭喊出了自己名字的前半段，我们知道了枭的姓氏是<strong>薄井</strong>。薄井这个姓氏的典故，无法确定只是巧合还是制作组真的有意为之。</p>
<blockquote>
<p>【薄井】 日本姓氏語源辞典 臼井の異形。栃木県さくら市馬場では草分けと伝える。栃木県那須郡那須町漆塚に江戸時代にあった。 アイヌ系。個人名。北海道白糠郡白糠町のウヘンスーが薄井勇一に改名。推定では1875年頃。</p>
</blockquote>
<p>在《日本姓氏语源辞典》中，薄井这个姓氏主要来源有两个，前者是氏族名，后者是个例。</p>
<p>薄井作为氏族姓，是臼井的异称，二者在日文中都读作うすい。臼井氏又是千叶氏的分家，臼井氏之祖<strong>臼井常康</strong>在平安末期跟随千叶氏的<strong>千叶常胤</strong>，同属于源赖朝势力，并参与了讨伐平泉的奥州合战。战后奥州千叶氏继承藤原氏的领地，成为奥州新的统治者。到了战国时代，千叶氏与臼井氏依然很活跃。这个薄井姓氏的来源对应枭协助内府军灭亡苇名国。</p>
<p>千叶氏的众多家纹之中，有两个在《只狼》中出现过。</p>
<p><a href="https://image.gcores.com/16f0bee1-9805-4c50-bb8f-09520c5f9319.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/16f0bee1-9805-4c50-bb8f-09520c5f9319.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="丸に九曜"></a></p>
<p>丸に九曜</p>
<p>一个是<strong>九耀纹</strong>，在游戏开场CG中被苇名一心击败的田村主膳，衣服背后的家纹就是九耀纹。</p>
<p><a href="https://image.gcores.com/5e58ad6c-e83c-4413-8355-50bfe3445106.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5e58ad6c-e83c-4413-8355-50bfe3445106.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="田村主膳背后的家纹"></a></p>
<p>田村主膳背后的家纹</p>
<p>另外一个是<strong>五三桐纹</strong>，这个家纹在游戏中无法直接找到，需要解包游戏的贴图文件。桐纹是最常见的家纹之一，桐纹来自于天皇象征的桐竹凤凰，后来被许多大名使用过，现代政府一些部门和皇室相关的机构依然在使用五三桐纹。</p>
<p><a href="https://image.gcores.com/741a38e0-3e28-40c0-88c9-093741854a0d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/741a38e0-3e28-40c0-88c9-093741854a0d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="五三桐"></a></p>
<p>五三桐</p>
<p>游戏前期通往苇名城的路上会遭遇数名精英侍大将，这些武士的背后印着平田氏的家纹。把游戏数据解包后，同时打开侍大将马甲的贴图文件和法线贴图文件，会发现上面的家纹不同，正常贴图上是平田氏家纹，而法线贴图上是五三桐纹。</p>
<p><a href="https://image.gcores.com/7c867d79-24fb-46b0-a377-95be241090bf.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7c867d79-24fb-46b0-a377-95be241090bf.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>五三桐纹应该是游戏开发过程中占位的图案，正式版被统一更换成平田氏家纹。官方设定集中侍大将的原画也证实了五三桐是原案，实锤制作团队忘记修改这张法线贴图。</p>
<p><a href="https://image.gcores.com/81214f9f-1b0d-4b39-8b2a-0f82cdfaf900.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/81214f9f-1b0d-4b39-8b2a-0f82cdfaf900.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="侍大将 原画"></a></p>
<p>侍大将 原画</p>
<p>薄井姓氏的第二个出处是个例，1875年左右有个叫ウヘンスー的阿依努人改名为<strong>薄井勇一</strong>。为什么一个普通人改名会记录在姓氏辞典中？就又要说到大和民族对少数民族的迫害了。</p>
<p>北海道曾经叫虾夷地，1869年正式改名为北海道，同时政府启动了北海道开荒计划。1871年日本政府颁布<strong>户籍法</strong>，将阿依努人划分为“平民”阶级一视同仁，阿依努族的风俗习惯都被禁止，接受日语和化教育。在这样的背景下，阿依努人被强制将本名改成和名。</p>
<p>阿依努人失去的不仅仅是自己的姓名，因为日本政府一直都不承认少数民族，可以说民族之名也丧失了。直到这个世纪的2008年，日本政府重提此事，正式认可北海道的阿依努族是本国的少数民族。在长达一百多年的漫长岁月里，阿依努人被迫抛弃自己的民族文化，所以游戏中枭想要扬名于日本的另一层含义可能指的是让民族之名延续，堂堂正正活下去。</p>
<p>如果把以上这些原型联系在一起，结合我个人的联想，则会产生这样一个枭的形象：</p>
<p>枭曾经是苇名之地一个部落的成员，因为某些原因失去了自己的家人，被外来统治者收留，改名并成为忍者侍奉外来统治者，后来枭机缘巧合转而投靠苇名一心，盗国之战夺回苇名的自治权，杀死自己的旧主，被称为无主的忍者。二十年后内府压境，苇名国日薄西山，枭认为一心辜负了苇名，于是私通内府，试图先推翻苇名氏再自立，他的所作所为偏离了道义，氏族的神灵也不再眷顾他，最后死在自己养子的手上。</p>
<p>被迫改名，私通外敌，企图建立新的政权，是不是感觉很熟悉？这正是奥州藤原氏初代目藤原清衡在前九年之役和后三年之役的经历。</p>
<p>不知道创作者在原案中是否为枭提供了类似的人物背景，希望官方将来通过某些方式可以补全《只狼》中这些缺失的故事。</p>
<h1 id="御灵信仰-政治斗争的失败者们"><a href="#御灵信仰-政治斗争的失败者们" class="headerlink" title="御灵信仰 政治斗争的失败者们"></a>御灵信仰 政治斗争的失败者们</h1><p>平安时代，右大臣<strong>菅原道真</strong>被左大臣藤原时平污蔑陷害，贬官九州最后抑郁而亡。据说菅原道真死后，京城出现异相，皇子病死，宫中的清凉殿遭受落雷，朝廷认为是死去的菅原道真在作祟，立刻恢复其生前职位，修建天满宫镇压其怨灵。御灵信仰成型于平安初期，平安时代出现了大量的御灵，菅原道真就是其中最著名的御灵之一。</p>
<p>御灵信仰表现出日文文化难以理解的一面，无论好坏都要参拜。御灵信仰中参拜的御灵大多都是<strong>政治斗争和战争中牺牲的敌人</strong>，防止死者化为怨灵报复，对他们参拜祈祷怨灵转化成御灵保佑国泰民安。可以说参拜御灵的地方必出现过怨恨。</p>
<p>苇名国各处可以看到大量的御灵冢，以及两种死灵系精英敌人：<strong>无首</strong>和<strong>七面武者</strong>。</p>
<p><a href="https://image.gcores.com/a8ae379a-cd8f-4b4e-bc0d-c4140954f5f5.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a8ae379a-cd8f-4b4e-bc0d-c4140954f5f5.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="无首和七面武者"></a></p>
<p>无首和七面武者</p>
<p>无首曾是为苇名而战的将领们，他们身首异处，这种死法通常也是古时战败将士最终的命运。通过道具描述，我们可以感觉到大部分无首似乎都死于走火入魔后造反，他们为了护国“误入歧途”。对谁造反？处决者又是谁？游戏中语焉不详。</p>
<p><a href="https://image.gcores.com/5f289a0c-f842-4daf-8b8d-72cc58a5c332.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5f289a0c-f842-4daf-8b8d-72cc58a5c332.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="河童"></a></p>
<p>河童</p>
<p>遭遇无首难免后背一凉，配合诡异的音乐有种怪谈的感觉。<strong>无首</strong>的形象来自日本妖怪<strong>河童</strong>，无首消失然后突然出现在主角背后掏屁股的动作，还原了河童会偷取人类尻子玉的传说，无首那一圈不科学的头发，也是致敬了河童中年秃顶发型。河童、鬼和天狗作为日本最有代表性的三种妖怪在《只狼》中齐聚一堂，可以感觉到FromSoftware对妖怪的选择非常克制，没有去堆砌符号化的经典妖怪形象。</p>
<p><a href="https://image.gcores.com/e7f82ba8-e5b3-453c-9b0f-f46ac219e233.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e7f82ba8-e5b3-453c-9b0f-f46ac219e233.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平将门的头颅"></a></p>
<p>平将门的头颅</p>
<p>平安时代著名的御灵不得不提<strong>平将门</strong>，平将门在关东自立新帝试图推翻天皇的统治，被藤原秀乡讨伐后斩首。关于平将门之死有一个奇特的传说，挂起来示众的头颅几个月都不腐烂，怒瞪双眼，大喊道：“我的身体在哪里，谁敢与我一战”，吓得围观者四处奔逃，最后头颅飞向空中寻找自己的身躯。</p>
<p><a href="https://image.gcores.com/cf6ad2bf-a050-4edb-bb62-2b0a24022946.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cf6ad2bf-a050-4edb-bb62-2b0a24022946.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平将门与六个替身（左侧射箭的是藤原秀乡）"></a></p>
<p>平将门与六个替身（左侧射箭的是藤原秀乡）</p>
<p>另外一种御灵敌人<strong>七面武者</strong>的名字，可能取自<strong>平将门七人影武者</strong>的传说。《俵藤太物语》中记载，平将门有六个如影随形的替身护卫，面貌身型相似，外人分不清哪个才是平将门的真身，藤原秀乡讨伐平将门时也被众多影武者迷惑。</p>
<p><a href="https://image.gcores.com/c7c0e755-b590-4984-b88f-85fa6669b6cb.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c7c0e755-b590-4984-b88f-85fa6669b6cb.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="七人将门"></a></p>
<p>七人将门</p>
<p><a href="https://image.gcores.com/6e574cc9-3546-4b5c-b911-68ff1948c169.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6e574cc9-3546-4b5c-b911-68ff1948c169.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平新皇 将门公 七人影武者"></a></p>
<p>平新皇 将门公 七人影武者</p>
<p>千叶县千叶市的<strong>七天王冢</strong>被认为是平将门七骑武者之墓，据说其中葬着平将门的六名替身武者：藤原玄茂、藤原玄明、多治经明、坂上遂高、平将赖、平将武。</p>
<p><a href="https://image.gcores.com/4cdaa8dd-8323-4cbc-b9b2-1558989dc74e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4cdaa8dd-8323-4cbc-b9b2-1558989dc74e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="黑泽明 影武者"></a></p>
<p>黑泽明 影武者</p>
<p>让面貌身材相似的影武者混淆敌人视听，是古代保护首领安全的有效方法。因为那时没有照相机等现代手段来记录外貌细节，除了亲近的心腹很少有人知道首领具体的容貌。黑泽明的著名电影《影武者》便讲述了战国时代武田信玄的替身久而久之入戏动情的故事。在游戏领域，前几年某款同为断手设定的一线大作也讲了一个类似影武者的故事。（防剧透点击）</p>
<p><a href="https://image.gcores.com/323d94db-a333-4333-ba07-697bb28af91b.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/323d94db-a333-4333-ba07-697bb28af91b.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="……"></a></p>
<p>……</p>
<h1 id="误入歧途的护国勇者"><a href="#误入歧途的护国勇者" class="headerlink" title="误入歧途的护国勇者"></a>误入歧途的护国勇者</h1><p>游戏中共出现了五个无首（其实是六个），击败后掉落的道具描述了他们的遭遇。</p>
<p><a href="https://image.gcores.com/9d9a14d9-034c-4068-a71b-3380afd07a5e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9d9a14d9-034c-4068-a71b-3380afd07a5e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="无人参拜的首冢"></a></p>
<p>无人参拜的首冢</p>
<p>在苇名城附近一个阴暗的洞穴里，有一个无首守在荒凉的五轮塔周围。这里应该是他的首冢，长期无人来参拜。</p>
<blockquote>
<p>剛幹の御霊降ろし 「剛幹」を身に降ろす、首無しの遺魂 一時、体幹ダメージを軽減する 形代を消費すれば、何度でも使用できる 首無しは、かつて護国のため、 道を踏み外した勇者の成れの果て <strong>鎮めの首塚はあるが、長く参るものはいない</strong></p>
</blockquote>
<p>这个首冢无人参拜的无首，对应被坂上田村麻吕击败的<strong>阿弖流为</strong>。阿弖流为和同党母礼被劝降后押送入京，宫内贵族认为不能留下祸患将二人处以斩首。阿弖流为的身体和头颅据说分别葬在不同的地方，具体位置众说纷纭。</p>
<p><a href="https://image.gcores.com/7ad15863-7f33-4a02-bfd1-abea4d45a3ac.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7ad15863-7f33-4a02-bfd1-abea4d45a3ac.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="碑面上的图案是日本东北地图轮廓"></a></p>
<p>碑面上的图案是日本东北地图轮廓</p>
<p><a href="https://image.gcores.com/560d4182-a449-4bed-8f63-8e9c1f477ad6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/560d4182-a449-4bed-8f63-8e9c1f477ad6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>1994年纪念迁都平安京1200周年，京都清水寺为阿弖流为和母礼建碑认可其正面历史形象和功德。</p>
<p>旁边的说明碑写道：“八世纪末，日高见国的虾夷首领阿弖流为抵抗中央政府的数次侵略，后被坂上田村麻吕降服，和同胞母礼一起押送京城。坂上田村麻吕向政府求情失败，二人802年于河内国被处刑，在坂上田村麻吕开基的清水寺境内立显彰碑以鉴这段历史。”</p>
<p><a href="https://image.gcores.com/782f3d34-793a-4bcb-83f7-519cbbf241b8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/782f3d34-793a-4bcb-83f7-519cbbf241b8.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="牧野公园中的首冢"></a></p>
<p>牧野公园中的首冢</p>
<p>大阪府枚方市的牧野公园是传说中阿弖流为的首冢所在地之一，2007年在牧野公园中重新为其立冢碑，每年举行正式的参拜活动。</p>
<p>时代变迁，国家和民族观念也随之改变，是大逆不道的乱贼还是保卫家园的民族英雄，并没有一个固定的答案。</p>
<blockquote>
<p>夜叉戮の御霊降ろし 「夜叉戮」を身に降ろす、首無しの遺魂 一時、最大HPと体幹が大きく減少するが、 攻撃力と体幹攻撃力を大きく強化する 形代を消費すれば、何度でも使用できる 首無しは、かつて護国のため、 道を踏み外した勇者の成れの果て <strong>この勇者は、双子として生まれるはずだった 二人いたならば、宮の貴族に敗れるなどは…</strong></p>
</blockquote>
<p>源之宫湖中的双无首，其原型可能是<strong>藤原泰衡</strong>与<strong>藤原国衡</strong>两兄弟。藤原泰衡在秀衡去世后私通外敌逼死源义经，做了一系列错误的决策葬送掉奥州藤原氏的未来，而国衡将这一切看在眼中却没有出手阻止。两人如果能合力（协助源义经），也许就不会败给宫中的贵族（源赖朝）了吧。</p>
<p>发狂的无首和消失在森林之中的无首暂时没有发现具体的原型。找到的一些素材都比较牵强，就不在这里列举了。</p>
<p>沉入苇名城河中的无首可能是争议最大的，描述这个无首遭遇的文字中提到了一场语焉不详的叛乱。</p>
<blockquote>
<p>吽護の御霊降ろし 「吽護」を身に降ろす、首無しの遺魂 一時、物理攻撃によるHPダメージを軽減する 形代を消費すれば、何度でも使用できる 首無しは、かつて護国のため、 道を踏み外した勇者の成れの果て 護国に狂った武者は、 <strong>乱</strong>を企て首を刎ねられ、その身は堀に沈んだ</p>
</blockquote>
<p>这个无首对应前面所说的<strong>平将门</strong>。平将门谋反被斩首，头颅挂在城中示众，身体去向不明，有人认为是同党偷偷将身体取走，也有可能是被沉入护城河中。</p>
<p>游戏中这位被斩首的护国勇者谋划了一场什么样的叛乱呢？</p>
<h1 id="苇名城中暗藏的神秘叛乱"><a href="#苇名城中暗藏的神秘叛乱" class="headerlink" title="苇名城中暗藏的神秘叛乱"></a>苇名城中暗藏的神秘叛乱</h1><p>苇名城一个隐秘的角落提及了一场过去发生的叛乱，虽然没有证据可以证明这场叛乱指的是无首谋划的叛乱，以下推测仅供参考。</p>
<p>苇名城废弃地牢靠近七面武者出现位置附近的过道中，有一个残破倒塌的五轮塔。调查此塔会显示五轮塔上的碑文文本。</p>
<p><a href="https://image.gcores.com/f005af55-900f-4cb9-bfb9-ea57ef14d7cf.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f005af55-900f-4cb9-bfb9-ea57ef14d7cf.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="不同语言版本的倒塌供养塔文本"></a></p>
<p>不同语言版本的倒塌供养塔文本</p>
<p>这里同时列出了日文、繁体中文、简体中文三个版本的碑文文本，其中繁体中文的翻译是错误的。被镇压于此的是苇名人民的亡灵，他们被夺走了国家并被处以极刑，可以得出一个结论：立御灵五轮塔的是<strong>当时的外来统治者</strong>，侵略苇名后屠杀了大量的苇名人民。</p>
<p><a href="https://image.gcores.com/7cfd9fe9-c4da-4e3c-a0eb-6f90210569b1.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7cfd9fe9-c4da-4e3c-a0eb-6f90210569b1.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="投身处 原画"></a></p>
<p>投身处 原画</p>
<p>这个五轮供养塔提供的信息，符合我在神之篇中考据鸟居时的推测。此处附近的投身处立有源之宫风格的鸟居，说明这个废弃地牢过去可能是源之宫势力占领苇名时使用的场所，五轮塔和投身处之间是出现七面武者的空地，七面武者会掉落一把名为“奉魂”的龙之仪式匕首，这把匕首很明显也来自于源之宫。</p>
<blockquote>
<p>形代流し 刃も柄も真白い短刀 HPを形代に変換する 本来、この短刀は形代流しに使われる 白い刃で削り出した己の形代を、 源の水に流し、竜に奉る儀式だ 刻まれた銘は、「奉魂」 それがこの小刀の真の名</p>
</blockquote>
<p>奉魂匕首的物品描述上写着，将形代纸人顺水漂流是源之宫供奉神龙的仪式，而这把匕首在游戏中的实际作用是以血换取形代。再考虑到隔壁的古代牢房和深不见底的投身处，也许这里发生过令人不寒而栗的事情。</p>
<p>接着继续调查五轮塔，仔细观察会发现五轮塔的石碑上刻着清晰的字迹，让我们看看上面写了什么。</p>
<p><a href="https://image.gcores.com/2a64da9d-457e-4a67-a26e-307080fccee2.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2a64da9d-457e-4a67-a26e-307080fccee2.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="五轮塔碑文"></a></p>
<p>五轮塔碑文</p>
<blockquote>
<p>平田ノ乱　（あ？刑？）死者　（御？仏？）霊　鎮める</p>
</blockquote>
<p>碑文上有些字难以辨认，但不影响整体句意，这句话的意思是<strong>平田之乱的死者灵魂镇压于此</strong>。结合游戏文本和实际碑文的内容，可以得到以下信息：</p>
<p>过去苇名之地被外来者占领，苇名人民在平田起义试图夺回国家，起义失败被处刑，此事件被称为<strong>平田之乱</strong>。统治者在废弃地牢建造了五轮塔镇压死去的苇名亡灵。</p>
<p><a href="https://image.gcores.com/59cc5382-ae9c-4091-8ae5-4023934d5f14.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/59cc5382-ae9c-4091-8ae5-4023934d5f14.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平田宅邸"></a></p>
<p>平田宅邸</p>
<p>也许沉入护城河的无首谋划的“叛乱”就是这场平田之乱，被当时的统治者斩首并沉尸护城河，在历史上留下了谋反的污名，跟随护国勇者起义的大量苇名人民也一齐被杀害。护国勇士发狂的原因可能是饮用了变若水，或是堕入修罗化身为鬼。废弃地牢则可能是过去外来者镇压用的牢狱，一心复国后被废弃，所以现在叫做废弃地牢。苇名之地在创作之初的历史设定或许要比游戏中表现的更加黑暗和压抑。</p>
<p>从游戏开发的角度，游戏文本和场景贴图显示的内容不同，可能性最大的原因是<strong>游戏缩水</strong>。游戏文本删除了平田之乱的内容，但是场景的贴图没有随着修改。</p>
<p>平田宅邸和废弃地牢都是缩水的重灾区，存在大量没有交代的谜团，比如平田宅邸为什么会有隐藏的地下佛堂，废弃地牢的入口为什么有平田氏的家纹等等。</p>
<p>关于平田之乱，说两个算不上是原型的历史事件，毕竟仅靠一个名字想要考据实在太难了。二者都是日本东国发生的虾夷叛乱，看似独立的事件之间存在微妙的关系。</p>
<p>平安中期的宽平元年（889年），日本关东地区发生<strong>宽平延喜东国之乱</strong>，叛乱持续了很长时间。当时关西的中央朝廷对关东的治安问题无力处理，动员各地武士协助镇压做乱的俘囚，这一事件成为后来武士阶层崛起取代皇室统治的伏笔之一。平定这场叛乱最直接的受益者是<strong>坂东平氏</strong>，903年出生的平将门后来继承了坂东平氏的遗产。</p>
<p>天庆2年（938年），平将门反抗朝廷自称新皇的前夕，东北出羽地区又爆发了名为<strong>天庆之乱</strong>的虾夷叛乱，有人认为这场叛乱与平将门不无关系，平将门的父亲曾经是陆奥的镇守府将军，在一些文献中记载平将门有一个叫平将种的弟弟，可能是出羽虾夷叛乱的主谋。</p>
<blockquote>
<p>天慶2/大饗、〈不出簾外、〉七日節会、射礼、射遺、園韓神祭、無上卿可行事、将門事、不録、覧円堂会無童、賀茂祭、斎王依雨不渡河、<strong>出羽賊乱</strong>、神今食、依方忌不幸、繁時叙位事、祈雨事重可被行、於法性寺行法事、御書始、新嘗会、依納言以上不参無行幸、臨時祭、宣命参議奏事、陰陽寮依准三宮進新暦事、従内給誦経巻数度者等、 天慶2.4.17/十七日、<strong>出羽</strong>国馳駅言上<strong>凶賊乱逆</strong>与秋田城軍合戦事等、左衛門督入夜参入、夜国解文令外記送家、 天慶2.5.6/六日、<strong>出羽</strong>国馳駅使来、其解文云、<strong>賊徒</strong>到来秋田郡、開官舎、掠取官稲、焼亡百姓財物、又率<strong>異類</strong>可来云々、</p>
</blockquote>
<p>当时关白太政大臣<strong>藤原忠平</strong>的日记《<strong>贞信公记</strong>》中简要记载了这场叛乱，日记中提到贼群中有“<strong>异类</strong>”这个细节显得有些神秘。天庆之乱的过程细节以及镇压者是谁，在史籍上没有留下记载。</p>
<h1 id="仙峰寺-佛师-以及游戏中佛教的现实意义"><a href="#仙峰寺-佛师-以及游戏中佛教的现实意义" class="headerlink" title="仙峰寺 佛师 以及游戏中佛教的现实意义"></a>仙峰寺 佛师 以及游戏中佛教的现实意义</h1><p><a href="https://image.gcores.com/55c0faf7-44d6-4e2e-bb93-b6521edf65fe.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/55c0faf7-44d6-4e2e-bb93-b6521edf65fe.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="狮子猿饮水处"></a></p>
<p>狮子猿饮水处</p>
<p>《只狼》中的佛教元素有一种难以言表的奇妙氛围。接触游戏之初就隐隐约约感觉到，这个游戏中的佛教对政治方面的隐喻更重一些。一直不知道该从什么角度展开，直到国之篇完成多半才找到一个自认为比较理想的切入点。</p>
<p>尽管游戏中的佛教在细节方面的运用非常考究，但本文不会从这方面下手。而是回归人本位谈一谈那些笃信佛教的人、佛教对日本的影响以及创作者如何把这些信息融入到《只狼》的世界观中。</p>
<p>平安时代之前的奈良时代，以平城京（现奈良市西部）为中心兴起了六大佛教宗派：三论宗、成实宗、法相宗、俱舍宗、华严宗、律宗，统称<strong>南都六宗</strong>。</p>
<p><strong>桓武天皇</strong>迁都平安京后，为了摆脱奈良政治和佛教的影响，希望以平安京为中心发展新的佛教宗派来辅助朝廷统治。入唐求法的传教大师<strong>最澄</strong>和弘法大师<strong>空海</strong>回到日本后，分别创建<strong>天台宗</strong>和<strong>真言宗</strong>，此二宗为平安时代佛教的核心。征讨虾夷开疆扩土是当时中央朝廷面对的重要问题之一，镇护国家的佛教在这方面也起到了不小的作用。</p>
<p>游戏中的仙峰寺由多个现实原型重叠组成，每个原型的选择都有所理由。下面将按仙峰寺原案、地理位置、外观、本殿、奥之院、幻廊的顺序，考据其中都隐藏了什么样的典故。</p>
<p><strong>仙峰寺原案 会津高野山八叶寺</strong></p>
<p>一个叫“<a href="http://inbksk.hatenadiary.com/" target="_blank" rel="noopener"><strong>クズ底</strong></a>”的技术流狼学家博客公开了部分<a href="http://inbksk.hatenadiary.com/entry/2019/04/07/174345" target="_blank" rel="noopener">游戏弃用文本</a>的内容，可知仙峰寺早期的名字是<strong>八叶寺</strong>，对应福岛县会津若松市的<strong>诸陵山八叶寺</strong>。</p>
<blockquote>
<p>水源の村と、菩薩の谷 見事、二つの神器を手に入れたな だが、不死断ちには神器だけでは足りぬ <strong>八葉寺</strong>に行き、不死の秘密を探ってくれ</p>
</blockquote>
<p>八叶寺在战国时代受到会津芦名氏的庇护昌盛发展，后被另一位东北的战国大名伊达政宗烧毁，重建成现在的八叶寺。</p>
<p><a href="https://image.gcores.com/8ddea82a-69ac-4af5-bf2c-ecb8b245cdb3.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8ddea82a-69ac-4af5-bf2c-ecb8b245cdb3.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="八叶寺 阿弥陀堂"></a></p>
<p>八叶寺 阿弥陀堂</p>
<p>八叶寺是真言宗寺院，也被称为<strong>会津高野山</strong>。下文会说到真正的高野山金刚峰寺是真言宗的总本山，由真言宗祖师空海大师开基。</p>
<p><a href="https://image.gcores.com/dbc6e772-c56f-42fb-b6dc-2480335f9723.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/dbc6e772-c56f-42fb-b6dc-2480335f9723.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="会津高野山 八叶寺"></a></p>
<p>会津高野山 八叶寺</p>
<p>除了与会津芦名氏关系密切以外，八叶寺有供养死者的特殊行事，在一种叫过去帐的法具上记载故人的戒名和法号；安置施饿鬼塔婆供养；把故人的遗骨、遗发、遗齿放到小型的木制五轮塔中供养等等。</p>
<p>从这个原型的选择，可以看出游戏创作之初已经确定好了游戏舞台将是日本东北，并且以芦名氏曾经供养的八叶寺为原本，敲定与供养死者关系密切的仙峰寺。</p>
<p><strong>仙峰寺地理位置 关山中尊寺</strong></p>
<p><strong>关山中尊寺</strong>，天台宗东北大本山，创立者是奥州藤原氏一代目藤原清衡。中尊寺位于东山道陆奥国平泉的北侧，符合游戏中古地图的位置。平泉陷落时，因为中尊寺与平泉有一段距离最后得以幸存。游戏中苇名城的火海也没有波及到仙峰寺。</p>
<p><a href="https://image.gcores.com/314a45d7-d849-4b35-82bd-993deed1c8fe.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/314a45d7-d849-4b35-82bd-993deed1c8fe.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="中尊寺 金色堂"></a></p>
<p>中尊寺 金色堂</p>
<p>奥州藤原氏经营平泉的一百年中，清衡修建<strong>中尊寺</strong>，基衡修建<strong>毛越寺</strong>，秀衡修建<strong>无量光院</strong>，以中尊寺为代表的平泉寺院及遗迹现在被列入日本的世界文化遗产。</p>
<p>天台宗又被称为天台法华宗，以大乘佛教的妙法莲华经为基础。法华经提倡人人平等皆可成佛，所以日本的天台宗创立后，最澄大师与弟子们积极奔赴各地传教，促进了东北的稳定。根据寺传，中尊寺的前身是最澄的弟子<strong>慈觉大师圆仁</strong>开创的关山弘台寿院。圆仁俗姓<strong>壬生</strong>，出身于东国的壬生氏，后来成为第三代天台座主。</p>
<p>中尊寺和“不死”或多或少也有一些关系，奥州藤原氏前后四代领主的遗体都被制成木乃伊存放在中尊寺的金色堂中，这种特殊的殡葬形式是当时虾夷的习俗还是出于什么特殊的意愿，理由不明。</p>
<p><strong>仙峰寺外观 京都音羽山清水寺</strong></p>
<p><strong>音羽山清水寺</strong>，北法相宗大本山，平安中期到明治时代之间也兼修真言宗。清水寺最明显的特征是由139根木柱支撑起来的<strong>悬空舞台</strong>，这种结构被称为“<strong>悬造</strong>”或“<strong>舞台造</strong>”，游戏中仙峰寺也采用这一结构。</p>
<p><a href="https://image.gcores.com/7955051b-daeb-4918-bfab-aea18dd7eca9.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7955051b-daeb-4918-bfab-aea18dd7eca9.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="清水寺"></a></p>
<p>清水寺</p>
<p><a href="https://image.gcores.com/ead9e6d5-7512-4011-958e-69cdd297882f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ead9e6d5-7512-4011-958e-69cdd297882f.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺 原画"></a></p>
<p>仙峰寺 原画</p>
<p>上面这张原画可以看出仙峰寺最初的造型更接近清水寺，正式版修改了屋顶和舞台的形状。</p>
<p><a href="https://image.gcores.com/3745dc15-220c-4172-a7f9-3ae085702cb8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3745dc15-220c-4172-a7f9-3ae085702cb8.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺 原画"></a></p>
<p>仙峰寺 原画</p>
<p>清水寺的创立者是坂上田村麻吕，讨伐虾夷后坂上田村麻吕返回平安京，在清水寺中进行平定参拜，这也是阿弖流为的显彰碑设立在清水寺的原因。清水寺象征大和朝廷对东北的讨伐和统治，坂上田村麻吕希望阿弖流为能回到东北夷人治夷，这与天台宗的最澄大师观念相似。</p>
<p><strong>仙峰寺本堂 莲华王院三十三间堂</strong></p>
<p><strong>三十三间堂</strong>，正式名称为莲华王院本堂，是天台宗妙法院的境外佛堂。三十三间堂中金壁辉煌的佛像群令人印象深刻，创立者为平安末期的<strong>后白河天皇</strong>。</p>
<p><a href="https://image.gcores.com/598716d3-fd9e-49a2-be06-e94c31f7431e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/598716d3-fd9e-49a2-be06-e94c31f7431e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺 本堂"></a></p>
<p>仙峰寺 本堂</p>
<p><a href="https://image.gcores.com/37975cdb-e777-4b1a-949b-7fb8476a14ee.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/37975cdb-e777-4b1a-949b-7fb8476a14ee.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="莲华王院 三十三间堂"></a></p>
<p>莲华王院 三十三间堂</p>
<p>平安末期的第77代天皇后白河天皇仅在位两年，就让位给第78代天皇二条天皇，让位的目的是以上皇的身份进行<strong>院政</strong>。</p>
<p>退位院政这种畸形的政治模式是为了对抗藤原北家类似中国历史上外戚干政的<strong>摄关政治</strong>。之前的天皇曾经尝试直接反抗公家，在前文的御灵信仰部分曾提到，宇多天皇任命<strong>菅原道真</strong>为右大臣，与左大臣<strong>藤原时平</strong>共同执政，试图削弱藤原氏的权力，但当醍醐天皇继承皇位后，菅原道真被谗言陷害，贬官至九州抑郁而死，以藤原氏的胜利告终。</p>
<p>上皇通过院宣，越过天皇下达命令，可以有效压制藤原北家干政。然而这么做产生了新的问题，上皇派和天皇派出现分歧开始对峙。</p>
<p><a href="https://image.gcores.com/9ce1f335-d0f7-44d5-b127-d7d856d911e8.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9ce1f335-d0f7-44d5-b127-d7d856d911e8.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="后白河法皇"></a></p>
<p>后白河法皇</p>
<p>几经软禁和复权的后白河院见证了政局的动荡和皇权的衰败。在他院政的几十年，先后经历五位天皇轮流上位，分别是二条天皇、六条天皇、高仓天皇、安德天皇、后鸟羽天皇，并在不同时期与二条天皇、平清盛、源义仲、源赖朝等人对立。</p>
<p>京都法住寺（当时叫法住寺殿）是后白河上皇院政时期的离宫，<strong>平清盛受命为上皇在法住寺内修建了三十三间堂</strong>。源义仲上洛后与朝廷产生摩擦，突袭并烧毁了法住寺殿，软禁后白河院。</p>
<p><a href="https://image.gcores.com/d2f9d3e5-0536-437a-986e-d3ade22350ae.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d2f9d3e5-0536-437a-986e-d3ade22350ae.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="三十三间堂和法住寺"></a></p>
<p>三十三间堂和法住寺</p>
<p>平安时代多位天皇笃信佛教，后白河天皇退位开始院政11年后，遁入空门成为法皇，可见佛教在平安时代的巨大影响力。日本的僧兵也开始出现在历史舞台上，平安末期许多寺院都拥有强大的僧兵武装，同样笃信佛教的朝廷贵族难以应对寺院的僧兵，间接提高了武士阶层的重要性。</p>
<p><a href="https://image.gcores.com/b73e2684-481f-4029-932a-efad161a4da4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b73e2684-481f-4029-932a-efad161a4da4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="五条大桥上的源义经和武藏坊弁庆"></a></p>
<p>五条大桥上的源义经和武藏坊弁庆</p>
<p><strong>武藏坊弁庆</strong>是平安时代著名的僧兵，传说他在京都五条大桥上与过路的武士决斗，败者要留下自己的刀具，当收集到999把刀时，吹着笛子路过此地的源义经击败了他，于是武藏坊弁庆死心塌地成为源义经的郎党，效力终生。《只狼》引用了武藏坊弁庆的千本刀典故，在游戏中分别呈现于守护仙峰寺大桥寻求千本刀的<strong>甲胄武士</strong>和守护源之宫朱桥手持薙刀的<strong>破戒僧</strong>。</p>
<p><a href="https://image.gcores.com/8d90834d-5f13-4c0a-9b7f-4aad77d8bc88.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8d90834d-5f13-4c0a-9b7f-4aad77d8bc88.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="破戒僧和甲胄武士"></a></p>
<p>破戒僧和甲胄武士</p>
<p>僧兵直到战国时代依然很活跃，游戏中平田庄和苇名城出现了专门针对忍者的僧兵，亲切地督促玩家练习看破。</p>
<p><a href="https://image.gcores.com/46fbe63f-3b28-4f2d-873d-6222e2b63709.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/46fbe63f-3b28-4f2d-873d-6222e2b63709.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="僧兵 忍者猎人"></a></p>
<p>僧兵 忍者猎人</p>
<p>历史观点认为后白河法皇对佛教的依赖和无能，导致朝廷式微被武家取代。平清盛、源义仲等武家陆续被消灭后，源赖朝逼迫后白河法皇院宣讨伐朝敌奥州藤原氏。当河内源氏扫清一切障碍，也就意味着平安时代的结束。</p>
<p>仙峰上人这个角色的设定，或多或少可能参考了后白河法皇。</p>
<p>仙峰上人出身神秘，在苇名之地建立仙峰寺，对应后白河天皇离开平安宫，遁入空门后居住在法住寺，并下令修建三十三间堂。仙峰上人追求不死，试图再造另外一个龙胤，对应后白河法皇出家后依然试图通过院政掌握国家大权。仙峰寺的僧人们抛弃佛法追求不死，象征出家的僧人沾染政治，偏离修法的正道。</p>
<p>附虫这种从源之宫流出的劣质不死之力好比失去天意的王权，仙峰上人开悟后想把神龙送回西方，对应沉迷于佛教的后白河法皇，出家后还想通过佛教匡正皇权。</p>
<p><a href="https://image.gcores.com/0c19c50b-71aa-4968-8f26-edf60b19d5ee.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0c19c50b-71aa-4968-8f26-edf60b19d5ee.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="存放红色不死斩的木箱"></a></p>
<p>存放红色不死斩的木箱</p>
<p>著名魂学家VaatiVidya在视频中提出了仙峰寺的一个细节，变若御子将红色不死斩交给狼时，<strong>存放红色不死斩的木箱表面刻着源之宫的神纹</strong>。这把疑似来自源之宫的红色不死斩一直由仙峰上人保管，这也暗示了仙峰上人和源之宫可能存在某种关系。介于不死斩在《只狼》中特殊的意义，至少创作初期的仙峰上人应该不只是一个僧人那么简单。</p>
<blockquote>
<p>永旅経・蟲賜わりの章 永い悟りの旅路へいざなう経典。その一節 あの子に渡して欲しいと、託されたもの 我、蟲を賜わり、幾星霜 死なずとは、永き悟りの旅路なり 死なぬ訳もまた、悟らねばなるまい 神なる竜は、西の故郷より来られたという 我に、蟲を授けられたは、なにゆえか</p>
</blockquote>
<p>回顾仙峰上人留下的《永旅经》，似乎隐藏了另一层意思。后白河法皇坐在三十三间堂之中，是否也曾思考过相似的问题：“我被赐予皇权历经沧桑，将这样的权力授予我的缘由又是什么呢？”</p>
<p><strong>仙峰寺奥之院 高野山金刚峰寺</strong></p>
<p><strong>高野山金刚峰寺</strong>，真言宗总本山，由<strong>弘法大师空海</strong>创建。游戏中的奥之院可能参考了金刚峰寺的<strong>大师教会</strong>，造型上进行了一些修改，比如入母屋造样式屋顶的朝向。</p>
<p><a href="https://image.gcores.com/145531e4-2f67-4183-9516-2ccf96a14cc4.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/145531e4-2f67-4183-9516-2ccf96a14cc4.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="仙峰寺 奥之院"></a></p>
<p>仙峰寺 奥之院</p>
<p><a href="https://image.gcores.com/86de69a3-5718-46ce-ac38-01d2eeac158f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/86de69a3-5718-46ce-ac38-01d2eeac158f.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="高野山 金刚峰寺 大师教会"></a></p>
<p>高野山 金刚峰寺 大师教会</p>
<p>空海大师入定于金刚峰寺的奥之院，信徒一直相信空海大师到现在在活着，保佑世间平安。3月21日是大师入定之日，每年3月21日全山僧人都要参与“<strong>正御影供</strong>”仪式，运送更换御影堂中供养的御衣。</p>
<p><a href="https://image.gcores.com/b4d9725d-197f-46d2-bd71-241a52ec73b5.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b4d9725d-197f-46d2-bd71-241a52ec73b5.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="正御影供"></a></p>
<p>正御影供</p>
<p>游戏中想要完成龙之返乡结局，需要找到两本仙峰上人留下的《永旅经》。变若御子告诉狼去仙峰寺后面的洞穴里找仙峰上人，第二本《永旅经》就放置于仙峰上人的尸体处。出来告诉变若御子仙峰上人已死时，变若御子表现得很惊讶，说明仙峰寺中的僧人也一直认为仙峰上人还活着，就像高野山金刚峰寺奥之院中的空海大师一样。</p>
<p>不同于天台宗人人平等皆可成佛的观念，真言宗以大日如来的密严净土为教义，追求即身成佛。宫崎英高把即身佛的概念再创作成了仙峰寺中身上爬满蜈蚣的不死求道者，竟然没有引起现实中佛寺的非议。</p>
<p>从某种程度上来说，空海大师似乎认为虾夷是野蛮不可教化的。空海的汉诗文集《<strong>性灵集</strong>》第一卷，有一首写给好友<strong>小野岑守</strong>的杂言诗，名为《<strong>赠野陆州歌</strong>》，空海以此诗庆祝小野岑守上任陆奥守。</p>
<p><a href="https://image.gcores.com/fcb988b9-cfec-4eac-90c1-e0afb8049f4e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fcb988b9-cfec-4eac-90c1-e0afb8049f4e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="赠野陆州歌 并序"></a></p>
<p>赠野陆州歌 并序</p>
<p>以下是个人整理的简体中文版，如有错误请指出。</p>
<blockquote>
<p>日本丽城三百州 就中陆奥最难柔 天皇赫怒几按剑 相将幄中争驰谋 往帝伐 今上忧 时时牧守不能刘 自古将军悉啾啾 毛人羽人接境界 猛虎豺狼处处鸠 老鸦目 猪鹿裘 髻中插著骨毒箭 手中每执刀与矛 不田不衣逐麋鹿 靡晦靡明山谷游 罗刹流 非人俦 时时来往人村里 杀食千万人与牛 走马弄刀如电击 弯弓飞箭谁敢囚 苦哉边人每被毒 岁岁年年常吃愁 我皇为世出能鉴 亦咨焉刃局（这里可能少两个字） 千人万人举不应 唯君一个帝心抽 山河气 五百贤 允武允文得自天 九流三略肚里吞 鹏翼一搏睨此境 毛人面缚侧城边 凶兵蕰库待冶铸 智剑满胸几许千 不战不征自无敌 或男或女保天年 昔闻妫帝干舞术 今见野公略无匹 京邑梅花先春开 京城杨柳茂春日 边城缓暖无春蕊 边垒早冬无茂实 高天虽高听必卑 况乎鹤响九皋出 莫愁久住风尘里 圣主必封万户秩</p>
</blockquote>
<p>空海把陆奥地区比喻为豺狼之境，虾夷人如同罗刹，不织衣不耕地。他认为这样的蛮夷应该当作非人来看待。空海作为佛学大师表达出如此偏激和消极的看法，需要结合当时特定的政治环境来考虑。</p>
<p><strong>仙峰寺幻廊 奈良东大寺</strong></p>
<p><strong>奈良东大寺</strong>，华严宗大本山，创立者是第45代天皇<strong>圣武天皇</strong>。在仙峰寺的所有寺院原型中，建成于奈良时代的东大寺最为古老，它代表了日本历史上佛教对政治影响的根源。也许正因为如此，创作者把东大寺放在了仙峰寺如梦境般虚无缥缈的幻廊之中。</p>
<p><a href="https://image.gcores.com/f2e1fc75-da61-4f20-ad51-5bda7997baa8.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f2e1fc75-da61-4f20-ad51-5bda7997baa8.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="东大寺 大佛殿"></a></p>
<p>东大寺 大佛殿</p>
<p>官方设定集中幻廊中央建筑的原画，和东大寺的大佛殿几乎一模一样。</p>
<p><a href="https://image.gcores.com/e684b892-ea74-44fb-ad5d-4444a9d10f72.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e684b892-ea74-44fb-ad5d-4444a9d10f72.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="幻廊 原案"></a></p>
<p>幻廊 原案</p>
<p>正式版修改了唐破风的形状、屋顶样式以及墙壁装饰的细节，去掉了屋顶醒目的金色鸱尾。在源之宫中我们还有机会看到这些金色鸱尾。</p>
<p><a href="https://image.gcores.com/fd768df5-ea6a-4f8f-b78b-f340ebe47ca2.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fd768df5-ea6a-4f8f-b78b-f340ebe47ca2.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="幻廊 实际游戏"></a></p>
<p>幻廊 实际游戏</p>
<p>东大寺虽然现在属于华严宗寺院，奈良时代兼学南都六宗，平安时代又加入新兴的天台宗和真言宗，成为八宗兼学之寺。平安初期的桓武天皇鼓励发展以平安京为中心的新兴佛教，东大寺作为南都佛教寺院发展受到限制。到了平安末期，后白河法皇对东大寺的修缮作出很大贡献。</p>
<p>后白河法皇出家后，曾在东大寺中受戒。源平合战的前夕，<strong>平清盛</strong>下令<strong>火烧南都寺院</strong>，东大寺烧毁了包括大佛殿在内的很多建筑，后来在<strong>源赖朝</strong>的帮助下，后白河法皇作为导师为东大寺举行“<strong>大佛开眼供养</strong>”仪式并开展了修复工作，镰仓时代东大寺再次复兴。</p>
<p>东大寺和远在东北的奥州藤原氏也有交集。东大寺烧毁后需要大量的修复资金。有记录曾记载，源赖朝为修缮贡献一千两黄金，藤原秀衡考虑到平泉稳定发展，需要维护与中央朝廷的关系，贡献五千两黄金。平氏灭亡之后，源赖朝变本加厉，要求平泉向朝廷的进贡需要在镰仓中转，秀衡避免冲突只能照做，当源赖朝又要求再为修复东大寺贡献三万两黄金时被婉言拒绝。</p>
<p>幻廊中央以东大寺大佛殿为原型的建筑内部，在游戏中叫作<strong>奈落堂</strong>。</p>
<p><a href="https://image.gcores.com/d25ec9c8-b7eb-44f8-b5eb-b7f417bb381f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d25ec9c8-b7eb-44f8-b5eb-b7f417bb381f.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="奈落堂"></a></p>
<p>奈落堂</p>
<p>奈落是佛教中的地狱，日语中奈落也指舞台下面，可能是因为舞台底下比较黑暗，另外一种类似都市怪谈的说法认为华丽的舞台背后往往存在着嫉妒和怨念，化作魔物潜伏在舞台之下，时而作祟造成舞台事故。</p>
<p>幻廊建筑的底部和仙峰寺一样，采用由木柱支撑的清水寺“<strong>舞台造</strong>”结构，所以奈落堂这个名字取了漂亮的双关，既指下面看不见底的万丈深渊，也指木柱支撑的悬空舞台之下。</p>
<h1 id="《火之鸟》中的虚假佛教"><a href="#《火之鸟》中的虚假佛教" class="headerlink" title="《火之鸟》中的虚假佛教"></a>《火之鸟》中的虚假佛教</h1><p>幻廊的原型东大寺还与游戏中的一个角色有关，那就是废弃寺院中指导玩家的<strong>雕佛师</strong>。</p>
<p><a href="https://image.gcores.com/7ffba424-02ac-4b1d-80c9-4d754eea90e0.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7ffba424-02ac-4b1d-80c9-4d754eea90e0.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="游戏中的佛师"></a></p>
<p>游戏中的佛师</p>
<p>佛师是专门制作佛像的雕刻职业，平安时代之前朝廷有统一的造佛所提供佛工的工作，到了平安时代造佛所纷纷倒闭，雕佛工作者以僧侣的身份在各大寺院雕刻佛像，被称为佛师。</p>
<p><a href="https://image.gcores.com/55f5b25f-968c-4851-91c5-e9d88a84fc48.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/55f5b25f-968c-4851-91c5-e9d88a84fc48.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="佛师"></a></p>
<p>佛师</p>
<p>游戏中的雕佛师作为被佛陀感化的代表，原型来自于手冢治虫的鸿篇巨著《火之鸟》凤凰篇的主角<strong>我王</strong>。</p>
<p><a href="https://image.gcores.com/482b4234-4544-4704-b345-06b919ab2c86.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/482b4234-4544-4704-b345-06b919ab2c86.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="火之鸟 凤凰篇"></a></p>
<p>火之鸟 凤凰篇</p>
<p>《火之鸟》凤凰篇的故事以两个主要角色我王与茜丸截然不同的人生轨迹展开，二人的命运令人唏嘘。</p>
<p>我王出生后遭遇事故，失去一臂一目和自己的父亲，母亲因此疯癫。童年遭遇不幸的我王一直被村民欺负，某日再也无法忍受羞辱而大开杀戒，逃离曾经生活的村庄落草为寇。</p>
<p>逃亡途中，我王遇到了京城雕佛师“大和的茜丸”，善良正直的茜丸被我王抢走衣物并砍断右手的手筋，在寺院的雕佛大师教导下茜丸拾起希望，重新拿起刻刀。</p>
<p><a href="https://image.gcores.com/b47e2851-28fa-4e39-8364-9c52a8cd536d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b47e2851-28fa-4e39-8364-9c52a8cd536d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>我王一路烧杀抢掠秉性多疑，亲手错杀至爱后沉浸在痛苦之中，此时一名高僧出现在我王面前，带着他去日本东北的<strong>奥州</strong>修行。</p>
<p><a href="https://image.gcores.com/01479c6c-5a77-415a-b0ea-c2db3a68dbf7.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/01479c6c-5a77-415a-b0ea-c2db3a68dbf7.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>勤奋努力的茜丸收到宫中贵族的命令，要求他在三年内必须完成凤凰的雕像，可凤凰究竟长什么样茜丸并不知道。有幸得到了贵人相助，茜丸被告知九州筑紫国有火之鸟的传说。</p>
<p>我王和茜丸第二次相遇于京城，茜丸认出了曾经伤害自己的我王，但没有记恨于他。茜丸动身前往九州寻找火之鸟，而我王跟随师傅准备去<strong>奥州平泉</strong>。</p>
<p><a href="https://image.gcores.com/82745313-bded-4579-9ef5-e41a77073e53.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/82745313-bded-4579-9ef5-e41a77073e53.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>一个偶然的机会，我王在师傅的引导下开始试着雕刻佛像，发泄心中的怨念和苦闷，我王雕出的佛像虽然面目狰狞却栩栩如生。</p>
<p><a href="https://image.gcores.com/5548c2a2-49e6-4b05-a79a-22e10f8ae250.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5548c2a2-49e6-4b05-a79a-22e10f8ae250.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>途中我王被当地人认出是曾经的恶贼，关入监牢。在牢狱中我王雕刻了大量面目狰狞的佛像，这也是游戏中废弃寺院场景的原型。</p>
<p><a href="https://image.gcores.com/4cdef099-6e61-4d83-93a5-c79a1bf38283.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4cdef099-6e61-4d83-93a5-c79a1bf38283.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><a href="https://image.gcores.com/8250aebf-e42b-4189-933f-1bab9112afc6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8250aebf-e42b-4189-933f-1bab9112afc6.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>我王出狱后找到师傅，发现师傅来到奥州平泉的真正目的是入定即身成佛，我王在坐化的师傅面前大彻大悟，参透了生命的真谛。</p>
<p><a href="https://image.gcores.com/c1d26138-9b56-4e60-bd81-0fbc271c9963.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c1d26138-9b56-4e60-bd81-0fbc271c9963.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>后来我王和茜丸被贵族召集雕刻寺庙的鬼瓦，二人再次相遇。</p>
<p><a href="https://image.gcores.com/b01c5f49-b9fe-4801-bbcc-5645f6030fde.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b01c5f49-b9fe-4801-bbcc-5645f6030fde.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>完成凤凰像的茜丸功成名就，但他对人间疾苦的领悟不及命途多舛的我王，比赛中所雕的鬼瓦虽然技艺精湛，却缺乏我王鬼瓦蕴含的情感。我王即将获胜时，沽名钓誉的茜丸爆出我王曾经的恶行，官方最终采用了茜丸的作品。而我王受到举报的惩罚被砍断了另外一只手，隐世于山间。</p>
<p><a href="https://image.gcores.com/59faf622-3b66-471b-8c2a-2cf1951a931f.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/59faf622-3b66-471b-8c2a-2cf1951a931f.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>故事的最后，我王雕刻的鬼瓦被藏于佛寺的仓库中，某日仓库着火波及到寺庙中的大佛堂，茜丸藏身火海之中，隐居的我王超度了离开人世的茜丸。</p>
<p>我王和茜丸都曾在梦中见过火之鸟，火之鸟将二人送入截然不同的转生轮回。我王永世为人，在反复犯罪和赎罪的因果报应中挣扎，而茜丸永世不再为人，感受世间其他万物的生命。</p>
<p>强烈推荐有兴趣的读者去欣赏一下《火之鸟》凤凰篇的原著，本文用贫瘠的语言只描述了这部巨作的一点皮毛。伟大作品所蕴含的思想真诚且充盈，从不同角度可以读出不同的感受，与上文所提到的《幽灵公主》类似，宫崎英高在游戏中致敬《火之鸟》也不仅仅是借用经典的人物形象。</p>
<p>凤凰篇的故事背景是<strong>奈良时代</strong>，<strong>圣武天皇</strong>在位时劳民伤财屡次迁都，十年间从平城京到恭仁京、难波京、紫香乐京，最后再次迁回平城京，其间天灾不断社会动荡。</p>
<p><a href="https://image.gcores.com/be545e2d-f609-49d1-a572-d2fd3f748400.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/be545e2d-f609-49d1-a572-d2fd3f748400.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>受唐朝影响，圣武天皇笃信佛教，祈求佛祖保佑国泰民安，741年开始在全国范围大势兴修<strong>国分寺</strong>，进一步加剧了人民的疾苦。</p>
<p><a href="https://image.gcores.com/8f8227a9-e4d3-475d-a0d9-724346e56bbb.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8f8227a9-e4d3-475d-a0d9-724346e56bbb.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>大和国的国分寺是<strong>东大寺</strong>，也是全国的总国分寺。我王的师傅<strong>良弁僧正</strong>，历史上是东大寺的开山。凤凰篇中作者借良弁之口，批判当时已经被政治利用的“虚假的佛教”。</p>
<p><a href="https://image.gcores.com/5bdbb1bb-2eb2-4248-84d3-ff98c2b30466.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5bdbb1bb-2eb2-4248-84d3-ff98c2b30466.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>我王和茜丸最后比拼的就是雕刻东大寺大佛殿的鬼瓦。东大寺建成后屡遭大火和地震，平安末期被平家放过一次火，战国时代也难逃被烧毁的命运，现在的东大寺大佛殿重修于1709年，规模仅为原来的三分之二。</p>
<p>逼迫茜丸雕刻凤凰的贵族<strong>橘诸兄</strong>是降籍的元皇族，任当时朝廷的右大臣，后晋升左大臣，他掌握朝廷大权，重用有遣唐经历的<strong>吉备真备</strong>，后者在漫画中也与茜丸有所交集。</p>
<p><a href="https://image.gcores.com/55aa0a6a-2886-4968-b064-f4de06d63995.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/55aa0a6a-2886-4968-b064-f4de06d63995.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="东大寺 大佛"></a></p>
<p>东大寺 大佛</p>
<p>圣武天皇743年下令准备修建东大寺大佛，747年开始修建，752年建成并举行大佛开眼仪式。</p>
<p><a href="https://image.gcores.com/a13bef37-8bc6-4f7d-90ed-3210b2851f37.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a13bef37-8bc6-4f7d-90ed-3210b2851f37.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>在大佛修建期间，圣武天皇主动让位于皇女，即第46代天皇孝谦天皇，部分文献记载，圣武天皇主动让位的原因是他一心向佛，选择遁入空门。</p>
<p>大佛建成不久，左大臣橘诸兄官场失势辞职，<strong>藤原仲麻吕</strong>崭露头角干涉政局。他扶持第47代淳仁天皇为傀儡，推行儒家为基础的唐风政治，遭到朝廷内的佛教势力反击。</p>
<p>藤原仲麻吕被扳倒后，孝谦上皇复位改名为<strong>称德天皇</strong>，当红僧人<strong>道镜</strong>独揽大权，甚至有取代天皇之势。称德天皇驾崩后，道镜很快被朝内其他势力打压失势。</p>
<p><a href="https://image.gcores.com/0a90cf41-4144-470b-8910-ce31c80b7bbd.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0a90cf41-4144-470b-8910-ce31c80b7bbd.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>飞鸟时代发生了壬申之乱，天武天皇从天智系夺权。之后皇族施行近亲结婚，后代体弱多病最后断绝了血脉。第49代天皇<strong>光仁天皇</strong>又回到了天智系，而下一任桓武天皇则是本篇文章开端的主角。当时佛教对政治的干涉根深蒂固，导致桓武天皇二度迁都以摆脱奈良佛教势力的控制，这就是为什么桓武天皇如此不待见奈良佛教和东大寺的原因。</p>
<p>随着迁都平安京，出现了天台宗和真言宗两大平安佛教，然而政治与佛教的关系再次越走越近，包括后白河天皇在内的多位平安时代天皇出家为法皇，以神道教为根基的中央政权过分依赖佛教，可见奈良时代的遗毒影响深远。</p>
<p>游戏中的不死之力暗指权力，仙峰寺的僧侣误入歧途追求不死也就对应了我王的师傅良弁口中“虚假的佛教”。以东大寺大佛殿为原型的幻廊中央建筑内并没有供奉大佛，而是象征佛教中地狱的奈落堂，上面是伸手不见五指的黑暗，下面是望不到底的万丈深渊，这样的场景设计是否隐含了创作者的讽刺之意呢？</p>
<h1 id="被抑制的修罗之火"><a href="#被抑制的修罗之火" class="headerlink" title="被抑制的修罗之火"></a>被抑制的修罗之火</h1><p>说回到雕佛师这个游戏角色，他和我王类似受到佛陀的感化，不断雕刻佛像抑制心中的火焰，我认为他所看到的火焰，不光是迷失自我的杀戮，也包含了导致他杀戮的起因。</p>
<p><a href="https://image.gcores.com/fad560ec-b39b-4341-8496-8d75339ff729.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fad560ec-b39b-4341-8496-8d75339ff729.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="怨嗟之鬼"></a></p>
<p>怨嗟之鬼</p>
<p>众所周知，雕佛师最后变成了可选BOSS怨恨之鬼，日文直译是怨嗟之鬼。引发雕佛师化身为鬼的直接原因是兵临城下的内府入侵者。</p>
<blockquote>
<p>戦いの残滓・<strong>怨嗟の鬼</strong> 心中に息づく、類稀な強者との戦いの記憶 今はその残滓のみが残り、 記憶は確かに狼の糧となった ある男が、修羅になりそこない、 怨嗟の炎の積り先となった 因果ゆえ、なかなかに死にきれぬ だが、鬼となり、ようやく逝けた</p>
</blockquote>
<p>日文中“怨嗟”一词来自中文，表示怨恨叹息之意。</p>
<blockquote>
<p>志士幽人莫<strong>怨嗟</strong>，古来材大难为用。 ——《古柏行》杜甫</p>
</blockquote>
<p>怨嗟的情绪更接近对不公的抱怨，常用来表示人民不满的情绪。《只狼》中的怨嗟，可以理解为苇名本地人经受常年累月的侵略和镇压所产生的怨气，这些怨气在佛师的身上积累，或者可以说，他是苇名本地人的代表。</p>
<p><a href="https://image.gcores.com/d98b73f7-23f0-4587-aeb1-392f01a53fc3.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d98b73f7-23f0-4587-aeb1-392f01a53fc3.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《炎立》中阿弖流为的诅咒"></a></p>
<p>《炎立》中阿弖流为的诅咒</p>
<p>荒废寺院中一个细节，雕佛师所在寺庙的门上方有一块牌匾，上面字迹模糊。试着调节亮度和对比度，隐隐约约可以看出似乎写着“火怨”或者“火怒”二字。</p>
<p><a href="https://image.gcores.com/68fa2ef9-f95f-4353-ab5d-d670cffb9e22.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/68fa2ef9-f95f-4353-ab5d-d670cffb9e22.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="荒废寺院的牌匾"></a></p>
<p>荒废寺院的牌匾</p>
<p>东北出身的小说家高桥克彦，写过一本以虾夷英雄阿弖流为对抗中央朝廷和坂上田村麻吕的长篇历史小说《火怨》，2000年此作品获得吉川英治文学奖。尽管利用各种方法去观察牌匾，还是不太确定游戏中的这个细节是否致敬了这本小说的名字。</p>
<p><a href="https://image.gcores.com/8d80303a-8a41-49fe-bd55-32ce731ab45f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8d80303a-8a41-49fe-bd55-32ce731ab45f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《火怨》高桥克彦"></a></p>
<p>《火怨》高桥克彦</p>
<p>如果FromSoftware打算继续扩展《只狼》世界观，补充修罗和鬼等概念是一个很好的方向，下文对DLC的猜测会再谈一谈这方面的延伸。</p>
<h1 id="再访源之宫"><a href="#再访源之宫" class="headerlink" title="再访源之宫"></a>再访源之宫</h1><p><a href="https://image.gcores.com/12f0501e-a9e7-43eb-8b79-e600ff2ff39e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/12f0501e-a9e7-43eb-8b79-e600ff2ff39e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫全景"></a></p>
<p>源之宫全景</p>
<p>神之篇曾提出了一个问题，名分如同皇城的源之宫究竟有何来历。经过进一步的考据，以及官方设定集公开的新信息，答案已经可以确定，<strong>源之宫的原型是平安时代的都城平安京</strong>。</p>
<p>让我们再次前往源之宫，整理一路上遇到的细节线索，感受宫崎英高是如何把源之宫和平安京联系在一起的。</p>
<h1 id="水生村-前往皇宫的必经之路"><a href="#水生村-前往皇宫的必经之路" class="headerlink" title="水生村 前往皇宫的必经之路"></a>水生村 前往皇宫的必经之路</h1><p><a href="https://image.gcores.com/6048b7ed-c54e-463e-9038-15afce61c575.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6048b7ed-c54e-463e-9038-15afce61c575.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水生村 原画"></a></p>
<p>水生村 原画</p>
<p>游戏中能获得各种增益效果的道具，叫作MIBU气球（ミブ風船）。日文中ミブ可以写作壬生，壬是天干第九位，五行属水，所以壬生和水生在日文中意义相同，读音也相同。中文版直接将ミブ翻译成了壬生。</p>
<blockquote>
<p>銭寄せのミブ風船 源の水を内に秘めた、招財祈願のミブ風船 黄色いミブ風船を割り拝み、 その水を浴びたものは、 一時的に銭の入手量が上昇する <strong>ミブは水生</strong>。水が生まれることを指す 葦名衆にとって、源の水は、 それ自体が詣での対象なのだ</p>
</blockquote>
<p>在物品描述中特别指出“壬生即水生”，明显告诉玩家这里存在谐音典故。与水生相比，现实中壬生更常用，大量带有壬生的地名集中于京都，也就是曾经的平安京。</p>
<p><a href="https://image.gcores.com/99ec9705-e7b1-4b22-998b-9560683bb267.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/99ec9705-e7b1-4b22-998b-9560683bb267.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="京都的壬生地区"></a></p>
<p>京都的壬生地区</p>
<p>京都的中京区，有一片区域以壬生为名，位于平安京的右京。平安京的右京（西侧）多湿地，于是政治和文化中心逐渐向左京（东侧）转移。这片区域地势低且潮湿，也是<strong>壬生村</strong>名字的由来，壬生村更早也曾被叫作<strong>水生村</strong>。得益于丰富的地下水源，壬生村特产“壬生菜”非常有名。</p>
<p><a href="https://image.gcores.com/94af9308-bd88-448d-b39c-2996d711ec5d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/94af9308-bd88-448d-b39c-2996d711ec5d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>因为染布需要大量的水，京都的壬生地区过去聚集了很多染坊。游戏中的水生村，我们也能发现纺织机和晾晒的染布，设定集上写着“血染的晾布”，可能意味着水生村用血染布（血液应该是无法染布的），或者指代红色的染布。</p>
<p>壬生地区还有一个名为“壬生寺”的著名寺院，不过没有发现壬生寺与游戏中水生村附近的废寺有什么相似之处。幕府末期，壬生寺是新选组的根据地，因此新选组有一个别名，“壬生狼”。</p>
<p><a href="https://image.gcores.com/984e257d-4b8c-42a7-8e7b-c5615c28d982.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/984e257d-4b8c-42a7-8e7b-c5615c28d982.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="神轿"></a></p>
<p>神轿</p>
<p>游戏中前往源之宫的唯一途径是通过水生村的神轿。在现实中，如果想要进入平安京的皇城大内里，从正南的罗城门走中轴线上的朱雀大路，会穿过壬生村所在的地区。</p>
<p><a href="https://image.gcores.com/850385bd-be2c-4b84-bdff-e67ec0728e34.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/850385bd-be2c-4b84-bdff-e67ec0728e34.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<h1 id="破戒僧-宫门的永恒守卫者"><a href="#破戒僧-宫门的永恒守卫者" class="headerlink" title="破戒僧 宫门的永恒守卫者"></a>破戒僧 宫门的永恒守卫者</h1><p>乘坐稻草人来到源之宫大门，从淤加美门后面突然跳出一个怪尼收门票。一些玩家会觉得奇怪，为什么源之宫的门卫是个僧人？</p>
<p><a href="https://image.gcores.com/d0dd0fbd-fcd2-4477-9817-554bd6727a1e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d0dd0fbd-fcd2-4477-9817-554bd6727a1e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="破戒僧 原画"></a></p>
<p>破戒僧 原画</p>
<p>原案设定稿中可以看出破戒僧守护的更像是寺院的院门，而不是正式版中的城门，红叶飞舞的场景也更符合仙峰寺秋季主题，把破戒僧放在源之宫似乎有赶工和缩水的嫌疑。</p>
<p>个人觉得破戒僧出现在源之宫，除了可能是赶工修改了流程，也隐含了创作者的一些想法。这么安排正好暗示平安时代佛教的状态，天皇笃信佛教，遁入空门后在佛堂中继续执政，皇宫大门由僧人来守护。把八百比丘尼长寿传说、不死的附虫和镇国佛教所产生的扭曲权力联系在一起。</p>
<p>有人可能会觉得这是过度解读，宫崎英高在《黑暗之魂》设定集的访谈中曾提到他会在游戏中设计一些难以理解的细节，破戒僧是否有这方面的象征意义，只有宫崎英高本人和制作团队知道。</p>
<blockquote>
<p>大冢：其实我十分好奇，持续溃烂的生物是如何诞生的？ 宫崎：持续溃烂的生物与普利希拉一样的情况是一样的。在已有明确概念与设定形象的情况下，把这种怪物委托给外包的设计师。持续溃烂的生物是最早的恶魔形象。恶魔诞生于混沌之火，而这家伙大概是在混沌之火还不安定的最早期诞生的。因此虽然缠绕着混沌之火，却无法适应，是个不断燃烧、不断溃烂，疼痛而残忍的形象。所以他一直露出悲伤的表情，一直在哭泣，是伊札里斯的女孩们的幼弟，不过却养育得体型庞大。<strong>因为带有这样的形象，所以特地做了个设定，从他所在的位置可以看到克拉格姐妹的遗迹。恐怕他一直在盯着姐姐们看吧，只有那样才是他的幸福。</strong> 藁谷：只要在BOSS房间试着眺望一下，说不定就能明白了。 宫崎：不，我想应该无法明白吧。<strong>《黑暗之魂》里有许多没有明示的隐藏设定，而在这些隐藏设定中，这个设定也属于特别难以理解，也无从理解的那种……</strong>总而言之，尽管拥有这样的设定，但在实际的设计工作中，设计师却一直没能理解那种悲凉的感觉，因此整个过程也挺艰难的。该怎么说呢，说到炎之巨人，大家都会自然而然地设计得非常勇猛。</p>
</blockquote>
<p>破戒僧官宣的原型是八百比丘尼，日本很多地区都有关于八百比丘尼的传说，她是一个吃了人鱼肉获得千年寿命并出家为尼的少女，把200年寿命让给当地的国主后周游各国，800岁时进入石洞入定。</p>
<p>水生村的神轿在一个天然洞窟之中，我们会在洞窟的石门前迎战破戒僧的幻影。这个场景的原型是传说中八百比丘尼入定的地方，位于福井县小滨市空印寺。</p>
<p><a href="https://image.gcores.com/39c97e37-09a0-4d52-9602-2c6b932d4a99.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/39c97e37-09a0-4d52-9602-2c6b932d4a99.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水生村 石洞"></a></p>
<p>水生村 石洞</p>
<p><a href="https://image.gcores.com/a0bff7c4-75ef-4982-98dd-7f9c7a9825b9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a0bff7c4-75ef-4982-98dd-7f9c7a9825b9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="八百比丘尼入定之地"></a></p>
<p>八百比丘尼入定之地</p>
<h1 id="留守在平安京的孤独女子"><a href="#留守在平安京的孤独女子" class="headerlink" title="留守在平安京的孤独女子"></a>留守在平安京的孤独女子</h1><p>验票后进入源之宫，很多玩家忍不住跳入水库游泳，然后被站在大樱上的水库管理员用雷枪戳得死去活来，这个精英叫“淤加美之长 静”。</p>
<p><a href="https://image.gcores.com/68d580bf-84df-4478-9b34-ecc97a1cd4a6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/68d580bf-84df-4478-9b34-ecc97a1cd4a6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="只狼大战水库管理员"></a></p>
<p>只狼大战水库管理员</p>
<p>说起平安时代和“静”，了解一些源义经故事的朋友应该会想到源义经的爱妾<strong>静御前</strong>。</p>
<p><a href="https://image.gcores.com/7349b4b5-e4a6-4e6f-a234-3dc19e09aa5f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7349b4b5-e4a6-4e6f-a234-3dc19e09aa5f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="2005 NHK大河剧 义经"></a></p>
<p>2005 NHK大河剧 义经</p>
<p>源义经与源赖朝决裂后，乘船逃亡九州，不幸遭遇暴风阻拦与其他将士分离。源义经带着静御前与随行的亲卫只好上岸改变逃跑路线，静御前在吉野与源义经分别后准备回京，被僧兵捕获送到源赖朝的镰仓大本营。</p>
<p>静御前被迫在源赖朝前面跳舞，不禁唱起思念源义经的歌曲激怒了源赖朝。此时静御前已经有了身孕，按源义经和静御前的身份和当时的社会习惯，女孩会被培养成白拍子，男孩则会被培养成武士，源赖朝下令静御前生下来的如果是女孩就帮她抚养成人，是男孩不留性命，最后静御前生下的男婴被源赖朝的手下沉入海中。失去爱子的静御前和母亲返回平安京，没有留下更多的记载。</p>
<p>御灵信仰章节说到菅原道真死后宫内天降暴雷，贵族害怕菅原道真的怨灵化为雷神，修建北野天满宫供奉火雷神，可见当时的人很容易把怨念和雷电联系到一起。想象一下返回京城后静御前的心情，源义经被源赖朝迫害可能一辈子再也无法见面，自己为源义经生下的孩子又被源赖朝杀害。</p>
<p>这也许就是为什么源之宫的大樱上站着一个遥望远方的淤加美人，她会操纵强力的雷电，被接近后又弱不禁风。（游戏中为数不多只有一条血的精英敌人）</p>
<h1 id="渡舟而来的神秘女武者"><a href="#渡舟而来的神秘女武者" class="headerlink" title="渡舟而来的神秘女武者"></a>渡舟而来的神秘女武者</h1><p><a href="https://image.gcores.com/d27b8c66-7233-4e0d-b8ae-d16dad6f03fd.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d27b8c66-7233-4e0d-b8ae-d16dad6f03fd.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="丈与巴的墓"></a></p>
<p>丈与巴的墓</p>
<p>另一个与淤加美一族有关的角色，是游戏中没有正式出现的<strong>巴</strong>，她的名字来自平安时代的虚构人物<strong>巴御前</strong>。虽然涉及到巴的剧情很少，我们从巴御前的事迹中依然可以找到一些与游戏的对应。</p>
<p><a href="https://image.gcores.com/8812cc5f-5422-410b-a32e-b6cc9ca90df9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/8812cc5f-5422-410b-a32e-b6cc9ca90df9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="时代祭中的巴御前"></a></p>
<p>时代祭中的巴御前</p>
<p>巴御前被认为是一个虚构人物，她的事迹主要出现在《<strong>平家物语</strong>》和《<strong>源平盛衰记</strong>》这两部军记物语中。巴御前是源义仲手下的女武将，在《源平盛衰记》中还是源义仲的爱妾。</p>
<p>《源平盛衰记》中，巴御前协助源义仲打赢了上文曾提到的<strong>俱利伽罗峠之战</strong>，这场战役的两个重要元素都在《只狼》中有所体现，被击败的平氏主将是<strong>平维盛</strong>，也就是源之宫中的壶之贵人维盛的原型。据说源义仲是靠<strong>火牛之计</strong>战胜了平维盛，对应苇名城中的火牛BOSS。</p>
<p>《平家物语》中，巴御前出现在描述源义仲败亡的部分，源义仲在宇治川之战败于源赖朝势力后命令巴御前逃跑，不要随自己一起送死，巴御前<strong>逃往东国</strong>，销声匿迹。巴御前这段离开源氏流亡的故事正好对应游戏中巴离开淤加美来到苇名之地。</p>
<h1 id="壶中贵人-平氏与鲤鱼"><a href="#壶中贵人-平氏与鲤鱼" class="headerlink" title="壶中贵人 平氏与鲤鱼"></a>壶中贵人 平氏与鲤鱼</h1><p><a href="https://image.gcores.com/e64d3974-c1c3-4c1e-81fe-0ee43057d04c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e64d3974-c1c3-4c1e-81fe-0ee43057d04c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="壶中贵人"></a></p>
<p>壶中贵人</p>
<p>游戏中玩家会遇到两个奇怪的NPC，躲在罐子里收集鳞片的壶中贵人。源之宫中的壶中贵人叫作<strong>维盛</strong>，取自于平氏的<strong>平维盛</strong>。平维盛最后以跳海了结自己的生命，在源平最终决战的坛之浦之战中，战败的大量平氏族人也都选择跳海自杀，民间有传闻，死于水中的平家人后来变成河童出没。</p>
<p>壶中贵人想要变成鲤鱼王，来源于中国的鲤鱼跳龙门，这个典故在日本也被熟知，鲤鱼顺着瀑布上行，跳过龙门化身为龙。游戏中两个常驻效果的技能也出自鲤鱼跳龙门的典故。</p>
<blockquote>
<p><strong>登り鯉</strong> 弾きを成功させたときの 体幹ダメージが上昇する常在効果 葦名流は、源の水の流れと縁深い 襲い来る刃を、見事に弾き返す様 それを滝を登る鯉に例えた  <strong>下り鯉</strong> 弾きを成功させた後、数秒間 攻撃による体幹ダメージが上昇する常在効果 葦名流は、源の水の流れと縁深い 刃を弾き返し、そこに苛烈に畳み掛ける様 それを滝を下る鯉に例えた</p>
</blockquote>
<p>壶中贵人不崇拜神龙，转而追求成为鲤鱼之王，鲤鱼终将跳过龙门成为龙。壶中贵人的另辟蹊径对应现实中平氏激进的夺权方式，比如平将门造反试图推翻朝廷统治，平清盛让直系血亲天皇上位，而源赖朝最后选择了“挟天子以令诸侯”，建立镰仓幕府，正如源之宫中守着樱龙却不去参拜的淤加美一族。</p>
<p>壶中贵人收集鱼鳞，可能来源于平氏的家纹。除了扬羽蝶以外，平氏还用过鳞纹（三角力量）作为家纹。</p>
<p><a href="https://image.gcores.com/f20cd8c8-a62d-48e5-88d5-3981e4417c56.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f20cd8c8-a62d-48e5-88d5-3981e4417c56.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="三つ鳞"></a></p>
<p>三つ鳞</p>
<p>当收集足够的鱼鳞，壶中贵人会送给主角有毒的鱼饵用来毒死老鱼王，老鱼王死后壶中贵人会变成新鱼王。历史上平氏虽然输给了源氏，后来却靠类似的方法成了“新鱼王”。</p>
<p>源赖朝统一天下，上任征夷大将军后仅仅过去7年就与世长辞。嫡子<strong>源赖家</strong>18岁继承幕府将军，不料政治斗争站错队伍很快被架空，流放至伊豆禅修寺幽闭。流放第二年，源赖家被人暗杀，始作俑者是源赖朝正室<strong>北条政子</strong>背后的<strong>北条氏</strong>。</p>
<p>第三任镰仓幕府将军是源赖朝的另一个儿子<strong>源实朝</strong>，上任时12岁，政权由北条氏控制。源实朝28岁被兄长源赖家之子<strong>公晓</strong>以复仇为名暗杀。</p>
<p>源赖家的后代四男一女全都死于非命，其中两个儿子被北条氏暗杀，一个儿子被逼自尽，一个儿子暗杀源实朝后被处刑，女儿难产死亡，而源实朝没有留下任何子嗣，河内源氏的血脉就此断绝。</p>
<p>就像游戏中给老鱼王下毒的壶之贵人，协助源赖朝统一天下的北条氏通过阴险的手段最后成为了“新鱼王”。北条氏自称是桓武平氏分流，其家纹正是三鳞纹。</p>
<p>另外还有一个有趣的小典故，源之宫中有一些淤加美人蹴踘。镰仓时代的史书《吾妻镜》中记载，源赖家和源实朝都是蹴踘高手，甚至到了沉迷的程度。</p>
<p><a href="https://image.gcores.com/fa35df53-a4b0-4cae-b893-dc725d091538.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fa35df53-a4b0-4cae-b893-dc725d091538.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="蹴踘的淤加美女武者"></a></p>
<p>蹴踘的淤加美女武者</p>
<p>《吾妻镜》是在北条氏掌权的背景下所著的官史，后世认为其立场偏颇，抹黑源氏三代洗白歌颂北条氏，所以历史究竟是什么让人深思。</p>
<h1 id="源之宫大内里"><a href="#源之宫大内里" class="headerlink" title="源之宫大内里"></a>源之宫大内里</h1><p><a href="https://image.gcores.com/81996651-364d-4b2e-b9fe-df1e94cc610d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/81996651-364d-4b2e-b9fe-df1e94cc610d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>源之宫左侧的水生庭院附近，有一座被鱼王破坏的大桥。这座桥在官方设定集上的名字是“<strong>通向大内里的太鼓桥</strong>”，这说明桥对面的建筑群即是源之宫大内里。在日本，大内里指皇宫，平安京的大内里又叫作平安宫。</p>
<p><a href="https://image.gcores.com/12feedbf-05a5-47cb-8946-011a1ae4fe62.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/12feedbf-05a5-47cb-8946-011a1ae4fe62.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p>源之宫中心的建筑在设定集上的名字是“<strong>大极殿</strong>”，大极殿是日本历代大内里的正殿。这个名字来自于中国“建中立极”的宫殿概念，从三国时期曹魏洛阳宫开始，皇宫的正殿被叫作太极殿。</p>
<blockquote>
<p>是时，大治洛阳宫，起昭阳、<strong>太极殿</strong>，筑总章观。 ——《三国志·魏书·明帝纪》</p>
</blockquote>
<p>源之宫的大极殿对应了平安宫的大极殿，殿北即是天皇居住的内里，也就是内宫。内里位置偏右，中轴线上的中和院是天皇祭神的场所。在游戏中，对应中和院的应该是内里后面的樱龙神域。</p>
<p><a href="https://image.gcores.com/dae429ce-fb8e-42a9-a9a9-f4d1f63021c9.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/dae429ce-fb8e-42a9-a9a9-f4d1f63021c9.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平安京大内里"></a></p>
<p>平安京大内里</p>
<p>大极殿作为大内里的正殿，本应是举行重要国事的地方，可是源之宫的大极殿看起来并没有这样的职能，一层是封闭的空室，二层两侧摆放了几个可能和御子有关的摄末社。这个细节还原了平安宫大极殿的特点。</p>
<p><a href="https://image.gcores.com/5eb5b338-685d-4ba7-b3d3-da43249ac3cb.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5eb5b338-685d-4ba7-b3d3-da43249ac3cb.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫大极殿中摆放的摄末社"></a></p>
<p>源之宫大极殿中摆放的摄末社</p>
<p>平安宫大极殿多灾多难，曾发生过三次大型火灾，前两次大火后重建修复，第三次大火将大极殿彻底烧毁，没有再次修复。</p>
<p><a href="https://image.gcores.com/09ec0c24-c059-489e-a43e-793937d1f47f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/09ec0c24-c059-489e-a43e-793937d1f47f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平安宫大极殿遗址"></a></p>
<p>平安宫大极殿遗址</p>
<p>屡次遭受火灾和重建导致大极殿被弃用，天皇执政的场所转移到内里的正殿<strong>紫宸殿</strong>，于是高位的贵族公卿们进入内宫谒见天皇。</p>
<p><a href="https://image.gcores.com/d8871213-ef3b-4314-9209-30a8a80ea3a4.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d8871213-ef3b-4314-9209-30a8a80ea3a4.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="啃噬生祭的仪式"></a></p>
<p>啃噬生祭的仪式</p>
<p>源之宫大内里深处的建筑大门紧闭，只能通过潜水绕到侧面进入，此处传送点叫“<strong>宫之内里</strong>”，表明这里即是源之宫的内里。进去后发现贵族们正在吃人，设定集上将其称为“<strong>啃噬生祭的仪式</strong>”。</p>
<p><a href="https://image.gcores.com/caff76a0-ce17-4498-8945-3e7d732e633e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/caff76a0-ce17-4498-8945-3e7d732e633e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="宫之内里 谒见之间"></a></p>
<p>宫之内里 谒见之间</p>
<p>这个贵族们“开会”的阴暗房间在设定集上的名字是“<strong>宫之内里 谒见之间</strong>”，说明这里是源之宫中贵族谒见御子的场所，还原了平安时代内里的紫宸殿处理朝政的特色。也许《只狼》的架空世界不存在天皇，过去的御子坐在这个房间中间的位置统治源之宫。源之宫的衰败以及贵族们在此所做的可怖之事，可能正是因为御子不在其位造成的，有些《黑暗之魂3》的味道。</p>
<h1 id="源之宫中的“草木屋”"><a href="#源之宫中的“草木屋”" class="headerlink" title="源之宫中的“草木屋”"></a>源之宫中的“草木屋”</h1><p>1000多年前的平安宫现在已经不复存在，镰仓时代以后平安宫多次遭遇火灾，年久失修成为废墟。我们现在可以参考的复制品主要来自京都的<strong>平安神宫</strong>和<strong>京都御所</strong>。</p>
<p>1895年，纪念迁都平安京1100周年，明治政府修建<strong>平安神宫</strong>，还原了大极殿为主的朝堂院。平安神宫本质上是神社，主祭神是桓武天皇和孝明天皇，桓武天皇是平安京的创立者，而孝明天皇是明治天皇的父亲，留守京都的最后一位天皇。江户幕府结束后，天皇和皇室随着明治新政府转移到了关东的东京。</p>
<p><a href="https://image.gcores.com/fe2117c3-b7be-4b97-87ca-25701715cac6.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fe2117c3-b7be-4b97-87ca-25701715cac6.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平安神宫 外拜殿"></a></p>
<p>平安神宫 外拜殿</p>
<p>平安神宫的外拜殿以八分之五的比例还原了平安宫大极殿。可以看出它的造型和源之宫的大极殿完全不同。平安宫大极殿经过两次重建，至少存在三种不同的样式，外拜殿复原采用的是最后一次重建的样式。根据学者考据，平安宫大极殿最初可能是双层结构，这一点上更接近源之宫大极殿。</p>
<p>源之宫的淤加美门几乎是复制了平安神宫的应天门。应天门原来是朝堂院的大门，平安京的罗城门和大内里的朱雀门可能也都是类似的造型。</p>
<p><a href="https://image.gcores.com/ca1dd8ba-c038-43bf-ab4a-9b17d086e85d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ca1dd8ba-c038-43bf-ab4a-9b17d086e85d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="平安神宫 应天门"></a></p>
<p>平安神宫 应天门</p>
<p><a href="https://image.gcores.com/d918e3d5-0c3b-484e-b773-006fa92d4b0d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d918e3d5-0c3b-484e-b773-006fa92d4b0d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="淤加美门"></a></p>
<p>淤加美门</p>
<p>平安时代中后朝廷衰败，平安宫由于天灾人祸逐渐被废弃。天皇移居到宫外的临时居所生活，<strong>京都御所</strong>是其中一处离宫。京都御所保留至今，让我们有机会看到古时平安宫内里的样子。</p>
<p>源之宫中有一处令许多玩家疑惑的地方，宫中遍布代表平安时代的朱红色建筑，唯独通向樱龙神域的内里是一个古旧的“草木屋”，甚至有人怀疑源之宫和内里不是同一时代建设的，实际上产生这种反差的真正原因是日本特别的建筑理念和工艺。</p>
<p>京都御所的正殿紫宸殿，作为平安宫内里紫宸殿的复制体，是举行重大仪式的场所。注意看紫宸殿不同于上述平安神宫的特殊屋顶，游戏中的源之宫内里也继承了这种特点。</p>
<p><a href="https://image.gcores.com/2829d34c-c166-4990-adec-0e732c3710c8.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2829d34c-c166-4990-adec-0e732c3710c8.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="京都御所 紫宸殿"></a></p>
<p>京都御所 紫宸殿</p>
<p><a href="https://image.gcores.com/a1165b57-e5a9-4020-a50b-cfb93056fc91.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a1165b57-e5a9-4020-a50b-cfb93056fc91.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="源之宫 内里"></a></p>
<p>源之宫 内里</p>
<p>这种不用瓦片的特殊屋顶工艺叫<strong>桧皮葺</strong>，是日本特有的建筑技法，由加工的桧木皮制成屋顶。桧（ヒノキ，中文：日本扁柏）是日本最高级的木材，采用桧皮葺的建筑往往也是最高规格的宫殿、神社或寺庙，比如上面所说的紫宸殿和天照大御神的伊势神宫。</p>
<p><a href="https://image.gcores.com/fb37e96c-0272-4e1d-8ab7-c9a2640f1b3d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fb37e96c-0272-4e1d-8ab7-c9a2640f1b3d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="桧皮葺屋根实物模型"></a></p>
<p>桧皮葺屋根实物模型</p>
<p>京都御所中采用桧皮葺的建筑都是曾为天皇所用的核心建筑，而其他附属建筑以及还原大极殿的平安神宫普遍采用了瓦葺。（不过平安神宫东神苑的尚美馆是桧皮葺）</p>
<p>所以通向樱龙神域的这间“茅房”才是源之宫中最高贵的建筑。</p>
<p><a href="https://image.gcores.com/9a080527-d86a-42d9-b441-eda0e9050355.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9a080527-d86a-42d9-b441-eda0e9050355.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="紫宸殿"></a></p>
<p>紫宸殿</p>
<p>平安时代红柱青瓦白墙的建筑风格受到了盛唐和佛教的影响，但作为国家象征的皇居和神社坚持着古老的传承，我们可以在日本文化的各个方面感受到这种积极学习接纳其他文化又不忘传统的反差感。</p>
<p>紫宸殿附近的清凉殿是天皇过去居住的御殿，同样也是桧皮葺屋顶，清凉殿对应源之宫内里后半部分的寝所。顺便一提，菅原道真死后作祟，宫内被雷劈的就是清凉殿。</p>
<p><a href="https://image.gcores.com/c1a516ee-a314-42ae-b8df-7ec31d3d8f34.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c1a516ee-a314-42ae-b8df-7ec31d3d8f34.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="清凉殿"></a></p>
<p>清凉殿</p>
<p>清凉殿中的<strong>昼御座</strong>和<strong>御帐台</strong>，同样出现在源之宫内里的寝所中，这些都是平安时代王公贵族们休息用的代表物件。</p>
<p><a href="https://image.gcores.com/d290cd30-4751-495f-878e-77f9d96a2e28.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d290cd30-4751-495f-878e-77f9d96a2e28.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="昼御座"></a></p>
<p>昼御座</p>
<p><a href="https://image.gcores.com/7a1097bd-206b-4b31-8af0-3916eb754d44.JPG?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/7a1097bd-206b-4b31-8af0-3916eb754d44.JPG?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="御帐台"></a></p>
<p>御帐台</p>
<p><a href="https://image.gcores.com/b7a2b73d-3394-43c3-a08f-4e91c726aeae.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b7a2b73d-3394-43c3-a08f-4e91c726aeae.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="宫之内里 寝所"></a></p>
<p>宫之内里 寝所</p>
<p><a href="https://image.gcores.com/150ffe15-d7f5-4701-bf1f-eb4f4b4ba429.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/150ffe15-d7f5-4701-bf1f-eb4f4b4ba429.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="实际游戏中的寝所"></a></p>
<p>实际游戏中的寝所</p>
<p>帐台白布上有些密集恐惧的有职文样是<strong>朽木茶印文（朽木茶摺型）</strong>，紫红色布筋上的有职文样是<strong>蝶鸟白印文（蝶鳥白摺型）</strong>，游戏中只有鸟纹，没有画出蝴蝶。</p>
<p><a href="https://image.gcores.com/0047c8e3-c363-4b45-b440-123c75a20d9d.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0047c8e3-c363-4b45-b440-123c75a20d9d.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="朽木纹和蝶鸟纹"></a></p>
<p>朽木纹和蝶鸟纹</p>
<p>壁代的图案是凤凰纹和祥云。在设定稿中采用的是<strong>凤凰丸纹</strong>，正式版改成了<strong>凤凰有职纹</strong>，可能是为了更符合平安时代的风格吧。</p>
<p><a href="https://image.gcores.com/94b1cbd0-9530-49d6-8583-38948ee4a951.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/94b1cbd0-9530-49d6-8583-38948ee4a951.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="凤凰纹样"></a></p>
<p>凤凰纹样</p>
<p>门框挂着御帘，御帘上侧有图案的部分叫作<strong>帽额</strong>或者<strong>天布</strong>，圆形图案是<strong>木瓜纹</strong>，三角形图案是<strong>蝶纹</strong>。</p>
<p><a href="https://image.gcores.com/67d8e900-3d0f-4704-a2f7-4e1d0018b457.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/67d8e900-3d0f-4704-a2f7-4e1d0018b457.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="御帘"></a></p>
<p>御帘</p>
<p>这些图案都是代表平安时代的常用样式，个人认为在游戏中应该没有特殊的含义。源之宫中的细节相当考究，还有很多建筑装饰等方面的有趣考据，因为和《只狼》的故事主题关系不大，打算放在番外篇里说，不知道下一次要鸽到何时。</p>
<h1 id="樱龙-拜泪-不死之力"><a href="#樱龙-拜泪-不死之力" class="headerlink" title="樱龙 拜泪 不死之力"></a>樱龙 拜泪 不死之力</h1><p>某日，宫崎英高在会议上问众策划：这回设计一个与以往不同的龙类BOSS，谁有想法？一位策划提议：我觉得可以参考那个操龙的少年！</p>
<p><a href="https://image.gcores.com/ebae2af8-766d-4837-a2db-c589c063751f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ebae2af8-766d-4837-a2db-c589c063751f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="魔神英雄传"></a></p>
<p>魔神英雄传</p>
<p>樱龙和拜得龙泪颇具东方韵味的设定，可能借鉴了一部经典老动画《魔神英雄传》，国内的80后玩家应该更熟悉这部动画的另外一个译名《神龙斗士》。</p>
<p><a href="https://image.gcores.com/b9253fee-349c-41f9-8a9d-8c778baeefd6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b9253fee-349c-41f9-8a9d-8c778baeefd6.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="樱龙"></a></p>
<p>樱龙</p>
<p>在OVA《魔神英雄传 没有终结之时的物语》中，为了解决创界山的新危机，主角战部渡前往神部界之上的天部界寻找拳龙的勾玉。到达天部界的元圣山时正好遇见拳龙生子，拳龙的勾玉即是生子时流下的眼泪。</p>
<p><a href="https://image.gcores.com/0dd0446a-4503-4b1e-a932-6d38c9a5459e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/0dd0446a-4503-4b1e-a932-6d38c9a5459e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="拳龙之泪"></a></p>
<p>拳龙之泪</p>
<p>拳龙生子时，村子里也会有一名人类拳龙子出生，龙泪形成的勾玉则是授予拳龙子的礼物，战部渡被告之是千年之前送到人间的拳龙子，这与《只狼》中御子的概念很相近。</p>
<p><a href="https://image.gcores.com/6693073f-2d5f-467d-a658-95bd463eb910.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6693073f-2d5f-467d-a658-95bd463eb910.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="战部渡和虎王"></a></p>
<p>战部渡和虎王</p>
<p><a href="https://image.gcores.com/ea0ccc69-1062-4c6b-a2c6-b69f052d2466.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ea0ccc69-1062-4c6b-a2c6-b69f052d2466.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="水质污染"></a></p>
<p>水质污染</p>
<p>这部OVA动画中也有水质污染的设定，主角的好基友虎王自我牺牲，潜入水中用勾玉封印了魔界大门，战部渡失去自己的拳龙勾玉从拳龙子变回了普通人，《魔神英雄传》版的回归常人结局。</p>
<p><a href="https://image.gcores.com/94a15a9d-b044-49be-a326-7d6fcc2e1fd1.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/94a15a9d-b044-49be-a326-7d6fcc2e1fd1.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="常樱树下"></a></p>
<p>常樱树下</p>
<p>主角提到此时是夏天，神社里的大樱却开花了。最后虎王神奇复活，两人在常樱树下重逢，总之是个皆大欢喜的结局。</p>
<p>樱龙的造型不知道是否参考了动画里的拳龙，整体外形、身上的毛和头部两侧的角都很相似。</p>
<p><a href="https://image.gcores.com/cd2eaab0-c671-4bb3-bc60-d7bdce044bc7.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cd2eaab0-c671-4bb3-bc60-d7bdce044bc7.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="拳龙和樱龙"></a></p>
<p>拳龙和樱龙</p>
<p>经过前后两篇文章的考据，如果说樱龙丝毫没有影射日本的天皇，我是不信的。这也可以解释为什么《只狼》在2018年E3宣传时九郎的身份还是皇子，正式发售却改成御子。</p>
<p>整个龙胤体系借鉴了许多不同的原型，在神之篇中曾考据过樱龙被迫流亡的遭遇和入侵异地击败当地的神明等设定来自于日本神话中的建御名方神和诹访当地神话传说，拜泪的桥段可能来自于经典的动画作品。</p>
<p>上升到国家的象征层面，樱龙直指了受到中国影响的古代日本和天皇系统。</p>
<p><a href="https://image.gcores.com/76f2dad0-506a-4e7c-9d2e-f687d0e6a7d4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/76f2dad0-506a-4e7c-9d2e-f687d0e6a7d4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="樱龙"></a></p>
<p>樱龙</p>
<p>樱龙拿着的武器，原型是日本的国宝文物<strong>七支刀</strong>。为什么要设计让樱龙使用这个武器，可以从不同的层面分析：</p>
<p><a href="https://image.gcores.com/4ec06114-01b1-4324-9114-ef05a91d9c3d.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4ec06114-01b1-4324-9114-ef05a91d9c3d.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="七支刀"></a></p>
<p>七支刀</p>
<p>奇幻题材中往往越老的东西越厉害，所以设计这类游戏的武器最常见的需求是拥有古老历史的上古神器，七支刀即是最能代表日本历史的武器之一。七支刀的独特之处在于这把铁剑上刻着文字，通过文字可追溯到公元5世纪之前，本文开端曾提到日本很长时间都没有自己的文字，所以七支刀作为日本本土发现的文物，上面记载的文字具有极高的历史价值。</p>
<p>七支刀频繁出现于各种日本游戏中，还有一个原因是它具有明确的造型，而其他那些只存在于传说中或已失传的武器需要重新设计造型。七支刀在视觉代表性上有无与伦比的优势。</p>
<p>上述这种取材方式被大部分游戏所采用，比如《大神》中天照大神把日本神话历史出现过的神兵用了个遍。</p>
<p><a href="https://image.gcores.com/b65dcc10-32e7-4988-acfd-6e2d54342062.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b65dcc10-32e7-4988-acfd-6e2d54342062.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="大神的武器"></a></p>
<p>大神的武器</p>
<p>接下来需要考虑的是FromSoftware的传统，会在大部分自家游戏中塞一把月光大剑。月光大剑和樱龙一起登场是个很好的选择。樱龙的武器从材质和颜色上看，很接近以往作品中出现的月光大剑。</p>
<p><a href="https://image.gcores.com/ed3a455c-94e8-4234-afaa-18d0b2b31dd4.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/ed3a455c-94e8-4234-afaa-18d0b2b31dd4.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="月光大剑"></a></p>
<p>月光大剑</p>
<p>宫崎英高不喜欢简单粗暴的挪用形象是笔者撰写考据文章的动力之一。在宫崎英高的游戏中，借鉴现实原型或多或少会根据游戏自身的世界观设定进行调整和再创作，由此产生解读的乐趣。</p>
<p>七支刀上所刻铭文如下：</p>
<blockquote>
<p>泰■四年十■月十六日丙午正陽造百錬■七支刀■辟百兵宜供供侯王■■■■作 先世以来未有此刀百濟■世■奇生聖音故為倭王旨造■■■世</p>
</blockquote>
<p>后世对这段残缺文字有许多不同的解读。从某种角度来看，宫崎英高在游戏中玩碎片叙事不正经说人话也创造了类似考古的乐趣，下一步也许该给文本打码了。（SCP警告）</p>
<p>从这段铭文可知，此刀由百济王赠与倭王，代表了百济和日本的交流。到了平安时代，朝鲜半岛的百济已经灭亡百余年。桓武天皇的生母高野新笠是百济武宁王的后代，也就是说从桓武天皇开始（平安时代开始），日本皇室加入了百济的血脉。2001年明仁天皇在生日前记者招待会上，公开表示了日本皇室与百济的深远关系，这在韩国引起极大反响。所以用樱龙泛指日本天皇系统的话，七支刀则代表了与百济的关系。</p>
<p>而樱龙的龙形象，代表了日本与中国的关系。神之篇中说过，龙图腾传到日本后没有取代太阳成为天皇的象征，而是与日本本土的蛇信仰融合。但这不代表天皇根本不使用龙图腾，用现在的话来说，受到中国文化影响的古代日本，已经变成中国的形状了。</p>
<p>从天皇的御服上可以感受到日本对中国传来文化的取舍，以下所列举的是历代天皇普遍采用的服饰样式，特定时代存在一些变化。</p>
<p><a href="https://image.gcores.com/a9a9f613-b724-4404-9e35-b2b9228006cd.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/a9a9f613-b724-4404-9e35-b2b9228006cd.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="黄栌染御袍"></a></p>
<p>黄栌染御袍</p>
<p>天皇在平常仪式和外国使臣谒见时穿着<strong>黄栌染御袍</strong>，也就是我们常说的黄袍。黄栌染御袍上的文样是<strong>桐竹凤凰</strong>，凤凰降临代表帝王治国有方，太平盛世。桐竹凤凰的典故来自中国黄帝得凤象的传说，记载于汉代韩婴所著的《韩诗外传》第八卷第八章：</p>
<blockquote>
<p>黄帝乃服黄衣，戴黄冕，致斋于宫，凤乃蔽日而至，黄帝降于东阶，西面再拜稽首，曰：“皇天降祉，不敢不承命。”凤乃止帝东国，集帝梧桐，食帝竹实，没身不去。</p>
</blockquote>
<p>重大仪式天皇则会穿着<strong>衮龙御衣</strong>，也就是龙袍。</p>
<p><a href="https://image.gcores.com/889330dc-1412-4857-a5b3-4eafd496f9bd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/889330dc-1412-4857-a5b3-4eafd496f9bd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="孝明天皇的衮衣"></a></p>
<p>孝明天皇的衮衣</p>
<p>红色的衮龙御衣上绣着四爪龙和日月星辰等图案，这一传统从第45代天皇圣武天皇一直持续到第121代天皇孝明天皇，明治维新后龙袍被弃用，对应场合统一穿着桐竹凤凰的黄栌染御袍。碰巧的是，圣武天皇修建了仙峰寺幻廊的原型东大寺，而孝明天皇作为最后一个留守京都的天皇，是平安神宫的主祭神。</p>
<p><a href="https://image.gcores.com/fc32c7d0-ff0c-4ea2-bb1e-f08ea3779800.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/fc32c7d0-ff0c-4ea2-bb1e-f08ea3779800.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="御祭服"></a></p>
<p>御祭服</p>
<p>就像红柱青瓦丛中坚持使用“草木屋顶”，到了神事方面的仪式天皇改穿纯白色御服，比如<strong>御祭服</strong>和<strong>帛御袍</strong>。受中国影响改穿龙袍之前，据说帛御袍也是天皇的冕服。白色是日本文化中最神圣的颜色，所以白色动物被认为是尊贵之物，比如日本武尊死后化为白鸟。也许这就是把樱龙设计成白色的原因，但游戏中樱龙白色的皮肤呈现出不太健康的病态感。</p>
<p>皇权在平安末期的急速衰落，正如伤痕累累的樱龙。前文提到平氏挟持安德天皇带着三神器离开平安京，随着源平最终决战坛之浦之战落败，安德天皇跳海自尽，三神器落入海中。后白河上皇选定的下一位天皇<strong>后鸟羽天皇在没有三神器加持下继承了皇位</strong>，万世一系的天皇系统在神圣性上受到了永久的损伤。</p>
<p>后鸟羽天皇后来成为镰仓幕府时代的首位天皇。经过700多年的幕府统治，本国平民和异国来客甚至到了只知幕府将军不知天皇的地步。</p>
<p>龙胤的不死之力所暗示的事物显而易见，就是权力这一人类创造的虚构之力。无论是组成宗教的教权，还是组成国家的政权，无非是以不同形式将人类凝聚在一起。游戏中九郎授予狼不死契约、弦一郎和枭请求赐予龙胤以及为斩断不死拜得樱龙一泪等情景都颇具仪式感，仪式感在无形之中加固了人们对心中虚构之力的信念。</p>
<p><a href="https://image.gcores.com/3e407453-1b85-4075-a041-abdb97c469d6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3e407453-1b85-4075-a041-abdb97c469d6.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="请求赐予龙胤"></a></p>
<p>请求赐予龙胤</p>
<p>大和朝廷是以神道教为根基的国家政权，将教权和政权合二为一，所呈现出的即是游戏中最高级的“龙胤不死之力”。相信这种力量的信徒维持着其在现实中的投影，超越个人生命的限制，以集体的形式永存于世。但这种不朽无法离开人的载体而独立存在，当违背自然和历史的规律沦为“失道”，不朽也难逃化为泡影的命运。</p>
<h1 id="《只狼》的世界将走向何方"><a href="#《只狼》的世界将走向何方" class="headerlink" title="《只狼》的世界将走向何方"></a>《只狼》的世界将走向何方</h1><p>《只狼》提供了四种不同结局，分别是<strong>斩断不死</strong>、<strong>修罗</strong>、<strong>回归常人</strong>、<strong>龙之返乡</strong>。这四个结局可以看作是对这个架空世界的世界观设定不同方向的延伸。</p>
<p>根据结局时龙胤和九郎的状态，将这四个结局放在一张图里。龙之返乡中九郎已经没有实体，默认肉体死亡，只保留了精神。</p>
<p><a href="https://image.gcores.com/b310aa55-ba9c-4eb5-84af-735ad8f2ccf6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b310aa55-ba9c-4eb5-84af-735ad8f2ccf6.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="img"></a></p>
<p><strong>斩断不死与修罗</strong></p>
<p><a href="https://image.gcores.com/b58774eb-ff9c-4345-b371-67fef3477fb2.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b58774eb-ff9c-4345-b371-67fef3477fb2.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="斩断不死"></a></p>
<p>斩断不死</p>
<p><strong>斩断不死</strong>是标准结局，狼最后完成九郎的夙愿，龙胤与九郎双亡。这个结局对应历史上源义经的经历，藤原秀衡病死后，藤原泰衡在源赖朝的压力下突袭高馆，源义经选择自尽。</p>
<p>游戏进展到终盘，狼再一次来到苇名城的芒草原保护九郎，此时弦一郎拿着黑色不死斩砍伤九郎，试图强夺龙胤。红黑两把不死斩承载了对权力干涉的特殊意义，在它们可能的原型中有所对应。</p>
<p>蜈蚣切（红色不死斩）的主人藤原秀乡阻止了平将门自立新帝的造反计划，同时立功的还有平氏的平贞盛，天皇赏赐其小乌丸（黑色不死斩），被视为平氏传家之宝。平安末期平清盛绑架挟持天皇另立新皇等夺权行径，被源氏讨伐，在坛之浦之战中随着平氏灭亡小乌丸也去向不明。</p>
<p><a href="https://image.gcores.com/6b53ef42-1bdb-4cf0-ae1c-02a6c35c59b6.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6b53ef42-1bdb-4cf0-ae1c-02a6c35c59b6.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="佛师 狼"></a></p>
<p>佛师 狼</p>
<p>个人认为斩断不死是《只狼》中最有东方意境的结局。有人诟病《只狼》中的复活机制在设定上不如魂系列那样自洽，假如把游戏过程当作狼在雕刻佛像求得内心平静时闪回的记忆片段，那么每一次死亡后回到鬼佛点，便是思绪随着刻刀声回到了面前的佛雕上。他不停的雕刻佛像，一次又一次陷入苇名城灭国保护少主的回忆之中，反思自己的所作所为是否正确，他所经历的也许只是现实的历史变故，但记忆中的事物却变得光怪陆离，充满魔幻色彩。</p>
<p><a href="https://image.gcores.com/b00e2f52-dc01-48f2-995c-c3265594e2ab.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b00e2f52-dc01-48f2-995c-c3265594e2ab.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="枭与九郎的对话"></a></p>
<p>枭与九郎的对话</p>
<p>当狼拿到前往源之宫必需的物品后，苇名城被孤影众渗透，站在天守阁看台上的枭与御子九郎有一段对话。九郎问枭有什么企图，他回答道：</p>
<blockquote>
<p>我没有任何企图。（たくらむなど、滅相も）</p>
</blockquote>
<p>宫崎英高喜欢在游戏中使用生僻和古旧的词汇，认为是很有乐趣的事情，比如枭的称号“大忍び”，无论翻译成什么都和原意有微妙的区别。这种奇特的感觉在转译成其他语言版本后往往就丢失了。</p>
<p><a href="https://image.gcores.com/2ba7baf6-2468-48bf-ad9d-bf4e8694a08e.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2ba7baf6-2468-48bf-ad9d-bf4e8694a08e.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="游戏的更新日志也难逃一劫，乃至（ないし）在日语中常用于法律合同等正式书面。"></a></p>
<p>游戏的更新日志也难逃一劫，乃至（ないし）在日语中常用于法律合同等正式书面。</p>
<p>枭在回复九郎时使用的“滅相も”是“滅相もない”的省略，这是表达否定的一种日语固定用法。其中的“灭相”来自于佛教用语，大乘佛教法相宗有四有为相，分别是生相、住相、异相和灭相。</p>
<blockquote>
<p>大乘法相宗谓色心之法体，自有生住异灭四相之变化。即言四相者，以其变化分位而名之假法也。本无今有之位名生。生位暂停之位名住。住别前后之位名异。无位名灭。此中前三者为有，故同在现在。一为无，故在过去。 ——《佛学大辞典》四有为相</p>
</blockquote>
<p>以我个人对佛教粗浅的理解，出现为生，持续为住，变化为异，消亡为灭，是对世间万物自然规律的总结。这也正好触碰到《只狼》的核心主题，追求不死是违背万物之理的行为。也许创作时考虑到这些，故意让渴望得到龙胤的枭说出这个词。</p>
<p>平安时代末期的随笔家鸭长明在镰仓幕府统治天下后创作的《方丈记》开篇所写：</p>
<blockquote>
<p>行く川のながれは絶えずして、しかも本の水にあらず。淀みに浮ぶうたかたは、かつ消えかつ結びて久しくとどまることなし。世の中にある人とすみかと、またかくの如し。 江河川流不息，流过的水已经不是原本的水了。淤积处浮现的泡沫，时而消失时而出现，不会久留。世间之人也正是如此。</p>
</blockquote>
<p>在天守阁上击败弦一郎再次见到御子时，御子九郎放弃了之前私自逃离苇名的想法。</p>
<blockquote>
<p>死なぬ、というのは、淀みを生む 不死の契りも、変若水も、竜咳も、みなそうだ 人の、人としての生き方を歪めてしまう 私は、竜胤の不死が生む、淀みの連鎖を断ち切りたい 不死会产生淤积 不死的契约、变若水、龙咳都是这样的存在 这扭曲了身为人类活着的方式 我想要斩断龙胤不死产生的淤积连锁</p>
</blockquote>
<p>九郎为了大义决定要斩断不死，因为扭曲的不死之力会产生“淀み”。宫崎英高在《只狼》中将这种对永恒的执着比喻成滚滚向前的时间长河中停滞的淤泥，但这并不是他第一次提出这样的观念。</p>
<p>《黑暗之魂》的故事发生在一个叫罗德兰的国度。罗德兰是个特殊的地方，似乎不同的时空叠加在一起，不死人们只有在特定的场合可以看到彼此。不死人共同的使命是成为初火的薪柴，延续这个世界。</p>
<p><a href="https://image.gcores.com/1ed71efe-079a-4eb1-92eb-0d956f5158bd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1ed71efe-079a-4eb1-92eb-0d956f5158bd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="亚诺尔隆德"></a></p>
<p>亚诺尔隆德</p>
<p>游戏中是这样形容罗德兰的：“時の流れの淀んだロードランの地”。意为时间流逝淤积停滞的罗德兰之地。罗德兰的王城亚诺尔隆德看起来无比辉煌，但我们最后会发现这一切都是幻象，众神早已离开或消失，亚诺尔隆德现在只是一座暗无天日的空寂死城。</p>
<p><a href="https://image.gcores.com/6c1f7f1f-abfb-4dcc-b1cf-596dee4f519c.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/6c1f7f1f-abfb-4dcc-b1cf-596dee4f519c.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="失去光芒的亚诺尔隆德"></a></p>
<p>失去光芒的亚诺尔隆德</p>
<p>而这一切虚假幻象都是历史中不愿前进的淤泥，试图通过传火这种违背自然规律的行为去阻止世界的变化。宫崎英高可能想让玩家理解和接受万物的兴起消亡，无论是强大的帝国还是个人的生命皆无法永存于世。</p>
<p><strong>修罗</strong>结局中狼看似反常的行为，个人认为并不唐突。当玩家在天守阁上选择听从义父命令抛弃主人，就默认狼作为一个空白容器继承了义父的意志，会做出与义父相同的举动，这包括了对忍者来说最恶劣的行为，背叛。狼无论如何选择，被困于背叛因果循环中的枭最后都将被自己的养子刺死。</p>
<p>把修罗和斩断不死这两个呈对角线的结局放在一起看，分别代表狼将会成为下一个枭还是下一个佛师。二人都表现了苇名之地人民的疾苦和迷茫，前者将压迫的仇恨主动释放出来，陷入修罗和背叛，后者笃信佛教修行克制，最终还是未能控制住内心的怨念之火化身为鬼。这两位作为主角导师的垂老之人，殊途同归以死解脱了痛苦。</p>
<p><strong>回归常人与龙之返乡</strong> </p>
<p><a href="https://image.gcores.com/23316c79-9758-4591-aa8a-098811611691.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/23316c79-9758-4591-aa8a-098811611691.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="回归常人"></a></p>
<p>回归常人</p>
<p><strong>回归常人</strong>结局主角自我牺牲斩断龙胤，九郎失去御子身份，作为凡人度过余生。</p>
<p>这个结局对应虚构的<strong>源义经北行传说</strong>。传说源义经逃过了平泉一劫，与武藏坊弁庆向北行进，最后到达北海道。日本东北很多地方流传着源义经北上的事迹。（也可能是为了促进当地旅游业）</p>
<p><a href="https://image.gcores.com/1ce7d4a5-eecd-417e-a8e3-2e59e0c281f9.gif" target="_blank" rel="noopener"><img src="https://image.gcores.com/1ce7d4a5-eecd-417e-a8e3-2e59e0c281f9.gif?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000" alt="源义经北行路线"></a></p>
<p>源义经北行路线</p>
<p>藤原秀衡病死后，藤原泰衡在源赖朝的压力下袭击了源义经居住的高馆，传说一个叫<strong>杉目太郎行信</strong>的影武者替源义经牺牲在高馆，宫城县金成町现在立有他的供养碑。</p>
<p><a href="https://image.gcores.com/3fdee523-b059-4cd6-9814-f0f0e6e79b63.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/3fdee523-b059-4cd6-9814-f0f0e6e79b63.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="杉目太郎行信的供养碑"></a></p>
<p>杉目太郎行信的供养碑</p>
<p>源义经北行传说里，义经最终到达日本最北的北海道销声匿迹，也许他最后以一个平常人的身份，在北地度过了平静的余生。源义经幸存的故事后来被写入很多文学作品之中，人们都希望这位悲剧英雄能有一个更好的归属。</p>
<p>《只狼》中没有交代九郎在回归凡人结局后的去向，也许为了躲避内府和源义经一样北上过隐居的生活了吧。</p>
<p><a href="https://image.gcores.com/24684c69-5b37-4e28-9d5f-3ae2524069fc.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/24684c69-5b37-4e28-9d5f-3ae2524069fc.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="龙之返乡"></a></p>
<p>龙之返乡</p>
<p><strong>龙之返乡</strong>对于中国玩家来说是个十分神往的结局，龙的西方故乡让人联想到日本以西的中国。把神龙送回到原来的地方，似乎就解决了一切问题。但是回顾宫崎英高所有的作品会发现，无论《恶魔之魂》、《黑暗之魂》还是《血源诅咒》，几乎没有完美的结局，或多或少有种事情没有按照预想发展的怅然若失。</p>
<p>回归常人与龙之返乡结局呈对角线，实际上是让玩家选择自然赐予我们的生命与人类意识产生的虚构之力哪个更重要。回归常人结局九郎放弃御子身份，以一个平常人的活法感受生命，而龙之返乡结局的走向似乎不是出于九郎本意，在仙峰寺变若御子的引导下将抽象的龙胤送还到龙胤应该存在的地方。</p>
<p>《只狼》所借鉴的《幽灵公主》和《火之鸟》等作品中，都把中央朝廷说成是西方的大和之国，个人认为龙之返乡也许象征着衰落皇权的再次复兴，继续讲关于日本自己的故事。</p>
<p>纵观日本历史，还真有这么一段可以看作是“龙之返乡”的历史。同样是一个时代的终结，同样是执着于过去之人的挣扎，非常适合拿来做宫崎英高作品的素材。本文最后对续作的展望，会具体说说这个“龙之返乡”具体是什么。</p>
<h1 id="宫崎英高的重构美学"><a href="#宫崎英高的重构美学" class="headerlink" title="宫崎英高的重构美学"></a>宫崎英高的重构美学</h1><p>《只狼》用日本战国的外皮讲了一个平安时代的故事，这种“表面一套背后一套”的创作结构至少在游戏领域还不多见。本章节谈一谈FromSoftware为何会选择这样创作的个人理解，以及宫崎英高在创作中借鉴现实原型的思想。</p>
<blockquote>
<p><strong>宫崎英高：</strong>战国时代是一个非常具有魅力的时代，但是并非是因为我个人的喜好才做了这个选择。就像我刚才说的，还是从游戏的设计角度，这一次想要强调“立体场景”这一点，从而确定了“忍者”这个大前提，那么确定了忍者之后，其实能选择的时代背景就只有两个：战国时代和江户时代。</p>
</blockquote>
<p>《只狼》的世界充满魅力并且隐藏了丰富的典故，但不可否认这是一个<strong>玩法优先于叙事</strong>的游戏，在决定讲一个什么故事之前，先要确定游戏的核心玩法。</p>
<p>在访谈中宫崎英高提到《只狼》的创作起始于“立体场景”这一玩法上的卖点，而忍者是最适合在立体场景中行动的身份。敲定游戏的主角是忍者后，游戏的时代背景也就限制在战国和江户这两个历史时代。</p>
<p>从商业角度，战国时代也是一个保险的选择。虽然FromSoftware曾经开发过《九怨》和《御迦》等平安时代背景的游戏，但是这些游戏在制作规模和销售预期上都无法与2019年的《只狼》相比。作为一款由动视负责海外发行面向全球市场的多平台作品，《只狼》承受了更多的商业压力，在选材上也需要更加慎重。</p>
<p><a href="https://image.gcores.com/a4b83776-e8c2-4dee-9612-d0ba38e38b68.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/a4b83776-e8c2-4dee-9612-d0ba38e38b68.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《九怨》和《御迦》"></a></p>
<p>《九怨》和《御迦》</p>
<p>但凡事都有利弊，知名度高的战国时代也有其局限性。战国的历史被充分开发，在各种游戏中一遍又一遍演绎，玩家对这个时代的人和事都太过熟悉，创作难免落入陈词滥调和毫无诚意的形象挪用。比如玩家游玩一款新的日本战国游戏，往往会喜闻乐见织田信长作为反派这次又以什么姿态登场，最后如何被本能寺大火烧死。</p>
<p>但如果对具体的历史人物和事件大幅度改编，脱离玩家脑海中的固有印象，又会遭到反对的声音。这些重重枷锁将会极大程度限制宫崎英高团队最擅长的重构再创作能力。</p>
<p>《恶魔之魂》、《黑暗之魂》、《血源诅咒》中，FromSoftware分别对欧洲中世纪和英国维多利亚时代重构，仔细玩会发现其中融入了很多日本人独有的东西，使得这些作品与市面上其他同类作品相比，散发着一种奇特怪异的气质。一旦接受了宫式重构美学，就很难再从那些死板挪用经典形象的游戏中得到满足。</p>
<p>《只狼》在此基础上更进一步，将整块的历史素材丢到熔炉中解构。虽然这次直接点明了游戏的故事发生于架空的日本战国，本质上却和恶黑血类似，把本不应该放在一起的事物按照游戏自身的世界观需求拼贴成一个自洽的微观小世界。</p>
<p>这样大胆的操作体现了FromSoftware作为日本游戏公司主场作战的自信，日本本土的各种文化典故用起来信手拈来毫不手软。中日文化同源，作为一个中国玩家也能一定程度体会到游戏中亚洲文化的醍醐味，是一件很幸运的事情。</p>
<p><a href="https://image.gcores.com/d607599c-e8f0-4d71-893b-3cc06e1e00c1.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/d607599c-e8f0-4d71-893b-3cc06e1e00c1.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="《只狼》历史原型关系归纳表"></a></p>
<p>《只狼》历史原型关系归纳表</p>
<p>把神之篇和国之篇提到的原型归纳整理，可以还原出平安时代大致的历史事件。游戏的架空世界既没有笨拙地照搬历史，又能让玩家发现游戏和现实的联系。</p>
<p>这种借鉴的方式始于《黑暗之魂》初代的创作。宫崎英高在《黑暗之魂》设定集的开发者座谈中解释了引用现实原型的理由，从最后成品效果来看，试水的小隆德遗迹显然是成功的。</p>
<blockquote>
<p>宫崎英高：小隆德遗迹尝试了与其他地图稍有不同的方式。其形象为实际存在的建筑物，也就是以圣米歇尔山为主题制作出来的。当然了，两者并非完全相同，只要比较一下就能立刻发现不同之处。在《装甲核心》中，制作都市之类的场景时也是这样的，策划师也好，设计师也好，甚至连原画设计师也一样，<strong>比起从零去创作某样东西，还是实际存在的事物拥有更多的意义，也拥有更大的信息量</strong>，因此我也想在《黑暗之魂》中试一试。最终效果有好的也有不好的，但无论如何，这么做还是出现了很多难以从零发现的情报，而能够发现这些情报，也让我们这次尝试有了价值。尤其是从远方眺望时，情报量方面的差异十分显著。不过，因为小隆德遗迹采用了这样的方式，所以是在最后才进入设计阶段的。</p>
</blockquote>
<p>如果宫崎英高没有公开小隆德遗迹的原型是法国的圣米歇尔山，想必极少有人会发现二者之间的联系。所以这种借鉴方式的目的不在于直接挪用经典形象。</p>
<p>游戏中的小隆德遗迹和现实中的圣米歇尔山有一个共同点，它们都是受水位变化影响的城市。</p>
<p><a href="https://image.gcores.com/9cd8e615-9731-4102-aeed-ac7b8a4d6bae.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/9cd8e615-9731-4102-aeed-ac7b8a4d6bae.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="小隆德遗迹"></a></p>
<p>小隆德遗迹</p>
<p>《黑暗之魂》中的小隆德遗迹是一座被水淹没的鬼城，积水下面是被封印的深渊。开闸放水后水位下降，露出之前被淹没的城区，四处可见浸泡腐烂的尸体，玩家很快会意识到小隆德遗迹中那些棘手的怨灵可能就是封印深渊时牺牲的市民。</p>
<p><a href="https://image.gcores.com/5c490b5f-8b93-4bbd-a4ad-c05c3cdf7fe9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/5c490b5f-8b93-4bbd-a4ad-c05c3cdf7fe9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="圣米歇尔山"></a></p>
<p>圣米歇尔山</p>
<p>圣米歇尔山位于法国西海岸的一个小岛上，此地特殊的地势导致潮汐落差接近15米，满潮时圣米歇尔山会孤立成小岛，干潮时与陆地相连。岛上有历史悠久的圣米歇尔山修道院，据说曾经有许多前来朝圣的人丧命于汹涌的潮水中。</p>
<p>两千多年前凯尔特人来到这里，祭祀凯尔特神话的太阳神百勒努斯（Belenus），并把这座山叫作墓山。然后罗马人从南而来，驱赶了凯尔特人，没有留下任何建筑。</p>
<p>几百年后，主教奥伯特受到米迦勒启迪，在岛上修建修道院。在漫长的岁月中几经易手，被不同的国家和教团管理，修道院不断被增建翻修。虽然外部整体呈现哥特式风格，内部混杂了多种中世纪的建筑风格，教堂是加洛林式，中殿是诺曼式，罗曼式的圣坛在英法百年战争中摧毁，后来以火焰哥特式重建。</p>
<p><a href="https://image.gcores.com/c7e7ff51-aeff-4ee7-8eb9-b12859003e07.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c7e7ff51-aeff-4ee7-8eb9-b12859003e07.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="10世纪-11世纪-17世纪-19世纪的演变 小隆德遗迹的建筑比较像右上的11世纪"></a></p>
<p>10世纪-11世纪-17世纪-19世纪的演变 小隆德遗迹的建筑比较像右上的11世纪</p>
<p>宫崎英高所说的信息量，可以理解是历史沉淀形成的层次感，每个细节都有其产生和变化的原因，环环相扣。而不是根据需求一次性创作出来的产物。</p>
<p>圣米歇尔山之所以会成为现在的样子，是不同文化的碰撞融合以及独特地理环境共同造就的结果，设计小隆德遗迹这个场景跳过了对整体外观和符号化形象的临摹借用，真正借鉴的是现实事物的文化底蕴。</p>
<p>创作过程中无法掌握造成结果的所有因，反而赋予了作品生命力和充足的解读空间，使玩家能够从中挖掘出创作者都没有意识到的信息。</p>
<p>与之相对，在访谈中宫崎英高表示他非常讨厌<strong>不负责任和偷懒的形象挪用</strong>。</p>
<blockquote>
<p>中村浩：还有，让我有些在意的是恶魔系的敌人。宫崎有讨厌过度直接的形象标志的倾向，也是因为一旦采用了太多既有的标志，反而会对世界观的构筑产生阻碍吧。所以当我最终交出了那样的设计，也不知道评价会怎样。  宫崎英高：唔……那是你想太多了吧（笑）。就像我刚刚说的，我很喜欢那样的结果。<strong>当然了，我不喜欢那种不怎么费劲的标志化。有时候也会出现这样的情况，因为想给自己的设计增添特征，于是随随便便地在搜索图片中选出眼热的要素加上去，那种做法我就很不喜欢。</strong>比方说，山羊头与恶魔感之所以会是一种标志式的惯例，当然是因为它们拥有古老的文化经历。如果以那些文化底蕴为基础不断绘制出新的作品，理应会带上与原本不同的意义。只要是在考虑到这一点的基础上，再采用山羊头这样的标志，当然不可能有人去否认那样的设计。所谓的标志，是因为它们背负着各种各样的意义，所以才会成为标志。与此同时，也意味着后来者难以给它们添上新的意义，所以才会成为设计上的强力武器。总而言之，从结果来说，那些设计真的很不错。</p>
</blockquote>
<p>市面上充斥着大量滥用标志化元素的游戏，其中不乏美术水平高超的作品，但因为设计师对借鉴引用的事物缺乏理解，仅仅是为了满足特定的风格需求或者制造噱头，其中的底蕴被无视和抹杀，同时也失去与游戏自身的世界观设定产生化学反应的机会。最后呈现给玩家的游戏世界干枯平淡缺乏吸引力，难以留下深刻的印象。比如一些游戏会随意添加宗教内容，只是因为创作者觉得有了这些元素会让游戏显得更酷一些。</p>
<p>笔者认为国内的游戏开发者在设计游戏的世界观设定时，重视这方面的思考是一件事半功倍的事情。尽管这对创作者的个人水平是很大的挑战，不光要熟悉各类游戏，还要广泛涉及游戏之外的各个领域。例如国人喜欢开发武侠题材，武侠是什么环境下产生的，存在哪些思想上的困境诸如此类的问题，每个人对其的理解是有差别的，把这些思考融入到游戏之中，才能避免流于表面的精美画面，沦为DND等西方游戏的换皮作品。</p>
<p>当对文化深层次的引用变得娴熟，不去过度依赖视觉元素来强化表达，创作者便有能力摆脱禁锢，不再受限于固定的题材。</p>
<p>最后说一说碎片化叙事。</p>
<p>游戏中总会出现一些不是特别关键但是让人浑身难受的缺失信息，有人认为这是宫崎英高精心设计的留白，也有人认为是因为宫崎英高不会正常讲故事。可以确定的是，其中一部分缺失是FromSoftware<strong>稳健的项目管理能力</strong>造成的。在游戏开发规模不断扩大的今天，游戏公司的项目管理能力尤为重要。某些大厂曾经创造无数辉煌，如今却被灾难般的开发进度所困扰。</p>
<p>FromSoftware能以稳定的频率推出相对优质的作品，在业内可以说是“做得快的不如我做得好，做得好的不如我做得快”。从《恶魔之魂》算起，十年内的六部主力作品综合评分都在90分上下，非常不容易。</p>
<p>这六部作品都有不同程度的删减痕迹，砍内容最严重的《血源诅咒》发售已数年，还有人陆陆续续挖掘出正式版废弃的内容，本文也多次对《只狼》中可能删掉的剧情设定提出了疑问和猜测。好的消息是每部作品留下的遗憾并没有被开发者忘记，在新的作品中或许会以不同的形式弥补。</p>
<blockquote>
<p>宫崎英高：当然了，作为一款游戏，这个角色也让我感到了些许后悔。葛温是这次的最终BOSS，在这个定位上，应该让玩家把游戏至今培养的所有技能——根据玩家的风格，当然也各有不同——竭尽全力地一股脑儿放出来，与之战斗。在最后的战斗里出现一位让玩家贯彻自我风格去发起挑战的强敌。这种感觉很好。人型、持剑的正统风格也是为了能够带来这样的感受……然而，结果却未能如愿，所以有些遗憾。</p>
</blockquote>
<p>对宫崎英高来说，《黑暗之魂》最终BOSS薪王葛温没有符合他的预想。作为最终BOSS，葛温居然可以被玩家利用弹反轻松击败，尽管这样的反差表现了英雄迟暮被初火燃烧殆尽的悲壮，宫崎英高还是希望最后能让玩家与人形强敌进行一场全力以赴的战斗。受限于当时的条件未能满足这一设想。</p>
<p><a href="https://image.gcores.com/02abb528-795c-4444-be23-46ee9f9ed073.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/02abb528-795c-4444-be23-46ee9f9ed073.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="薪王 葛温"></a></p>
<p>薪王 葛温</p>
<p>八年后，我们与剑圣一心决战于苇名城的芒草原上，亦敌亦友的英豪用精湛的剑术一轮轮攻向玩家（还有正义的连发手枪），考验玩家对游戏战斗系统的理解，这也是宫崎英高所有作品本篇中笔者最满意的最终BOSS战。</p>
<p><a href="https://image.gcores.com/370e7715-a910-4ce3-a711-3cb5a26ab1cd.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/370e7715-a910-4ce3-a711-3cb5a26ab1cd.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="剑圣 苇名一心"></a></p>
<p>剑圣 苇名一心</p>
<p>所以尽管《只狼》在游戏性和剧情交代上留下了一些遗憾，大可期待FromSoftware之后交出更满意的答卷。</p>
<p>本文的最后，根据游戏中缺失的内容和试图想要表达的思想，对《只狼》的DLC以及下一款东方题材续作做一些推测，可以看成是考据乐趣的延伸。</p>
<h1 id="DLC推测-东方的亚尔特留斯"><a href="#DLC推测-东方的亚尔特留斯" class="headerlink" title="DLC推测 东方的亚尔特留斯"></a>DLC推测 东方的亚尔特留斯</h1><p>根据以往FromSoftware出DLC的规律，宫崎英高貌似不喜欢老老实实去填本篇挖的热门坑，往往会从玩家想不到的角度补那么几笔。</p>
<p>《只狼》的本篇中有一个着墨不多但是非常重要的概念：<strong>修罗</strong>。</p>
<p>苇名一心在喝酒对话中对修罗的解释是痴迷于杀戮，一心的徒弟永真说自己的剑术不斩人只斩鬼。枭和佛师这两个更像是本地人的角色都与修罗有关，其中佛师所压制的火焰来自怨嗟，怨嗟又可以代表人民的不满。</p>
<p>如果按这个方向补充，《只狼》中的不死之力和修罗，类似《黑暗之魂》中的传火和深渊的关系，一条明线一条暗线。同时也为苇名之地为什么会被入侵镇压提供了合理的解释。</p>
<p>外面的人惧怕这片古老之地出现的鬼，派人来苇名铲除威胁，而镇压的苦难进一步促使了修罗和鬼的爆发，引起外来者更深的恐惧，形成恶性循环。</p>
<p>在这样的背景下远古时代最初的侵略者，用讨伐虾夷的征夷大将军<strong>坂上田村麻吕</strong>作为原型再适合不过，他的事迹也能很好地嵌入《只狼》的世界观设定中。</p>
<p><a href="https://image.gcores.com/785b641b-939a-4851-911e-a5eee8f2542f.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/785b641b-939a-4851-911e-a5eee8f2542f.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="坂上田村麻吕"></a></p>
<p>坂上田村麻吕</p>
<p>坂上田村麻吕被日本人尊为武神，其战斗力完全有资格放到DLC里面做BOSS。平定苇名之地的理由是本地人堕入修罗化身恶鬼，正如亚尔特留斯到乌拉席露处理深渊一样。与《黑暗之魂》不同的是，这次我们以“乌拉席露”本地人的角度看待整个事件。</p>
<ul>
<li>坂上田村麻吕是朝廷册封的征夷大将军，连接了<strong>源之宫</strong>和<strong>苇名之地</strong>。</li>
<li><strong>仙峰寺</strong>原型之一的京都清水寺由坂上田村麻吕创立。</li>
<li>坂上田村麻吕在东征途中路过诹访并参拜诹访大明神以求成功，也许与同时代的初代大祝有交集，对应游戏中与<strong>御子起源</strong>的关系，甚至可被设定成是一名借助神龙之力的<strong>龙胤契约者</strong>。</li>
</ul>
<p>坂上田村麻吕使用过的武器留下了很多传说，这里只选取众多版本中的一部分。</p>
<p><strong>坂上宝剑</strong>是坂上田村麻吕最出名的武器，他去世后此剑由天皇代代相传，成为守护国家的皇室珍宝，传说坂上宝剑遇到雷鸣时会自行出鞘。对应到游戏中，这个BOSS会使用代表源之宫的<strong>落雷之力</strong>。</p>
<p><a href="https://image.gcores.com/323bf138-3827-4740-8090-4cb196f83378.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/323bf138-3827-4740-8090-4cb196f83378.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="讨鬼传中的坂上宝剑"></a></p>
<p>讨鬼传中的坂上宝剑</p>
<p><strong>骚速</strong>，现保存于播州清水寺（有别于京都清水寺），文物由三口大刀组成，现在无法判断哪个是真正的骚速。这三把刀之中，一口是切刃造，其余两口是锋两刃造，神之篇中提到过是平氏传家宝小乌丸也是锋两刃造。这个武器可以把此BOSS和<strong>不死斩</strong>联系起来。</p>
<p><a href="https://image.gcores.com/2320e17a-c4e0-40d4-aa3b-34af94728b05.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2320e17a-c4e0-40d4-aa3b-34af94728b05.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="三口大刀"></a></p>
<p>三口大刀</p>
<p><strong>黑漆剑</strong>，保存于京都鞍马寺，也就是源义经少年时生活过的地方。据说此刀的特殊造型是为了对抗虾夷的蕨手刀。也有观点认为，真正的黑漆剑可能与坂上宝剑或骚速为同一物。与源义经和虾夷有关，说不定这把武器就是平田氏家传由九郎交给狼的<strong>楔丸</strong>原型。</p>
<p><a href="https://image.gcores.com/2bf792a2-8df4-43af-b0c4-1892cc2194c9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2bf792a2-8df4-43af-b0c4-1892cc2194c9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="黑漆剑"></a></p>
<p>黑漆剑</p>
<p><strong>鬼切安纲</strong>，别称鬼切丸，现保存于北野天满宫。坂上田村麻吕曾经将此刀奉纳于伊势神宫，平安中期的源赖光在参拜伊势神宫期间受天照大神托梦，被赐予鬼切，由源氏家传以保天下平安。有观点认为，鬼切安纲才是源赖光的酒吞童子退治传说中童子切安纲的武器原型，在另外一些记载中，源赖光将鬼切安纲借给赖光四天王之一渡边纲，渡边纲用此刀砍断了茨城童子的手臂。游戏中可以设定成一把来自淤加美一族并对修罗有特效的武器，专门用来<strong>斩鬼</strong>。</p>
<p><a href="https://image.gcores.com/43149077-ebab-4763-87bf-160fdad1c13a.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/43149077-ebab-4763-87bf-160fdad1c13a.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="渡边纲与茨城童子"></a></p>
<p>渡边纲与茨城童子</p>
<p>总结一下这位BOSS的形象：此人来自于远古时代，是苇名之地最初的侵略者，目的是根除修罗之力。他与源之宫、仙峰寺以及御子的起源皆有关系，战斗会使用正版的雷术（雷返逃课就不要想了），两把不死斩也可能是由他带到苇名之地。如何见到这个BOSS，游戏中已经给出答案，通过铃铛进入过去的回忆。</p>
<p>本文完稿之际，FromSoftware放出了一张疑似DLC的截图。</p>
<p><a href="https://image.gcores.com/2daeea25-bc77-443e-a662-b449df6756b0.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/2daeea25-bc77-443e-a662-b449df6756b0.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="与本篇细节不同的荒废寺院"></a></p>
<p>与本篇细节不同的荒废寺院</p>
<p>从这张图基本可以确定《只狼》有DLC计划。通过修改细节和复用地形创造不同时空的同一场景，是FromSoftware喜欢使用（省钱）的手法。</p>
<p>代替了竹林的粗壮大树证明这个场景是曾经的废弃寺院，剧情大概率将会与佛师的过去和修罗有关。因为游戏中绝大部分鬼佛都不会与行进方向相背，这个场景很可能是从寺庙出发，利用本篇断掉的吊桥去往山谷对面。静等DLC放出新的预告片，再进行仔细分析。</p>
<h1 id="续作展望-日本历史中的“龙之返乡”"><a href="#续作展望-日本历史中的“龙之返乡”" class="headerlink" title="续作展望 日本历史中的“龙之返乡”"></a>续作展望 日本历史中的“龙之返乡”</h1><p>假如FromSoftware未来打算再做一款日本题材游戏，可能会借鉴哪些历史？从思想表达的角度，提一些自己的看法。</p>
<p>宫崎英高想在《只狼》中讲一个“日本如何成为日本”的故事，来自盛唐的文化影响了日本的各个方面，朝廷与少数民族数个世纪的摩擦，武士阶层崛起，朝廷的衰败导致日本进入了漫长的幕府时代。</p>
<p>然而到此为止日本物语只讲了一半，距离故事的完成还差一大步。这个全世界范围内最了解中国的国家经过混杂着必然和偶然的历史变革，成了另外一番模样。</p>
<p>故事的后半段发生于另一个时代交替之际，<strong>江户幕府时代末期</strong>，简称<strong>幕末</strong>。德川家康统一日本战国后创建江户幕府，经过200多年的统治，这个政权也步入了垂老之年。</p>
<p><a href="https://image.gcores.com/cae08dfd-a82d-463f-96b9-83f119132f32.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/cae08dfd-a82d-463f-96b9-83f119132f32.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="黑船来航"></a></p>
<p>黑船来航</p>
<p>平安时代的一系列因，导致长达700余年幕府将军掌权的果。经过漫长岁月，至高的皇权已被众人遗忘，甚至当时有人不知道天皇的存在。</p>
<p>1853年<strong>黑船来航</strong>，船体涂着黑色沥青的美国舰队出现在海平面上迫使日本开国。德川幕府无力应对，于是尊皇攘夷和倒幕的声音高涨，那些古籍中所记载天孙降临的权威在人们心中开始复苏。</p>
<p><a href="https://image.gcores.com/b82db015-6441-4d62-8a51-31ce170ec0ab.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/b82db015-6441-4d62-8a51-31ce170ec0ab.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="坂本龙马"></a></p>
<p>坂本龙马</p>
<p>维新志士<strong>坂本龙马</strong>少时见证了黑船来航，他师从北辰一刀流精通剑术，同时非常崇尚西方的先进文化技术。后来坂本龙马促使萨摩藩和长州潘成为萨长同盟，起意让无力“征夷”的德川幕府主动将权力交还给当时的明治天皇。</p>
<p>关于坂本龙马有一段有趣的故事，让人不禁联想到掏出连发手枪的剑圣苇名一心。在大正时代创作的《坂本龙马传》中，坂本龙马和土佐勤王党成员桧垣直治有三段依次递进的对话。</p>
<p>坂本龙马见到桧垣直治说：“以后室内乱斗会变多，我喜欢用灵巧的小太刀。”再次见到带着小太刀的桧垣直治，坂本龙马又对他说：“今后已经是用枪的时代了。”第三次见到带着枪的桧垣直治，坂本龙马掏出一本《万国公法》说道：“未来是万国公法的时代了。”</p>
<p><a href="https://image.gcores.com/c37a89ca-4408-4d88-bac0-8e1497a40f3a.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c37a89ca-4408-4d88-bac0-8e1497a40f3a.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="大政奉还"></a></p>
<p>大政奉还</p>
<p>1867年，德川幕府在京都二条城举行“<strong>大政奉还</strong>”仪式，将名义上的权力交还给天皇新政府，明治天皇随即颁布《<strong>王政复古令</strong>》。流离失所的皇权再次归位，日本即将不再由武士阶层出身的幕府将军统治。</p>
<p>可惜的是，大政奉还前夕坂本龙马在京都近江屋被暗杀。究竟暗杀者是谁成为未解之谜，至今没有统一说法。有观点认为凶手是维护幕府统治的新选组。</p>
<p><a href="https://image.gcores.com/c65cd3b2-d1f7-4568-9098-43c4868257ea.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/c65cd3b2-d1f7-4568-9098-43c4868257ea.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="京剧 坂本龙马"></a></p>
<p>京剧 坂本龙马</p>
<p>宫崎英高喜欢把游戏背景设定在衰败的末世，末世中总会有人拒绝新时代的到来，极力挽留已逝的荣耀。在幕末的环境下，这类人的代表便是支持幕府的<strong>新选组（新選組）</strong>。受尊皇攘夷影响，京都不断聚集倒幕志士，新选组因此成立并协助幕府维持京都治安。新选组最初以京都的壬生村为根据地，壬生村即是上文所提及水生村的原型。新选组的前身是“<strong>壬生浪士组</strong>”，也被叫作“<strong>壬生狼</strong>”。如果《只狼2》的主角出身于新选组，正好又对应了游戏的名字。</p>
<p><a href="https://image.gcores.com/e51e71ad-8bcb-482b-aa17-cc445011fa25.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/e51e71ad-8bcb-482b-aa17-cc445011fa25.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="2004 NHK大河剧 新选组"></a></p>
<p>2004 NHK大河剧 新选组</p>
<p>虽然德川幕府将名义上的权力和平归还天皇，统治国家的实权最终还是以战争的形式交接。二者开战于戊辰之年，故名为<strong>戊辰战争</strong>。战火从南到北波及整个日本，新选组为旧幕府出战损失惨重，局长近藤勇被极刑处死，一番队组长冲田总司途中病死，副长土方岁三带着剩余部队前往当时还叫作<strong>虾夷地</strong>的北海道，准备最后决战。</p>
<p><a href="https://image.gcores.com/f2114e94-5e24-4044-8f5c-c74d75461bcb.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f2114e94-5e24-4044-8f5c-c74d75461bcb.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="五棱郭塔上的土方岁三像"></a></p>
<p>五棱郭塔上的土方岁三像</p>
<p>旧幕府势力在北海道建立了名为<strong>虾夷共和国</strong>的新政权，设五棱郭为大本营。箱馆之战土方岁三一骑当千也未能挽回败势，中弹身亡。五棱郭开城投降。德川庆喜被软禁，德川幕府彻底灭亡，历史又一次完成时代交替。后世的文化作品歌颂新选组的忠义和悲壮，但不能否认他们已经成为了阻止历史前进的淤泥。</p>
<p>1876年明治政府颁布<strong>废刀令</strong>，除皇家、军人和警察以外，一律禁止佩刀。武士和忍者不得不离开历史舞台。</p>
<p><a href="https://image.gcores.com/f74c9903-4b45-4c44-addf-a95361f016c9.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/f74c9903-4b45-4c44-addf-a95361f016c9.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="废佛毁释活动被毁坏的佛像"></a></p>
<p>废佛毁释活动被毁坏的佛像</p>
<p>曾经镇护国家的佛教也遭受了打击。新政府为了强化神道教的地位施行<strong>神佛分离</strong>，政权与神道教政教合一，而佛教不再干涉国政。</p>
<p>虽然政府没有明令禁止佛教，但在民间却引发了更严重的<strong>废佛毁释</strong>运动，直到今天我们还能在日本看到许多被摧毁的佛像。与此同时，一直以来受阻的基督教被解禁，在日本快速发展。</p>
<p><a href="https://image.gcores.com/724c69fa-f4bd-45a7-83f5-85222fd7c0fe.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/724c69fa-f4bd-45a7-83f5-85222fd7c0fe.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="游戏中此雕像的官方名是“社之蛇菩萨”，代表了过去日本神佛混淆的状态"></a></p>
<p>游戏中此雕像的官方名是“社之蛇菩萨”，代表了过去日本神佛混淆的状态</p>
<p>神道教失去了神秘的面纱，各地的教权上交中央政府。神别氏族禁止世袭，意味着许多传承名存实亡，各大神社的神官皆由政府统一机构派遣。</p>
<p>明政府还施行了开拓虾夷地的计划，并将其命名为北海道，就像上文考据枭的名字部分所提及的，阿依努人被迫和化弃用本名，民族习俗也被禁止。</p>
<p>某些群体在明治维新中被淘汰并感到绝望，但从整体来看这是向前发展的新时代，正如《黑暗之魂》灭火后的黑暗时代一样。</p>
<p>《只狼》的故事由神明与国家两条线构成，狼寻找仙乡和神龙以求斩断不死，而苇名国面临被内府入侵的危机。以幕末为时代背景同样可以构建出与《只狼》类似的故事结构，寻找神明和国家受难两个故事穿插在一起。</p>
<p><a href="https://image.gcores.com/1c5ed0d2-5fb1-49be-b850-9aa96e923c38.png?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/1c5ed0d2-5fb1-49be-b850-9aa96e923c38.png?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="戊辰战争"></a></p>
<p>戊辰战争</p>
<p>国家线以戊辰战争为原型，讲述“内府”灭亡前的抵抗战。轮回的历史总是有相似之处，江户末期的戊辰战争与平安末期的治承寿永之乱（源平合战与征讨奥州）二者都决定了时代的接替，战争都波及到日本全境，战线从南到北，最后都在虾夷的地盘上决战。</p>
<p><a href="https://image.gcores.com/fca3c3a1-6af7-4ee4-9d4e-e77c2e9786ee.jpeg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/fca3c3a1-6af7-4ee4-9d4e-e77c2e9786ee.jpeg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="五棱郭"></a></p>
<p>五棱郭</p>
<p>游戏的“现在时”可以定位在戊辰战争最后的五棱郭一役，<strong>星状堡垒</strong>五棱郭的造型非常醒目。星状堡垒（棱堡）最早出现于15世纪中叶的意大利，这种极具美感的设计在防守方面有效克制了近现代火器。火炮难以在星状堡垒的城墙上轰开有效的突破口，没有弧线的城墙减少守城的死角，无论从任何角度进攻，进攻者都会将自己的侧后方暴露在守城者的火力范围内。五棱郭也是不可多得的游戏场景素材。</p>
<p><a href="https://image.gcores.com/95439670-1b80-43ee-b74a-6933f48b9309.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/95439670-1b80-43ee-b74a-6933f48b9309.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="Citadel of Jaca 西班牙"></a></p>
<p>Citadel of Jaca 西班牙</p>
<p>“内府”节节败退的过程中，新的主角需要去调查神明故事线，追寻“龙之忍者”的传说。</p>
<p>神明线一系列语焉不详的历史来源于黑船来航。这一事件意味着日本长久以来受到中国影响的华夷观念彻底崩塌，旧世界的游戏规则已经不再适用。从大洋彼岸而来的西方舰队带来的“新东西”让日本人再次发生剧烈变化。</p>
<p>在宫崎英高的作品中，玩家接触的大部分信息都发生于过去，这种叙事方式在传统的《生化危机》也有所体现，对过去的好奇让玩家不知不觉代入了调查员的身份，与洛夫克拉夫特的故事有很好的相性，《血源诅咒》在一定程度上抓住了洛式气氛的精髓。</p>
<p>以黑船来航为原型，设定不知何时的遥远过去曾有西方的古船来到日之本，并将西方列强对日本的影响再创作成更具体的事物，比如古船带来的感染或者血脉。玩家调查这些停靠在海岸边的古老船只的过程，就又构成了一个印斯茅斯阴影式桥段，宫崎英高似乎非常喜欢这部小说，在《血源诅咒》和《只狼》中都曾借鉴印斯茅斯阴影的元素。</p>
<p>在真实历史中，据说黑船来航时真就有一位效力于津藩藤堂家叫作<strong>泽村保祐（泽村甚三郎）</strong>的忍者被命令秘密调查黑船，他也被认为是历史记载最后一位执行隐秘活动的忍者。新的时代再也不需要忍者这样古旧的职业，后来的间谍特工也已经和我们心目中的忍者形象相差甚远。</p>
<p>然而他从黑船上只偷出来一些面包烟草之类的物品以及几张纸条，其中一张纸条上记载着“英国女人床上功夫很好”……</p>
<p>世界东方的日本处于一个时代结束的边缘时，遥远欧洲的大英帝国正是强大的维多利亚时代，这就又涉及到另一个玩家们日日夜夜惦记的续作了。（虽然历史上的黑船是美国舰队）</p>
<p><a href="https://image.gcores.com/4a1f102a-9e51-4155-886f-51413d41b95e.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/4a1f102a-9e51-4155-886f-51413d41b95e.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="那个游戏"></a></p>
<p>那个游戏</p>
<p>那么船带来了什么“不好的东西”呢？作为中国人听下去可能会不太愉快。</p>
<p>随着崇祯皇帝自尽和大明灭亡，汉人政权被满人政权代替。日本江户时代一些儒学者认为中国已经沦为蛮夷，自称小中华的日本应该继承中华正统的衣钵。日本人心中那条东方巨龙的形象正在逐渐倒塌。</p>
<p>皇权光复以后日本开始全面学习西方的明治维新，更是抛弃了曾经的老师中国。1885年福泽谕吉在《时事新报》上发表了著名的《脱亚论》。</p>
<p><a href="https://www.douban.com/note/510380221/" target="_blank" rel="noopener">福泽谕吉《脱亚论》原文配白话译文</a></p>
<p><a href="https://image.gcores.com/29e52da9-9d1d-495a-8b1b-8ed1d4326654.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/29e52da9-9d1d-495a-8b1b-8ed1d4326654.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="一万日元上的福泽谕吉 他被认为是对日本现代发展贡献最大的人之一"></a></p>
<p>一万日元上的福泽谕吉 他被认为是对日本现代发展贡献最大的人之一</p>
<p>九年后的甲午之年，日本战胜清朝，双方签订《马关条约》。</p>
<p>西化的大和民族仿佛被注入新的血液，获得了启蒙。再之后的历史作为中国人都应该永远铭记，化身为野兽的日本对包括中国在内的亚洲各国造成了无比惨痛的伤害。</p>
<p>我们那个既好学又令人生畏的邻居，从古至今就是这么一步步发展成现在的日本。文化中一半血液来自中国，熟练使用汉字，研读古今汉籍，现在还保存着模仿唐宋等时代的古建筑；另一半血液来自西方，快速转变成现代国家，却又曾误入歧途成为法西斯的一员。</p>
<p>关于续作，甚至可以想象这样一个充满恶意的场景：玩家追随龙之忍者的传说，最后到达新的龙之乡。我们熟悉的那位独臂忍者已经满头白发，不知在此守卫了多久。</p>
<p>击败龙之忍者，在他身后静静沉睡的变若御子旁边参拜再次进入仙乡。响起激昂的西方管弦乐与男女声合唱，其中掺杂着断断续续不再灵动的樱龙旋律，樱龙的残骸旁爬起一只后背长着翅膀口吐火焰，我们同样称之为“龙”的生物。</p>
<p><a href="https://image.gcores.com/83cb9683-ad06-4d6a-8272-9742128a45d3.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/83cb9683-ad06-4d6a-8272-9742128a45d3.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="那个BOSS"></a></p>
<p>那个BOSS</p>
<p>宫崎英高在这种事情上可是有前科的，所以我毫不怀疑宫崎英高会再次用诸如此类残酷的桥段表现自己的末世美学。那么如果所谓的龙之返乡是上面所描述的样子，你是否能接受呢？</p>
<p><a href="https://image.gcores.com/46f42b4b-ef8f-4f11-83a0-14ec2320c148.jpg?x-oss-process=image/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" target="_blank" rel="noopener"><img src="https://image.gcores.com/46f42b4b-ef8f-4f11-83a0-14ec2320c148.jpg?x-oss-process=image/resize,limit_1,m_lfit,w_700,h_2000/quality,q_90/watermark,image_d2F0ZXJtYXJrLnBuZw,g_se,x_10,y_10" alt="那个制作人"></a></p>
<p>那个制作人</p>
<p>非常感谢有耐心看完这篇拙文，以上是根据我个人的理解所描述的《只狼》世界，如果有不同的见解，欢迎留下评论交流！同时期待《只狼》能够顺利推出DLC，这样就可以准备下一篇原型浅谈了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://ja.wikipedia.org/" target="_blank" rel="noopener">日文维基百科</a></p>
<p><a href="https://souls-seed.blogspot.com/" target="_blank" rel="noopener">ソウルの種</a></p>
<p><a href="http://inbksk.hatenadiary.com/" target="_blank" rel="noopener"><strong>クズ底</strong></a></p>
<p><a href="https://www.amazon.co.jp/SEKIRO-SHADOWS-TWICE-Official-Artworks/dp/4049125935/ref=sr_1_1?__mk_zh_CN=亚马逊网站&keywords=sekiro&qid=1565861325&s=gateway&sr=8-1" target="_blank" rel="noopener">SEKIRO: SHADOWS DIE TWICE Official Artworks </a></p>
<p><a href="http://www001.upp.so-net.ne.jp/dassai/index.htm" target="_blank" rel="noopener">古代史獺祭</a></p>
<p><a href="https://miko.org/~uraki/kuon/furu/furu_index1.htm" target="_blank" rel="noopener">古事記<del>往古之追慕</del></a></p>
<p><a href="http://www.seisaku.bz/nihonshoki/shoki_07.html" target="_blank" rel="noopener">日本書紀巻第七 景行天皇</a></p>
<p><a href="https://trc-adeac.trc.co.jp/WJ11E0/WJJS06U/0220205100/0220205100100020/ht010070" target="_blank" rel="noopener">新編弘前市史　通史編2(近世1)</a></p>
<p><a href="https://trc-adeac.trc.co.jp/WJ11E0/WJJS06U/0220205100/0220205100100010/ht030170/" target="_blank" rel="noopener">新編弘前市史　通史編1(古代・中世) 「日の本将軍」安藤氏</a></p>
<p><a href="http://kazuno.in.coocan.jp/86kioku/18K-06/Hakuchou-Densetsu/58.htm" target="_blank" rel="noopener">白鳥伝説</a></p>
<p>[エミシの抵抗と同化](<a href="http://www10.plala.or.jp/shosuzki/japan/ainu" target="_blank" rel="noopener">http://www10.plala.or.jp/shosuzki/japan/ainu</a> 3.htm)</p>
<p><a href="https://bunka.nii.ac.jp/heritages/detail/19604/" target="_blank" rel="noopener">源平合戦図屏風　一の谷・屋島合戦図</a></p>
<p><a href="https://hangeshow.exblog.jp/9621631/" target="_blank" rel="noopener">日の丸を掲げた蝦夷</a></p>
<p><a href="https://webarchives.tnm.jp/imgsearch/show/C0061786" target="_blank" rel="noopener">清水寺縁起絵巻</a></p>
<p><a href="https://manareki.com/sakanouetamuramaro2" target="_blank" rel="noopener">坂上田村麻呂とアテルイを超わかりやすく説明</a></p>
<p><a href="https://www.rekihaku.ac.jp/up-cgi/login.pl?p=param/kyud/db_param" target="_blank" rel="noopener">旧高旧領取調帳データベース</a></p>
<p><a href="http://dsntsugaru.blog.fc2.com/blog-entry-35.html" target="_blank" rel="noopener">鬼沢の鬼伝説</a></p>
<p><a href="http://www.city.hirosaki.aomori.jp/school/jitoku/2014-1127-kisinn-denndetu.html" target="_blank" rel="noopener">弘前市 鬼神伝説</a></p>
<p><a href="https://japanknowledge.com/articles/blogjournal/howtoread/entry.html?entryid=50" target="_blank" rel="noopener">茂庭 竜神が棲む山村</a></p>
<p><a href="https://www1.atwiki.jp/occultfantasy/pages/714.html" target="_blank" rel="noopener">Fantapedia～幻想大事典 オオカミのカムイ</a></p>
<p><a href="http://blog.livedoor.jp/namepower/archives/1242143.html" target="_blank" rel="noopener"><strong>アイヌ系日本人の姓</strong></a></p>
<p><a href="http://chibasi.net/usui.htm#kagetane1" target="_blank" rel="noopener">臼井氏　房総平氏の名流</a></p>
<p><a href="http://chibasi.net/oushumain.htm" target="_blank" rel="noopener">東北の千葉一族</a></p>
<p><a href="https://moutaku3.exblog.jp/17783195/" target="_blank" rel="noopener">アテルイ（阿弖流爲）・モレ（母礼）</a></p>
<p><a href="http://aterui8.jp/history/info/aterui_info303.html" target="_blank" rel="noopener">阿弖流為・母禮顕彰碑の説明文を多言語化</a></p>
<p><a href="https://cultural-experience.blogspot.com/2015/12/blog-post_99.html" target="_blank" rel="noopener">平将門の伝説</a></p>
<p><a href="https://mrs.living.jp/chiba/tokuhain_blog/reporter/82336" target="_blank" rel="noopener">七つの塚に眠る秘密～七天王塚伝説～</a></p>
<p><a href="http://mokuou.blogspot.com/2012/05/29394.html" target="_blank" rel="noopener">天慶2年（939）4月　出羽俘囚の乱</a></p>
<p><a href="https://www.fukutabi.net/fuku/wakamatu/hatiyou.html" target="_blank" rel="noopener">会津若松市：歴史・観光・見所＞八葉寺</a></p>
<p><a href="http://www.hojusan.org/hon-matsu/hachiyo-ji/hachiyo-ji-sanpai.html" target="_blank" rel="noopener">八葉寺 特別供養</a></p>
<p><a href="http://dl.ndl.go.jp/info:ndljp/pid/819437/8?tocOpened=1" target="_blank" rel="noopener">性霊集. 巻第１−４</a></p>
<p>[雑言詩「贈野陸州歌井序」について](<a href="http://echo-lab.ddo.jp/Libraries/密教文化/密教文化" target="_blank" rel="noopener">http://echo-lab.ddo.jp/Libraries/密教文化/密教文化</a> Vol. 2005 No. 214/密教文化 Vol. 2005 No. 214  001中谷 征充「雑言詩「贈野陸州歌井序」について  P1-18」.pdf)</p>
<p><a href="https://blogs.yahoo.co.jp/oyosyoka803/38531749.html" target="_blank" rel="noopener"><strong>空海のタントラ「仏教」とチベット（2）090318</strong></a></p>
<p><a href="https://ameblo.jp/emishi-no-mori/" target="_blank" rel="noopener">エミシの森</a></p>
<p><a href="http://www.kyototownmap.com/page/mibu.html" target="_blank" rel="noopener">壬生の歴史</a></p>
<p><a href="https://www.kyototsuu.jp/Geography/AreaMibu.html" target="_blank" rel="noopener">壬生　京都通百科事典</a></p>
<p><a href="https://shigemori.kyo2.jp/e429881.html" target="_blank" rel="noopener">時代祭（ふく紘）</a></p>
<p><a href="http://www.mashin-eiyuuden-wataru.net/ova2/index.html" target="_blank" rel="noopener">魔神英雄伝ワタル 終わりなき時の物語</a></p>
<p><a href="https://www.jstage.jst.go.jp/article/fiber1944/51/2/51_2_P78/_pdf" target="_blank" rel="noopener">天皇の御装束</a></p>
<p><a href="https://zh.wikisource.org/zh-hans/佛學大辭典/四有為相" target="_blank" rel="noopener">佛学大辞典/四有为相</a></p>
<p><a href="https://www.aozora.gr.jp/cards/000196/files/975_15935.html" target="_blank" rel="noopener">『方丈記』 鴨長明</a></p>
<p><a href="https://shiten3403.exblog.jp/22710944/" target="_blank" rel="noopener">『杉目太郎行信』</a></p>
<p><a href="https://meitou.info/" target="_blank" rel="noopener">名刀幻想辞典</a></p>
<p><a href="https://www.city.kato.lg.jp/kakukanogoannai/kyouikushinkoubu/shogaigakushuka/bunkazai/siteibunkazai/kunisiteibunkazai/1510206361583.html" target="_blank" rel="noopener">大刀／加東市</a></p>
<p><a href="http://www.kariginu.jp/sozai/sozai1-2.htm" target="_blank" rel="noopener">有職文様素材集</a></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>只狼</tag>
      </tags>
  </entry>
  <entry>
    <title>OVA催眠性指導 ＃4宮島椿の場合</title>
    <url>/OVA%E5%82%AC%E7%9C%A0%E6%80%A7%E6%8C%87%E5%B0%8E%20%EF%BC%834%E5%AE%AE%E5%B3%B6%E6%A4%BF%E3%81%AE%E5%A0%B4%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v70/71/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>




]]></content>
  </entry>
  <entry>
    <title>OVA巨乳J○がオジさんチ○ポとじゅぽじゅぽいやらしいセックスしてます。＃1どうやって誘惑、シちゃおっかなぁ</title>
    <url>/OVA%E5%B7%A8%E4%B9%B3J%E2%97%8B%E3%81%8C%E3%82%AA%E3%82%B8%E3%81%95%E3%82%93%E3%83%81%E2%97%8B%E3%83%9D%E3%81%A8%E3%81%98%E3%82%85%E3%81%BD%E3%81%98%E3%82%85%E3%81%BD%E3%81%84%E3%82%84%E3%82%89%E3%81%97%E3%81%84%E3%82%BB%E3%83%83%E3%82%AF%E3%82%B9%E3%81%97%E3%81%A6%E3%81%BE%E3%81%99%E3%80%82%EF%BC%831%E3%81%A9%E3%81%86%E3%82%84%E3%81%A3%E3%81%A6%E8%AA%98%E6%83%91%E3%80%81%E3%82%B7%E3%81%A1%E3%82%83%E3%81%8A%E3%81%A3%E3%81%8B%E3%81%AA%E3%81%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v72/72/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>




]]></content>
  </entry>
  <entry>
    <title>OVA巨乳J○がオジさんチ○ポとじゅぽじゅぽいやらしいセックスしてます。＃2オジさんチ○ポ、みんなでシェア</title>
    <url>/OVA%E5%B7%A8%E4%B9%B3J%E2%97%8B%E3%81%8C%E3%82%AA%E3%82%B8%E3%81%95%E3%82%93%E3%83%81%E2%97%8B%E3%83%9D%E3%81%A8%E3%81%98%E3%82%85%E3%81%BD%E3%81%98%E3%82%85%E3%81%BD%E3%81%84%E3%82%84%E3%82%89%E3%81%97%E3%81%84%E3%82%BB%E3%83%83%E3%82%AF%E3%82%B9%E3%81%97%E3%81%A6%E3%81%BE%E3%81%99%E3%80%82%EF%BC%832%E3%82%AA%E3%82%B8%E3%81%95%E3%82%93%E3%83%81%E2%97%8B%E3%83%9D%E3%80%81%E3%81%BF%E3%82%93%E3%81%AA%E3%81%A7%E3%82%B7%E3%82%A7%E3%82%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v72/73/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>




]]></content>
  </entry>
  <entry>
    <title>RAN_-_SEM_(JUST_SEX)</title>
    <url>/RAN_-_SEM_(JUST_SEX)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v151/153/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
  <entry>
    <title>RINXSEN_RANXSEM_~CROSS_MIX~_SUB_(SEX_SCENES)</title>
    <url>/RINXSEN_RANXSEM_~CROSS_MIX~_SUB_(SEX_SCENES)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v151/154/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
  <entry>
    <title>RYOUJOKU_FAMIRESU_CHOUKYOU_MENU_SUB_(SEX_SCENES)</title>
    <url>/RYOUJOKU_FAMIRESU_CHOUKYOU_MENU_SUB_(SEX_SCENES)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v168/169/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
  <entry>
    <title>RYOU_SEIBAI!!_SUB_(SEX_SCENES)</title>
    <url>/RYOU_SEIBAI!!_SUB_(SEX_SCENES)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v168/168/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
  <entry>
    <title>TRIANGLE_BLUE_SUB_(SEX_SCENES)</title>
    <url>/TRIANGLE_BLUE_SUB_(SEX_SCENES)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v168/170/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
  <entry>
    <title>TRUE_BLUE_SUB_(SEX_SCENES)</title>
    <url>/TRUE_BLUE_SUB_(SEX_SCENES)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v168/171/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
  <entry>
    <title>オトメドリ 上巻 純潔の輪舞曲</title>
    <url>/%E3%82%AA%E3%83%88%E3%83%A1%E3%83%89%E3%83%AA%20%E4%B8%8A%E5%B7%BB%20%E7%B4%94%E6%BD%94%E3%81%AE%E8%BC%AA%E8%88%9E%E6%9B%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v74/74/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>




]]></content>
  </entry>
  <entry>
    <title>君想ふ恋</title>
    <url>/%E5%90%9B%E6%83%B3%E3%81%B5%E6%81%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/videoBed/22/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>

<a id="more"></a> 





]]></content>
      <categories>
        <category>封面</category>
      </categories>
      <tags>
        <tag>封面</tag>
      </tags>
  </entry>
  <entry>
    <title>恋愛不要学派 THE ANIMATION 「私を調教してみたい」</title>
    <url>/%E6%81%8B%E6%84%9B%E4%B8%8D%E8%A6%81%E5%AD%A6%E6%B4%BE%20THE%20ANIMATION%20%E3%80%8C%E7%A7%81%E3%82%92%E8%AA%BF%E6%95%99%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%E3%81%84%E3%80%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v78/78/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>




]]></content>
  </entry>
  <entry>
    <title>聖ヤリマン学園援交日記</title>
    <url>/%E8%81%96%E3%83%A4%E3%83%AA%E3%83%9E%E3%83%B3%E5%AD%A6%E5%9C%92%E6%8F%B4%E4%BA%A4%E6%97%A5%E8%A8%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v78/79/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>




]]></content>
  </entry>
  <entry>
    <title>魔法少女</title>
    <url>/%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.css">

<div id="dplayer" class="dplayer-video dplayer dplayer-no-danmaku dplayer-paused"></div>

<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/hls.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ashjian/videoBed/lib/DPlayer.min.js"></script>

<script>
  $(function(){ 
    const dp = new DPlayer({
      container: document.getElementById('dplayer'),
      autoplay:!0,theme:"#42b983",loop:true,lang:"zh-cn",preload:"auto",volume:Number("0"),
      video: {
          url: 'https://cdn.jsdelivr.net/gh/ashjian/v147/150/playlist.m3u8',
          type: 'hls',
          defaultQuality: 0,
          pic: '',
          thumbnails: '',
      },
  });
})
</script>





]]></content>
  </entry>
</search>
